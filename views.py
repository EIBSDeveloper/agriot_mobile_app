from collections import defaultdict
from operator import itemgetter 
import base64 
from urllib.parse import urlparse, parse_qs
from django.http import Http404, HttpRequest
from deep_translator import GoogleTranslator
from django.utils.crypto import get_random_string
from django.conf import settings
from django.db.models import Func, F, IntegerField, Value
from django.db.models.functions import Length, Substr, Cast
from base64 import b64decode 
from django.utils.translation import activate, gettext as _ 
from django.forms.models import model_to_dict
# from services.firebase import send_push_notification
from django.db import transaction
from decimal import Decimal
from io import BytesIO
import traceback
from rest_framework.response import Response
from .utils.fcm import send_fcm_message
from rest_framework import status  
import uuid
import requests 
import uuid
from django.core.files.base import ContentFile
from django.utils.deconstruct import deconstructible
from rest_framework.parsers import JSONParser, MultiPartParser
import base64
import io  # This import is required to work with byte data
from django.core.files.uploadedfile import InMemoryUploadedFile
from rest_framework.parsers import MultiPartParser, JSONParser
import base64
import io
from datetime import datetime, timedelta
from django.db.models import Max, Q
from rest_framework.decorators import api_view
from rest_framework.response import Response
from rest_framework import status
from django.utils.timezone import make_aware, now
from django.core.files.uploadedfile import InMemoryUploadedFile
from rest_framework.parsers import MultiPartParser, JSONParser
from rest_framework.response import Response
from rest_framework.decorators import api_view, parser_classes
from rest_framework import status 
from .serializers import *
from PIL import Image
from django.utils import timezone
from django.db import transaction
from datetime import timedelta
from django.db.models import Max
from django.db.models.functions import Cast, Substr
import io
from rest_framework.decorators import api_view, parser_classes
from django.db.models import Sum
from django.core.files.base import ContentFile
from api.middleware import *
from rest_framework.decorators import api_view
from django.core.files.storage import default_storage
from rest_framework.response import Response
from rest_framework import status
from api.serializers import *
from _keenthemes import settings
import datetime  
from django.db import IntegrityError
# Create your views here.
from decimal import Decimal, InvalidOperation
from django.core.exceptions import ValidationError
import random
from rest_framework.permissions import AllowAny
from rest_framework.decorators import permission_classes
from datetime import datetime, timedelta
from django.db.models import Sum, F, FloatField
from django.db.models.functions import Cast 
from django.db.models import Sum, Count
from django.db import transaction
from django.db.models import Max
from django.db.models import Q
from django.db.models.functions import Substr  # Updated import
from PIL import Image
from io import BytesIO
from django.core.files.uploadedfile import InMemoryUploadedFile
import logging
from ai.utils import send_otp_email
from ai.utils import send_notification_email
from shapely.geometry import Point, Polygon
# import imghdr
import mimetypes
import base64
import traceback
from rest_framework.pagination import PageNumberPagination
from django.core.exceptions import ValidationError ,ObjectDoesNotExist
from rest_framework.exceptions import NotFound
from drf_spectacular.utils import extend_schema
from rest_framework.pagination import PageNumberPagination
from drf_spectacular.utils import OpenApiParameter


logger = logging.getLogger('api')


target_language = ['ta', 'hi']
SUPPORTED_LANGUAGES = ['en', 'ta', 'hi']


def get_user_language(farmer_id):
    try:
        return UserLanguagePreference.objects.get(user__id=farmer_id, status=0).language_code
    except UserLanguagePreference.DoesNotExist:
        return "en" 
 
@api_view(['GET', 'POST'])
def user_language(request, farmer_id): 
    farmer = get_object_or_404(Farmer, id=farmer_id)

    if request.method == 'GET':
        try:
            # Get the language preference for the specified farmer (user)
            language_preference = UserLanguagePreference.objects.get(user=farmer, status=0)
            return Response({
                'language_code': language_preference.language_code,
                'language_name': language_preference.language_name
            })
        except UserLanguagePreference.DoesNotExist:
            return Response({'message': 'Language preference not found, defaulting to English.'}, status=status.HTTP_404_NOT_FOUND)
    
    elif request.method == 'POST':
        try: 
            language_code = request.data.get('language_code')

            if not language_code:
                return Response({'message': 'Language code is required'}, status=status.HTTP_400_BAD_REQUEST)
 
            language_preference, created = UserLanguagePreference.objects.update_or_create(
                user=farmer,  
                status=0,  
                defaults={'language_code': language_code, 'language_name': language_code.title()}   
            )

            return Response({
                'language_code': language_preference.language_code,
                'language_name': language_preference.language_name
            })
        
        except Exception as e:
            return Response({'message': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@api_view(['GET'])
def get_id(request):

    return Response({"id": request.user_id}, status=status.HTTP_200_OK)

@api_view(['POST'])
def get_login(request):
    if request.method == 'POST':
        mobile_number = request.data.get('mobile_number', None)
        name = request.data.get('name', 'New Farmer')   
        
        if not mobile_number:
            return Response({"detail": "Mobile number is required."}, status=status.HTTP_400_BAD_REQUEST)
 
        if len(mobile_number) > 15:  # Update to 15 characters
            return Response({"detail": "Mobile number exceeds the allowed length of 15 characters."},
                     status=status.HTTP_400_BAD_REQUEST)
 
        if len(name) > 200:   
            return Response({"detail": "Name exceeds the allowed length of 200 characters."}, 
                            status=status.HTTP_400_BAD_REQUEST)

        try: 
            farmer = Farmer.objects.get(phone=mobile_number)
        except Farmer.DoesNotExist: 
            try:
                farmer = Farmer.objects.create(phone=mobile_number, name=name)
            except Exception as e:
                return Response({"detail": f"Error saving farmer: {str(e)}"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
        
        # Prepare response data
        response_data = {
            "id": farmer.id,
            "name": farmer.name,
            "phone": farmer.phone,
            "email": farmer.email,
            "country": farmer.country.name if farmer.country else None,
            "state": farmer.state.name if farmer.state else None,
            "city": farmer.city.name if farmer.city else None,
            "taluk": farmer.taluk.name if farmer.taluk else None,
            "village": farmer.village.name if farmer.village else None,
            "door_no": farmer.door_no,
            "pincode": farmer.pincode,
            "description": farmer.description,
            "img": farmer.img.url if farmer.img else None,
            "company_name": farmer.company_name,
            "tax_no": farmer.tax_no,
            "username": farmer.username,
            "subscription_start_date": farmer.subscription_start_date,
            "subscription_end_date": farmer.subscription_end_date,
            "remaining_days": farmer.remaining_days,
            "amounts": farmer.amounts,
            "status": farmer.status,
        }
        return Response(response_data, status=status.HTTP_200_OK)
 
@api_view(['GET'])
def refresh_access_token(request):
    refresh_token = JWTAuthenticationMiddleware.get_token_from_bearer(request)
    try:
        new_access_token = JWTAuthenticationMiddleware.refresh_access_token(refresh_token)
        return Response({
            'status': 'success',
            'access_token': new_access_token
        }, status=status.HTTP_200_OK)
    except AuthenticationFailed as e:
        return Response({"error": str(e)}, status=status.HTTP_400_BAD_REQUEST)
    
# @api_view(['GET'])
# def country_list(request):
#     countries = Country.objects.filter(status=0)
#     serializer = CountrySerializer(countries, many=True)
 
#     response_data = {
#         "countries": serializer.data,
#         "language": {
#             "default": "en"
#         },
        
#     }

#     return Response(response_data)

# @api_view(['GET'])
# def country_list(request):
#     # Get the language code from query params (e.g., ?lang=ta) or fallback to 'en'
#     language_code = request.GET.get('lang', 'en')  # Default to 'en' if no lang parameter is provided
    
#     # Filter countries with status=0 (active)
#     countries = Country.objects.filter(status=0)
    
#     # Serialize the countries, passing the language code in context
#     serializer = CountrySerializer(countries, many=True, context={'language_code': language_code})
    
#     # Prepare the response data
#     response_data = {
#         "countries": serializer.data,
#         "language": {
#             "default": "en"
#         }
#     }

#     return Response(response_data)

@api_view(['GET'])
def country_list(request):
    # Get the language code from query params or default to 'en'
    language_code = request.GET.get('lang', 'en')

    # Get active countries
    countries = Country.objects.filter(status=0)

    # Build the response data manually
    country_data = []
    for country in countries:
        country_data.append({
            "id": country.id,
            "name": country.get_translated_value("name", language_code),
        })

    response_data = {
        "countries": country_data,
        "language": {
            "default": "en"
        }
    }

    return Response(response_data)



# @api_view(['POST'])
# def state_list(request):
#     country_id = request.data.get('country_id')
    
#     if not country_id:
#         return Response({"error": "country_id is required"}, status=status.HTTP_400_BAD_REQUEST)
    
#     # Get the states for the given country_id
#     states = State.objects.filter(country_id=country_id,status=0)
#     serializer = StateSerializer(states, many=True)

#     # Add the language information to the response
#     response_data = {
        
#         "states": serializer.data,
#         "language": {
#             "default": "en"
#         },
#     }

#     return Response(response_data)

@api_view(['POST'])
def state_list(request):
    country_id = request.data.get('country_id')

    if not country_id:
        return Response({"error": "country_id is required"}, status=status.HTTP_400_BAD_REQUEST)

    # Get the language from ?lang=ta or default to 'en'
    language_code = request.query_params.get('lang', 'en')

    # Filter states
    states = State.objects.filter(country_id=country_id, status=0)

    # Serialize with language context
    serializer = StateSerializer(states, many=True, context={'language_code': language_code})

    # Final response
    response_data = {
        "states": serializer.data,
        "language": {
            "default": "en"
        },
    }

    return Response(response_data)


# @api_view(['POST'])
# def city_list(request):
#     state_id = request.data.get('state_id')
    
#     if not state_id:
#         return Response({"error": "state_id is required"}, status=status.HTTP_400_BAD_REQUEST)
    
#     # Get the cities for the given state_id
#     cities = City.objects.filter(state_id=state_id,status=0)
#     serializer = CitySerializer(cities, many=True)

#     # Add the language information to the response
#     response_data = {
       
#         "cities": serializer.data,
#          "language": {
#             "default": "en"
#         },
#     }

#     return Response(response_data)

@api_view(['POST'])
def city_list(request):
    state_id = request.data.get('state_id')

    if not state_id:
        return Response({"error": "state_id is required"}, status=status.HTTP_400_BAD_REQUEST)

    # Get language from query param (?lang=ta) or fallback to 'en'
    language_code = request.query_params.get('lang', 'en')

    # Filter cities for the given state
    cities = City.objects.filter(state_id=state_id, status=0)

    # Serialize with language context
    serializer = CitySerializer(cities, many=True, context={'language_code': language_code})

    response_data = {
        "cities": serializer.data,
        "language": {
            "default": "en"
        },
    }

    return Response(response_data)

# @api_view(['POST'])
# def taluk_list(request):
#     city_id = request.data.get('city_id')
    
#     if not city_id:
#         return Response({"error": "city_id is required"}, status=status.HTTP_400_BAD_REQUEST)
    
#     # Get the taluks for the given city_id
#     taluks = Taluk.objects.filter(city_id=city_id,status=0)
#     serializer = TalukSerializer(taluks, many=True)

#     # Add the language information to the response
#     response_data = {
#         "taluks": serializer.data,
#         "language": {
#             "default": "en"
#         },
       
#     }

#     return Response(response_data)

@api_view(['POST'])
def taluk_list(request):
    city_id = request.data.get('city_id')

    if not city_id:
        return Response({"error": "city_id is required"}, status=status.HTTP_400_BAD_REQUEST)

    language_code = request.query_params.get('lang', 'en')

    taluks = Taluk.objects.filter(city_id=city_id, status=0)
    serializer = TalukSerializer(taluks, many=True, context={'language_code': language_code})

    response_data = {
        "taluks": serializer.data,
        "language": {
            "default": "en"
        },
    }

    return Response(response_data)


# @api_view(['POST'])
# def village_list(request):
#     taluk_id = request.data.get('taluk_id')
    
#     if not taluk_id:
#         return Response({"error": "taluk_id is required"}, status=status.HTTP_400_BAD_REQUEST)
    
#     # Get the villages for the given taluk_id
#     villages = Village.objects.filter(taluk_id=taluk_id,status=0)
#     serializer = VillageSerializer(villages, many=True)

#     # Add the language information to the response
#     response_data = {
#         "villages": serializer.data,
#         "language": {
#             "default": "en"
#         },
#     }

#     return Response(response_data)

@api_view(['POST'])
def village_list(request):
    taluk_id = request.data.get('taluk_id')
    
    if not taluk_id:
        return Response({"error": "taluk_id is required"}, status=status.HTTP_400_BAD_REQUEST)

    language_code = request.query_params.get('lang', 'en')
    
    # Get the villages for the given taluk_id
    villages = Village.objects.filter(taluk_id=taluk_id,status=0)
    serializer = VillageSerializer(villages, many=True, context={'language_code': language_code})

    # Add the language information to the response
    response_data = {
        "villages": serializer.data,
        "language": {
            "default": "en"
        },
    }

    return Response(response_data)

# Notification GET
@api_view(['GET'])
def notification_list(request,id):
    notifications = Notification.objects.all()
    serializer = NotificationSerializer(notifications, many=True)
    return Response(serializer.data)

# CropType GET
# @api_view(['GET'])
# def crop_type_list(request):
#     try: 
#         crop_types = CropType.objects.filter(status=0) 
#         serializer = CropTypeSerializer(crop_types, many=True) 
#         response_data = {
#             "data": serializer.data,
#             "language": {
#                 "default": "en"
#             },
           
#         } 
#         return Response(response_data, status=status.HTTP_200_OK)

#     except Exception as e: 
#         return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


@api_view(['GET'])
def crop_type_list(request):
    try:
        language_code = request.GET.get('lang', 'en') 
        crop_types = CropType.objects.filter(status=0) 
        serializer = CropTypeSerializer(crop_types, many=True, context={'language_code': language_code}) 
        response_data = {
            "data": serializer.data,
            "language": {
                "default": "en"
            },
           
        } 
        return Response(response_data, status=status.HTTP_200_OK)

    except Exception as e: 
        return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)



# @api_view(['POST'])
# def crop_list(request): 
#     crop_type_id = request.data.get('croptype_id', None) 
#     if not crop_type_id:
#         return Response({"message": "croptype_id is required."}, status=status.HTTP_400_BAD_REQUEST) 
#     try:
#         crop_type = CropType.objects.get(id=crop_type_id, status=0)
#     except CropType.DoesNotExist:
#         return Response({"message": "CropType not found."}, status=status.HTTP_404_NOT_FOUND) 
#     crops = Crop.objects.filter(croptype=crop_type, status=0) 
#     serializer = CropSerializer(crops, many=True) 
#     response_data = {
        
#         "data": serializer.data,
#         "language": {
#             "default": "en"
#         },
#     }
 
#     return Response(response_data, status=status.HTTP_200_OK)

@api_view(['POST'])
def crop_list(request): 
    crop_type_id = request.data.get('croptype_id')
    
    if not crop_type_id:
        return Response({"message": "croptype_id is required."}, status=status.HTTP_400_BAD_REQUEST)

    try:
        crop_type = CropType.objects.get(id=crop_type_id, status=0)
    except CropType.DoesNotExist:
        return Response({"message": "CropType not found."}, status=status.HTTP_404_NOT_FOUND)

    # Get language from query param (?lang=ta)
    language_code = request.GET.get('lang', 'en')
    
    crops = Crop.objects.filter(croptype=crop_type, status=0) 
    serializer = CropSerializer(crops, many=True, context={'language_code': language_code})

    response_data = {
        "data": serializer.data,
        "language": {
            "default": language_code
        },
    }

    return Response(response_data, status=status.HTTP_200_OK)





# @api_view(['GET'])
# def soil_type_list(request):
#     try: 
#         soil_types = SoilType.objects.filter(status=0)
 
#         serializer = SoilTypeSerializer(soil_types, many=True)
 
#         response_data = {
#             "data": serializer.data,
#             "language": {
#                 "default": "en"
#             },
            
#         }
 
#         return Response(response_data, status=status.HTTP_200_OK)

#     except Exception as e: 
#         return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@api_view(['GET'])
def soil_type_list(request):
    try:
        language_code = request.GET.get('lang', 'en')

        soil_types = SoilType.objects.filter(status=0)
 
        serializer = SoilTypeSerializer(soil_types, many=True, context={'language_code': language_code})
 
        response_data = {
            "data": serializer.data,
            "language": {
                "default": "en"
            },
            
        }
 
        return Response(response_data, status=status.HTTP_200_OK)

    except Exception as e: 
        return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)



# @api_view(['GET'])
# def area_unit_list(request):
#     try: 
#         area_units = AreaUnit.objects.filter(status=0)
#         serializer = AreaUnitSerializer(area_units, many=True) 
#         response_data = {
#             "data": serializer.data,
#             "language": {
#                 "default": "en"
#             }, 
#         } 
#         return Response(response_data, status=status.HTTP_200_OK) 
#     except Exception as e: 
#         return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@api_view(['GET'])
def area_unit_list(request):
    try:
        language_code = request.GET.get('lang', 'en')

        area_units = AreaUnit.objects.filter(status=0)
        serializer = AreaUnitSerializer(area_units, many=True, context={'language_code': language_code}) 
        response_data = {
            "data": serializer.data,
            "language": {
                "default": "en"
            }, 
        } 
        return Response(response_data, status=status.HTTP_200_OK) 
    except Exception as e: 
        return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)





# ProductType GET
# @api_view(['GET'])
# def product_type_list(request):
#     product_types = ProductType.objects.filter(status=0)
#     serializer = ProductTypeSerializer(product_types, many=True)

#     # Prepare the response data with language field
#     response_data = {
       
#         "data": serializer.data,
#          "language": {
#             "default": "en"
#         },
#     }

#     # Return the serialized data with language information
#     return Response(response_data)

@api_view(['GET'])
def product_type_list(request):
    language_code = request.GET.get('lang', 'en')

    product_types = ProductType.objects.filter(status=0)
    serializer = ProductTypeSerializer(product_types, many=True, context={'language_code': language_code})

    response_data = {
        "data": serializer.data,
        "language": {
            "default": language_code
        },
    }

    return Response(response_data)



# Schedule GET
@api_view(['GET'])
def schedule_list(request):
    schedules = Schedule.objects.filter(status=0)
    serializer = ScheduleSerializer(schedules, many=True)
    return Response(serializer.data)

# @api_view(['GET'])
# def land_unit_list(request):
#     try: 
#         land_units = LandUnit.objects.filter(status=0)
#         serializer = LandUnitSerializer(land_units, many=True) 
#         response_data = { 
#             "data": serializer.data,
#             "language": {
#                 "default": "en"
#             },
#         } 
#         return Response(response_data, status=status.HTTP_200_OK) 
#     except Exception as e: 
#         return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
 
# @api_view(['GET'])
# def land_unit_list(request):
#     try: 
#         # Get the language code from the query params
#         language_code = request.GET.get('lang', 'en')  # Default to 'en' if no 'lang' parameter is provided
        
#         land_units = LandUnit.objects.filter(status=0)
#         serializer = LandUnitSerializer(land_units, many=True, context={'language_code': language_code})
        
#         response_data = { 
#             "data": serializer.data,
#             "language": {
#                 "default": "en"
#             },
#         } 

#         return Response(response_data, status=status.HTTP_200_OK) 
    
#     except Exception as e: 
#         return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
 
# @api_view(['GET'])
# def land_unit_list(request):
#     try: 
#         language_code = request.GET.get('lang', 'en')  # Default to 'en'

#         land_units = LandUnit.objects.filter(status=0)

#         data = []
#         for unit in land_units:
#             item = {
#                 "id": unit.id,
#                 "name": unit.get_translated_value("name", language_code),
#                 "landunitdef": unit.get_translated_value("landunitdef", language_code),
#                 "description": unit.get_translated_value("description", language_code),
#             }
#             data.append(item)

#         response_data = {
#             "data": data,
#             "language": {
#                 "default": "en"
#             },
#         }

#         return Response(response_data, status=status.HTTP_200_OK)

#     except Exception as e:
#         return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@api_view(['GET'])
def land_unit_list(request):
    try: 
        language_code = request.GET.get('lang', 'en')  # Default to 'en'

        land_units = LandUnit.objects.filter(status=0)

        data = []
        for unit in land_units:
            item = {
                "id": unit.id,
                "name": unit.get_translated_value("name", language_code),
                # "landunitdef": unit.get_translated_value("landunitdef", language_code),
                # "description": unit.get_translated_value("description", language_code),
            }
            data.append(item)

        response_data = {
            "data": data,
            # "language": {
            #     "default": "en"
            # },
        }

        return Response(response_data, status=status.HTTP_200_OK)

    except Exception as e:
        return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


# ExpensesCategory GET
# @api_view(['GET'])
# def expenses_category_list(request):
#     expenses_categories = ExpensesCategory.objects.filter(status=0)
#     serializer = ExpensesCategorySerializer(expenses_categories, many=True)
#     return Response(serializer.data)

@api_view(['GET'])
def expenses_category_list(request):
    language_code = request.GET.get('lang', 'en')  # Default to English

    expenses_categories = ExpensesCategory.objects.filter(status=0)
    serializer = ExpensesCategorySerializer(expenses_categories, many=True, context={'language_code': language_code})

    response_data = {
        "data": serializer.data,
        "language": {
            "default": language_code
        }
    }

    return Response(response_data)


# Expenses GET
# @api_view(['GET'])
# def expenses_list(request):
#     expenses = Expenses.objects.filter(status=0)
#     serializer = ExpensesSerializer(expenses, many=True)
#     return Response(serializer.data)

@api_view(['GET'])
def expenses_list(request):
    # Get the language code from query parameters (default is 'en')
    language_code = request.GET.get('lang', 'en')

    # Retrieve the expenses and filter by active status
    expenses = Expenses.objects.filter(status=0)

    # Serialize the expenses and pass the language code to the serializer context
    serializer = ExpensesSerializer(expenses, many=True, context={'language_code': language_code})

    # Return the serialized data
    return Response(serializer.data)

# InventoryType GET
@api_view(['GET'])
def inventory_type_list(request):
    inventory_types = InventoryType.objects.filter(status=0)
    serializer = InventoryTypeSerializer(inventory_types, many=True)
    return Response(serializer.data)

# InventoryCategory GET
@api_view(['GET'])
def inventory_category_list(request):
    inventory_categories = InventoryCategory.objects.filter(status=0)
    serializer = InventoryCategorySerializer(inventory_categories, many=True)
    return Response(serializer.data)

# InventoryItems GET
@api_view(['GET'])
def inventory_items_list(request):
    inventory_items = InventoryItems.objects.filter(status=0)
    serializer = InventoryItemsSerializer(inventory_items, many=True)
    return Response(serializer.data)

# HarvestingType GET
# @api_view(['GET'])
# def harvesting_type_list(request):
#     harvesting_types = HarvestingType.objects.filter(status=0)
#     serializer = HarvestingTypeSerializer(harvesting_types, many=True)

#     # Prepare the response data with language field
#     response_data = {
        
#         "data": serializer.data,
#         "language": {
#             "default": "en"
#         },
#     }

#     # Return the serialized data with language information
#     return Response(response_data)
 
@api_view(['GET'])
def harvesting_type_list(request):
    # Get the language code from query parameters (default is 'en')
    language_code = request.GET.get('lang', 'en')  # 'lang' is expected as a query parameter

    # Filter HarvestingType to get active items
    harvesting_types = HarvestingType.objects.filter(status=0)

    # Serialize the data, passing the language code to the serializer context
    serializer = HarvestingTypeSerializer(harvesting_types, many=True, context={'language_code': language_code})

    # Prepare the response data with language field
    response_data = {
        "data": serializer.data,
        "language": {
            "default": language_code
        },
    }

    # Return the response with the data and language info
    return Response(response_data)



# @api_view(['GET'])
# def schedule_activity_type_list(request):
#     # Get all activity types where the status is 0 (active)
#     activity_types = ScheduleActivityType.objects.filter(status=0)
    
#     # Serialize the data
#     serializer = ScheduleActivityTypeSerializer(activity_types, many=True)
    
#     # Prepare the response data
#     response_data = {
#         "language": {
#             "default": "en"
#         },
#         "data": serializer.data  # Add the serialized data under the "data" key
#     }
    
#     return Response(response_data)
 
@api_view(['GET'])
def schedule_activity_type_list(request):
    # Get the language code from the query param, default to 'en'
    language_code = request.GET.get('lang', 'en')
    
    # Get all activity types where the status is 0 (active)
    activity_types = ScheduleActivityType.objects.filter(status=0)
    
    # Serialize the data with language context
    serializer = ScheduleActivityTypeSerializer(activity_types, many=True, context={'language_code': language_code})
    
    # Prepare the response data
    response_data = {
        "language": {
            "default": "en"
        },
        "data": serializer.data
    }
    
    return Response(response_data)

# Detection GET
# @api_view(['GET'])
# def detection_list(request):
#     detections = Detection.objects.filter(status=0)
#     serializer = DetectionSerializer(detections, many=True)
#     return Response(serializer.data)

@api_view(['GET'])
def detection_list(request):
    language_code = request.GET.get('lang', 'en')  # Default to English
    detections = Reasons.objects.filter(status=0)
    serializer = ReasonsSerializer(detections, many=True, context={'language_code': language_code})

    return Response({
        "data": serializer.data,
        "language": {"default": "en"}
    })
 
# @api_view(['GET'])
# def document_category_list(request): 
#     doctype = request.query_params.get('doctype', None)

#     if doctype is not None:
#         document_categories = DocumentCategory.objects.filter(status=0, doctype=doctype)
#     else:
#         document_categories = DocumentCategory.objects.filter(status=0)
 
#     serializer = DocumentCategorySerializer(document_categories, many=True)
 
#     response_data = {
#         "language": {
#             "default": "en"
#         },
#         "data": serializer.data  
#     }

#     return Response(response_data, status=status.HTTP_200_OK)
 
 
@api_view(['GET'])
def document_category_list(request): 
    doctype = request.query_params.get('doctype', None)
    language_code = request.query_params.get('lang', 'en')

    if doctype is not None:
        document_categories = DocumentCategory.objects.filter(status=0, doctype=doctype)
    else:
        document_categories = DocumentCategory.objects.filter(status=0)
 
    serializer = DocumentCategorySerializer(document_categories, many=True, context={'language_code': language_code})
 
    response_data = {
        "language": {
            "default": language_code
        },
        "data": serializer.data  
    }

    return Response(response_data, status=status.HTTP_200_OK)

# NearByLocationCategory GET
# @api_view(['GET'])
# def nearby_location_category_list(request):
#     nearby_location_categories = NearByLocationCategory.objects.filter(status=0)
#     serializer = NearByLocationCategorySerializer(nearby_location_categories, many=True)
#     return Response(serializer.data)

# NearByLocationCategory GET
@api_view(['GET'])
def nearby_location_category_list(request):
    language_code = request.GET.get('lang', 'en')  # Default to English if no lang param

    nearby_location_categories = NearByLocationCategory.objects.filter(status=0)
    serializer = NearByLocationCategorySerializer(
        nearby_location_categories, 
        many=True, 
        context={'language_code': language_code}
    )

    return Response({
        "language": {
            "default": "en"
        },
        "data": serializer.data
    })




# GuidelinesCategory GET
# @api_view(['GET'])
# def guidelines_category_list(request):
#     guidelines_categories = GuidelinesCategory.objects.filter(status=0)
#     serializer = GuidelinesCategorySerializer(guidelines_categories, many=True)
#     return Response(serializer.data)
 
@api_view(['GET'])
def guidelines_category_list(request):
    language_code = request.GET.get('lang', 'en')  # Default to English if no lang param
    guidelines_categories = GuidelinesCategory.objects.filter(status=0)
    serializer = GuidelinesCategorySerializer(guidelines_categories, many=True, context={'language_code': language_code})
    return Response({
        "language": {
            "default": "en"
        },
        "data": serializer.data
    })


def send_welcome_email(email, name, username, password):
    print(f"Sending Welcome Mail")  # Debugging line

    try:
        # Here, we use the user's email as the sender
        send_mail(
            'Welcome to AgriOT | Your Login Credentials',  # Subject of the email
            f"""Dear {name},

            Thank you for choosing AgriOT, your all-in-one farming companion! ðŸšœðŸŒ±

            With AgriOT, you can:
            âœ… Store and manage expenses, sales, land, crop, and inventory details.
            âœ… Get guidelines for best crop schedule practices.
            âœ… Plan and follow crop schedules in a calendar format.
            âœ… Enjoy a pocket-friendly and efficient farm management experience.

            Your Login Credentials:
            ðŸ“§ Email: {username}
            ðŸ”‘ Password: {password}

            ðŸ”’ Please keep your email and password safe and secure.

            ðŸ‘‰ Login now to start managing your farm smarter:
            http://147.93.19.253:5000/

            We look forward to helping you grow your farm with AgriOT! ðŸš€

            Best Regards,
            AgriOT Team""",  # Body of the email
            settings.DEFAULT_FROM_EMAIL,  # Send from the user's email (email parameter from CustomUser)
            [email],  # Recipient email address
            fail_silently=False,  # Ensure any failure is raised as an exception
        )
        print(f"Welcome mail sent successfully to {email}!")  # Debugging line
    except Exception as e:
        print(f"Error sending email: {e}") 

def send_welcome_sms(mobile_number, name, username, password):
    print("Sending Welcome SMS")
    SMS_TEMPLATE = {
        'authkey': '155099Ajzgw9B8dfq6737236aP1',  
        'sender_id': 'ELYSIU',  
        'template_id': '1007049094377493090',   
        'country_code': '91',  
        'message_content': 
            f"""Dear {name},

            Thank you for choosing AgriOT, your all-in-one farming companion! ðŸšœðŸŒ±

            With AgriOT, you can:
            âœ… Store and manage expenses, sales, land, crop, and inventory details.
            âœ… Get guidelines for best crop schedule practices.
            âœ… Plan and follow crop schedules in a calendar format.
            âœ… Enjoy a pocket-friendly and efficient farm management experience.

            Your Login Credentials:
            ðŸ“§ Username: {username}
            ðŸ”‘ Password: {password}

            ðŸ”’ Please keep your email and password safe and secure.

            ðŸ‘‰ Login now to start managing your farm smarter:
            http://147.93.19.253:5000/

            We look forward to helping you grow your farm with AgriOT! ðŸš€

            Best Regards,
            AgriOT Team"""  # Define your message content with placeholder
    }

    mobile_number = SMS_TEMPLATE['country_code'] + str(mobile_number)

    message_content = SMS_TEMPLATE['message_content']

    # print(f"Message Content: {message_content}")  # Debugging line

    # Build the API URL for sending SMS
    url = f"https://api.msg91.com/api/sendhttp.php?authkey={SMS_TEMPLATE['authkey']}&sender={SMS_TEMPLATE['sender_id']}&route=default&message={message_content}&mobiles={mobile_number}&DLT_TE_ID={SMS_TEMPLATE['template_id']}"

    try:
        # Make the GET request to send the SMS
        response = requests.get(url)

        # Log the response (for debugging purposes)
        print(f"API Response: {response.text}")

        # Check if the request was successful
        if response.status_code == 200:
            print(f"Welcome SMS sent successfully to {mobile_number}!")  # Debugging line
        else:
            print(f"Failed to send Welcome SMS. Status code: {response.status_code}")
            print(f"Error details: {response.text}")

    except requests.exceptions.RequestException as e:
        # Catch any request exceptions and log the error
        print(f"Error occurred while sending OTP: {e}")

def get_translated_value(field, lang_code):
    activate(lang_code)  
    return _(field)      
    
import requests

def send_sms(mobile_number, message_content):
    SMS_TEMPLATE = {
        'authkey': '155099Ajzgw9B8dfq6737236aP1',
        'sender_id': 'ELYSIU',
        'template_id': '1007049094377493090',  # Use your approved DLT template id
        'country_code': '91',
    }
    
    formatted_mobile_number = SMS_TEMPLATE['country_code'] + str(mobile_number)
    
    # URL encode the message content for safe URL usage
    import urllib.parse
    encoded_message = urllib.parse.quote(message_content)
    
    url = (f"https://api.msg91.com/api/sendhttp.php?authkey={SMS_TEMPLATE['authkey']}"
           f"&sender={SMS_TEMPLATE['sender_id']}"
           f"&route=default"
           f"&message={encoded_message}"
           f"&mobiles={formatted_mobile_number}"
           f"&DLT_TE_ID={SMS_TEMPLATE['template_id']}")
    
    try:
        response = requests.get(url)
        if response.status_code == 200:
            print(f"SMS sent successfully to {formatted_mobile_number}")
            return {"status": "success", "message": "SMS sent successfully"}
        else:
            print(f"Failed to send SMS: {response.text}")
            return {"status": "failed", "message": response.text}
    except Exception as e:
        print(f"Exception sending SMS: {e}")
        return {"status": "error", "message": str(e)}



@api_view(['PUT', 'DELETE', 'GET'])
def manage_farmer(request, id=None):

   
    # if request.method == 'GET':
    #     farmer = get_object_or_404(Farmer, id=id)
        
    #     language_code = get_user_language(id)

    #     # Fetch subscriptions related to the farmer
    #     subscriptions = AddSubcription.objects.filter(farmers=farmer)

    #     subscription_data = []
    #     for subscription in subscriptions:
    #         package = subscription.packages

    #         # Calculate days remaining until subscription expires
    #         if subscription.enddate:
    #             today = timezone.now().date()
    #             days_remaining = (subscription.enddate - today).days
    #         else:
    #             days_remaining = None  # In case there's no end date

    #         subscription_data.append({
    #             "package_name": get_translated_value(package.name if package else "No Package", language_code),
    #             "package_duration": get_translated_value(package.package_duration.name if package and package.package_duration else "N/A", language_code),
    #             "package_validity": package.package_validity if package else "N/A",
    #             "startdate": subscription.startdate,
    #             "enddate": subscription.enddate,
    #             "remainingdays": subscription.remainingdays,
    #             "renewal": subscription.renewal,
    #             "status": subscription.status,
    #             "sub_amount": subscription.sub_amount,
    #             "package_amount": package.amount if package else 0,
    #             "package_sub_amount": package.sub_amount if package else 0,
    #             "package_offer": package.offer if package else False,
    #             "package_percentage": package.percentage if package else 0,
    #             "package_myland_count": package.myland_count if package else 0,
    #             "package_mycrops_count": package.mycrops_count if package else 0,
    #             "package_is_myvechicle": package.is_myvechicle if package else False,
    #             "package_myvechicle_count": package.myvechicle_count if package else 0,
    #             "package_is_mymachinery": package.is_mymachinery if package else False,
    #             "package_mymachinery_count": package.mymachinery_count if package else 0,
    #             "package_is_mytools": package.is_mytools if package else False,
    #             "package_mytools_count": package.mytools_count if package else 0,
    #             "package_is_myinventory": package.is_myinventory if package else False,
    #             "package_myinventory_products": package.myinventory_products if package else 0,
    #             "package_is_attendance": package.is_attendance if package else False,
    #             "package_employee_count": package.employee_count if package else 0,
    #             "package_is_payouts": package.is_payouts if package else False,
    #             "package_is_widget": package.is_widget if package else False,
    #             "subscription_expiration_days": days_remaining  # Add the calculated remaining days
    #         })

    #     addresss_parts = []

    #     # Add address parts based on available values, set "" if door_no missing
    #     addresss_parts.append(get_translated_value(farmer.door_no, language_code) if farmer.door_no else "")
    #     addresss_parts.append(get_translated_value(farmer.village.name, language_code) if farmer.village else None)
    #     addresss_parts.append(get_translated_value(farmer.taluk.name, language_code) if farmer.taluk else None)
    #     addresss_parts.append(get_translated_value(farmer.city.name, language_code) if farmer.city else None)
    #     addresss_parts.append(get_translated_value(farmer.state.name, language_code) if farmer.state else None)
    #     addresss_parts.append(get_translated_value(farmer.country.name, language_code) if farmer.country else None)

    #     # Join the parts together, skipping None values
    #     addresss = ", ".join(part for part in addresss_parts if part is not None)

    #     address_parts = []

    #     # Add door_no translated or empty string
    #     if farmer.door_no:
    #         door_no = farmer.get_translated_value("door_no", language_code)
    #         address_parts.append(door_no)
    #     else:
    #         address_parts.append("")

    #     # Translate and add village, taluk, city, state, country names or None
    #     if farmer.village:
    #         village_name = farmer.village.get_translated_value("name", language_code)
    #         address_parts.append(village_name)
    #     else:
    #         address_parts.append(None)

    #     if farmer.taluk:
    #         taluk_name = farmer.taluk.get_translated_value("name", language_code)
    #         address_parts.append(taluk_name)
    #     else:
    #         address_parts.append(None)

    #     if farmer.city:
    #         city_name = farmer.city.get_translated_value("name", language_code)
    #         address_parts.append(city_name)
    #     else:
    #         address_parts.append(None)

    #     if farmer.state:
    #         state_name = farmer.state.get_translated_value("name", language_code)
    #         address_parts.append(state_name)
    #     else:
    #         address_parts.append(None)

    #     if farmer.country:
    #         country_name = farmer.country.get_translated_value("name", language_code)
    #         address_parts.append(country_name)
    #     else:
    #         address_parts.append(None)

    #     # Join the address parts into a single string, skipping None
    #     address = ", ".join(part for part in address_parts if part is not None)

    #     # If there's an image, get its URL
    #     farmer_img_url = ""
    #     if farmer.img:
    #         farmer_img_url = request.build_absolute_uri(f'/SuperAdmin{farmer.img.url}' if farmer.img else "")

    #     # Data dictionary containing both language responses
    #     data = {
    #         "en": {
    #             "id": farmer.id,
    #             "name": get_translated_value(farmer.name, "en"),
    #             "phone": farmer.phone,
    #             "email": farmer.email,
    #             "country_id": farmer.country.id if farmer.country else None,
    #             "country_name": farmer.country.name if farmer.country else None,
    #             "state_id": farmer.state.id if farmer.state else None,
    #             "state_name": farmer.state.name if farmer.state else None,
    #             "city_id": farmer.city.id if farmer.city else None,
    #             "city_name": farmer.city.name if farmer.city else None,
    #             "taluk_id": farmer.taluk.id if farmer.taluk else None,
    #             "taluk_name": farmer.taluk.name if farmer.taluk else None,
    #             "village_id": farmer.village.id if farmer.village else None,
    #             "village_name": farmer.village.name if farmer.village else None,
    #             "door_no": farmer.door_no if farmer.door_no else "",
    #             "pincode": farmer.pincode if farmer.pincode else None,
    #             "description": farmer.description if farmer.description else None,
    #             "company_name": farmer.company_name if farmer.company_name else None,
    #             "tax_no": farmer.tax_no if farmer.tax_no else None,
    #             "address": addresss,
    #             "subscriptions": subscription_data if subscriptions.exists() else [],
    #             "img_url": farmer_img_url,
    #         },
    #         "ta": {
    #             "id": farmer.id,
    #             "name": farmer.get_translated_value("name", language_code),
    #             "phone": farmer.phone,
    #             "email": farmer.email,
    #             "country_id": farmer.country.id if farmer.country else None,
    #             "country_name": farmer.country.get_translated_value("name", language_code) if farmer.country else None,
    #             "state_id": farmer.state.id if farmer.state else None,
    #             "state_name": farmer.state.get_translated_value("name", language_code) if farmer.state else None,
    #             "city_id": farmer.city.id if farmer.city else None,
    #             "city_name": farmer.city.get_translated_value("name", language_code) if farmer.city else None,
    #             "taluk_id": farmer.taluk.id if farmer.taluk else None,
    #             "taluk_name": farmer.taluk.get_translated_value("name", language_code) if farmer.taluk else None,
    #             "village_id": farmer.village.id if farmer.village else None,
    #             "village_name": farmer.village.get_translated_value("name", language_code) if farmer.village else None,
    #             "door_no": farmer.get_translated_value("door_no", language_code) if farmer.door_no else "",
    #             "pincode": farmer.pincode if farmer.pincode else None,
    #             "description": farmer.get_translated_value("description", language_code) if farmer.description else None,
    #             "company_name": farmer.get_translated_value("company_name", language_code) if farmer.company_name else None,
    #             "tax_no": farmer.tax_no if farmer.tax_no else None,
    #             "address": address,
    #             "subscriptions": subscription_data if subscriptions.exists() else [],
    #             "img_url": farmer_img_url,
    #         },
    #     }

    #     # Return the response based on the `language_code` parameter
    #     if language_code == 'en':
    #         return JsonResponse(data["en"], status=status.HTTP_200_OK)
    #     elif language_code == 'ta':
    #         return JsonResponse(data["ta"], status=status.HTTP_200_OK)
    #     else:
    #         return JsonResponse({"error": "Unsupported language code"}, status=status.HTTP_400_BAD_REQUEST)
    
    if request.method == 'GET':
        farmer = get_object_or_404(Farmer, id=id)
        
        language_code = get_user_language(id)

        # Fetch subscriptions related to the farmer
        subscriptions = AddSubcription.objects.filter(farmers=farmer)

        subscription_data = []
        for subscription in subscriptions:
            package = subscription.packages

            if subscription.enddate:
                today = timezone.now().date()
                days_remaining = (subscription.enddate - today).days
            else:
                days_remaining = None

            subscription_data.append({
                "package_name": get_translated_value(package.name if package else "No Package", language_code),
                "package_duration": get_translated_value(package.package_duration.name if package and package.package_duration else "N/A", language_code),
                "package_validity": package.package_validity if package else "N/A",
                "startdate": subscription.startdate,
                "enddate": subscription.enddate,
                "remainingdays": subscription.remainingdays,
                "renewal": subscription.renewal,
                "status": subscription.status,
                "sub_amount": subscription.sub_amount,
                "package_amount": package.amount if package else 0,
                "package_sub_amount": package.sub_amount if package else 0,
                "package_offer": package.offer if package else False,
                "package_percentage": package.percentage if package else 0,
                "package_myland_count": package.myland_count if package else 0,
                "package_mycrops_count": package.mycrops_count if package else 0,
                "package_is_myvechicle": package.is_myvechicle if package else False,
                "package_myvechicle_count": package.myvechicle_count if package else 0,
                "package_is_mymachinery": package.is_mymachinery if package else False,
                "package_mymachinery_count": package.mymachinery_count if package else 0,
                "package_is_mytools": package.is_mytools if package else False,
                "package_mytools_count": package.mytools_count if package else 0,
                "package_is_myinventory": package.is_myinventory if package else False,
                "package_myinventory_products": package.myinventory_products if package else 0,
                "package_is_attendance": package.is_attendance if package else False,
                "package_employee_count": package.employee_count if package else 0,
                "package_is_payouts": package.is_payouts if package else False,
                "package_is_widget": package.is_widget if package else False,
                "subscription_expiration_days": days_remaining
            })

        # Compose address without location hierarchy fields; just door_no or empty
        address_parts = []
        address_parts.append(get_translated_value(farmer.door_no, language_code) if farmer.door_no else "")
        address = ", ".join(part for part in address_parts if part)

        # Farmer image url
        farmer_img_url = ""
        if farmer.img:
            farmer_img_url = request.build_absolute_uri(f'/SuperAdmin{farmer.img.url}')

        data = {
            "en": {
                "id": farmer.id,
                "name": get_translated_value(farmer.name, "en"),
                "phone": farmer.phone,
                "email": farmer.email,
                # Removed country/state/city/taluk/village fields here
                "door_no": farmer.door_no if farmer.door_no else "",
                "pincode": farmer.pincode if farmer.pincode else None,
                "description": farmer.description if farmer.description else None,
                "company_name": farmer.company_name if farmer.company_name else None,
                "tax_no": farmer.tax_no if farmer.tax_no else None,
                "address": address,
                "locations": farmer.locations if farmer.locations else None,  # And here
                "subscriptions": subscription_data if subscriptions.exists() else [],
                "img_url": farmer_img_url,
            },
            "ta": {
                "id": farmer.id,
                "name": farmer.get_translated_value("name", language_code),
                "phone": farmer.phone,
                "email": farmer.email,
                # Removed country/state/city/taluk/village fields here
                "door_no": farmer.get_translated_value("door_no", language_code) if farmer.door_no else "",
                "pincode": farmer.pincode if farmer.pincode else None,
                "description": farmer.get_translated_value("description", language_code) if farmer.description else None,
                "company_name": farmer.get_translated_value("company_name", language_code) if farmer.company_name else None,
                "tax_no": farmer.tax_no if farmer.tax_no else None,
                "address": address,
                "locations": farmer.locations if farmer.locations else None,  # And here
                "subscriptions": subscription_data if subscriptions.exists() else [],
                "img_url": farmer_img_url,
            },
        }

        if language_code == 'en':
            return JsonResponse(data["en"], status=status.HTTP_200_OK)
        elif language_code == 'ta':
            return JsonResponse(data["ta"], status=status.HTTP_200_OK)
        else:
            return JsonResponse({"error": "Unsupported language code"}, status=status.HTTP_400_BAD_REQUEST)
     
    # elif request.method == 'PUT': 
    #     farmer = get_object_or_404(Farmer, id=id)
    #     data = request.data 

    #     # Check if the phone number is already in use by another farmer
    #     if 'phone' in data:
    #         phone = data.get('phone')
    #         if Farmer.objects.exclude(id=id).filter(phone=phone).exists():
    #             return JsonResponse({"error": "The phone number is already in use by another farmer."}, status=400)

    #     # --- Name-based creation/update for foreign keys ---

    #     # Handle country_name
    #     if 'country_name' in data and data['country_name'].strip():
    #         country_name = data['country_name'].strip()
    #         country_obj, created = Country.objects.get_or_create(name=country_name)
    #         if not created:
    #             country_obj.name = country_name
    #             country_obj.save()
    #         data['country'] = country_obj.id

    #     # Handle state_name
    #     if 'state_name' in data and data['state_name'].strip():
    #         state_name = data['state_name'].strip()
    #         country_id = data.get('country')
    #         if country_id:
    #             state_obj, created = State.objects.get_or_create(name=state_name, country_id=country_id)
    #             if not created:
    #                 state_obj.name = state_name
    #                 state_obj.save()
    #             data['state'] = state_obj.id

    #     # Handle city_name
    #     if 'city_name' in data and data['city_name'].strip():
    #         city_name = data['city_name'].strip()
    #         state_id = data.get('state')
    #         country_id = data.get('country')  # <-- Added
    #         if state_id and country_id:
    #             city_obj, created = City.objects.get_or_create(
    #                 name=city_name,
    #                 state_id=state_id,
    #                 country_id=country_id  # Include country if required by your model
    #             )
    #             if not created:
    #                 city_obj.name = city_name
    #                 city_obj.save()
    #             data['city'] = city_obj.id
    #         elif state_id:  # fallback if no country_id
    #             city_obj, created = City.objects.get_or_create(
    #                 name=city_name,
    #                 state_id=state_id
    #             )
    #             if not created:
    #                 city_obj.name = city_name
    #                 city_obj.save()
    #             data['city'] = city_obj.id

    #     # Handle taluk_name
    #     if 'taluk_name' in data and data['taluk_name'].strip():
    #         taluk_name = data['taluk_name'].strip()
    #         city_id = data.get('city')
    #         state_id = data.get('state')
    #         country_id = data.get('country')

    #         # Make sure you have required parent ids
    #         if city_id and state_id and country_id:
    #             taluk_obj, created = Taluk.objects.get_or_create(
    #                 name=taluk_name,
    #                 city_id=city_id,
    #                 state_id=state_id,
    #                 country_id=country_id
    #             )
    #             if not created:
    #                 taluk_obj.name = taluk_name
    #                 taluk_obj.save()
    #             data['taluk'] = taluk_obj.id

    #         # Fallback if country or state missing (adjust as per your model's requirements)
    #         elif city_id and state_id:
    #             taluk_obj, created = Taluk.objects.get_or_create(
    #                 name=taluk_name,
    #                 city_id=city_id,
    #                 state_id=state_id
    #             )
    #             if not created:
    #                 taluk_obj.name = taluk_name
    #                 taluk_obj.save()
    #             data['taluk'] = taluk_obj.id


    #     # Handle village_name
    #     if 'village_name' in data and data['village_name'].strip():
    #         village_name = data['village_name'].strip()
    #         taluk_id = data.get('taluk')
    #         city_id = data.get('city')
    #         state_id = data.get('state')
    #         country_id = data.get('country')

    #         # Check if all foreign keys are present
    #         if taluk_id and city_id and state_id and country_id:
    #             village_obj, created = Village.objects.get_or_create(
    #                 name=village_name,
    #                 taluk_id=taluk_id,
    #                 city_id=city_id,
    #                 state_id=state_id,
    #                 country_id=country_id
    #             )
    #             if not created:
    #                 village_obj.name = village_name
    #                 village_obj.save()
    #             data['village'] = village_obj.id

    #         # Fallback if some are missing, adjust based on your model's requirements
    #         elif taluk_id:
    #             village_obj, created = Village.objects.get_or_create(
    #                 name=village_name,
    #                 taluk_id=taluk_id
    #             )
    #             if not created:
    #                 village_obj.name = village_name
    #                 village_obj.save()
    #             data['village'] = village_obj.id


    #     # Assign foreign key objects
    #     try:
    #         country = Country.objects.get(id=data.get('country')) if data.get('country') else farmer.country 
    #         state = State.objects.get(id=data.get('state')) if data.get('state') else farmer.state
    #         city = City.objects.get(id=data.get('city')) if data.get('city') else farmer.city
    #         taluk = Taluk.objects.get(id=data.get('taluk')) if data.get('taluk') else farmer.taluk
    #         village = Village.objects.get(id=data.get('village')) if data.get('village') else farmer.village
    #     except Exception as e:
    #         return JsonResponse({"error": f"Invalid foreign key value: {str(e)}"}, status=400)

    #     # Google Translate logic
    #     translate_json = farmer.translate_json if farmer.translate_json else {
    #         "name": {},
    #         "company_name": {},
    #         "door_no": {},
    #         "description": {}
    #     }

    #     # Update fields with translation
    #     farmer.name = data.get('name', farmer.name)
    #     if 'name' in data:
    #         for lang in target_language:
    #             try:
    #                 translated_name = GoogleTranslator(source='auto', target=lang).translate(farmer.name)
    #                 print(f"Translated '{farmer.name}' to {lang}: {translated_name}")
    #                 translate_json["name"][lang] = translated_name
    #             except Exception as e:
    #                 print(f"Error translating '{farmer.name}' to {lang}: {e}")

    #     farmer.description = data.get('description', farmer.description)
    #     if 'description' in data:
    #         for lang in target_language:
    #             try:
    #                 translated_description = GoogleTranslator(source='auto', target=lang).translate(farmer.description)
    #                 translate_json["description"][lang] = translated_description
    #             except Exception as e:
    #                 print(f"Error translating '{farmer.description}' to {lang}: {e}")

    #     farmer.company_name = data.get('company_name', farmer.company_name)
    #     if 'company_name' in data:
    #         for lang in target_language:
    #             try:
    #                 translated_company_name = GoogleTranslator(source='auto', target=lang).translate(farmer.company_name)
    #                 translate_json["company_name"][lang] = translated_company_name
    #             except Exception as e:
    #                 print(f"Error translating '{farmer.company_name}' to {lang}: {e}")

    #     farmer.door_no = data.get('door_no', farmer.door_no)
    #     if 'door_no' in data:
    #         for lang in target_language:
    #             try:
    #                 translated_door_no = GoogleTranslator(source='auto', target=lang).translate(farmer.door_no)
    #                 translate_json["door_no"][lang] = translated_door_no
    #             except Exception as e:
    #                 print(f"Error translating '{farmer.door_no}' to {lang}: {e}")

    #     # Other fields
    #     farmer.phone = data.get('phone', farmer.phone)
    #     farmer.email = data.get('email', farmer.email)
    #     farmer.country = country
    #     farmer.state = state
    #     farmer.city = city
    #     farmer.taluk = taluk
    #     farmer.village = village
    #     farmer.pincode = data.get('pincode', farmer.pincode)
    #     farmer.tax_no = data.get('tax_no', farmer.tax_no)
    #     farmer.created_at = timezone.now()

    #     # Image handling
    #     if 'img' in data:
    #         img_data = data['img']
    #         if img_data.startswith("data:image"):
    #             image_data = img_data.split(';base64,')[1]
    #             img_name = f'farmer_{farmer.id}_{timezone.now().strftime("%Y%m%d%H%M%S")}.png'
    #             img_path = os.path.join('media/', img_name)
    #             decoded_img = base64.b64decode(image_data)
    #             img_file = ContentFile(decoded_img, name=img_name)
    #             farmer.img.save(img_name, img_file, save=True)

    #     # Set default status
    #     farmer.status = 0

    #     try:
    #         with transaction.atomic():
    #             farmer.full_clean()

    #             if farmer.farmer_user:
    #                 farmer_user = farmer.farmer_user
    #                 farmer_user.name = data.get('name', farmer_user.name)
    #                 farmer_user.phone_number = data.get('phone', farmer_user.phone_number)
    #                 farmer_user.email = data.get('email', farmer_user.email)
    #                 farmer_user.save()

    #             if farmer.status == 0:
    #                 subscription = AddSubcription.objects.filter(farmers=farmer).first()
    #                 if subscription:
    #                     subscription.status = 0
    #                     subscription.save()

    #             farmer.translate_json = translate_json
    #             farmer.save()

    #             if not WidgetConfig.objects.filter(farmer=farmer).exists():
    #                 WidgetConfig.objects.create(
    #                     farmer=farmer,
    #                     created_at=timezone.now()
    #                 )
    #                 print(f"WidgetConfig created for Farmer ID: {farmer.id}")

    #             try:
    #                 if farmer.email:
    #                     send_welcome_email(farmer.email, farmer.name, farmer.email, farmer.phone)
    #                 else:
    #                     send_welcome_sms(farmer.phone, farmer.name, farmer.phone, farmer.phone)
    #             except Exception as e:
    #                 print(e)
    #                 print("Error in sending Welcome Email or SMS")

    #             img_url = request.build_absolute_uri(f'/SuperAdmin{farmer.img.url}') if farmer.img else None

    #             response_data = {
    #                 "id": farmer.id,
    #                 "name": farmer.name,
    #                 "phone": farmer.phone,
    #                 "email": farmer.email,
    #                 "country": farmer.country.id if farmer.country else None,
    #                 "country_name": farmer.country.name if farmer.country else None,
    #                 "state": farmer.state.id if farmer.state else None,
    #                 "state_name": farmer.state.name if farmer.state else None,
    #                 "city": farmer.city.id if farmer.city else None,
    #                 "city_name": farmer.city.name if farmer.city else None,
    #                 "taluk": farmer.taluk.id if farmer.taluk else None,
    #                 "taluk_name": farmer.taluk.name if farmer.taluk else None,
    #                 "village": farmer.village.id if farmer.village else None,
    #                 "village_name": farmer.village.name if farmer.village else None,
    #                 "door_no": farmer.door_no,
    #                 "pincode": farmer.pincode,
    #                 "description": farmer.description,
    #                 "company_name": farmer.company_name,
    #                 "tax_no": farmer.tax_no,
    #                 "status": farmer.status,
    #                 "img": img_url,
    #                 "language": {
    #                     "default": "en"
    #                 }
    #             }

    #             return JsonResponse(response_data, status=200)

    #     except ValidationError as e:
    #         return JsonResponse({"errors": e.message_dict}, status=400)
    #     except Exception as e:
    #         return JsonResponse({"error": str(e)}, status=500)

    # elif request.method == 'PUT':
    #     farmer = get_object_or_404(Farmer, id=id)
    #     data = request.data

    #     # Validate unique phone number
    #     if 'phone' in data:
    #         phone = data.get('phone')
    #         if Farmer.objects.exclude(id=id).filter(phone=phone).exists():
    #             return JsonResponse({"error": "The phone number is already in use by another farmer."}, status=400)

    #     # Google Translate logic
    #     translate_json = farmer.translate_json if farmer.translate_json else {
    #         "name": {},
    #         "company_name": {},
    #         "door_no": {},
    #         "description": {}
    #     }

    #     # Name + Translation
    #     farmer.name = data.get('name', farmer.name)
    #     if 'name' in data:
    #         for lang in target_language:
    #             try:
    #                 translated_name = GoogleTranslator(source='auto', target=lang).translate(farmer.name)
    #                 translate_json["name"][lang] = translated_name
    #             except Exception as e:
    #                 print(f"Error translating name to {lang}: {e}")

    #     # Description + Translation
    #     farmer.description = data.get('description', farmer.description)
    #     if 'description' in data:
    #         for lang in target_language:
    #             try:
    #                 translated_desc = GoogleTranslator(source='auto', target=lang).translate(farmer.description)
    #                 translate_json["description"][lang] = translated_desc
    #             except Exception as e:
    #                 print(f"Error translating description to {lang}: {e}")

    #     # Company name + Translation
    #     farmer.company_name = data.get('company_name', farmer.company_name)
    #     if 'company_name' in data:
    #         for lang in target_language:
    #             try:
    #                 translated_company = GoogleTranslator(source='auto', target=lang).translate(farmer.company_name)
    #                 translate_json["company_name"][lang] = translated_company
    #             except Exception as e:
    #                 print(f"Error translating company name to {lang}: {e}")

    #     # Door no + Translation
    #     farmer.door_no = data.get('door_no', farmer.door_no)
    #     if 'door_no' in data:
    #         for lang in target_language:
    #             try:
    #                 translated_door = GoogleTranslator(source='auto', target=lang).translate(farmer.door_no)
    #                 translate_json["door_no"][lang] = translated_door
    #             except Exception as e:
    #                 print(f"Error translating door no to {lang}: {e}")

    #     # Other fields
    #     farmer.phone = data.get('phone', farmer.phone)
    #     farmer.email = data.get('email', farmer.email)
    #     farmer.pincode = data.get('pincode', farmer.pincode)
    #     farmer.tax_no = data.get('tax_no', farmer.tax_no)
    #     farmer.created_at = timezone.now()

    #     # âœ… Updated location-based fields with URL parsing
    #     locations_input = data.get('locations', farmer.locations)
    #     farmer.locations = locations_input

    #     if locations_input and 'google.com/maps' in locations_input:
    #         try:
    #             import re

    #             # Extract latitude and longitude from Google Maps URL (format: @lat,lng)
    #             match = re.search(r'@([-.\d]+),([-.\d]+)', locations_input)
    #             if match:
    #                 farmer.latitude = float(match.group(1))
    #                 farmer.longitude = float(match.group(2))
    #         except Exception as e:
    #             print(f"Error parsing coordinates from URL: {e}")
    #     else:
    #         # If no URL or no match, fallback to manual lat/lng from data
    #         farmer.latitude = data.get('latitude', farmer.latitude)
    #         farmer.longitude = data.get('longitude', farmer.longitude)

    #     # Image handling
    #     if 'img' in data:
    #         img_data = data['img']
    #         if img_data.startswith("data:image"):
    #             try:
    #                 image_data = img_data.split(';base64,')[1]
    #                 img_name = f'farmer_{farmer.id}_{timezone.now().strftime("%Y%m%d%H%M%S")}.png'
    #                 decoded_img = base64.b64decode(image_data)
    #                 img_file = ContentFile(decoded_img, name=img_name)
    #                 farmer.img.save(img_name, img_file, save=True)
    #             except Exception as e:
    #                 print(f"Image decoding failed: {e}")

    #     farmer.status = 0  # Set default status

    #     try:
    #         with transaction.atomic():
    #             farmer.full_clean()

    #             # Update CustomUser linked to farmer
    #             if farmer.farmer_user:
    #                 farmer_user = farmer.farmer_user
    #                 farmer_user.name = data.get('name', farmer_user.name)
    #                 farmer_user.phone_number = data.get('phone', farmer_user.phone_number)
    #                 farmer_user.email = data.get('email', farmer_user.email)
    #                 farmer_user.save()

    #             # Subscription status handling
    #             if farmer.status == 0:
    #                 subscription = AddSubcription.objects.filter(farmers=farmer).first()
    #                 if subscription:
    #                     subscription.status = 0
    #                     subscription.save()

    #             farmer.translate_json = translate_json
    #             farmer.save()

    #             # Create WidgetConfig if not exists
    #             if not WidgetConfig.objects.filter(farmer=farmer).exists():
    #                 WidgetConfig.objects.create(
    #                     farmer=farmer,
    #                     created_at=timezone.now()
    #                 )
    #                 print(f"WidgetConfig created for Farmer ID: {farmer.id}")

    #             # Send welcome message
    #             try:
    #                 if farmer.email:
    #                     send_welcome_email(farmer.email, farmer.name, farmer.email, farmer.phone)
    #                 else:
    #                     send_welcome_sms(farmer.phone, farmer.name, farmer.phone, farmer.phone)
    #             except Exception as e:
    #                 print(f"Error sending welcome notification: {e}")

    #             img_url = request.build_absolute_uri(f'/SuperAdmin{farmer.img.url}') if farmer.img else None

    #             response_data = {
    #                 "id": farmer.id,
    #                 "name": farmer.name,
    #                 "phone": farmer.phone,
    #                 "email": farmer.email,
    #                 "door_no": farmer.door_no,
    #                 "pincode": farmer.pincode,
    #                 "description": farmer.description,
    #                 "company_name": farmer.company_name,
    #                 "tax_no": farmer.tax_no,
    #                 "status": farmer.status,
    #                 "locations": farmer.locations,
    #                 "latitude": farmer.latitude,
    #                 "longitude": farmer.longitude,
    #                 "img": img_url,
    #                 "language": {
    #                     "default": "en"
    #                 }
    #             }

    #             return JsonResponse(response_data, status=200)

    #     except ValidationError as e:
    #         return JsonResponse({"errors": e.message_dict}, status=400)
    #     except Exception as e:
    #         return JsonResponse({"error": str(e)}, status=500)

    elif request.method == 'PUT':
        farmer = get_object_or_404(Farmer, id=id)
        data = request.data

        old_status = farmer.status  # Save the old status before changes

        # Validate unique phone number
        if 'phone' in data:
            phone = data.get('phone')
            if Farmer.objects.exclude(id=id).filter(phone=phone).exists():
                return JsonResponse({"error": "The phone number is already in use by another farmer."}, status=400)

        # Google Translate logic
        translate_json = farmer.translate_json if farmer.translate_json else {
            "name": {},
            "company_name": {},
            "door_no": {},
            "description": {}
        }

        # Name + Translation
        farmer.name = data.get('name', farmer.name)
        if 'name' in data:
            for lang in target_language:
                try:
                    translated_name = GoogleTranslator(source='auto', target=lang).translate(farmer.name)
                    translate_json["name"][lang] = translated_name
                except Exception as e:
                    print(f"Error translating name to {lang}: {e}")

        # Description + Translation
        farmer.description = data.get('description', farmer.description)
        if 'description' in data:
            for lang in target_language:
                try:
                    translated_desc = GoogleTranslator(source='auto', target=lang).translate(farmer.description)
                    translate_json["description"][lang] = translated_desc
                except Exception as e:
                    print(f"Error translating description to {lang}: {e}")

        # Company name + Translation
        farmer.company_name = data.get('company_name', farmer.company_name)
        if 'company_name' in data:
            for lang in target_language:
                try:
                    translated_company = GoogleTranslator(source='auto', target=lang).translate(farmer.company_name)
                    translate_json["company_name"][lang] = translated_company
                except Exception as e:
                    print(f"Error translating company name to {lang}: {e}")

        # Door no + Translation
        farmer.door_no = data.get('door_no', farmer.door_no)
        if 'door_no' in data:
            for lang in target_language:
                try:
                    translated_door = GoogleTranslator(source='auto', target=lang).translate(farmer.door_no)
                    translate_json["door_no"][lang] = translated_door
                except Exception as e:
                    print(f"Error translating door no to {lang}: {e}")

        # Other fields
        farmer.phone = data.get('phone', farmer.phone)
        farmer.email = data.get('email', farmer.email)
        farmer.pincode = data.get('pincode', farmer.pincode)
        farmer.tax_no = data.get('tax_no', farmer.tax_no)
        farmer.created_at = timezone.now()

        # Location fields update with URL parsing
        locations_input = data.get('locations', farmer.locations)
        farmer.locations = locations_input

        if locations_input and 'google.com/maps' in locations_input:
            try:
                import re
                match = re.search(r'@([-.\d]+),([-.\d]+)', locations_input)
                if match:
                    farmer.latitude = float(match.group(1))
                    farmer.longitude = float(match.group(2))
            except Exception as e:
                print(f"Error parsing coordinates from URL: {e}")
        else:
            farmer.latitude = data.get('latitude', farmer.latitude)
            farmer.longitude = data.get('longitude', farmer.longitude)

        # Image handling
        if 'img' in data:
            img_data = data['img']
            if img_data.startswith("data:image"):
                try:
                    image_data = img_data.split(';base64,')[1]
                    img_name = f'farmer_{farmer.id}_{timezone.now().strftime("%Y%m%d%H%M%S")}.png'
                    decoded_img = base64.b64decode(image_data)
                    img_file = ContentFile(decoded_img, name=img_name)
                    farmer.img.save(img_name, img_file, save=True)
                except Exception as e:
                    print(f"Image decoding failed: {e}")

        # Set status to 0 (default)
        farmer.status = 0

        try:
            with transaction.atomic():
                farmer.full_clean()

                # Update linked CustomUser
                if farmer.farmer_user:
                    farmer_user = farmer.farmer_user
                    farmer_user.name = data.get('name', farmer_user.name)
                    farmer_user.phone_number = data.get('phone', farmer_user.phone_number)
                    farmer_user.email = data.get('email', farmer_user.email)
                    farmer_user.save()

                # Subscription status handling
                if farmer.status == 0:
                    subscription = AddSubcription.objects.filter(farmers=farmer).first()
                    if subscription:
                        subscription.status = 0
                        subscription.save()

                farmer.translate_json = translate_json
                farmer.save()

                # Check if status changed from 7 to 0 and create notification
                # if old_status == 7 and farmer.status == 0:
                #     notification_message = "Try full access free for 3 days â€” subscribe to keep using the service."
                #     FarmerNotification.objects.create(
                #         farmer=farmer,
                #         name="New Farmer",
                #         type="Farmer Management",
                #         message=notification_message,
                #         is_read=False
                #     )

                # Check if status changed from 7 to 0 and create notification + send email
                if old_status == 7 and farmer.status == 0:
                    notification_message = "Try full access free for 3 days â€” subscribe to keep using the service."
                    
                    # Create DB notification
                    FarmerNotification.objects.create(
                        farmer=farmer,
                        name="New Farmer",
                        type="Farmer Management",
                        message=notification_message,
                        is_read=False
                    )
                    
                    # Send notification email if email exists
                    if farmer.email:
                        try:
                            send_notification_email(
                                email=farmer.email,
                                subject="Welcome to Our Service!",
                                message=notification_message
                            )
                        except Exception as e:
                            print(f"Error sending notification email: {e}")

                    # **Send SMS notification to farmer's phone**
                    if farmer.phone:
                        try:
                            sms_result = send_sms(farmer.phone, notification_message)
                            print(f"SMS sending result: {sms_result}")
                        except Exception as e:
                            print(f"Error sending SMS notification: {e}")


                # Create WidgetConfig if not exists
                if not WidgetConfig.objects.filter(farmer=farmer).exists():
                    WidgetConfig.objects.create(
                        farmer=farmer,
                        created_at=timezone.now()
                    )
                    print(f"WidgetConfig created for Farmer ID: {farmer.id}")

                # Send welcome message
                try:
                    if farmer.email:
                        send_welcome_email(farmer.email, farmer.name, farmer.email, farmer.phone)
                    else:
                        send_welcome_sms(farmer.phone, farmer.name, farmer.phone, farmer.phone)
                except Exception as e:
                    print(f"Error sending welcome notification: {e}")

                img_url = request.build_absolute_uri(f'/SuperAdmin{farmer.img.url}') if farmer.img else None

                response_data = {
                    "id": farmer.id,
                    "name": farmer.name,
                    "phone": farmer.phone,
                    "email": farmer.email,
                    "door_no": farmer.door_no,
                    "pincode": farmer.pincode,
                    "description": farmer.description,
                    "company_name": farmer.company_name,
                    "tax_no": farmer.tax_no,
                    "status": farmer.status,
                    "locations": farmer.locations,
                    "latitude": farmer.latitude,
                    "longitude": farmer.longitude,
                    "img": img_url,
                    "language": {
                        "default": "en"
                    }
                }

                return JsonResponse(response_data, status=200)

        except ValidationError as e:
            return JsonResponse({"errors": e.message_dict}, status=400)
        except Exception as e:
            return JsonResponse({"error": str(e)}, status=500)



    elif request.method == 'DELETE': 
        farmer = get_object_or_404(Farmer, id=id)

        try: 
            farmer.delete()
 
            return JsonResponse({"message": "Farmer deleted successfully"}, status=200)

        except Exception as e:
            return JsonResponse({"error": str(e)}, status=500)

@api_view(['GET'])
def get_land_list(request,id):
    land_id = request.query_params.get('id') 
    lands = MyLand.objects.filter(id=land_id)
    serializer = MyLandDetailsSerializer(lands, many=True)
    return Response(serializer.data, status=status.HTTP_200_OK)
 
@api_view(['GET'])
def get_land_with_crop_list(request, id):
    try: 
        lands = MyLand.objects.filter(farmer=id, status=0)  
        if not lands.exists():
            return Response(
                {"detail": "No lands found for the given farmer or lands are not active."},
                status=status.HTTP_404_NOT_FOUND
            )
    except MyLand.DoesNotExist:
        return Response(
            {"detail": "Error: MyLand not found for the given farmer."},
            status=status.HTTP_404_NOT_FOUND
        )
    except Exception as e:
        return Response(
            {"detail": f"An unexpected error occurred: {str(e)}"},
            status=status.HTTP_500_INTERNAL_SERVER_ERROR
        )

    try:
        land_data_list = []
        custom_response = {
            "lands": [],
        }

        for land in lands:
            land_data = MyLandDetailsSerializer(land).data
            crops = MyCrop.objects.filter(land=land, status=0)
            land_data['crop_count'] = crops.count()
            crop_list = []

            # Add land details to the custom response
            custom_response["lands"].append({
                "id": land.id,
                "name": land.name,
                "farmer_id": land.farmer.id, 
                "farmer_name": land.farmer.name,  
                "soil_type_id": land.soil_type.id, 
                "soil_type_name": land.soil_type.name,
                "country_id": land.country.id,
                "country_name": land.country.name,
                "state_id": land.state.id,  
                "state_name": land.state.name,  
                "city_id": land.city.id,  
                "city_name": land.city.name,  
                "taluk_id": land.taluk.id,  
                "taluk_name": land.taluk.name,  
                "village_id": land.village.id,  
                "village_name": land.village.name,  
                "door_no": land.door_no,
                "locations": land.locations,
                "latitude": land.latitude,
                "longitude": land.longitude,
                "patta_number": land.patta_number,
                "description": land.description,
                "l_status": land.l_status,
                "crop_count": land_data['crop_count'],
                "measurement_value": land.measurement_value,
                "measurement_unit": land.measurement_unit.name,
                "measurement_unit_id": land.measurement_unit.id,
                "survey_details": MyLandSurveyDetailsSerializer(land.survey_details.all(), many=True).data,
                "documents": MyLandDocumentSerializer(land.documents.all(), many=True).data,
                "crops": []
            })

            land_data['crop_count'] = crops.count()

            for crop in crops:
                crop_data = MyCropDetailsSerializer(crop).data
                schedules = MySchedule.objects.filter(my_crop=crop, farmer=id,status=0)

                crop_data['schedule_total_count'] = schedules.count()
                crop_data['schedule_completed_count'] = schedules.filter(schedule_status__status=1).count()

                if crop.plantation_date:
                    days_since_plantation = crop.plantation_date
                    crop_data['days_since_plantation'] = days_since_plantation

                crop_list.append(crop_data)

                # Add crop details to custom response
                custom_response["lands"][-1]["crops"].append({
                    "id": crop.id,
                    "name": crop.crop.name,
                    "crop_id": crop.crop.id,
                    "crop_image": '/assets' + crop.crop.img.url if crop.crop.img else '/assets/images/product_img/crop_default.png',
                    "farmer_id": crop.farmer.id,  
                    "farmer_name": crop.farmer.name,  
                    "crop_type_id": crop.crop_type.id,  
                    "crop_type_name": crop.crop_type.name,
                    "harvestingType_id" :crop.harvesting_type.id,
                    "harvestingType_name":crop.harvesting_type.name,
                    "plantationDate":crop.plantation_date,
                    "land_id":crop.land.id,
                    "land_name":crop.land.name,
                    "measurement_unit_id": crop.measurement_unit.id,  
                    "measurement_unit_name": crop.measurement_unit.name,
                    "survey_details": MyLandSurveyDetailsSerializer(crop.survey_details.all(), many=True).data,
                    "geoMarks":crop.geo_marks,
                    "expense":crop.expense,
                    "sales":crop.sales,
                    "schedule_total_count": crop_data['schedule_total_count'],
                    "schedule_completed_count": crop_data['schedule_completed_count'],
                    "days_since_plantation": crop_data.get('days_since_plantation', None)
                })

            land_data_list.append(land_data)

        # Return the custom response with land and crop details
        return Response(custom_response, status=status.HTTP_200_OK)
    
    except Exception as e:
        return Response(
            {"detail": f"An error occurred while processing the land and crop data: {str(e)}"},
            status=status.HTTP_500_INTERNAL_SERVER_ERROR
        )
        try:
            # Attempt to get lands for the given farmer and ensure the status is 0
            lands = MyLand.objects.filter(farmer=id, status=0)  
            if not lands.exists():
                return Response(
                    {"detail": "No lands found for the given farmer or lands are not active."},
                    status=status.HTTP_404_NOT_FOUND
                )
        except MyLand.DoesNotExist:
            return Response(
                {"detail": "Error: MyLand not found for the given farmer."},
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            return Response(
                {"detail": f"An unexpected error occurred: {str(e)}"},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

        try:
            land_data_list = []
            custom_response = {
                "lands": [],
            }

            for land in lands:
                land_data = MyLandDetailsSerializer(land).data
                crops = MyCrop.objects.filter(land=land, status=0)
                land_data['crop_count'] = crops.count()
                crop_list = []

                # Add land details to the custom response
                custom_response["lands"].append({
                    "id": land.id,
                    "name": land.name,
                    "farmer_id": land.farmer.id, 
                    "farmer_name": land.farmer.name,  
                    "soil_type_id": land.soil_type.id, 
                    "soil_type_name": land.soil_type.name,
                    "country_id": land.country.id,
                    "country_name": land.country.name,
                    "state_id": land.state.id,  
                    "state_name": land.state.name,  
                    "city_id": land.city.id,  
                    "city_name": land.city.name,  
                    "taluk_id": land.taluk.id,  
                    "taluk_name": land.taluk.name,  
                    "village_id": land.village.id,  
                    "village_name": land.village.name,  
                    "door_no": land.door_no,
                    "locations": land.locations,
                    "latitude": land.latitude,
                    "longitude": land.longitude,
                    "patta_number": land.patta_number,
                    "description": land.description,
                    "l_status": land.l_status,
                    "crop_count": land_data['crop_count'],
                    "measurement_value": land.measurement_value,
                    "measurement_unit": land.measurement_unit.name,
                    "measurement_unit_id": land.measurement_unit.id,
                    "survey_details": MyLandSurveyDetailsSerializer(land.survey_details.all(), many=True).data,
                    "documents": MyLandDocumentSerializer(land.documents.all(), many=True).data,
                    "crops": []
                })

                land_data['crop_count'] = crops.count()

                for crop in crops:
                    crop_data = MyCropDetailsSerializer(crop).data
                    schedules = MySchedule.objects.filter(my_crop=crop, farmer=id)

                    crop_data['schedule_total_count'] = schedules.count()
                    crop_data['schedule_completed_count'] = schedules.filter(schedule_status__status=1).count()

                    if crop.plantation_date:
                        days_since_plantation = crop.plantation_date
                        crop_data['days_since_plantation'] = days_since_plantation

                    crop_list.append(crop_data)

                    # Add crop details to custom response
                    custom_response["lands"][-1]["crops"].append({
                        "id": crop.id,
                        "name": crop.crop.name,
                        "farmer_id": crop.farmer.id,  
                        "farmer_name": crop.farmer.name,  
                        "crop_type_id": crop.crop_type.id,  
                        "crop_type_name": crop.crop_type.name,
                        "harvestingType_id" :crop.harvesting_type.id,
                        "harvestingType_name":crop.harvesting_type.name,
                        "plantationDate":crop.plantation_date,
                        "land_id":crop.land.id,
                        "land_name":crop.land.name,
                        "measurement_value": crop.measurement_value, 
                        "measurement_unit_id": crop.measurement_unit.id,  
                        "measurement_unit_name": crop.measurement_unit.name,
                        "survey_details": MyLandSurveyDetailsSerializer(crop.survey_details.all(), many=True).data,
                        "geoMarks":crop.geo_marks,
                        "expense":crop.expense,
                        "sales":crop.sales,
                        "schedule_total_count": crop_data['schedule_total_count'],
                        "schedule_completed_count": crop_data['schedule_completed_count'],
                        "days_since_plantation": crop_data.get('days_since_plantation', None)
                    })

                land_data_list.append(land_data)

            # Return the custom response with land and crop details
            return Response(custom_response, status=status.HTTP_200_OK)
        
        except Exception as e:
            return Response(
                {"detail": f"An error occurred while processing the land and crop data: {str(e)}"},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

@api_view(['POST'])
def get_land_details(request,id):
    land_id = request.data.get('land_id')  # Get the land_id from the request data
    if not land_id:
        return Response({"detail": "land_id is required."}, status=status.HTTP_400_BAD_REQUEST)
    
    try:
        # Retrieve the land object
        land = MyLand.objects.get(id=land_id,farmer = id,status=0)
    except MyLand.DoesNotExist:
        return Response({"detail": "MyLand not found."}, status=status.HTTP_404_NOT_FOUND)

    # Serialize the land data
    land_data = MyLandDetailsSerializer(land).data
    
    # Retrieve all crops related to the land
    crops = MyCrop.objects.filter(land=land,status=0)
    crop_list = []
    
    # Serialize each crop and add schedule details
    for crop in crops:
        crop_data = MyCropDetailsSerializer(crop).data
        
        # Retrieve schedules for each crop
        schedules = MySchedule.objects.filter(my_crop=crop,status=0)
        
        # Calculate total count and completed count of schedules
        total_schedule_count = schedules.count()
        completed_schedule_count = schedules.filter(schedule_status__status=1).count()
        
        # Add the schedule counts to the crop data
        crop_data['schedule_total_count'] = total_schedule_count
        crop_data['schedule_completed_count'] = completed_schedule_count
        
        # Append the crop data to the crop list
        crop_list.append(crop_data)
    
    # Add the crop list to the land data
    land_data['crops'] = crop_list  # Attach crops to the land data
    
    return Response(land_data, status=status.HTTP_200_OK)

# Crop Methods:
@api_view(['POST', 'PUT'])
def manage_my_crop(request, id):  
    try:
        farmer = Farmer.objects.get(id=id)
    except Farmer.DoesNotExist:
        return Response({"detail": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)
    if request.method == 'POST':
        serializer = MyCropInsertionSerializer(data=request.data)
        if serializer.is_valid():
            crop_instance = serializer.save(
                farmer=farmer, 
                created_at=timezone.now(),
                created_by=farmer.farmer_user, 
                updated_at=timezone.now(),
                updated_by=farmer.farmer_user
            )
            # Serialize the saved crop instance using MyCropDetailsSerializer
            crop_details_serializer = MyCropDetailsSerializer(crop_instance)
            return Response(crop_details_serializer.data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    
    elif request.method == 'PUT':
        crop_id = request.data.get('id')
        if not pk:
            return Response({"error": "crop id is required for update"}, status=status.HTTP_400_BAD_REQUEST)
        try:
            my_crop = MyCrop.objects.get(id=crop_id,farmer = farmer.id)
        except MyCrop.DoesNotExist:
            return Response({"detail": "MyCrop not found."}, status=status.HTTP_404_NOT_FOUND)
        serializer = MyCropInsertionSerializer(my_crop, data=request.data)
        if serializer.is_valid():
            crop_instance = serializer.save(updated_at=timezone.now(), updated_by=farmer.farmer_user)
            crop_details_serializer = MyCropDetailsSerializer(crop_instance)
            return Response(crop_details_serializer.data, status=status.HTTP_200_OK)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

@api_view(['POST'])
def get_purchase_expense(request, farmer_id):
    try:
        # Fetching farmer data
        print(f"Attempting to fetch farmer with ID: {farmer_id}")  # Debugging statement
        farmer = Farmer.objects.get(id=farmer_id)
        print(f"Farmer found: {farmer}")  # Debugging statement
    except Farmer.DoesNotExist:
        print(f"Farmer with ID {farmer_id} not found.")  # Debugging statement
        return Response({"message": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)

    # Getting filter type from the request data
    filter_type = request.data.get('filter_type', 'week')
    print(f"Filter type received: {filter_type}")  # Debugging statement

    # Initializing queryset for expenses
    expenses_queryset = MyExpense.objects.filter(farmer=farmer)
    print(f"Initial Expenses count: {expenses_queryset.count()}")  # Debugging statement

    # Determine the start date based on filter type
    if filter_type == 'week':
        start_date = timezone.now() - timedelta(days=7)
    elif filter_type == 'month':
        start_date = timezone.now() - timedelta(days=30)
    elif filter_type == 'year':
        start_date = timezone.now() - timedelta(days=365)
    else:
        print("Invalid filter type provided.")  # Debugging statement
        return Response(
            {
                "success": False,
                "message": "Invalid filter type. Must be 'week', 'month', or 'year'."
            },
            status=400
        )
    
    # Print the start date used for the filter
    print(f"Start date for filter: {start_date}")  # Debugging statement

    # Apply date filter to the expenses queryset
    expenses_queryset = expenses_queryset.filter(created_day__gte=start_date)
    print(f"Filtered Expenses count: {expenses_queryset.count()}")  # Debugging statement

    # Summing the total expense amount
    total_expense_sum = expenses_queryset.aggregate(total_expense_sum=Sum('amount'))['total_expense_sum'] or 0
    print(f"Total expense sum: {total_expense_sum}")  # Debugging statement

    # Building the normal list with expense details
    normal_list = []
    for expense in expenses_queryset:
        print(f"Processing expense: {expense.type_expenses.name}, Amount: {expense.amount}")  # Debugging statement
        normal_list.append({
            "expense_name": expense.type_expenses.name if expense.type_expenses else None,
            "date": expense.created_day,
            "crop_name": expense.my_crop.crop.name if expense.my_crop and expense.my_crop.crop else None,
            "amount": expense.amount,
        })

    # Grouping expenses by type
    grouped_expenses = defaultdict(lambda: 0)
    for expense in expenses_queryset:
        expense_name = expense.type_expenses.name if expense.type_expenses else None
        grouped_expenses[expense_name] += expense.amount or 0
        print(f"Grouping expense: {expense_name}, Amount: {expense.amount}")  # Debugging statement

    # Formatting grouped expenses
    formatted_expenses = []
    for expense_name, total_amount in grouped_expenses.items():
        formatted_amount = f"{total_amount / 1000:.1f}k" if total_amount >= 1000 else f"{total_amount:.0f}"
        percentage = (total_amount / total_expense_sum) * 100 if total_expense_sum > 0 else 0
        print(f"Formatted expense: {expense_name}, Amount: {formatted_amount}, Percentage: {percentage}")  # Debugging statement

        formatted_expenses.append({
            "expense_name": expense_name,
            "formatted_amount": formatted_amount,
            "percentage": round(percentage, 2),
        })

    # Final response
    print(f"Returning final response with {len(normal_list)} normal list items and {len(formatted_expenses)} formatted expenses.")  # Debugging statement
    return Response({
        "success": True,
        "normal_list": normal_list,
        "formatted_expenses": formatted_expenses,
        "total_expense_sum": total_expense_sum,
        "total_count": len(normal_list),
    }, status=200)

@api_view(['POST'])
def delete_my_crop(request, id):
    try:
        farmer = Farmer.objects.get(id=id)
    except Farmer.DoesNotExist:
        return Response({"detail": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)
    pk = request.data.get('id')
    if not pk:
        return Response({"error": "Crop id is required for delete"}, status=status.HTTP_400_BAD_REQUEST)
    try:
        my_crop = MyCrop.objects.get(pk=pk, farmer=farmer)
    except MyCrop.DoesNotExist:
        return Response({"detail": "MyCrop not found."}, status=status.HTTP_404_NOT_FOUND)
    try:
        if my_crop.status == 2:
            return Response({"message": "The crop is already deleted."}, status=status.HTTP_400_BAD_REQUEST)
        my_crop.status = 2
        my_crop.updated_at = timezone.now()
        my_crop.updated_by = farmer.farmer_user
        my_crop.save()
        return Response({"message": "Your crop has been deleted successfully."}, status=status.HTTP_200_OK)
    except Exception as e:
        return Response({"error": f"Something went wrong: {str(e)}"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
 
# Function to fix base64 padding
def fix_base64_padding(base64_string):
    padding_needed = len(base64_string) % 4
    if padding_needed:
        base64_string += '=' * (4 - padding_needed)
    return base64_string
 
 

@api_view(['POST'])
def manage_customer(request, id=None):
    try:
        farmer = Farmer.objects.get(id=id)
    except Farmer.DoesNotExist:
        return Response({"detail": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)

    # --- Handle country_name ---
    country_name = request.data.get('country_name')
    country = request.data.get('country')
    if country_name and country_name.strip():
        country_obj, created = Country.objects.get_or_create(name=country_name.strip())
        country = country_obj.id

    # --- Handle state_name ---
    state_name = request.data.get('state_name')
    state = request.data.get('state')
    if state_name and state_name.strip():
        country_id_for_state = country if country else None
        state_obj, created = State.objects.get_or_create(name=state_name.strip(), country_id=country_id_for_state)
        state = state_obj.id

    # --- Handle city_name ---
    city_name = request.data.get('city_name')
    city = request.data.get('city')
    if city_name and city_name.strip():
        state_id_for_city = state if state else None 
        country_id_for_city = country if country else None
        city_obj, created = City.objects.get_or_create(name=city_name.strip(), state_id=state_id_for_city, 
            country_id=country_id_for_city,)
        city = city_obj.id

    # --- Handle taluk_name ---
    taluk_name = request.data.get('taluk_name')
    taluk = request.data.get('taluk')
    if taluk_name and taluk_name.strip():
        city_id_for_taluk = city if city else None
        state_id_for_taluk = state if state else None
        country_id_for_taluk = country if country else None
        taluk_obj, created = Taluk.objects.get_or_create(name=taluk_name.strip(), city_id=city_id_for_taluk,
            state_id=state_id_for_taluk,
            country_id=country_id_for_taluk,)
        taluk = taluk_obj.id

    # --- Handle village_name ---
    village_name = request.data.get('village_name')
    village = request.data.get('village')
    if village_name and village_name.strip():
        taluk_id_for_village = taluk if taluk else None
        city_id_for_village = city if city else None
        state_id_for_village = state if state else None
        country_id_for_village = country if country else None

        village_obj, created = Village.objects.get_or_create(
            name=village_name.strip(),
            taluk_id=taluk_id_for_village,
            city_id=city_id_for_village,
            state_id=state_id_for_village,
            country_id=country_id_for_village,
        )
        village = village_obj.id

    # Override location fields in request.data for serializer
    mutable_data = request.data.copy()
    mutable_data['country'] = country
    mutable_data['state'] = state
    mutable_data['city'] = city
    mutable_data['taluk'] = taluk
    mutable_data['village'] = village
    request._full_data = mutable_data  # override the original data for serializer

    customer_img = mutable_data.get('customer_img', None)

    if customer_img:
        print("Processing customer image...")

    # Base64 image handling
    if customer_img and isinstance(customer_img, str):
        try:
            customer_img = fix_base64_padding(customer_img.strip())
            img_data = base64.b64decode(customer_img.split(';base64,')[1])

            image = Image.open(BytesIO(img_data))
            image.verify()

            image_name = f'customer_image_{timezone.now().strftime("%Y%m%d%H%M%S")}.png'
            image_file = ContentFile(img_data, name=image_name)
            mutable_data['customer_img'] = image_file
            request._full_data = mutable_data

            print(f"Base64 image decoded and processed: {image_name}")
        except Exception as e:
            print(f"Error in base64 image processing: {str(e)}")
            return Response({"error": f"Invalid base64 image format: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

    elif 'customer_img' in request.FILES:
        print("Regular image file upload detected.")

    if request.method == 'POST':
        serializer = MyCustomerInsertionSerializer(data=mutable_data)
        if serializer.is_valid():
            print("Serializer is valid, saving customer data...")

            current_subscription = farmer.subscriptions.first()
            if not current_subscription:
                return Response({"detail": "No active subscription found for the farmer."}, status=status.HTTP_400_BAD_REQUEST)

            package = current_subscription.packages

            current_customer_count = MyCustomer.objects.filter(Q(status=0) | Q(status=1), farmer=farmer).count()
            if package.customer_count and package.customer_count <= current_customer_count:
                return Response({"detail": "Customer limit exceeded for the current package."}, status=status.HTTP_400_BAD_REQUEST)

            try:
                with transaction.atomic():
                    # Create Customer
                    customer = serializer.save(
                        farmer=farmer,
                        created_at=timezone.now(),
                        created_by=farmer.farmer_user,
                        updated_at=timezone.now(),
                        updated_by=farmer.farmer_user
                    )
                    print("Customer created successfully:", customer)

                    if customer.is_customer_is_vendor:
                        print("Creating vendor for customer...")

                        current_vendor_count = MyVendor.objects.filter(Q(status=0) | Q(status=1), farmer=farmer).count()
                        if package.myinventory_vendors and package.myinventory_vendors <= current_vendor_count:
                            return Response({"detail": "Vendor limit exceeded for the current package."}, status=status.HTTP_400_BAD_REQUEST)

                        inventory_type = []
                        if customer.market and customer.market.exists():
                            inventory_type = customer.market.values_list('id', flat=True)

                        vendor_data = {
                            'farmer': farmer.id,
                            'name': customer.customer_name,
                            'mobile_no': customer.mobile_no,
                            'email': customer.email,
                            'gst_number': customer.gst_no,
                            'tax_number': customer.tax_no,
                            'opening_balance': customer.opening_balance,
                            'status': customer.status,
                            'business_name': customer.shop_name,
                            'inventory_type': inventory_type,
                            'door_no': customer.door_no,
                            'country': customer.country.id if customer.country else None,
                            'state': customer.state.id if customer.state else None,
                            'city': customer.city.id if customer.city else None,
                            'taluk': customer.taluk.id if customer.taluk else None,
                            'village': customer.village.id if customer.village else None,
                            'pincode': customer.post_code,
                            'description': customer.description,
                            'created_at': timezone.now(),
                            'created_by': farmer.farmer_user.id,
                            'updated_at': timezone.now(),
                            'updated_by': farmer.farmer_user.id,
                            'is_customer_is_vendor': customer.is_customer_is_vendor,
                        }

                        if customer.customer_img:
                            vendor_data['vendor_image'] = customer.customer_img

                        vendor_data['credit'] = customer.is_credit
                        vendor_data['debit'] = not customer.is_credit

                        vendor_serializer = MyVendorSerializer(data=vendor_data)
                        if vendor_serializer.is_valid():
                            vendor = vendor_serializer.save()
                            print("Vendor created successfully.")

                            # Link the customer and vendor objects
                            customer.vendor = vendor
                            customer.save(update_fields=['vendor'])

                            vendor.customer = customer
                            vendor.save(update_fields=['customer'])

                        else:
                            print("Vendor creation failed:", vendor_serializer.errors)
                            return Response(vendor_serializer.errors, status=status.HTTP_400_BAD_REQUEST)

                    details = MyCustomerDetailsSerializer(customer)
                    return Response({
                        "status": "Added Successfully",
                        "response": details.data,
                        "language": {"default": "en"}
                    }, status=status.HTTP_201_CREATED)

            except Exception as exc:
                print(f"Transaction failed: {exc}")
                return Response({"detail": f"Error saving customer/vendor data: {str(exc)}"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        print("Serializer validation failed:", serializer.errors)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)




# Helper function to fix base64 padding issues
def fix_base64_padding(base64_string):
    return base64_string + "=" * (4 - len(base64_string) % 4)
  
@api_view(['PUT'])
def update_manage_customer(request, farmer_id, customer_id):
    try:
        # Fetch the farmer and customer by their IDs
        farmer = get_object_or_404(Farmer, id=farmer_id)
        customer = get_object_or_404(MyCustomer, id=customer_id, farmer=farmer)
        
        # Get the data from the PUT request
        data = request.data
        
        # Process base64 or regular image (unchanged)
        customer_img = data.get('customer_img', None)
        if customer_img and isinstance(customer_img, str):
            try:
                print("Processing base64 customer image...")
                customer_img = fix_base64_padding(customer_img.strip())
                img_data = base64.b64decode(customer_img.split(';base64,')[1])
                image = Image.open(BytesIO(img_data))
                image.verify()
                image_name = f'customer_image_{timezone.now().strftime("%Y%m%d%H%M%S")}.png'
                image_file = ContentFile(img_data, name=image_name)
                data['customer_img'] = image_file
                print(f"Base64 image decoded and processed: {image_name}")
            except Exception as e:
                print(f"Error in base64 image processing: {str(e)}")
                return Response({"error": f"Invalid base64 image format: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)
        elif 'customer_img' in request.FILES:
            print("Regular image file upload detected.")

        # --- LOCATION HANDLING ---
        country_obj = None
        state_obj = None
        city_obj = None
        taluk_obj = None
        village_obj = None

        country_name = data.get('country_name')
        if country_name and country_name.strip():
            country_obj, _ = Country.objects.get_or_create(name=country_name.strip())

        state_name = data.get('state_name')
        if state_name and state_name.strip():
            state_obj, _ = State.objects.get_or_create(name=state_name.strip(), country=country_obj)

        city_name = data.get('city_name')
        if city_name and city_name.strip():
            city_obj, _ = City.objects.get_or_create(name=city_name.strip(), state=state_obj, country=country_obj)

        taluk_name = data.get('taluk_name')
        if taluk_name and taluk_name.strip():
            taluk_obj, _ = Taluk.objects.get_or_create(name=taluk_name.strip(), city=city_obj, state=state_obj, country=country_obj)

        village_name = data.get('village_name')
        if village_name and village_name.strip():
            village_obj, _ = Village.objects.get_or_create(
                name=village_name.strip(),
                taluk=taluk_obj,
                city=city_obj,
                state=state_obj,
                country=country_obj,
            )
        
        # Manually update the customer model with the provided data (unchanged)
        customer.customer_name = data.get('customer_name', customer.customer_name)
        customer.shop_name = data.get('shop_name', customer.shop_name)
        customer.mobile_no = data.get('mobile_no', customer.mobile_no)
        customer.email = data.get('email', customer.email)
        customer.door_no = data.get('door_no', customer.door_no)

        # Assign the location objects, fallback to existing if not provided
        customer.country = country_obj if country_obj else customer.country
        customer.state = state_obj if state_obj else customer.state
        customer.city = city_obj if city_obj else customer.city
        customer.taluk = taluk_obj if taluk_obj else customer.taluk
        customer.village = village_obj if village_obj else customer.village

        customer.post_code = data.get('post_code', customer.post_code)
        customer.gst_no = data.get('gst_no', customer.gst_no)
        customer.tax_no = data.get('tax_no', customer.tax_no)
        customer.is_credit = data.get('is_credit', customer.is_credit)
        customer.opening_balance = data.get('opening_balance', customer.opening_balance)
        customer.description = data.get('description', customer.description)
        customer.is_customer_is_vendor = data.get('is_customer_is_vendor', customer.is_customer_is_vendor)

        # Update the farmer field
        customer.farmer = farmer

        # If a new image has been uploaded, update it
        if 'customer_img' in data:
            customer.customer_img = data['customer_img']

        # Save the customer after updating
        customer.save()

        # Update the associated MyVendor record (unchanged except location assignment)
        try:
            vendor = MyVendor.objects.get(customer=customer)
            vendor.name = customer.customer_name
            vendor.business_name = customer.shop_name
            vendor.email = customer.email
            vendor.mobile_no = customer.mobile_no
            vendor.door_no = customer.door_no

            # Assign location objects to vendor as well
            vendor.country = customer.country
            vendor.state = customer.state
            vendor.city = customer.city
            vendor.taluk = customer.taluk
            vendor.village = customer.village

            vendor.pincode = customer.post_code
            vendor.gst_number = customer.gst_no
            vendor.tax_number = customer.tax_no
            vendor.credit = customer.is_credit
            vendor.debit = not customer.is_credit
            vendor.opening_balance = customer.opening_balance
            vendor.vendor_image = customer.customer_img
            vendor.description = customer.description 
            
            # Update the Many-to-Many relation for inventory_type
            if 'inventory_type' in data:
                inventory_type_ids = data.get('inventory_type', [])
                vendor.inventory_type.set(inventory_type_ids)

            vendor.farmer = farmer

            vendor.save()

        except MyVendor.DoesNotExist:
            return Response({"detail": "Vendor not found for this customer."}, status=status.HTTP_404_NOT_FOUND)

        # Prepare response data (unchanged)
        customer_data = {
            "customer_id": customer.id,
            "customer_name": customer.customer_name,
            "shop_name": customer.shop_name,
            "mobile_no": customer.mobile_no,
            "email": customer.email,
            "door_no": customer.door_no,
            "country_id": customer.country.id if customer.country else None,
            "state_id": customer.state.id if customer.state else None,
            "city_id": customer.city.id if customer.city else None,
            "taluk_id": customer.taluk.id if customer.taluk else None,
            "village_id": customer.village.id if customer.village else None,
            "post_code": customer.post_code,
            "gst_no": customer.gst_no,
            "tax_no": customer.tax_no,
            "is_credit": customer.is_credit,
            "opening_balance": customer.opening_balance,
            "description": customer.description,
            "is_customer_is_vendor": customer.is_customer_is_vendor,
            "customer_img": customer.customer_img.url if customer.customer_img else None,
            "farmer_id": customer.farmer.id
        }

        vendor_data = {
            "vendor_id": vendor.id,
            "vendor_name": vendor.name,
            "business_name": vendor.business_name,
            "email": vendor.email,
            "mobile_no": vendor.mobile_no,
            "door_no": vendor.door_no,
            "country_id": vendor.country.id if vendor.country else None,
            "state_id": vendor.state.id if vendor.state else None,
            "city_id": vendor.city.id if vendor.city else None,
            "taluk_id": vendor.taluk.id if vendor.taluk else None,
            "village_id": vendor.village.id if vendor.village else None,
            "pincode": vendor.pincode,
            "gst_number": vendor.gst_number,
            "tax_number": vendor.tax_number,
            "credit": vendor.credit,
            "debit": vendor.debit,
            "opening_balance": vendor.opening_balance,
            "vendor_image": vendor.vendor_image.url if vendor.vendor_image else None,
            "description": vendor.description,
            "farmer_id": vendor.farmer.id
        }

        return Response({
            "message": "Customer and Vendor updated successfully",
            "customer_data": customer_data,
            "vendor_data": vendor_data
        }, status=status.HTTP_200_OK)

    except Exception as e:
        return Response({"detail": str(e)}, status=status.HTTP_400_BAD_REQUEST)



@api_view(['POST'])
def deactivate_customer_and_vendor(request, farmer_id, customer_id):
    try: 
        farmer = get_object_or_404(Farmer, id=farmer_id)
        customer = get_object_or_404(MyCustomer, id=customer_id, farmer=farmer)
         
        try:
            vendor = MyVendor.objects.get(customer=customer)
        except MyVendor.DoesNotExist:
            vendor = None
         
        customer.status = 2
        customer.save()

        # If the vendor exists, change the vendor's status to 2 as well
        if vendor:
            vendor.status = 2
            vendor.save()

        return Response({"message": "Customer and Vendor deactivated successfully."}, status=status.HTTP_200_OK)

    except Exception as e:
        return Response({"detail": str(e)}, status=status.HTTP_400_BAD_REQUEST)

@api_view(['POST'])
def delete_customer(request,id):
    customer_id = request.data.get("id")
    try:
        farmer = Farmer.objects.get(id=id,status = 0)
    except Farmer.DoesNotExist:
        return Response({"detail": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)
    try:
        customer = MyCustomer.objects.get(id=customer_id,farmer = id,status = 0)
    except MyCustomer.DoesNotExist:
        return Response({"detail": "Customer not found."}, status=status.HTTP_404_NOT_FOUND)
    customer.status = 2
    customer.updated_at = timezone.now()
    customer.updated_by = farmer.farmer_user
    customer.save()
    return Response({"detail": "Customer deleted Successfully."}, status=status.HTTP_200_OK)

@api_view(['GET'])
def list_customers(request,id):
    customers = MyCustomer.objects.filter(farmer=id, status=0)
    response_data = []
    for customer in customers:
        for idx, market in enumerate(customer.market.all(), start=1):  # Enumerate to create unique keys
            customer_data = {
                "id": customer.id,
                "farmer_id": customer.farmer.id if customer.farmer else None,
                "farmer": customer.farmer.name if customer.farmer else None,
                "customer_name": customer.customer_name,
                "type": "customer",  # Static value as in your example
                "shop_name": customer.shop_name,
                "mobile_no": customer.mobile_no,
                "email": customer.email,
                "door_no": customer.door_no,
                "country_id": customer.country.id if customer.country else None,
                "country": customer.country.name if customer.country else None,
                "state_id": customer.state.id if customer.state else None,
                "state": customer.state.name if customer.state else None,
                "city_id": customer.city.id if customer.city else None,
                "city": customer.city.name if customer.city else None,
                "taluk_id": customer.taluk.id if customer.taluk else None,
                "taluk": customer.taluk.name if customer.taluk else None,
                "village_id": customer.village.id if customer.village else None,
                "village": customer.village.name if customer.village else None,
                "gst_no": customer.gst_no,
                "tax_no": customer.tax_no,
                "post_code": customer.post_code,
                "is_credit": customer.is_credit,
                "opening_balance": customer.opening_balance,
                "description": customer.description,
                "is_customer_is_vendor": customer.is_customer_is_vendor,
                # Now showing individual market details
                f"market_id": market.id,
                f"market": market.name
            }
            response_data.append(customer_data)
    return Response(response_data, status=status.HTTP_200_OK)

@api_view(['POST'])
def customer_details(request, id):
    customer_id = request.data.get('customer_id')
    customers = MyCustomer.objects.filter(id=customer_id, farmer=id, status=0)
    customer_list = []
    for customer in customers:
        for idx, market in enumerate(customer.market.all(), start=1):  # Enumerate to create unique keys
            customer_data = {
                "id": customer.id,
                "farmer_id": customer.farmer.id if customer.farmer else None,
                "farmer": customer.farmer.name if customer.farmer else None,
                "customer_name": customer.customer_name,
                "type": "customer",  # Static value as in your example
                "shop_name": customer.shop_name,
                "mobile_no": customer.mobile_no,
                "email": customer.email,
                "door_no": customer.door_no,
                "country_id": customer.country.id if customer.country else None,
                "country": customer.country.name if customer.country else None,
                "state_id": customer.state.id if customer.state else None,
                "state": customer.state.name if customer.state else None,
                "city_id": customer.city.id if customer.city else None,
                "city": customer.city.name if customer.city else None,
                "taluk_id": customer.taluk.id if customer.taluk else None,
                "taluk": customer.taluk.name if customer.taluk else None,
                "village_id": customer.village.id if customer.village else None,
                "village": customer.village.name if customer.village else None,
                "gst_no": customer.gst_no,
                "tax_no": customer.tax_no,
                "post_code": customer.post_code,
                "is_credit": customer.is_credit,
                "opening_balance": customer.opening_balance,
                "description": customer.description,
                "is_customer_is_vendor": customer.is_customer_is_vendor,
                # Now showing individual market details
                f"market_id": market.id,
                f"market": market.name
            }
            customer_list.append(customer_data)
    
    return Response(customer_list, status=status.HTTP_200_OK)
 
def decode_base64_and_save_image(base64_data, folder='vendors'):
    # Split the base64 string into data type and the actual base64 string
    if base64_data.startswith("data:image"):
        image_data = base64_data.split(",")[1]
    else:
        image_data = base64_data
    
    # Decode the base64 string
    image = ContentFile(base64.b64decode(image_data))

    # Save it as a file
    image_name = f"{get_random_string(8)}.png"  # You can change the extension based on image type (e.g., .jpg)
    image_file = ContentFile(image.read(), name=image_name)

    # Return the image file
    return image_file 
  
 

@api_view(['POST'])
def manage_vendor(request, id=None):
    try:
        farmer = Farmer.objects.get(id=id, status=0)
        print(f"Farmer found: {farmer.name}, ID: {farmer.id}")
    except Farmer.DoesNotExist:
        return Response({"detail": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)

    # Vendor limit check based on farmer's subscription
    subscription = AddSubcription.objects.filter(farmers=farmer, status=0).first()
    if subscription:
        vendor_limit = subscription.packages.myinventory_vendors
        current_vendor_count = MyVendor.objects.filter(Q(status=0) | Q(status=1), farmer=farmer).count()

        if current_vendor_count >= vendor_limit:
            return Response({
                'detail': f"You have already reached the maximum vendor limit of {vendor_limit} for your subscription package."
            }, status=status.HTTP_400_BAD_REQUEST)

    data = request.data
    print(f"Request data received: {data}")

    required_fields = ['name', 'inventory_type', 'email', 'mobile_no', 
                       # we remove 'country', 'state', 'city', 'taluk', 'village', 'pincode'
                       # because now we accept both id or name and it's optional one or the other
                       'pincode']
    
    missing_fields = [field for field in required_fields if field not in data]
    if missing_fields:
        return Response({"detail": f"Missing fields: {', '.join(missing_fields)}"}, status=status.HTTP_400_BAD_REQUEST)

    # Handle Country
    country_obj = None
    country_name = data.get('country_name')
    if country_name and country_name.strip():
        country_obj, _ = Country.objects.get_or_create(name=country_name.strip())
    elif 'country' in data:
        try:
            country_obj = Country.objects.get(id=data['country'])
        except Country.DoesNotExist:
            return Response({"detail": "Country not found."}, status=status.HTTP_400_BAD_REQUEST)

    # Handle State
    state_obj = None
    state_name = data.get('state_name')
    if state_name and state_name.strip():
        # link to country if exists
        if country_obj:
            state_obj, _ = State.objects.get_or_create(name=state_name.strip(), country=country_obj)
        else:
            state_obj, _ = State.objects.get_or_create(name=state_name.strip())
    elif 'state' in data:
        try:
            state_obj = State.objects.get(id=data['state'])
        except State.DoesNotExist:
            return Response({"detail": "State not found."}, status=status.HTTP_400_BAD_REQUEST)

    # Handle City
    city_obj = None
    city_name = data.get('city_name')
    if city_name and city_name.strip():
        if state_obj:
            city_obj, _ = City.objects.get_or_create(name=city_name.strip(), state=state_obj ,
            country=country_obj)
        else:
            city_obj, _ = City.objects.get_or_create(name=city_name.strip())
    elif 'city' in data:
        try:
            city_obj = City.objects.get(id=data['city'])
        except City.DoesNotExist:
            return Response({"detail": "City not found."}, status=status.HTTP_400_BAD_REQUEST)

    # Handle Taluk
    taluk_obj = None
    taluk_name = data.get('taluk_name')
    if taluk_name and taluk_name.strip():
        if city_obj:
            taluk_obj, _ = Taluk.objects.get_or_create(name=taluk_name.strip(), city=city_obj,
            state=state_obj,
            country=country_obj)
        else:
            taluk_obj, _ = Taluk.objects.get_or_create(name=taluk_name.strip())
    elif 'taluk' in data:
        try:
            taluk_obj = Taluk.objects.get(id=data['taluk'])
        except Taluk.DoesNotExist:
            return Response({"detail": "Taluk not found."}, status=status.HTTP_400_BAD_REQUEST)

    # Handle Village
    village_obj = None
    village_name = data.get('village_name')
    if village_name and village_name.strip():
        village_obj, _ = Village.objects.get_or_create(
            name=village_name.strip(),
            taluk=taluk_obj,
            city=city_obj,
            state=state_obj,
            country=country_obj
        )
    elif 'village' in data:
        try:
            village_obj = Village.objects.get(id=data['village'])
        except Village.DoesNotExist:
            return Response({"detail": "Village not found."}, status=status.HTTP_400_BAD_REQUEST)

    # Vendor Image Handling
    vendor_img = data.get('vendor_img', None)
    if vendor_img:
        print("Processing vendor image...")

        if isinstance(vendor_img, str):
            try:
                vendor_img = vendor_img.strip()
                if vendor_img.startswith('data:image'):
                    vendor_img = vendor_img.split(';base64,')[1]

                img_data = base64.b64decode(vendor_img)
                image = Image.open(BytesIO(img_data))
                image.verify()

                image_name = f'vendor_image_{timezone.now().strftime("%Y%m%d%H%M%S")}.png'
                image_file = ContentFile(img_data, name=image_name)

                # Override vendor_img in request data with processed file
                request.data._mutable = True  # if request.data is QueryDict, make it mutable
                request.data['vendor_img'] = image_file
                request.data._mutable = False
                print(f"Vendor base64 image processed: {image_name}")
            except Exception as e:
                return Response({"error": f"Invalid base64 image format: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

        elif 'vendor_img' in request.FILES:
            print("Regular vendor image file upload detected.")

    # Create Vendor
    vendor = MyVendor(
        farmer=farmer,
        name=data.get('name'),
        business_name=data.get('business_name', ''),
        email=data.get('email'),
        mobile_no=data.get('mobile_no'),
        alter_mobile_no=data.get('alter_mobile_no') if data.get('alter_mobile_no') not in [None, ''] else None,
        door_no=data.get('door_no', ''),
        country=country_obj,
        state=state_obj,
        city=city_obj,
        taluk=taluk_obj,
        village=village_obj,
        pincode=data.get('pincode', 0),
        gst_number=data.get('gst_no', ''),
        tax_number=data.get('tax_no', ''),
        credit=data.get('is_credit', False),
        debit=data.get('is_debit', False),
        opening_balance=data.get('opening_balance', 0),
        vendor_image=request.data.get('vendor_img'),
        description=data.get('description', ''),
        status=0,
        created_at=timezone.now(),
        created_by=farmer.farmer_user,
        updated_at=timezone.now(),
        updated_by=farmer.farmer_user,
    )
    vendor.save()

    if 'inventory_type' in data:
        inventory_type_ids = data['inventory_type']
        inventory_types = InventoryType.objects.filter(id__in=inventory_type_ids)
        vendor.inventory_type.set(inventory_types)

    vendor_details = {
        'id': vendor.id,
        'farmer': vendor.farmer.name if vendor.farmer else "",
        'name': vendor.name,
        'business_name': vendor.business_name,
        'inventory_type': [it.name for it in vendor.inventory_type.all()],
        'email': vendor.email,
        'mobile_no': vendor.mobile_no,
        'alter_mobile_no': vendor.alter_mobile_no,
        'door_no': vendor.door_no,
        'country': vendor.country.name if vendor.country else "",
        'state': vendor.state.name if vendor.state else "",
        'city': vendor.city.name if vendor.city else "",
        'taluk': vendor.taluk.name if vendor.taluk else "",
        'village': vendor.village.name if vendor.village else "",
        'pincode': vendor.pincode,
        'gst_number': vendor.gst_number,
        'tax_number': vendor.tax_number,
        'credit': vendor.credit,
        'debit': vendor.debit,
        'opening_balance': vendor.opening_balance,
        'vendor_image': vendor.vendor_image.url if vendor.vendor_image else "",
        'description': vendor.description,
        'type': 'vendor',
        'language': {"default": "en"}
    }

    FarmerNotification.objects.create(
        farmer=farmer,
        name=f"Vendor Created: {vendor.name}",
        type="Vendor Created",
        message=f"Your Vendor '{vendor.name}' has been Created.",
        created_at=timezone.now(),
        is_read=False
    )

    return Response(vendor_details, status=status.HTTP_201_CREATED)

 

def decode_base64_and_save_image(base64_string, folder='myvendors'):
    """
    Decodes a base64 image string and returns an InMemoryUploadedFile
    suitable for assigning to a Django ImageField (respects upload_to).
    """
    try:
        if base64_string.startswith('data:image'):
            format, imgstr = base64_string.split(';base64,')
            ext = format.split('/')[-1]
        else:
            imgstr = base64_string
            ext = 'png'  # fallback if no mime type given

        img_data = base64.b64decode(imgstr)
        img = Image.open(io.BytesIO(img_data))
        img_io = io.BytesIO()
        img.save(img_io, format=ext.upper())
        img_io.seek(0)

        file_name = f"{uuid.uuid4()}.{ext}"
        image_file = InMemoryUploadedFile(
            file=img_io,
            field_name=None,
            name=file_name,
            content_type=f'image/{ext}',
            size=len(img_data),
            charset=None
        )

        return image_file
    except Exception as e:
        print(f"[decode_base64_and_save_image] Error: {e}")
        return None

 

@api_view(['PUT'])
def update_vendor(request, id=None):
    try:
        farmer = Farmer.objects.get(id=id, status=0)
    except Farmer.DoesNotExist:
        return Response({"detail": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)

    try:
        vendor = MyVendor.objects.get(id=request.data.get('vendor_id'), farmer=farmer)
    except MyVendor.DoesNotExist:
        return Response({"detail": "Vendor not found or not associated with the specified farmer"}, status=status.HTTP_400_BAD_REQUEST)

    data = request.data
    translated_json = vendor.translate_json or {
        "name": {},
        "business_name": {},
        "door_no": {},
        "description": {}
    }

    # Translation logic (unchanged)
    for field in ["name", "business_name", "door_no", "description"]:
        new_val = data.get(field)
        if new_val and new_val != getattr(vendor, field):
            try:
                for lang in target_language:
                    translated_text = GoogleTranslator(source='auto', target=lang).translate(new_val)
                    translated_json[field][lang] = translated_text
            except Exception as e:
                print(e)
                print(f"Error in translation for field {field}")

    # Validate required fields (optional: you can adjust as needed)
    required_fields = ['name', 'inventory_type', 'email', 'mobile_no', 'pincode']
    missing_fields = [field for field in required_fields if field not in data]
    if missing_fields:
        return Response({"detail": f"Missing fields: {', '.join(missing_fields)}"}, status=status.HTTP_400_BAD_REQUEST)

    # -------- Location handling with id or name --------
    # Country
    country_obj = None
    country_name = data.get('country_name')
    if country_name and country_name.strip():
        country_obj, _ = Country.objects.get_or_create(name=country_name.strip())
    elif 'country' in data:
        try:
            country_obj = Country.objects.get(id=data['country'])
        except Country.DoesNotExist:
            return Response({"detail": "Country not found."}, status=status.HTTP_400_BAD_REQUEST)

    # State
    state_obj = None
    state_name = data.get('state_name')
    if state_name and state_name.strip():
        if country_obj:
            state_obj, _ = State.objects.get_or_create(name=state_name.strip(), country=country_obj)
        else:
            state_obj, _ = State.objects.get_or_create(name=state_name.strip())
    elif 'state' in data:
        try:
            state_obj = State.objects.get(id=data['state'])
        except State.DoesNotExist:
            return Response({"detail": "State not found."}, status=status.HTTP_400_BAD_REQUEST)

    # City
    city_obj = None
    city_name = data.get('city_name')
    if city_name and city_name.strip():
        if state_obj:
            city_obj, _ = City.objects.get_or_create(name=city_name.strip(), state=state_obj, 
            country=country_obj)
        else:
            city_obj, _ = City.objects.get_or_create(name=city_name.strip())
    elif 'city' in data:
        try:
            city_obj = City.objects.get(id=data['city'])
        except City.DoesNotExist:
            return Response({"detail": "City not found."}, status=status.HTTP_400_BAD_REQUEST)

    # Taluk
    taluk_obj = None
    taluk_name = data.get('taluk_name')
    if taluk_name and taluk_name.strip():
        if city_obj:
            taluk_obj, _ = Taluk.objects.get_or_create(name=taluk_name.strip(), city=city_obj,
            state=state_obj,
            country=country_obj)
        else:
            taluk_obj, _ = Taluk.objects.get_or_create(name=taluk_name.strip())
    elif 'taluk' in data:
        try:
            taluk_obj = Taluk.objects.get(id=data['taluk'])
        except Taluk.DoesNotExist:
            return Response({"detail": "Taluk not found."}, status=status.HTTP_400_BAD_REQUEST)

    # Village
    village_obj = None
    village_name = data.get('village_name')
    if village_name and village_name.strip():
        village_obj, _ = Village.objects.get_or_create(
            name=village_name.strip(),
            taluk=taluk_obj,
            city=city_obj,
            state=state_obj,
            country=country_obj
        )
    elif 'village' in data:
        try:
            village_obj = Village.objects.get(id=data['village'])
        except Village.DoesNotExist:
            return Response({"detail": "Village not found."}, status=status.HTTP_400_BAD_REQUEST)

    # -------- Image handling --------
    if 'vendor_img' in data:
        vendor_image_path = decode_base64_and_save_image(data['vendor_img'], folder='vendors')
        vendor.vendor_image = vendor_image_path

    # Update vendor fields
    vendor.name = data.get('name', vendor.name)
    vendor.business_name = data.get('business_name', vendor.business_name)
    vendor.email = data.get('email', vendor.email)
    vendor.mobile_no = data.get('mobile_no', vendor.mobile_no)
    vendor.alter_mobile_no = data.get('alter_mobile_no', vendor.alter_mobile_no)
    vendor.door_no = data.get('door_no', vendor.door_no)
    vendor.country = country_obj
    vendor.state = state_obj
    vendor.city = city_obj
    vendor.taluk = taluk_obj
    vendor.village = village_obj
    vendor.pincode = data.get('pincode', vendor.pincode)
    vendor.gst_number = data.get('gst_number', vendor.gst_number)
    vendor.tax_number = data.get('tax_number', vendor.tax_number)
    vendor.credit = data.get('credit', vendor.credit)
    vendor.debit = data.get('debit', vendor.debit)
    vendor.opening_balance = data.get('opening_balance', vendor.opening_balance)
    vendor.description = data.get('description', vendor.description)
    vendor.updated_at = timezone.now()
    vendor.updated_by = farmer.farmer_user
    vendor.translate_json = translated_json
    vendor.save()

    # Update inventory types (many-to-many)
    if 'inventory_type' in data:
        inventory_type_ids = data['inventory_type']
        inventory_types = InventoryType.objects.filter(id__in=inventory_type_ids)
        vendor.inventory_type.set(inventory_types)

    # Prepare response
    vendor_details = {
        'id': vendor.id,
        'farmer': vendor.farmer.name if vendor.farmer else "",
        'name': vendor.name,
        'business_name': vendor.business_name,
        'inventory_type': [it.name for it in vendor.inventory_type.all()],
        'email': vendor.email,
        'mobile_no': vendor.mobile_no,
        'alter_mobile_no': vendor.alter_mobile_no,
        'door_no': vendor.door_no,
        'country': vendor.country.name if vendor.country else "",
        'state': vendor.state.name if vendor.state else "",
        'city': vendor.city.name if vendor.city else "",
        'taluk': vendor.taluk.name if vendor.taluk else "",
        'village': vendor.village.name if vendor.village else "",
        'pincode': vendor.pincode,
        'gst_number': vendor.gst_number,
        'tax_number': vendor.tax_number,
        'credit': vendor.credit,
        'debit': vendor.debit,
        'opening_balance': vendor.opening_balance,
        'vendor_image': vendor.vendor_image.url if vendor.vendor_image else "",
        'description': vendor.description,
        'type': 'vendor',
        'language': {"default": "en"}
    }

    notification_message = f"Your Vendor '{vendor.name}' has been Updated."
    FarmerNotification.objects.create(
        farmer=farmer,
        name=f"Vendor Updated: {vendor.name}",
        type="Vendor Updated",
        message=notification_message,
        created_at=timezone.now(),
        is_read=False
    )

    return Response(vendor_details, status=status.HTTP_200_OK)



@api_view(['PUT'])
def update_customer_vendor(request, id=None):
    try:
        # Get the farmer object based on the id
        farmer = Farmer.objects.get(id=id, status=0)
    except Farmer.DoesNotExist:
        return Response({"detail": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)

    try:
        # Get the customer object to update
        customer = MyCustomer.objects.get(id=request.data.get('customer_id'), farmer=farmer)
    except MyCustomer.DoesNotExist:
        return Response({"detail": "Customer not found or not associated with the specified farmer"}, status=status.HTTP_400_BAD_REQUEST)

    # Get the updated data from the request
    data = request.data

    # Validate the required fields
    required_fields = ['customer_name', 'mobile_no', 'email', 'country', 'state', 'city', 'taluk', 'village', 'post_code']
    missing_fields = [field for field in required_fields if field not in data]

    if missing_fields:
        return Response({"detail": f"Missing fields: {', '.join(missing_fields)}"}, status=status.HTTP_400_BAD_REQUEST)

    # Fetch related instances for foreign key fields (retrieve the actual object, not just the ID)
    country = None
    state = None
    city = None
    taluk = None
    village = None

    try:
        if 'country' in data:
            country = Country.objects.get(id=data['country'])  # Fetch the Country instance by ID

        if 'state' in data:
            state = State.objects.get(id=data['state'])  # Fetch the State instance by ID

        if 'city' in data:
            city = City.objects.get(id=data['city'])  # Fetch the City instance by ID

        if 'taluk' in data:
            taluk = Taluk.objects.get(id=data['taluk'])  # Fetch the Taluk instance by ID

        if 'village' in data:
            village = Village.objects.get(id=data['village'])  # Fetch the Village instance by ID
    except (Country.DoesNotExist, State.DoesNotExist, City.DoesNotExist, Taluk.DoesNotExist, Village.DoesNotExist) as e:
        return Response({"detail": f"{str(e)} not found."}, status=status.HTTP_400_BAD_REQUEST)

    # Check and decode the vendor image (if provided)
    if 'customer_img' in data:
        try:
            customer_img = decode_base64_and_save_image(data['customer_img'], folder='customers')
            customer.customer_img = customer_img  # Update the customer's image field
        except Exception as e:
            return Response({"detail": f"Error processing the image: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

    # Update the customer's fields with the new data
    customer.customer_name = data.get('customer_name', customer.customer_name)
    customer.shop_name = data.get('shop_name', customer.shop_name)
    customer.mobile_no = data.get('mobile_no', customer.mobile_no)
    customer.email = data.get('email', customer.email)
    customer.door_no = data.get('door_no', customer.door_no)
    customer.country = country  # Assign the Country instance
    customer.state = state  # Assign the State instance
    customer.city = city  # Assign the City instance
    customer.taluk = taluk  # Assign the Taluk instance
    customer.village = village  # Assign the Village instance
    customer.post_code = data.get('post_code', customer.post_code)
    customer.gst_no = data.get('gst_no', customer.gst_no)
    customer.tax_no = data.get('tax_no', customer.tax_no)
    customer.is_credit = data.get('is_credit', customer.is_credit)
    customer.opening_balance = data.get('opening_balance', customer.opening_balance)
    customer.description = data.get('description', customer.description)

    # Update the `is_customer_is_vendor` field if provided
    if 'is_customer_is_vendor' in data:
        customer.is_customer_is_vendor = data.get('is_customer_is_vendor', customer.is_customer_is_vendor)

    # Updating the timestamp and the user making the update
    customer.updated_at = timezone.now()
    customer.updated_by = farmer.farmer_user  # Assuming the farmer's user updates the customer

    # Save the updated customer instance inside try-except to catch database errors
    try:
        customer.save()
    except Exception as e:
        return Response({"detail": f"Error saving customer: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

    # Create a notification after the customer is updated
    notification_message = f"Your Customer '{customer.customer_name}' has been Updated."
    FarmerNotification.objects.create(
        farmer=farmer,
        name=f"Customer Updated: {customer.customer_name}",
        type="Customer Updated",
        message=notification_message,
        created_at=timezone.now(),
        is_read=False
    )

    # Prepare the response data without using serializers
    customer_details = {
        'id': customer.id,
        'farmer': customer.farmer.name if customer.farmer else "",
        'customer_name': customer.customer_name,
        'shop_name': customer.shop_name,
        'mobile_no': customer.mobile_no,
        'email': customer.email,
        'door_no': customer.door_no,
        'country': customer.country.name if customer.country else "",
        'state': customer.state.name if customer.state else "",
        'city': customer.city.name if customer.city else "",
        'taluk': customer.taluk.name if customer.taluk else "",
        'village': customer.village.name if customer.village else "",
        'post_code': customer.post_code,
        'gst_no': customer.gst_no,
        'tax_no': customer.tax_no,
        'is_credit': customer.is_credit,
        'opening_balance': customer.opening_balance,
        'customer_img': customer.customer_img.url if customer.customer_img else "",
        'description': customer.description,
        'is_customer_is_vendor': customer.is_customer_is_vendor,  # Include the is_customer_is_vendor field
        'type': 'customer',
        'language': {
            "default": "en"
        }
    }

    return Response(customer_details, status=status.HTTP_200_OK)

def decode_base64_and_save_image(base64_string, folder):
    # Check if the base64 string is valid and contains a comma
    if ',' not in base64_string:
        raise ValueError("Invalid base64 string format. The string must contain a comma.")

    # Split the base64 string to separate the data part
    try:
        base64_data = base64_string.split(",")[1]  # Get the actual data after the comma
    except IndexError:
        raise ValueError("Invalid base64 string. No data found after the comma.")

    # Generate a unique file name using uuid
    file_name = str(uuid.uuid4()) + ".png"  # You can change the extension based on the actual image format (e.g., jpg, jpeg)
    folder_path = os.path.join(settings.MEDIA_ROOT, folder)  # Full path to the folder where the image will be saved
    file_path = os.path.join(folder_path, file_name)

    # Ensure the directory exists
    if not os.path.exists(folder_path):
        os.makedirs(folder_path)  # Create the folder if it doesn't exist

    # Decode the base64 data
    try:
        decoded_image = b64decode(base64_data)
    except Exception as e:
        raise ValueError(f"Error decoding base64 data: {e}")

    # Save the image file
    with open(file_path, "wb") as f:
        f.write(decoded_image)

    return file_path  # Return the path of the saved image

# @api_view(['PUT'])
# def update_customer(request, id=None):
#     try:
#         # Get the farmer object based on the id
#         farmer = Farmer.objects.get(id=id, status=0)
#     except Farmer.DoesNotExist:
#         return Response({"detail": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)

#     try:
#         # Get the customer object to update
#         customer = MyCustomer.objects.get(id=request.data.get('customer_id'), farmer=farmer)
#     except MyCustomer.DoesNotExist:
#         return Response({"detail": "Customer not found or not associated with the specified farmer"}, status=status.HTTP_400_BAD_REQUEST)

#     # Get the updated data from the request
#     data = request.data

#     translated_json = customer.translate_json or {
#         "customer_name": {},
#         "shop_name": {},
#         "door_no": {},
#         "description": {}
#     }

#     customer_name = data.get('customer_name')
#     if customer_name != customer.customer_name:
        
#         try:
#             for lang in target_language:
#                 translated_text = GoogleTranslator(source='auto', target=lang).translate(customer_name)
#                 translated_json["customer_name"][lang] = translated_text
#         except Exception as e:
#             print(e)
#             print("Error in translation")

#     shop_name = data.get('shop_name')        
#     if shop_name != customer.shop_name:
#         try:
#             for lang in target_language:
#                 translated_text = GoogleTranslator(source='auto', target=lang).translate(shop_name)
#                 translated_json["shop_name"][lang] = translated_text
#         except Exception as e:
#             print(e)
#             print("Error in translation")

#     door_no = data.get('door_no')
#     if door_no != customer.door_no:
#         try:
#             for lang in target_language:
#                 translated_text = GoogleTranslator(source='auto', target=lang).translate(door_no)
#                 translated_json["door_no"][lang] = translated_text
#         except Exception as e:
#             print(e)
#             print("Error in translation")

#     description = data.get('description')
#     if description != customer.description:
#         try:
#             for lang in target_language:
#                 translated_text = GoogleTranslator(source='auto', target=lang).translate(description)
#                 translated_json["description"][lang] = translated_text
#         except Exception as e:
#             print(e)
#             print("Error in translation")

#     # Validate the required fields
#     required_fields = ['customer_name', 'mobile_no', 'email', 'country', 'state', 'city', 'taluk', 'village', 'post_code']
#     missing_fields = [field for field in required_fields if field not in data]
    
#     if missing_fields:
#         return Response({"detail": f"Missing fields: {', '.join(missing_fields)}"}, status=status.HTTP_400_BAD_REQUEST)

#     # Fetch related instances for foreign key fields (retrieve the actual object, not just the ID)
#     country = None
#     state = None
#     city = None
#     taluk = None
#     village = None

#     try:
#         if 'country' in data:
#             country = Country.objects.get(id=data['country'])  # Fetch the Country instance by ID

#         if 'state' in data:
#             state = State.objects.get(id=data['state'])  # Fetch the State instance by ID

#         if 'city' in data:
#             city = City.objects.get(id=data['city'])  # Fetch the City instance by ID

#         if 'taluk' in data:
#             taluk = Taluk.objects.get(id=data['taluk'])  # Fetch the Taluk instance by ID

#         if 'village' in data:
#             village = Village.objects.get(id=data['village'])  # Fetch the Village instance by ID
#     except (Country.DoesNotExist, State.DoesNotExist, City.DoesNotExist, Taluk.DoesNotExist, Village.DoesNotExist) as e:
#         return Response({"detail": f"{str(e)} not found."}, status=status.HTTP_400_BAD_REQUEST)

#     # Check and decode the vendor image (if provided)
#     if 'customer_img' in data:
#         try:
#             customer_img = decode_base64_and_save_image(data['customer_img'], folder='customers')
#             customer.customer_img = customer_img  # Update the customer's image field
#         except Exception as e:
#             return Response({"detail": f"Error processing the image: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

#     # Update the customer's fields with the new data
#     customer.customer_name = data.get('customer_name', customer.customer_name)
#     customer.shop_name = data.get('shop_name', customer.shop_name)
#     customer.mobile_no = data.get('mobile_no', customer.mobile_no)
#     customer.email = data.get('email', customer.email)
#     customer.door_no = data.get('door_no', customer.door_no)
#     customer.country = country  # Assign the Country instance
#     customer.state = state  # Assign the State instance
#     customer.city = city  # Assign the City instance
#     customer.taluk = taluk  # Assign the Taluk instance
#     customer.village = village  # Assign the Village instance
#     customer.post_code = data.get('post_code', customer.post_code)
#     customer.gst_no = data.get('gst_no', customer.gst_no)
#     customer.tax_no = data.get('tax_no', customer.tax_no)
#     customer.is_credit = data.get('is_credit', customer.is_credit)
#     customer.opening_balance = data.get('opening_balance', customer.opening_balance)
#     customer.description = data.get('description', customer.description)
#     customer.updated_at = timezone.now()
#     customer.updated_by = farmer.farmer_user  # Assuming the farmer's user updates the customer

#     # Save the updated customer instance inside try-except to catch database errors
#     try:
#         customer.save()
#     except Exception as e:
#         return Response({"detail": f"Error saving customer: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

#     # Create a notification after the customer is updated
#     notification_message = f"Your Customer '{customer.customer_name}' has been Updated."
#     FarmerNotification.objects.create(
#         farmer=farmer,
#         name=f"Customer Updated: {customer.customer_name}", 
#         type="Customer Updated",
#         message=notification_message,
#         created_at=timezone.now(),
#         is_read=False
#     )

#     # Prepare the response data without using serializers
#     customer_details = {
#         'id': customer.id,
#         'farmer': customer.farmer.name if customer.farmer else "",
#         'customer_name': customer.customer_name,
#         'shop_name': customer.shop_name,
#         'mobile_no': customer.mobile_no,
#         'email': customer.email,
#         'door_no': customer.door_no,
#         'country': customer.country.name if customer.country else "",
#         'state': customer.state.name if customer.state else "",
#         'city': customer.city.name if customer.city else "",
#         'taluk': customer.taluk.name if customer.taluk else "",
#         'village': customer.village.name if customer.village else "",
#         'post_code': customer.post_code,
#         'gst_no': customer.gst_no,
#         'tax_no': customer.tax_no,
#         'is_credit': customer.is_credit,
#         'opening_balance': customer.opening_balance,
#         'customer_img': customer.customer_img.url if customer.customer_img else "",
#         'description': customer.description,
#         'type': 'customer',
#         'language': {
#             "default": "en"
#         }
#     }

#     return Response(customer_details, status=status.HTTP_200_OK)

@api_view(['PUT'])
def update_customer(request, id=None):
    try:
        farmer = Farmer.objects.get(id=id, status=0)
    except Farmer.DoesNotExist:
        return Response({"detail": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)

    try:
        customer = MyCustomer.objects.get(id=request.data.get('customer_id'), farmer=farmer)
    except MyCustomer.DoesNotExist:
        return Response({"detail": "Customer not found or not associated with the specified farmer"}, status=status.HTTP_400_BAD_REQUEST)

    data = request.data

    # Translations for fields (your existing translation logic)
    translated_json = customer.translate_json or {
        "customer_name": {},
        "shop_name": {},
        "door_no": {},
        "description": {}
    }
    target_language = ['hi', 'ta', 'te']  # example languages, adjust as needed

    def translate_field(field_name):
        val = data.get(field_name)
        if val is not None and val != getattr(customer, field_name):
            try:
                for lang in target_language:
                    translated_text = GoogleTranslator(source='auto', target=lang).translate(val)
                    translated_json[field_name][lang] = translated_text
            except Exception as e:
                print(f"Error in translation of {field_name}: {e}")

    translate_field('customer_name')
    translate_field('shop_name')
    translate_field('door_no')
    translate_field('description')

    customer.translate_json = translated_json

    # --- Connect or create location objects by name or id ---

    country_obj = None
    state_obj = None
    city_obj = None
    taluk_obj = None
    village_obj = None

    # Country
    country_name = data.get('country_name')
    if country_name and country_name.strip():
        country_obj, _ = Country.objects.get_or_create(name=country_name.strip())
    elif 'country' in data:
        try:
            country_obj = Country.objects.get(id=data['country'])
        except Country.DoesNotExist:
            return Response({"detail": "Country not found."}, status=status.HTTP_400_BAD_REQUEST)

    # State (must link to country_obj if present)
    state_name = data.get('state_name')
    if state_name and state_name.strip():
        # If country_obj exists, link state to it
        if country_obj:
            state_obj, _ = State.objects.get_or_create(name=state_name.strip(), country=country_obj)
        else:
            # Create/get state without country if country_obj is None (optional: you might want to enforce country)
            state_obj, _ = State.objects.get_or_create(name=state_name.strip())
    elif 'state' in data:
        try:
            state_obj = State.objects.get(id=data['state'])
        except State.DoesNotExist:
            return Response({"detail": "State not found."}, status=status.HTTP_400_BAD_REQUEST)

    # City (link only to state_obj, no country)
    city_name = data.get('city_name')
    if city_name and city_name.strip():
        if state_obj:
            city_obj, _ = City.objects.get_or_create(name=city_name.strip(), state=state_obj ,
           
            country=country_obj)
        else:
            city_obj, _ = City.objects.get_or_create(name=city_name.strip())
    elif 'city' in data:
        try:
            city_obj = City.objects.get(id=data['city'])
        except City.DoesNotExist:
            return Response({"detail": "City not found."}, status=status.HTTP_400_BAD_REQUEST)

    # Taluk (link only to city_obj)
    taluk_name = data.get('taluk_name')
    if taluk_name and taluk_name.strip():
        if city_obj:
            taluk_obj, _ = Taluk.objects.get_or_create(name=taluk_name.strip(), city=city_obj,
            state=state_obj,
            country=country_obj)
        else:
            taluk_obj, _ = Taluk.objects.get_or_create(name=taluk_name.strip())
    elif 'taluk' in data:
        try:
            taluk_obj = Taluk.objects.get(id=data['taluk'])
        except Taluk.DoesNotExist:
            return Response({"detail": "Taluk not found."}, status=status.HTTP_400_BAD_REQUEST)

    # Village (link to taluk, city, state, country if available)
    village_name = data.get('village_name')
    if village_name and village_name.strip():
        village_obj, _ = Village.objects.get_or_create(
            name=village_name.strip(),
            taluk=taluk_obj,
            city=city_obj,
            state=state_obj,
            country=country_obj
        )
    elif 'village' in data:
        try:
            village_obj = Village.objects.get(id=data['village'])
        except Village.DoesNotExist:
            return Response({"detail": "Village not found."}, status=status.HTTP_400_BAD_REQUEST)

    # Assign location objects to customer
    customer.country = country_obj
    customer.state = state_obj
    customer.city = city_obj
    customer.taluk = taluk_obj
    customer.village = village_obj

    # Handle image (base64 or file) if provided
    if 'customer_img' in data:
        try:
            customer_img_data = data['customer_img']
            if isinstance(customer_img_data, str) and customer_img_data.startswith('data:image'):
                # Decode base64 and save
                header, base64_data = customer_img_data.split(';base64,')
                img_data = base64.b64decode(base64_data)
                image = Image.open(io.BytesIO(img_data))
                image.verify()  # validate image

                image_name = f'customer_image_{timezone.now().strftime("%Y%m%d%H%M%S")}.png'
                image_file = InMemoryUploadedFile(io.BytesIO(img_data), None, image_name, 'image/png', len(img_data), None)
                customer.customer_img = image_file
            else:
                # if it is a file uploaded (depends on your client implementation)
                customer.customer_img = data['customer_img']
        except Exception as e:
            return Response({"detail": f"Error processing customer image: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

    # Update remaining fields
    customer.customer_name = data.get('customer_name', customer.customer_name)
    customer.shop_name = data.get('shop_name', customer.shop_name)
    customer.mobile_no = data.get('mobile_no', customer.mobile_no)
    customer.email = data.get('email', customer.email)
    customer.door_no = data.get('door_no', customer.door_no)
    customer.post_code = data.get('post_code', customer.post_code)
    customer.gst_no = data.get('gst_no', customer.gst_no)
    customer.tax_no = data.get('tax_no', customer.tax_no)
    customer.is_credit = data.get('is_credit', customer.is_credit)
    customer.opening_balance = data.get('opening_balance', customer.opening_balance)
    customer.description = data.get('description', customer.description)

    customer.updated_at = timezone.now()
    customer.updated_by = farmer.farmer_user  # Assuming this field exists

    try:
        customer.save()
    except Exception as e:
        return Response({"detail": f"Error saving customer: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

    # Notification
    notification_message = f"Your Customer '{customer.customer_name}' has been Updated."
    FarmerNotification.objects.create(
        farmer=farmer,
        name=f"Customer Updated: {customer.customer_name}",
        type="Customer Updated",
        message=notification_message,
        created_at=timezone.now(),
        is_read=False
    )

    # Prepare response
    response_data = {
        'id': customer.id,
        'farmer': customer.farmer.name if customer.farmer else "",
        'customer_name': customer.customer_name,
        'shop_name': customer.shop_name,
        'mobile_no': customer.mobile_no,
        'email': customer.email,
        'door_no': customer.door_no,
        'country': customer.country.name if customer.country else "",
        'state': customer.state.name if customer.state else "",
        'city': customer.city.name if customer.city else "",
        'taluk': customer.taluk.name if customer.taluk else "",
        'village': customer.village.name if customer.village else "",
        'post_code': customer.post_code,
        'gst_no': customer.gst_no,
        'tax_no': customer.tax_no,
        'is_credit': customer.is_credit,
        'opening_balance': customer.opening_balance,
        'customer_img': customer.customer_img.url if customer.customer_img else "",
        'description': customer.description,
        'type': 'customer',
        'language': {
            "default": "en"
        }
    }

    return Response(response_data, status=status.HTTP_200_OK)


@api_view(['POST'])
def delete_vendor(request,id):
    vendor_id = request.data.get("id")
    try:
        farmer = Farmer.objects.get(id=id)
    except Farmer.DoesNotExist:
        return Response({"detail": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)
    try:
        vendor = MyVendor.objects.get(id = vendor_id,farmer=id,status= 0)
    except MyVendor.DoesNotExist:
        return Response({"detail": "Vendor not found."}, status=status.HTTP_404_NOT_FOUND)
    
    vendor.status = 2
    vendor.updated_at = timezone.now()
    vendor.updated_by = farmer.farmer_user
    vendor.save()
    return Response({"detail": "Vendor marked as deleted."}, status=status.HTTP_200_OK)
 
@api_view(['GET'])
def list_vendors(request, id):
    # Get vendors with status 0 for the specific farmer
    vendors = MyVendor.objects.filter(farmer=id, status=0)
    response_data = []

    # Add vendors data to response
    for vendor in vendors:
        for idx, inventory_type in enumerate(vendor.inventory_type.all(), start=1): 
            vendor_data = {
                "id": vendor.id,
                "vendor_id": vendor.id,
                "farmer_id": vendor.farmer.id if vendor.farmer else None,
                "farmer": vendor.farmer.name if vendor.farmer else None,
                "type": "vendor",
                "name": vendor.name,
                "business_name": vendor.business_name,
                "mobile_no": vendor.mobile_no,
                "email": vendor.email,
                "door_no": vendor.door_no,
                "country_id": vendor.country.id if vendor.country else None,
                "country": vendor.country.name if vendor.country else None,
                "state_id": vendor.state.id if vendor.state else None,
                "state": vendor.state.name if vendor.state else None,
                "city_id": vendor.city.id if vendor.city else None,
                "city": vendor.city.name if vendor.city else None,
                "taluk_id": vendor.taluk.id if vendor.taluk else None,
                "taluk": vendor.taluk.name if vendor.taluk else None,
                "village_id": vendor.village.id if vendor.village else None,
                "village": vendor.village.name if vendor.village else None,
                "credit": vendor.credit,
                "debit": vendor.debit,
                "opening_balance": vendor.opening_balance,
                "description": vendor.description,
                f"inventory_type_id": inventory_type.id,
                f"inventory_type": inventory_type.name
            }
            response_data.append(vendor_data)

    # Debugging: Check if customers are being filtered correctly
    print(f"Filtering customers with farmer_id={id}, is_customer_is_vendor=True, status=0")

    # Include customers marked as vendors (i.e., is_customer_is_vendor=True)
    customers_as_vendors = MyCustomer.objects.filter(farmer=id, is_customer_is_vendor=True, status=0)
    print(f"Found {customers_as_vendors.count()} customers marked as vendors.")

    # Add customers marked as vendors to the response
    for customer in customers_as_vendors:
        customer_data = {
            "id": customer.id,
            "customer_id": customer.id,
            "farmer_id": customer.farmer.id if customer.farmer else None,
            "farmer": customer.farmer.name if customer.farmer else None,
            "type": "vendor",  # Treating the customer as a vendor
            "name": customer.customer_name,
            "business_name": customer.shop_name if customer.shop_name else "",
            "mobile_no": customer.mobile_no,
            "email": customer.email,
            "door_no": customer.door_no,
            "country_id": customer.country.id if customer.country else None,
            "country": customer.country.name if customer.country else None,
            "state_id": customer.state.id if customer.state else None,
            "state": customer.state.name if customer.state else None,
            "city_id": customer.city.id if customer.city else None,
            "city": customer.city.name if customer.city else None,
            "taluk_id": customer.taluk.id if customer.taluk else None,
            "taluk": customer.taluk.name if customer.taluk else None,
            "village_id": customer.village.id if customer.village else None,
            "village": customer.village.name if customer.village else None,
            "credit": customer.is_credit,  # Assuming customers have 'is_credit' field
            "debit": customer.opening_balance,  # Assuming customers have opening balance
            "opening_balance": customer.opening_balance,
            "description": customer.description,
            "inventory_type_id": None,  # Assuming you do not have inventory types for customers
            "inventory_type": None
        }
        response_data.append(customer_data)

    # Return the final response
    return Response(response_data, status=status.HTTP_200_OK)

# @api_view(['GET'])
# def both_customers_and_vendors(request, id):
#     try:
#         customer_list = []
#         customers = MyCustomer.objects.filter(farmer=id, status=0,is_customer_is_vendor=True).order_by('created_at')
#         for customer in customers:
#             for market in customer.market.all():
#                 customer_data = {
#                     "id": customer.id,
#                     "farmer_id": customer.farmer.id if customer.farmer else None,
#                     "farmer": customer.farmer.name if customer.farmer else None,
#                     "customer_name": customer.customer_name,
#                     "type": "customer",
#                     "shop_name": customer.shop_name,
#                     "mobile_no": customer.mobile_no,
#                     "email": customer.email,
#                     "door_no": customer.door_no,
#                     "country_id": customer.country.id if customer.country else None,
#                     "country": customer.country.name if customer.country else None,
#                     "state_id": customer.state.id if customer.state else None,
#                     "state": customer.state.name if customer.state else None,
#                     "city_id": customer.city.id if customer.city else None,
#                     "city": customer.city.name if customer.city else None,
#                     "taluk_id": customer.taluk.id if customer.taluk else None,
#                     "taluk": customer.taluk.name if customer.taluk else None,
#                     "village_id": customer.village.id if customer.village else None,
#                     "village": customer.village.name if customer.village else None,
#                     "gst_no": customer.gst_no,
#                     "tax_no": customer.tax_no,
#                     "post_code": customer.post_code,
#                     "is_credit": customer.is_credit,
#                     "opening_balance": customer.opening_balance,
#                     "description": customer.description,
#                     "is_customer_is_vendor": customer.is_customer_is_vendor,
#                     "market_id": market.id,
#                     "market": market.name,
#                     "created_at": customer.created_at,
#                     "language":{
#                         "default":"en"
#                     }
#                 }
#                 customer_list.append(customer_data)
#         combined_data = customer_list
#         combined_data.sort(key=itemgetter('created_at'),reverse=True)
#         for entry in combined_data:
#             entry.pop('created_at', None)
#         response_data = combined_data
#         return Response(response_data, status=status.HTTP_200_OK)
#     except Exception as e:
#         return Response({"detail": f"An error occurred while processing customers and vendors: {str(e)}"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

 

@api_view(['GET'])
def both_customers_and_vendors(request, id):
    try:
        user_language_pref = UserLanguagePreference.objects.get(user=id)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'

    try:
        # A map to store customer data
        customer_data_map = defaultdict(lambda: {
            "id": None,
            "farmer_id": None,
            "farmer": None,
            "customer_name": None,
            "type": "customer",
            "shop_name": None,
            "mobile_no": None,
            "email": None,
            "door_no": None,
            "country_id": None,
            "country": None,
            "state_id": None,
            "state": None,
            "city_id": None,
            "city": None,
            "taluk_id": None,
            "taluk": None,
            "village_id": None,
            "village": None,
            "gst_no": None,
            "tax_no": None,
            "post_code": None,
            "is_credit": None,
            "opening_balance": None,
            "description": None,
            "is_customer_is_vendor": None,
            "markets": [],
            "language": {"default": "en"},
            "created_at": None  # Adding the created_at field to the default dict
        })

        # A map to store vendor data
        vendor_data_map = defaultdict(lambda: {
            "id": None,
            "farmer_id": None,
            "farmer": None,
            "vendor_name": None,
            "type": "vendor",
            "business_name": None,
            "mobile_no": None,
            "email": None,
            "door_no": None,
            "country_id": None,
            "country": None,
            "state_id": None,
            "state": None,
            "city_id": None,
            "city": None,
            "taluk_id": None,
            "taluk": None,
            "village_id": None,
            "village": None,
            "gst_number": None,
            "tax_number": None,
            "credit": None,
            "opening_balance": None,
            "vendor_image": None,
            "description": None,
            "is_customer_is_vendor": None,
            "inventory_types": [],  # Added inventory types list
            "language": {"default": "en"},
            "created_at": None
        })

        # Fetching customers and their details
        customers = MyCustomer.objects.filter(farmer=id, status=0, is_customer_is_vendor=True).order_by('created_at')

        for customer in customers:
            customer_data = customer_data_map[customer.id]
            customer_data["id"] = customer.id
            customer_data["farmer_id"] = customer.farmer.id if customer.farmer else None
            # customer_data["farmer"] = customer.farmer.name if customer.farmer else None
            # customer_data["customer_name"] = customer.customer_name
            # customer_data["shop_name"] = customer.shop_name
            customer_data["farmer"] = customer.farmer.get_translated_value("name", language_code) if customer.farmer else None
            customer_data["customer_name"] = customer.get_translated_value("customer_name", language_code) if customer else None
            # customer_data["type"] = { "en": "customer", "ta": "à®µà®¾à®Ÿà®¿à®•à¯à®•à¯ˆà®¯à®¾à®³à®°à¯" }.get(language_code, "customer")
            customer_data["shop_name"] = customer.get_translated_value("shop_name", language_code) if customer else None
            customer_data["mobile_no"] = customer.mobile_no
            customer_data["email"] = customer.email
            # customer_data["door_no"] = customer.door_no
            customer_data["door_no"] = customer.get_translated_value("door_no", language_code) if customer else None
            customer_data["country_id"] = customer.country.id if customer.country else None
            # customer_data["country"] = customer.country.name if customer.country else None
            customer_data["country"] = customer.country.get_translated_value("name", language_code) if customer.country else None
            customer_data["state_id"] = customer.state.id if customer.state else None
            # customer_data["state"] = customer.state.name if customer.state else None
            customer_data["state"] = customer.state.get_translated_value("name", language_code) if customer.state else None
            customer_data["city_id"] = customer.city.id if customer.city else None
            # customer_data["city"] = customer.city.name if customer.city else None
            customer_data["city"] = customer.city.get_translated_value("name", language_code) if customer.city else None
            customer_data["taluk_id"] = customer.taluk.id if customer.taluk else None
            # customer_data["taluk"] = customer.taluk.name if customer.taluk else None
            customer_data["taluk"] = customer.taluk.get_translated_value("name", language_code) if customer.taluk else None
            customer_data["village_id"] = customer.village.id if customer.village else None
            # customer_data["village"] = customer.village.name if customer.village else None
            customer_data["village"] = customer.village.get_translated_value("name", language_code) if customer.village else None
            customer_data["gst_no"] = customer.gst_no
            customer_data["tax_no"] = customer.tax_no
            customer_data["post_code"] = customer.post_code
            customer_data["is_credit"] = customer.is_credit
            customer_data["opening_balance"] = customer.opening_balance
            # customer_data["description"] = customer.description
            customer_data["description"] = customer.get_translated_value("description", language_code) if customer else "",
            customer_data["is_customer_is_vendor"] = customer.is_customer_is_vendor
            customer_data["created_at"] = customer.created_at  # Ensure created_at is set

            for market in customer.market.all():
                market_data = {
                    "market_id": market.id,
                    "market": market.name
                }
                customer_data["markets"].append(market_data)

        # Fetching vendors and including their inventory types
        vendors = MyVendor.objects.filter(farmer=id, status=0, is_customer_is_vendor=True).order_by('created_at')

        for vendor in vendors:
            vendor_data = vendor_data_map[vendor.id]
            vendor_data["id"] = vendor.id
            vendor_data["farmer_id"] = vendor.farmer.id if vendor.farmer else None
            # vendor_data["farmer"] = vendor.farmer.name if vendor.farmer else None
            # vendor_data["vendor_name"] = vendor.name
            # vendor_data["business_name"] = vendor.business_name
            vendor_data["farmer"] = vendor.farmer.get_translated_value("name", language_code) if vendor.farmer else None
            vendor_data["vendor_name"] = vendor.get_translated_value("name", language_code) if vendor else None
            # vendor_data["type"] = { "en": "vendor", "ta": "à®µà®¿à®±à¯à®ªà®©à¯ˆà®¯à®¾à®³à®°à¯" }.get(language_code, "vendor")
            vendor_data["business_name"] = vendor.get_translated_value("business_name", language_code) if vendor else None
            vendor_data["mobile_no"] = vendor.mobile_no
            vendor_data["email"] = vendor.email
            # vendor_data["door_no"] = vendor.door_no
            vendor_data["door_no"] = vendor.get_translated_value("door_no", language_code) if vendor else None
            vendor_data["country_id"] = vendor.country.id if vendor.country else None
            # vendor_data["country"] = vendor.country.name if vendor.country else None
            vendor_data["country"] = vendor.country.get_translated_value("name", language_code) if vendor.country else None
            vendor_data["state_id"] = vendor.state.id if vendor.state else None
            # vendor_data["state"] = vendor.state.name if vendor.state else None
            vendor_data["state"] = vendor.state.get_translated_value("name", language_code) if vendor.state else None
            vendor_data["city_id"] = vendor.city.id if vendor.city else None
            # vendor_data["city"] = vendor.city.name if vendor.city else None
            vendor_data["city"] = vendor.city.get_translated_value("name", language_code) if vendor.city else None
            vendor_data["taluk_id"] = vendor.taluk.id if vendor.taluk else None
            # vendor_data["taluk"] = vendor.taluk.name if vendor.taluk else None
            vendor_data["taluk"] = vendor.taluk.get_translated_value("name", language_code) if vendor.taluk else None
            vendor_data["village_id"] = vendor.village.id if vendor.village else None
            # vendor_data["village"] = vendor.village.name if vendor.village else None
            vendor_data["village"] = vendor.village.get_translated_value("name", language_code) if vendor.village else None
            vendor_data["gst_number"] = vendor.gst_number
            vendor_data["tax_number"] = vendor.tax_number
            vendor_data["credit"] = vendor.credit
            vendor_data["opening_balance"] = vendor.opening_balance
            vendor_data["vendor_image"] = vendor.vendor_image.url if vendor.vendor_image else None
            # vendor_data["description"] = vendor.description
            vendor_data["description"] = vendor.get_translated_value("description", language_code) if vendor else ""
            vendor_data["is_customer_is_vendor"] = vendor.is_customer_is_vendor
            vendor_data["created_at"] = vendor.created_at  # Ensure created_at is set

            # Add the vendor's inventory types to the vendor's data
            inventory_types = vendor.inventory_type.all()
            vendor_data["inventory_types"] = [
                {"id": inventory_type.id, "name": inventory_type.get_translated_value("name", language_code) if inventory_type else ""} for inventory_type in inventory_types
            ]
            # vendor_data["inventory_types"] = [
            #     {"id": inventory_type.id, "name": inventory_type.name} for inventory_type in inventory_types
            # ]

        # Combine customer and vendor data
        # combined_data = list(customer_data_map.values()) + list(vendor_data_map.values())
        combined_data = list(customer_data_map.values())

        # Sort the combined data by `created_at` if it exists
        sorted_data = sorted(combined_data, key=lambda x: x['created_at'] if x['created_at'] else "", reverse=True)

        # Remove `created_at` from each entry
        for entry in sorted_data:
            entry.pop('created_at', None)

        return Response(sorted_data, status=status.HTTP_200_OK)

    except Exception as e:
        return Response({"detail": f"An error occurred while processing customers and vendors: {str(e)}"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


# Vendor Details
@api_view(['POST'])
def vendor_details(request, id):
    vendor_id = request.data.get('vendor_id')
    vendors = MyVendor.objects.filter(id=vendor_id, farmer=id, status=0)
    vendor_list = []
    
    for vendor in vendors:
            for idx, inventory_type in enumerate(vendor.inventory_type.all(), start=1): 
                vendor_data = {
                "id": vendor.id,
                "vendor_id": vendor.id,
                "farmer_id": vendor.farmer.id if vendor.farmer else None,
                "farmer": vendor.farmer.name if vendor.farmer else None,
                "type": "vendor",
                "name":vendor.name,
                "business_name": vendor.business_name,
                "mobile_no": vendor.mobile_no,
                "email": vendor.email,
                "door_no": vendor.door_no,
                "country_id": vendor.country.id if vendor.country else None,
                "country": vendor.country.name if vendor.country else None,
                "state_id": vendor.state.id if vendor.state else None,
                "state": vendor.state.name if vendor.state else None,
                "city_id": vendor.city.id if vendor.city else None,
                "city": vendor.city.name if vendor.city else None,
                "taluk_id": vendor.taluk.id if vendor.taluk else None,
                "taluk": vendor.taluk.name if vendor.taluk else None,
                "village_id": vendor.village.id if vendor.village else None,
                "village": vendor.village.name if vendor.village else None,
                "credit":vendor.credit,
                "debit":vendor.debit,
                "opening_balance": vendor.opening_balance,
                "description": vendor.description,
                f"inventory_type_id": inventory_type.id,
                f"inventory_type": inventory_type.name
                }
                vendor_list.append(vendor_data)
    return Response(vendor_list, status=status.HTTP_200_OK)

@api_view(['GET'])
def list_customers_and_vendors(request, id):
    try:
        response_data = {
            "customers": [],
            "vendors": []
        }

        customers = MyCustomer.objects.filter(farmer=id, status=0)
        for customer in customers:
            for idx, market in enumerate(customer.market.all(), start=1):  # Enumerate to create unique keys
                customer_data = {
                    "id": customer.id,
                    "farmer_id": customer.farmer.id if customer.farmer else None,
                    "farmer": customer.farmer.name if customer.farmer else None,
                    "customer_name": customer.customer_name,
                    "type": "customer",  # Static value as in your example
                    "shop_name": customer.shop_name,
                    "mobile_no": customer.mobile_no,
                    "email": customer.email,
                    "door_no": customer.door_no,
                    "country_id": customer.country.id if customer.country else None,
                    "country": customer.country.name if customer.country else None,
                    "state_id": customer.state.id if customer.state else None,
                    "state": customer.state.name if customer.state else None,
                    "city_id": customer.city.id if customer.city else None,
                    "city": customer.city.name if customer.city else None,
                    "taluk_id": customer.taluk.id if customer.taluk else None,
                    "taluk": customer.taluk.name if customer.taluk else None,
                    "village_id": customer.village.id if customer.village else None,
                    "village": customer.village.name if customer.village else None,
                    "gst_no": customer.gst_no,
                    "tax_no": customer.tax_no,
                    "post_code": customer.post_code,
                    "is_credit": customer.is_credit,
                    "opening_balance": customer.opening_balance,
                    "description": customer.description,
                    "is_customer_is_vendor": customer.is_customer_is_vendor,
                    # Now showing individual market details
                    f"market_id": market.id,
                    f"market": market.name
                }
                response_data["customers"].append(customer_data)

        vendors = MyVendor.objects.filter(farmer=id, status=0)
        for vendor in vendors:
            for idx, inventory_type in enumerate(vendor.inventory_type.all(), start=1): 
                vendor_data = {
                "vendor_id": vendor.id,
                "farmer_id": vendor.farmer.id if vendor.farmer else None,
                "farmer": vendor.farmer.name if vendor.farmer else None,
                "type": "vendor",
                "name":vendor.name,
                "business_name": vendor.business_name,
                "mobile_no": vendor.mobile_no,
                "email": vendor.email,
                "door_no": vendor.door_no,
                "country_id": vendor.country.id if vendor.country else None,
                "country": vendor.country.name if vendor.country else None,
                "state_id": vendor.state.id if vendor.state else None,
                "state": vendor.state.name if vendor.state else None,
                "city_id": vendor.city.id if vendor.city else None,
                "city": vendor.city.name if vendor.city else None,
                "taluk_id": vendor.taluk.id if vendor.taluk else None,
                "taluk": vendor.taluk.name if vendor.taluk else None,
                "village_id": vendor.village.id if vendor.village else None,
                "village": vendor.village.name if vendor.village else None,
                "pincode": vendor.pincode,
                "credit":vendor.credit,
                "debit":vendor.debit,
                "opening_balance": vendor.opening_balance,
                "description": vendor.description,
                f"inventory_type_id": inventory_type.id,
                f"inventory_type": inventory_type.name
                }
                response_data["vendors"].append(vendor_data)

        return Response(response_data, status=status.HTTP_200_OK)

    except Exception as e:
        return Response(
            {"detail": f"An error occurred while processing customers and vendors: {str(e)}"},
            status=status.HTTP_500_INTERNAL_SERVER_ERROR
        )
   
@api_view(['POST'])
def delete_my_schedule(request, id):
    try:
        farmer = Farmer.objects.get(id=id)
    except Farmer.DoesNotExist:
        return Response({"detail": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)
    task_id = request.data.get('id', None)
    if not task_id:
        return Response({"error": "Task ID is required."}, status=status.HTTP_400_BAD_REQUEST)
    try:
        schedule_instance = MySchedule.objects.get(id=task_id, farmer=farmer)
    except MySchedule.DoesNotExist:
        return Response({"error": "Task not found."}, status=status.HTTP_404_NOT_FOUND)
    if schedule_instance.status == 2:
        return Response({"message": "The Schedule is already deleted."}, status=status.HTTP_400_BAD_REQUEST)
    schedule_instance.status = 2
    schedule_instance.updated_at = timezone.now()
    # schedule_instance.updated_by = farmer_instance.farmer 
    schedule_instance.save()

    return Response({"message": "Task Deleted."}, status=status.HTTP_200_OK)

@api_view(['GET'])
def get_customer_balances_view(request, farmer_id):
    # Fetch the farmer's customers and vendors based on the farmer_id
    customers = MyCustomer.objects.filter(farmer_id=farmer_id)
    vendors = MyVendor.objects.filter(farmer_id=farmer_id)

    # If no customers or vendors are found for the given farmer_id, return a 404 response
    if not customers.exists() and not vendors.exists():
        return Response({"message": "No customers or vendors found for the given farmer."}, status=status.HTTP_404_NOT_FOUND)

    # Calculate total payables (is_credit=False) for this farmer (customers and vendors)
    total_payables_customers = customers.filter(is_credit=False).aggregate(total_amount=Sum('opening_balance'))['total_amount'] or 0
    total_payables_vendors = vendors.filter(debit=True).aggregate(total_amount=Sum('opening_balance'))['total_amount'] or 0
    total_payables = total_payables_customers + total_payables_vendors

    # Calculate total receivables (is_credit=True) for this farmer (customers and vendors)
    total_receivables_customers = customers.filter(is_credit=True).aggregate(total_amount=Sum('opening_balance'))['total_amount'] or 0
    total_receivables_vendors = vendors.filter(credit=True).aggregate(total_amount=Sum('opening_balance'))['total_amount'] or 0
    total_receivables = total_receivables_customers + total_receivables_vendors

    # Prepare the combined customer and vendor data with necessary fields
    combined_data = []

    # Add customer data to the combined list
    for customer in customers:
        customer_info = {
            "name": customer.customer_name,
            "outstanding": customer.opening_balance,  # Adjust if needed based on actual outstanding field
            "market_name": [market.name for market in customer.market.all()],  # Assuming 'ManageMarket' model has a 'name' field
            "credit_debit": "+" if customer.is_credit else "-"  # If is_credit=True, it's receivable ("+"), else payable ("-")
        }
        combined_data.append(customer_info)

    # Add vendor data to the combined list
    for vendor in vendors:
        vendor_info = {
            "name": vendor.name,
            "outstanding": vendor.opening_balance,  # Adjust if needed based on actual outstanding field
            "inventory_type_name": [inventory.name for inventory in vendor.inventory_type.all()],  # Assuming 'InventoryType' model has a 'name' field
            "credit_debit": "+" if vendor.credit else "-"  # If credit=True, it's receivable ("+"), else payable ("-")
        }
        combined_data.append(vendor_info)

    # Format with and without 'K'
    response_data = {
        "payables": {
            "with_k": f"{total_payables}K" if total_payables >= 1000 else f"{total_payables}",
            "without_k": total_payables
        },
        "receivables": {
            "with_k": f"{total_receivables}K" if total_receivables >= 1000 else f"{total_receivables}",
            "without_k": total_receivables
        },
        "datas": combined_data
    }

    return Response(response_data, status=status.HTTP_200_OK)
 
@api_view(['GET'])
def list_market_names(request): 
    markets = ManageMarket.objects.all()    
    market_names = ManageMarketSerializer(markets, many=True).data   
    return Response(market_names, status=status.HTTP_200_OK)

#priya
# @api_view(['GET'])
# def get_inventory_summary(request, id):
#     inventory_data = []

#     # Get Fuel Data
#     fuel_items = MyFuel.objects.filter(farmer=id)
#     total_fuel_quantity = sum([item.quantity for item in fuel_items])  # Summing up the quantities
#     inventory_data.append({
#         "inventory_type": "fuel",
#         "total_quantity": total_fuel_quantity if fuel_items.exists() else 0
#     })

#     vehicle_count = MyVehicle.objects.filter(farmer=id).count()
#     inventory_data.append({
#         "inventory_type": "vehicle",
#         "total_count": vehicle_count if vehicle_count > 0 else 0
#     })


#     # Get Machinery Data
#     machinery_count = MyMachinery.objects.filter(farmer=id).count()
#     inventory_data.append({
#         "inventory_type": "machinery",
#         "total_count": machinery_count if machinery_count > 0 else 0
#     })

#     # Get Tools Data
#     tools_count = MyTools.objects.filter(farmer=id).count()
#     inventory_data.append({
#         "inventory_type": "tools",
#         "total_count": tools_count if tools_count > 0 else 0
#     })

#     # Get Vehicle Data
    
#     # Get Pesticides Data
#     pesticides_items = MyPesticides.objects.filter(farmer=id)
#     total_pesticides_quantity = sum([item.quantity for item in pesticides_items])
#     inventory_data.append({
#         "inventory_type": "pesticides",
#         "total_quantity": total_pesticides_quantity if pesticides_items.exists() else 0
#     })

#     # Get Fertilizer Data
#     fertilizer_items = MyFertilizers.objects.filter(farmer=id)
#     total_fertilizer_quantity = sum([item.quantity for item in fertilizer_items])
#     inventory_data.append({
#         "inventory_type": "fertilizer",
#         "total_quantity": total_fertilizer_quantity if fertilizer_items.exists() else 0
#     })

#     # Get Seeds Data
#     seeds_items = MySeeds.objects.filter(farmer=id)
#     total_seeds_quantity = sum([item.quantity for item in seeds_items])
#     inventory_data.append({
#         "inventory_type": "seeds",
#         "total_quantity": total_seeds_quantity if seeds_items.exists() else 0
#     })

#     return Response(inventory_data, status=status.HTTP_200_OK)

#bala
@api_view(['GET'])
def get_inventory_summary(request, id):
    inventory_data = []
 
    # Get Fuel Data
    fuel_items = MyFuel.objects.filter(farmer=id)
    total_fuel_quantity = sum([item.quantity for item in fuel_items])
    inventory_data.append({
        "id": 6,
        "inventory_type": "fuel",
        "total_quantity": total_fuel_quantity if fuel_items.exists() else 0,
        "unit_type": "liter"
    })
 
    # Vehicle Data
    vehicle_count = MyVehicle.objects.filter(farmer=id).count()
    inventory_data.append({
        "id": 1,
        "inventory_type": "vehicle",
        "total_count": vehicle_count if vehicle_count > 0 else 0,
        "unit_type": "count"
    })
 
    # Machinery Data
    machinery_count = MyMachinery.objects.filter(farmer=id).count()
    inventory_data.append({
        "id": 2,
        "inventory_type": "machinery",
        "total_count": machinery_count if machinery_count > 0 else 0,
        "unit_type": "count"
    })
 
    # Tools Data
    tools_count = MyTools.objects.filter(farmer=id).count()
    inventory_data.append({
        "id": 3,
        "inventory_type": "tools",
        "total_count": tools_count if tools_count > 0 else 0,
        "unit_type": "count"
    })
 
    # Pesticides Data
    pesticides_items = MyPesticides.objects.filter(farmer=id)
    total_pesticides_quantity = sum([item.quantity for item in pesticides_items])
    inventory_data.append({
        "id": 4,
        "inventory_type": "pesticides",
        "total_quantity": total_pesticides_quantity if pesticides_items.exists() else 0,
        "unit_type": "kg"
    })
 
    # Fertilizer Data
    fertilizer_items = MyFertilizers.objects.filter(farmer=id)
    total_fertilizer_quantity = sum([item.quantity for item in fertilizer_items])
    inventory_data.append({
        "id": 5,
        "inventory_type": "fertilizer",
        "total_quantity": total_fertilizer_quantity if fertilizer_items.exists() else 0,
        "unit_type": "kg"
    })
 
    # Seeds Data
    seeds_items = MySeeds.objects.filter(farmer=id)
    total_seeds_quantity = sum([item.quantity for item in seeds_items])
    inventory_data.append({
        "id": 7,
        "inventory_type": "seeds",
        "total_quantity": total_seeds_quantity if seeds_items.exists() else 0,
        "unit_type": "kg"
    })
 
    return Response(inventory_data, status=status.HTTP_200_OK)

# region Add new api function by Bala
 
# @api_view(['GET'])
# def get_inventory_purchase_list(request, farmer_id, inventory_type_id, inventory_items_id):
 
#     farmer = get_object_or_404(Farmer, id=farmer_id)
#     inventory_type = get_object_or_404(InventoryType, id=inventory_type_id)
#     inventory_items = get_object_or_404(InventoryItems, id=inventory_items_id)
 
#     inventories_qs = MyInventory.objects.filter(
#         farmer=farmer,
#         inventory_type=inventory_type,
#         inventory_items=inventory_items,
#         fuel_purchase__isnull=False,
#     ).select_related('fuel_purchase__vendor')  
 
#     fuel_data = inventories_qs.values(
#         'fuel_purchase__id',
#         'fuel_purchase__date_of_consumption',
#         'fuel_purchase__quantity',
#         'fuel_purchase__purchase_amount',
#         'fuel_purchase__vendor__id',
#         'fuel_purchase__vendor__name',
#     )
 
#     # Set up pagination: 10 items per page
#     paginator = PageNumberPagination()
#     paginator.page_size = 2
 
#     # Paginate
#     try:
#         paginated_fuel_data = paginator.paginate_queryset(list(fuel_data), request)
#     except NotFound:
#         return Response(
#             {
#                 "error": "No more items.",
#                 "message": "You have reached the end of the list."
#             },
#             status=status.HTTP_400_BAD_REQUEST
#         )
 
#     response_data = list(
#     map(lambda item: {
#         'id': item['fuel_purchase__id'],
#         'date_of_consumption': str(item['fuel_purchase__date_of_consumption']) if item['fuel_purchase__date_of_consumption'] else "N/A",
#         'quantity': str(item['fuel_purchase__quantity']) if item['fuel_purchase__quantity'] is not None else "0.00",
#         'unit_type': "liter",
#         'purchase_amount': str(item['fuel_purchase__purchase_amount']) if item['fuel_purchase__purchase_amount'] is not None else "0.00",
#         'vendor': {
#             'id': item['fuel_purchase__vendor__id'],
#             'name': item['fuel_purchase__vendor__name'] or "Unknown",
#         }
#     }, paginated_fuel_data)
#     )
   
#     return Response(response_data, status=status.HTTP_200_OK)
 
 
# @api_view(['GET'])
# def get_inventory_cusumption_list(request, farmer_id, inventory_type_id, inventory_items_id):
#     farmer = get_object_or_404(Farmer, id=farmer_id)
#     inventory_type = get_object_or_404(InventoryType, id=inventory_type_id)
#     inventory_items = get_object_or_404(InventoryItems, id=inventory_items_id)
 
#     inventories = MyInventory.objects.filter(
#         farmer=farmer,
#         inventory_type=inventory_type,
#         inventory_items=inventory_items
#     ).select_related('crop', 'crop__crop')  
 
#     paginator = PageNumberPagination()
#     paginator.page_size = 2
 
#     try:
#         paginated_inventories = paginator.paginate_queryset(list(inventories), request)
#     except NotFound:
#         return Response(
#             {
#                 "error": "No more items.",
#                 "message": "You have reached the end of the list."
#             },
#             status=status.HTTP_400_BAD_REQUEST
#         )
#     response_data = list(
#         map(lambda inventory: {
#         'id': inventory.id,
#         'quantity': str(inventory.quantity_utilized) if inventory.quantity_utilized else "0.00",
#         'date_of_consumption': str(inventory.date_of_consumption) if inventory.date_of_consumption else "N/A",
#         'start_kilometer': str(inventory.start_kilometer) if inventory.start_kilometer else "0.00",
#         'end_kilometer': str(inventory.end_kilometer) if inventory.end_kilometer else "0.00",
#         'usage_hours': str(inventory.usage_hours) if inventory.usage_hours else "0.00",
#         'rental': str(inventory.rental) if inventory.rental else "1",
#         'crop_id': inventory.crop.id if inventory.crop else None,
#         'crop_name': inventory.crop.crop.get_translated_value("name", language_code) if inventory.crop else "Unknown Crop",
#         'created_at': str(inventory.created_at) if inventory.created_at else "N/A",
#         'updated_at': str(inventory.updated_at) if inventory.updated_at else "N/A",
#     }, paginated_inventories))
 
#     return Response(response_data, status=status.HTTP_200_OK)
 
# endregion
 

# Fuel Inventory
@api_view(['GET'])
def get_fuel_inventory_list(request, id):
    try:
        fuel_items = MyFuel.objects.filter(farmer=id)  # Use filter to get multiple items
        if not fuel_items.exists():
            return Response({"detail": "Fuel items not found for the given farmer."}, status=status.HTTP_404_NOT_FOUND)
        fuel_data = MyFuelSerializer(fuel_items, many=True).data  # Pass 'many=True' when serializing
        return Response(fuel_data, status=status.HTTP_200_OK)
    except MyFuel.DoesNotExist:
        return Response({"detail": "Fuel items not found for the given farmer."}, status=status.HTTP_404_NOT_FOUND)

# Machinery Inventory
@api_view(['GET'])
def get_machinery_inventory_list(request, id):
    try:
        machinery_items = MyMachinery.objects.filter(farmer=id)  # Use filter to get multiple items
        if not machinery_items.exists():
            return Response({"detail": "Machinery items not found for the given farmer."}, status=status.HTTP_404_NOT_FOUND)
        machinery_data = MyMachinerySerializer(machinery_items, many=True).data  # Pass 'many=True' when serializing
        return Response(machinery_data, status=status.HTTP_200_OK)
    except MyMachinery.DoesNotExist:
        return Response({"detail": "Machinery items not found for the given farmer."}, status=status.HTTP_404_NOT_FOUND)

# Tools Inventory
@api_view(['GET'])
def get_tools_inventory_list(request, id):
    try:
        tools_items = MyTools.objects.filter(farmer=id)  # Use filter to get multiple items
        if not tools_items.exists():
            return Response({"detail": "Tools items not found for the given farmer."}, status=status.HTTP_404_NOT_FOUND)
        tools_data = MyToolsSerializer(tools_items, many=True).data  # Pass 'many=True' when serializing
        return Response(tools_data, status=status.HTTP_200_OK)
    except MyTools.DoesNotExist:
        return Response({"detail": "Tools items not found for the given farmer."}, status=status.HTTP_404_NOT_FOUND)

# Vehicle Inventory
@api_view(['GET'])
def get_vehicle_inventory_list(request, id):
    try:
        vehicle_items = MyVehicle.objects.filter(farmer=id)  # Use filter to get multiple items
        if not vehicle_items.exists():
            return Response({"detail": "Vehicle items not found for the given farmer."}, status=status.HTTP_404_NOT_FOUND)
        vehicle_data = MyVehicleSerializer(vehicle_items, many=True).data  # Pass 'many=True' when serializing
        return Response(vehicle_data, status=status.HTTP_200_OK)
    except MyVehicle.DoesNotExist:
        return Response({"detail": "Vehicle items not found for the given farmer."}, status=status.HTTP_404_NOT_FOUND)

# Pesticides Inventory
@api_view(['GET'])
def get_pesticide_inventory_list(request, id):
    try:
        pesticide_items = MyPesticides.objects.filter(farmer=id)  # Use filter to get multiple items
        if not pesticide_items.exists():
            return Response({"detail": "Pesticide items not found for the given farmer."}, status=status.HTTP_404_NOT_FOUND)
        pesticide_data = MyPesticidesSerializer(pesticide_items, many=True).data  # Pass 'many=True' when serializing
        return Response(pesticide_data, status=status.HTTP_200_OK)
    except MyPesticides.DoesNotExist:
        return Response({"detail": "Pesticide items not found for the given farmer."}, status=status.HTTP_404_NOT_FOUND)

# Fertilizers Inventory
@api_view(['GET'])
def get_fertilizer_inventory_list(request, id):
    try:
        fertilizer_items = MyFertilizers.objects.filter(farmer=id)  # Use filter to get multiple items
        if not fertilizer_items.exists():
            return Response({"detail": "Fertilizer items not found for the given farmer."}, status=status.HTTP_404_NOT_FOUND)
        fertilizer_data = MyFertilizersSerializer(fertilizer_items, many=True).data  # Pass 'many=True' when serializing
        return Response(fertilizer_data, status=status.HTTP_200_OK)
    except MyFertilizers.DoesNotExist:
        return Response({"detail": "Fertilizer items not found for the given farmer."}, status=status.HTTP_404_NOT_FOUND)

# Seeds Inventory
@api_view(['GET'])
def get_seed_inventory_list(request, id):
    try:
        seed_items = MySeeds.objects.filter(farmer=id)  # Use filter to get multiple items
        if not seed_items.exists():
            return Response({"detail": "Seed items not found for the given farmer."}, status=status.HTTP_404_NOT_FOUND)
        seed_data = MySeedsSerializer(seed_items, many=True).data  # Pass 'many=True' when serializing
        return Response(seed_data, status=status.HTTP_200_OK)
    except MySeeds.DoesNotExist:
        return Response({"detail": "Seed items not found for the given farmer."}, status=status.HTTP_404_NOT_FOUND)

@api_view(['GET'])
def list_consumptions(request,id):
    # Fetch all inventory consumptions
    consumptions = MyInventory.objects.filter(farmer=id)

    # Optionally, you can filter the consumptions based on certain query parameters, 
    # such as filtering by crop, inventory type, date, etc.
    crop_id = request.query_params.get('crop', None)
    if crop_id:
        consumptions = consumptions.filter(crop=crop_id)

    inventory_type_id = request.query_params.get('inventory_type', None)
    if inventory_type_id:
        consumptions = consumptions.filter(inventory_type=inventory_type_id)

    date_of_consumption = request.query_params.get('date_of_consumption', None)
    if date_of_consumption:
        consumptions = consumptions.filter(date_of_consumption=date_of_consumption)

    # Serialize the consumptions data
    serializer = MyInventoryInsertionsSerializer(consumptions, many=True)

    return Response(serializer.data, status=status.HTTP_200_OK)
 
# @api_view(['GET'])
# def get_product_market_report(request, farmer_id): 
#     land_id = request.query_params.get('land_id')

#     try: 
#         farmer = Farmer.objects.get(id=farmer_id)
#         land = MyLand.objects.get(id=land_id, farmer=farmer)  
 
#         reports = ProductMarketReport.objects.filter(market__village=land.village).order_by('-id')[:5]

#         # Group data by market
#         market_data = {}
#         for report in reports:
#             market_name = report.market.name
#             product_name = report.product.name
#             product_price = report.price

#             # Check if the market's village matches the land's village
#             if report.market.village == land.village:
#                 if market_name not in market_data:
#                     market_data[market_name] = {
#                         "market": market_name,
#                         "price": [],
#                         "language":{
#                             "default":"en"
#                         }
#                     }

#                 # Add product price to the corresponding market
#                 market_data[market_name]["price"].append({
#                     "product": product_name,
#                     "product_price": product_price
#                 })

#         # Convert the grouped data into a list
#         market_list = list(market_data.values())

#         return Response(market_list, status=200)

#     except MyLand.DoesNotExist:
#         return Response({"error": "Land not found for the given farmer_id and land_id"}, status=status.HTTP_404_NOT_FOUND)

#     except Farmer.DoesNotExist:
#         return Response({"error": "Farmer not found with the given farmer_id"}, status=status.HTTP_404_NOT_FOUND)

@api_view(['GET'])
def get_product_market_report(request, farmer_id):
    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'  # Fallback to 'en' if no preference is found

    land_id = request.query_params.get('land_id')

    try: 
        farmer = Farmer.objects.get(id=farmer_id)
        land = MyLand.objects.get(id=land_id, farmer=farmer)  
 
        reports = ProductMarketReport.objects.filter(market__village=land.village).order_by('-id')[:5]

        # Group data by market
        market_data = {}
        for report in reports:
            market_name = report.market.get_translated_value("name", language_code) if report.market else report.market.name
            # product_name = report.product.name
            product_name = report.product.get_translated_value("name", language_code) if report.product else report.product.name,
            product_price = report.price

            # Check if the market's village matches the land's village
            if report.market.village == land.village:
                if market_name not in market_data:
                    market_data[market_name] = {
                        "market": market_name,
                        "price": [],
                        "language":{
                            "default":"en"
                        }
                    }

                # Add product price to the corresponding market
                market_data[market_name]["price"].append({
                    "product" : report.product.get_translated_value("name", language_code) if report.product else report.product.name,
                    "product_price": product_price
                })

        # Convert the grouped data into a list
        market_list = list(market_data.values())

        return Response(market_list, status=200)

    except MyLand.DoesNotExist:
        return Response({"error": "Land not found for the given farmer_id and land_id"}, status=status.HTTP_404_NOT_FOUND)

    except Farmer.DoesNotExist:
        return Response({"error": "Farmer not found with the given farmer_id"}, status=status.HTTP_404_NOT_FOUND)


@api_view(['POST'])
def add_task(request, id):
    try:
        # Get the Farmer instance based on the provided ID
        farmer_instance = Farmer.objects.get(id=id)
    except Farmer.DoesNotExist:
        return Response({"error": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)

    # POST method - Create a new task
    if request.method == 'POST':
        # Deserialize incoming data using the serializer
        serializer = MyScheduleInsertionSerilaizer(data=request.data)
        
        if serializer.is_valid():
            # Save the schedule instance by passing the full Farmer instance
            schedule_details = serializer.save(
                farmer=farmer_instance,  # Pass the actual Farmer instance here
                updated_by=farmer_instance.farmer_user,  # Assuming these fields are related to the user
                created_by=farmer_instance.farmer_user
            )
            
            # Serialize the schedule details for response
            schedule_instance_data = MyScheduleDetailsSerializer(schedule_details).data
            
            # Return the created schedule data as the response
            return Response(schedule_instance_data, status=status.HTTP_201_CREATED)
        
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    
@api_view(['POST'])
def get_task_date(request, id):
    user_id = id
    
    # Retrieve date from request data (assuming it's sent as a string 'YYYY-MM-DD')
    date_str = request.data.get('date')  # Get the 'date' from the request body
    if not date_str:
        return Response({"error": "Date is required."}, status=status.HTTP_400_BAD_REQUEST)
    
    try:
        # Convert the string date to a datetime object
        task_date = datetime.strptime(date_str, '%Y-%m-%d').date()
    except ValueError:
        return Response({"error": "Invalid date format. Please use YYYY-MM-DD."}, status=status.HTTP_400_BAD_REQUEST)

    try:
        farmer_instance = Farmer.objects.get(id=user_id)
    except Farmer.DoesNotExist:
        return Response({"error": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)

    # Filter tasks based on the given date
    tasks = MySchedule.objects.filter(farmer=farmer_instance, start_date=task_date)

    if not tasks:
        return Response({"error": "No tasks found for this farmer on the specified date."}, status=status.HTTP_404_NOT_FOUND)

    grouped_tasks = defaultdict(list)
    for task in tasks:
        day_name = task.start_date.strftime('%a')

        crop_info = {
            "crop_type": task.my_crop.crop.name if task.my_crop else "Crop Not Allocated",
            "description": task.schedule if task.schedule else "Schedule Not Allocated",
        }

        grouped_tasks[task.start_date.strftime('%b %d')].append({"Day": day_name, "crop": [crop_info]})

    response_data = [{"Date": date, "Day": day_info[0]['Day'], "crop": [item['crop'][0] for item in day_info]} 
                     for date, day_info in grouped_tasks.items()]

    return Response(response_data, status=status.HTTP_200_OK)

@api_view(['POST'])
def get_task_detail(request, id):
    task_id = request.data.get('id')
    try:
        farmer_instance = Farmer.objects.get(id=id)
    except Farmer.DoesNotExist:
        return Response({"error": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)
    try:
        task = MySchedule.objects.get(id=task_id, farmer=id)
    except MySchedule.DoesNotExist:
        return Response({"error": "Task not found."}, status=status.HTTP_404_NOT_FOUND)
    crop = task.my_crop
    if crop and crop.crop.img:
        crop_image_url = '/assets' + crop.crop.img.url
    else:
        crop_image_url = '/assets/images/product_img/crop_default.png'
    task_serializer = MyScheduleDetailsSerializer(task)
    task_data = task_serializer.data
    task_data['crop_image'] = crop_image_url
    return Response(task_data, status=status.HTTP_200_OK)

@api_view(['POST'])
def get_task_list_for_year(request, id):
    user_id = id
    year = request.data.get('year', None)

    if not year:
        return Response({"error": "Year parameter is required."}, status=status.HTTP_400_BAD_REQUEST)

    try:
        # Ensure that the year is an integer
        year = int(year)
    except ValueError:
        return Response({"error": "'year' parameter should be an integer."}, status=status.HTTP_400_BAD_REQUEST)

    try:
        # Fetch the farmer instance by ID
        farmer_instance = Farmer.objects.get(id=user_id)
    except Farmer.DoesNotExist:
        return Response({"error": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)

    # Define the start and end date of the year
    start_date = datetime(year, 1, 1)
    end_date = datetime(year + 1, 1, 1)

    # Filter tasks for the given farmer and within the specified year range
    tasks = MySchedule.objects.filter(farmer=farmer_instance, start_date__gte=start_date, start_date__lt=end_date)

    if not tasks:
        return Response({"error": "No tasks found for this farmer in the specified year."}, status=status.HTTP_404_NOT_FOUND)

    # Serialize the tasks
    task_serializer = MyScheduleDetailsSerializer(tasks, many=True)

    # Prepare data for counting tasks by date
    response_data = defaultdict(lambda: {"task_count": 0, "tasks": [], "completed": 0, "waiting": 0})

    for task in task_serializer.data:
        task_date = task['start_date']
        # Check schedule_status to determine if task is completed or waiting
        if task['schedule_status'] == 'Completed':
            is_completed = True
        elif task['schedule_status'] == 'Waiting':
            is_completed = False
        else:
            is_completed = None  # In case there is another status

        # Update counts
        response_data[task_date]['task_count'] += 1
        response_data[task_date]['tasks'].append({
            "activity_type_name": task['schedule_activity_type'],
            "description": task['schedule'],
            "isCompleted": is_completed
        })
        
        if is_completed:
            response_data[task_date]['completed'] += 1
        elif is_completed is False:
            response_data[task_date]['waiting'] += 1

    # Parse dates and prepare the final events list
    events = [{"Date": datetime.strptime(date, '%Y-%m-%d').strftime('%Y, %m, %d'), "count": data['task_count']} 
              for date, data in response_data.items()]

    response_data = {
        "completed_task": [datetime.strptime(date, '%Y-%m-%d').strftime('%Y, %m, %d') 
                           for date, data in response_data.items() if data['completed'] > 0],
        "waiting_task": [datetime.strptime(date, '%Y-%m-%d').strftime('%Y, %m, %d') 
                         for date, data in response_data.items() if data['waiting'] > 0],
        "events": events
    }

    return Response(response_data, status=status.HTTP_200_OK)
 
@api_view(['POST'])
def view_vehicle(request):
    if request.method == 'POST':
        vehicle_id = request.data.get('vehicle_id')
        user_id = request.data.get('user_id')

        if vehicle_id is None or user_id is None:
            return Response({'error': 'vehicle_id and user_id are required.'}, status=status.HTTP_400_BAD_REQUEST)

        try:
            # Fetch the vehicle based on the vehicle_id and user_id
            vehicle = MyVehicle.objects.get(id=vehicle_id, created_by=user_id)
            # Fetch associated documents for the vehicle
            documents = MyVehicleDocuments.objects.filter(vehicle=vehicle)

            # Serialize the vehicle and documents
            vehicle_serializer = MyVehicleSerializer(vehicle)
            documents_serializer = MyVehicleDocumentSerializer(documents, many=True)

            # Prepare the response data
            response_data = {
                'vehicle': vehicle_serializer.data,
                'documents': documents_serializer.data
            }

            return Response(response_data, status=status.HTTP_200_OK)
        
        except MyVehicle.DoesNotExist:
            return Response({'error': 'Vehicle not found or you do not have permission to access it.'}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
 
# @api_view(['GET'])
# def get_fuels_by_inventory_type(request, farmer_id):
#     try:
#         user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
#         language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
#     except UserLanguagePreference.DoesNotExist:
#         language_code = 'en'  # Fallback to 'en' if no preference is found

#     try:
#         # Extract 'inventory_type' from the query params
#         inventory_type_id = request.query_params.get('inventory_type', None)
        
#         if inventory_type_id is None:
#             return Response({"error": "inventory_type parameter is required."}, status=400)

#         try:
#             settings = GeneralSetting.objects.first()
#             date_format = convert_to_strftime_format(settings.date_format) if settings else '%d-%m-%Y'  # Fallback to default format
#         except Exception as e:
#             date_format = '%d-%m-%Y'

#         def format_date(date):
#             return date.strftime(date_format) if date else ""    

#         # Filter MyFuel based on the farmer_id and inventory_type_id
#         my_fuels = MyFuel.objects.filter(farmer_id=farmer_id, inventory_type_id=inventory_type_id,status__in=[0, 1])
        
#         # If no fuels found for the given filter, return an appropriate message
#         if not my_fuels:
#             return Response({"message": "No fuels found for the provided inventory type."}, status=404)

#         # Prepare the list of fuel data
#         fuel_list = []
#         for fuel in my_fuels:
#             fuel_list.append({
#                 "id": fuel.id, 
#                 "date_of_consumption": format_date(fuel.date_of_consumption),
#                 "vendor": {
#                     "id": fuel.vendor.id if fuel.vendor else None,
#                     # "name": fuel.vendor.name if fuel.vendor else None
#                     "name": fuel.vendor.get_translated_value("name", language_code) if fuel.vendor else None
#                 },
#                 "inventory_type": {
#                     "id": fuel.inventory_type.id if fuel.inventory_type else None,
#                     # "name": fuel.inventory_type.name if fuel.inventory_type else None
#                     "name": fuel.inventory_type.get_translated_value("name", language_code) if fuel.inventory_type else None
#                 },
#                 "inventory_category": {
#                     "id": fuel.inventory_category.id if fuel.inventory_category else None,
#                     # "name": fuel.inventory_category.name if fuel.inventory_category else None
#                     "name": fuel.inventory_category.get_translated_value("name", language_code) if fuel.inventory_category else None
#                 },
#                 "inventory_items": {
#                     "id": fuel.inventory_items.id if fuel.inventory_items else None,
#                     # "name": fuel.inventory_items.name if fuel.inventory_items else None
#                     "name": fuel.inventory_items.get_translated_value("name", language_code) if fuel.inventory_items else None
#                 },
#                 "quantity": str(fuel.quantity),  
#                 "purchase_amount": str(fuel.purchase_amount),  
#                 "language": {
#                     "default": "en"
#                 }
#             })
        
#         # Return the response with the filtered fuel list
#         return Response({"fuels": fuel_list})

#     except Exception as e:
#         return Response({"error": str(e)}, status=500)

@api_view(['GET'])
def get_fuels_by_inventory_type(request, farmer_id):
    try:
        try:
            user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
            language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
        except UserLanguagePreference.DoesNotExist:
            language_code = 'en'
        
        # Extract 'inventory_type' from the query params
        inventory_type_id = request.query_params.get('inventory_type', None)
        
        if inventory_type_id is None:
            return Response({"error": "inventory_type parameter is required."}, status=400)

        try:
            settings = GeneralSetting.objects.first()
            date_format = convert_to_strftime_format(settings.date_format) if settings else '%d-%m-%Y'  # Fallback to default format
        except Exception as e:
            date_format = '%d-%m-%Y'

        def format_date(date):
            return date.strftime(date_format) if date else ""    

        # Filter MyFuel based on the farmer_id and inventory_type_id
        my_fuels = MyFuel.objects.filter(farmer_id=farmer_id, inventory_type_id=inventory_type_id,status__in=[0, 1])
        
        # If no fuels found for the given filter, return an appropriate message
        if not my_fuels:
            return Response({"message": "No fuels found for the provided inventory type."}, status=404)

        # Prepare the list of fuel data
        fuel_list = []
        for fuel in my_fuels:
            fuel_list.append({
                "id": fuel.id, 
                "date_of_consumption": format_date(fuel.date_of_consumption),
                "vendor": {
                    "id": fuel.vendor.id if fuel.vendor else None,
                    "name": fuel.vendor.get_translated_value("name", language_code) if fuel.vendor else None
                },
                "inventory_type": {
                    "id": fuel.inventory_type.id if fuel.inventory_type else None,
                    "name": fuel.inventory_type.get_translated_value("name", language_code) if fuel.inventory_type else None
                },
                "inventory_category": {
                    "id": fuel.inventory_category.id if fuel.inventory_category else None,
                    "name": fuel.inventory_category.get_translated_value("name", language_code) if fuel.inventory_category else None
                },
                "inventory_items": {
                    "id": fuel.inventory_items.id if fuel.inventory_items else None,
                    "name": fuel.inventory_items.get_translated_value("name", language_code) if fuel.inventory_items else None
                },
                "quantity": str(fuel.quantity),  
                "purchase_amount": str(fuel.purchase_amount),  
                "language": {
                    "default": "en"
                }
            })
        
        # Return the response with the filtered fuel list
        return Response({"fuels": fuel_list})

    except Exception as e:
        return Response({"error": str(e)}, status=500)


@api_view(['GET'])
def get_fuels_by_inventory_items(request, farmer_id):
    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'

    try:
        # Extract 'inventory_type' and 'inventory_items' from the query params
        inventory_type_id = request.query_params.get('inventory_type', None)
        inventory_items_id = request.query_params.get('inventory_items', None)

        try:
            settings = GeneralSetting.objects.first()
            date_format = convert_to_strftime_format(settings.date_format) if settings else '%d-%m-%Y'  # Fallback to default format
        except Exception as e:
            date_format = '%d-%m-%Y'

        def format_date(date):
            return date.strftime(date_format) if date else ""  
        
        if inventory_type_id is None:
            return Response({"error": "inventory_type parameter is required."}, status=400)

        # Build the filters for MyFuel
        filters = {
            'farmer_id': farmer_id,
            'inventory_type_id': inventory_type_id,
            'status__in': [0, 1]  # Assuming 0 indicates active fuels
        }
        
        # If 'inventory_items' is provided, add it to the filter
        if inventory_items_id:
            filters['inventory_items_id'] = inventory_items_id
        
        # Apply the filters to get the fuels
        my_fuels = MyFuel.objects.filter(**filters)
        
        # If no fuels found for the given filter, return an appropriate message
        if not my_fuels:
            return Response({"message": "No fuels found for the provided inventory type and inventory items."}, status=404)

        # Prepare the list of fuel data
        fuel_list = []
        for fuel in my_fuels:
            fuel_data = {
                "id": fuel.id, 
                "date_of_consumption": format_date(fuel.date_of_consumption),
                "vendor": {
                    "id": fuel.vendor.id if fuel.vendor else None,
                    # "name": fuel.vendor.name if fuel.vendor else None
                    "name": fuel.vendor.get_translated_value("name", language_code) if fuel.vendor else None
                },
                "inventory_type": {
                    "id": fuel.inventory_type.id if fuel.inventory_type else None,
                    # "name": fuel.inventory_type.name if fuel.inventory_type else None
                    "name": fuel.inventory_type.get_translated_value("name", language_code) if fuel.inventory_type else None
                },
                "inventory_category": {
                    "id": fuel.inventory_category.id if fuel.inventory_category else None,
                    # "name": fuel.inventory_category.name if fuel.inventory_category else None
                    "name": fuel.inventory_category.get_translated_value("name", language_code) if fuel.inventory_category else None
                },
                "inventory_items": {
                    "id": fuel.inventory_items.id if fuel.inventory_items else None,
                    # "name": fuel.inventory_items.name if fuel.inventory_items else None
                    "name": fuel.inventory_items.get_translated_value("name", language_code) if fuel.inventory_items else None
                },
                "quantity": str(fuel.quantity),  
                "purchase_amount": str(fuel.purchase_amount),
                "language": {"default": "en"}
            }
            
            # Add additional inventory items details if needed
            if fuel.inventory_items:
                fuel_data["inventory_items_details"] = {
                    "id": fuel.inventory_items.id if fuel.inventory_items else None,
                    "name": fuel.inventory_items.get_translated_value("name", language_code) if fuel.inventory_items else None,
                    "description": fuel.inventory_items.get_translated_value("description", language_code) if fuel.inventory_items else None
                    # "name": fuel.inventory_items.name if fuel.inventory_items else None,
                    # "description": fuel.inventory_items.description if fuel.inventory_items else None
                }

            fuel_list.append(fuel_data)
        
        # Return the response with the filtered fuel list
        return Response({"fuels": fuel_list})

    except Exception as e:
        return Response({"error": str(e)}, status=500)

# @api_view(['GET'])
# def get_vehicles_by_inventory_type(request, farmer_id):
#     try:
#         # Extract 'inventory_type' from the request query parameters
#         inventory_type_id = request.query_params.get('inventory_type', None)
        
#         # Check if 'inventory_type' is provided in the query params
#         if inventory_type_id is None:
#             return Response({"error": "inventory_type parameter is required."}, status=400)

#         # Filter MyVehicle based on the farmer_id and inventory_type_id
#         my_vehicles = MyVehicle.objects.filter(farmer_id=farmer_id, inventory_type_id=inventory_type_id,  status__in=[0, 1])

#         try:
#             settings = GeneralSetting.objects.first()
#             date_format = convert_to_strftime_format(settings.date_format) if settings else '%d-%m-%Y'  # Fallback to default format
#         except Exception as e:
#             date_format = '%d-%m-%Y'

#         def format_date(date):
#             return date.strftime(date_format) if date else ""   
        
#         # If no vehicles found for the given filter, return an appropriate message
#         if not my_vehicles:
#             return Response({"message": "No vehicles found for the provided inventory type."}, status=404)

#         # Prepare the list of vehicle data
#         vehicle_list = []
#         for vehicle in my_vehicles:
#             vehicle_list.append({
#                 "id": vehicle.id,  
#                 "fuel_capacity": str(vehicle.fuel_capacity),  # Convert Decimal to string for JSON compatibility
#                 "date_of_consumption": vehicle.date_of_consumption,
#                 "vendor": {
#                     "id": vehicle.vendor.id if vehicle.vendor else None,
#                     "name": vehicle.vendor.name if vehicle.vendor else None
#                 },
#                 "inventory_type": {
#                     "id": vehicle.inventory_type.id if vehicle.inventory_type else None,
#                     "name": vehicle.inventory_type.name if vehicle.inventory_type else None
#                 },
#                 "inventory_category": {
#                     "id": vehicle.inventory_category.id if vehicle.inventory_category else None,
#                     "name": vehicle.inventory_category.name if vehicle.inventory_category else None
#                 },
#                 "inventory_items": {
#                     "id": vehicle.inventory_items.id if vehicle.inventory_items else None,
#                     "name": vehicle.inventory_items.name if vehicle.inventory_items else None
#                 },
#                 "date_of_consumption": format_date(vehicle.date_of_consumption),
#                 "language": {
#                     "default": "en"
#                 }
#             })
        
#         # Return the response with the filtered vehicle list
#         return Response({"vehicles": vehicle_list})

#     except Exception as e:
#         return Response({"error": str(e)}, status=500)

@api_view(['GET'])
def get_vehicles_by_inventory_type(request, farmer_id):
    try:
        try:
            user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
            language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
        except UserLanguagePreference.DoesNotExist:
            language_code = 'en'

        # Extract 'inventory_type' from the request query parameters
        inventory_type_id = request.query_params.get('inventory_type', None)
        
        # Check if 'inventory_type' is provided in the query params
        if inventory_type_id is None:
            return Response({"error": "inventory_type parameter is required."}, status=400)

        # Filter MyVehicle based on the farmer_id and inventory_type_id
        my_vehicles = MyVehicle.objects.filter(farmer_id=farmer_id, inventory_type_id=inventory_type_id,  status__in=[0, 1])

        try:
            settings = GeneralSetting.objects.first()
            date_format = convert_to_strftime_format(settings.date_format) if settings else '%d-%m-%Y'  # Fallback to default format
        except Exception as e:
            date_format = '%d-%m-%Y'

        def format_date(date):
            return date.strftime(date_format) if date else ""   
        
        # If no vehicles found for the given filter, return an appropriate message
        if not my_vehicles:
            return Response({"message": "No vehicles found for the provided inventory type."}, status=404)

        # Prepare the list of vehicle data
        vehicle_list = []
        for vehicle in my_vehicles:
            vehicle_list.append({
                "id": vehicle.id,  
                "fuel_capacity": str(vehicle.fuel_capacity),  # Convert Decimal to string for JSON compatibility
                "date_of_consumption": vehicle.date_of_consumption,
                "vendor": {
                    "id": vehicle.vendor.id if vehicle.vendor else None,
                    "name": vehicle.vendor.get_translated_value("name", language_code) if vehicle.vendor else None
                },
                "inventory_type": {
                    "id": vehicle.inventory_type.id if vehicle.inventory_type else None,
                    "name": vehicle.inventory_type.get_translated_value("name", language_code) if vehicle.inventory_type else None
                },
                "inventory_category": { 
                    "id": vehicle.inventory_category.id if vehicle.inventory_category else None,
                    "name": vehicle.inventory_category.get_translated_value("name", language_code) if vehicle.inventory_category else None
                },
                "inventory_items": { 
                    "id": vehicle.inventory_items.id if vehicle.inventory_items else None,
                    "name": vehicle.inventory_items.get_translated_value("name", language_code) if vehicle.inventory_items else None
                },
                "date_of_consumption": format_date(vehicle.date_of_consumption),
                "register_no":vehicle.register_number,
                "language": {
                    "default": "en"
                }
            })
        
        # Return the response with the filtered vehicle list
        return Response({"vehicles": vehicle_list})

    except Exception as e:
        return Response({"error": str(e)}, status=500)




@api_view(['GET'])
def get_vehicles_by_inventory_items(request, farmer_id):
    try:
        # Extract 'inventory_type' and 'inventory_items' from the request query parameters
        inventory_type_id = request.query_params.get('inventory_type', None)
        inventory_items_id = request.query_params.get('inventory_items', None)
        
        # Check if 'inventory_type' is provided in the query params
        if inventory_type_id is None:
            return Response({"error": "inventory_type parameter is required."}, status=400)

        # Initialize the filter for MyVehicle queryset
        filter_params = {'farmer_id': farmer_id, 'inventory_type_id': inventory_type_id, 'status__in':[0, 1]}
        
        # If 'inventory_items' is provided, include it in the filter
        if inventory_items_id is not None:
            filter_params['inventory_items_id'] = inventory_items_id
        
        # Filter MyVehicle based on the provided parameters
        my_vehicles = MyVehicle.objects.filter(**filter_params)
        
        try:
            settings = GeneralSetting.objects.first()
            date_format = convert_to_strftime_format(settings.date_format) if settings else '%d-%m-%Y'  # Fallback to default format
        except Exception as e:
            date_format = '%d-%m-%Y'

        def format_date(date):
            return date.strftime(date_format) if date else ""    
        
        # If no vehicles found for the given filters, return an appropriate message
        if not my_vehicles:
            return Response({"message": "No vehicles found for the provided filters."}, status=404)

        # Prepare the list of vehicle data
        vehicle_list = []
        for vehicle in my_vehicles:
            vehicle_list.append({
                "id": vehicle.id,  
                "fuel_capacity": str(vehicle.fuel_capacity),  # Convert Decimal to string for JSON compatibility
                "date_of_consumption": vehicle.date_of_consumption,
                "vendor": {
                    "id": vehicle.vendor.id if vehicle.vendor else None,
                    "name": vehicle.vendor.name if vehicle.vendor else None
                },
                "inventory_type": {
                    "id": vehicle.inventory_type.id if vehicle.inventory_type else None,
                    "name": vehicle.inventory_type.name if vehicle.inventory_type else None
                },
                "inventory_category": {
                    "id": vehicle.inventory_category.id if vehicle.inventory_category else None,
                    "name": vehicle.inventory_category.name if vehicle.inventory_category else None
                },
                "inventory_items": {
                    "id": vehicle.inventory_items.id if vehicle.inventory_items else None,
                    "name": vehicle.inventory_items.name if vehicle.inventory_items else None
                },
                "date_of_consumption": format_date(vehicle.date_of_consumption),
                "language": {
                    "default": "en"
                }
            })
        
        # Return the response with the filtered vehicle list
        return Response({"vehicles": vehicle_list})

    except Exception as e:
        return Response({"error": str(e)}, status=500)

# @api_view(['GET'])
# def get_machinery_by_inventory_type(request, farmer_id):

#     try:
#         user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
#         language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
#     except UserLanguagePreference.DoesNotExist:
#         language_code = 'en'

#     try: 
#         # Retrieve 'inventory_type' from query parameters
#         inventory_type_id = request.query_params.get('inventory_type', None)
        
#         # Check if 'inventory_type' is provided in the query params
#         if inventory_type_id is None:
#             return Response({"error": "inventory_type parameter is required."}, status=400)


#         try:
#             settings = GeneralSetting.objects.first()
#             date_format = convert_to_strftime_format(settings.date_format) if settings else '%d-%m-%Y'  # Fallback to default format
#         except Exception as e:
#             date_format = '%d-%m-%Y'

#         def format_date(date):
#             return date.strftime(date_format) if date else ""    
 
#         # Filter MyMachinery based on farmer_id and inventory_type_id
#         my_machinery = MyMachinery.objects.filter(farmer_id=farmer_id, inventory_type_id=inventory_type_id, status__in=[0, 1])
         
#         # If no machinery found for the given filters, return a message
#         if not my_machinery:
#             return Response({"message": "No machinery found for the provided inventory type."}, status=404)
 
#         # Prepare the machinery data to return
#         machinery_list = []
#         for machinery in my_machinery:
#             machinery_list.append({
#                 "id": machinery.id, 
#                 "vendor": {
#                     "id": machinery.vendor.id if machinery.vendor else None,
#                     # "name": machinery.vendor.name if machinery.vendor else None
#                     "name": machinery.vendor.get_translated_value("name", language_code) if machinery.vendor else None
#                 },
#                 "inventory_type": {
#                     "id": machinery.inventory_type.id if machinery.inventory_type else None,
#                     # "name": machinery.inventory_type.name if machinery.inventory_type else None
#                     "name": machinery.inventory_type.get_translated_value("name", language_code) if machinery.inventory_type else None
#                 },
#                 "inventory_category": {
#                     "id": machinery.inventory_category.id if machinery.inventory_category else None,
#                     # "name": machinery.inventory_category.name if machinery.inventory_category else None
#                     "name": machinery.inventory_category.get_translated_value("name", language_code) if machinery.inventory_category else None
#                 },
#                 "inventory_items": {
#                     "id": machinery.inventory_items.id if machinery.inventory_items else None,
#                     # "name": machinery.inventory_items.name if machinery.inventory_items else None
#                     "name": machinery.inventory_items.get_translated_value("name", language_code) if machinery.inventory_items else None
#                 },
#                 "machinery_type": machinery.machinery_type,
#                 "fuel_capacity": str(machinery.fuel_capacity),  
#                 "purchase_amount": str(machinery.purchase_amount),   
#                 "date_of_consumption": format_date(machinery.date_of_consumption),
#                 "language": {
#                     "default": "en"
#                 }
#             })
         
#         # Return the response with the filtered machinery data
#         return Response({"machinery": machinery_list})

#     except Exception as e:
#         # Handle any exceptions that occur
#         return Response({"error": str(e)}, status=500)

@api_view(['GET'])
def get_machinery_by_inventory_type(request, farmer_id):
    try: 
        try:
            user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
            language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
        except UserLanguagePreference.DoesNotExist:
            language_code = 'en'

        # Retrieve 'inventory_type' from query parameters
        inventory_type_id = request.query_params.get('inventory_type', None)
        
        # Check if 'inventory_type' is provided in the query params
        if inventory_type_id is None:
            return Response({"error": "inventory_type parameter is required."}, status=400)


        try:
            settings = GeneralSetting.objects.first()
            date_format = convert_to_strftime_format(settings.date_format) if settings else '%d-%m-%Y'  # Fallback to default format
        except Exception as e:
            date_format = '%d-%m-%Y'

        def format_date(date):
            return date.strftime(date_format) if date else ""    
 
        # Filter MyMachinery based on farmer_id and inventory_type_id
        my_machinery = MyMachinery.objects.filter(farmer_id=farmer_id, inventory_type_id=inventory_type_id, status__in=[0, 1])
         
        # If no machinery found for the given filters, return a message
        if not my_machinery:
            return Response({"message": "No machinery found for the provided inventory type."}, status=404)
 
        # Prepare the machinery data to return
        machinery_list = []
        for machinery in my_machinery:
            machinery_list.append({
                "id": machinery.id, 
                "vendor": {
                    "id": machinery.vendor.id if machinery.vendor else None,
                    "name": machinery.vendor.get_translated_value("name", language_code) if machinery.vendor else None
                },
                "inventory_type": {
                    "id": machinery.inventory_type.id if machinery.inventory_type else None,
                    "name": machinery.inventory_type.get_translated_value("name", language_code) if machinery.inventory_type else None
                },
                "inventory_category": {
                    "id": machinery.inventory_category.id if machinery.inventory_category else None,
                    "name": machinery.inventory_category.get_translated_value("name", language_code) if machinery.inventory_category else None
                },
                "inventory_items": {
                    "id": machinery.inventory_items.id if machinery.inventory_items else None,
                    "name": machinery.inventory_items.get_translated_value("name", language_code) if machinery.inventory_items else None
                },
                "machinery_type": machinery.machinery_type,
                "fuel_capacity": str(machinery.fuel_capacity),  
                "purchase_amount": str(machinery.purchase_amount),   
                "date_of_consumption": format_date(machinery.date_of_consumption),
                "language": {
                    "default": "en"
                }
            })
         
        # Return the response with the filtered machinery data
        return Response({"machinery": machinery_list})

    except Exception as e:
        # Handle any exceptions that occur
        return Response({"error": str(e)}, status=500)


@api_view(['GET'])
def get_machinery_by_inventory_items(request, farmer_id):
    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'

    try: 
        # Retrieve 'inventory_type' and 'inventory_items' from query parameters
        inventory_type_id = request.query_params.get('inventory_type', None)
        inventory_items_id = request.query_params.get('inventory_items', None)
        
        # Check if 'inventory_type' is provided in the query params
        if inventory_type_id is None:
            return Response({"error": "inventory_type parameter is required."}, status=400)

        try:
            settings = GeneralSetting.objects.first()
            date_format = convert_to_strftime_format(settings.date_format) if settings else '%d-%m-%Y'  # Fallback to default format
        except Exception as e:
            date_format = '%d-%m-%Y'

        def format_date(date):
            return date.strftime(date_format) if date else ""  
        
        # If 'inventory_items' is provided, filter by that too
        if inventory_items_id:
            my_machinery = MyMachinery.objects.filter(
                farmer_id=farmer_id, 
                inventory_type_id=inventory_type_id, 
                inventory_items_id=inventory_items_id,  # Filter by inventory_items
                status__in=[0, 1]
            )
        else:
            my_machinery = MyMachinery.objects.filter(
                farmer_id=farmer_id, 
                inventory_type_id=inventory_type_id, 
                status__in=[0, 1]
            )

        # If no machinery found for the given filters, return a message
        if not my_machinery:
            return Response({"message": "No machinery found for the provided filters."}, status=404)
        
        # Prepare the machinery data to return
        machinery_list = []
        for machinery in my_machinery:
            machinery_list.append({
                "id": machinery.id, 
                "vendor": {
                    "id": machinery.vendor.id if machinery.vendor else None,
                    # "name": machinery.vendor.name if machinery.vendor else None
                    "name": machinery.vendor.get_translated_value("name", language_code) if machinery.vendor else None
                },
                "inventory_type": {
                    "id": machinery.inventory_type.id if machinery.inventory_type else None,
                    # "name": machinery.inventory_type.name if machinery.inventory_type else None
                    "name": machinery.inventory_type.get_translated_value("name", language_code) if machinery.inventory_type else None
                },
                "inventory_category": {
                    "id": machinery.inventory_category.id if machinery.inventory_category else None,
                    # "name": machinery.inventory_category.name if machinery.inventory_category else None
                    "name": machinery.inventory_category.get_translated_value("name", language_code) if machinery.inventory_category else None
                },
                "inventory_items": {
                    "id": machinery.inventory_items.id if machinery.inventory_items else None,
                    # "name": machinery.inventory_items.name if machinery.inventory_items else None
                    "name": machinery.inventory_items.get_translated_value("name", language_code) if machinery.inventory_items else None
                },
                "machinery_type": machinery.machinery_type,
                "fuel_capacity": str(machinery.fuel_capacity),  
                "purchase_amount": str(machinery.purchase_amount),   
                "date_of_consumption": format_date(machinery.date_of_consumption),
                "language": {
                    "default": "en"
                }
            })
        
        # Return the response with the filtered machinery data
        return Response({"machinery": machinery_list})

    except Exception as e:
        # Handle any exceptions that occur
        return Response({"error": str(e)}, status=500)
 
# @api_view(['GET'])
# def get_tools_by_inventory_type(request, farmer_id):
#     try:
#         # Extract 'inventory_type' from the query parameters
#         inventory_type_id = request.query_params.get('inventory_type', None)
        
#         # Check if 'inventory_type' is provided in the query params
#         if inventory_type_id is None:
#             return Response({"error": "inventory_type parameter is required."}, status=400)

#         # Filter MyTools based on the farmer_id and inventory_type_id
#         my_tools = MyTools.objects.filter(farmer_id=farmer_id, inventory_type_id=inventory_type_id, status__in=[0, 1])
        
#         # If no tools found for the given filter, return an appropriate message
#         if not my_tools:
#             return Response({"message": "No tools found for the provided inventory type."}, status=404)

#         try:
#             settings = GeneralSetting.objects.first()
#             date_format = convert_to_strftime_format(settings.date_format) if settings else '%d-%m-%Y'  # Fallback to default format
#         except Exception as e:
#             date_format = '%d-%m-%Y'

#         def format_date(date):
#             return date.strftime(date_format) if date else ""    

#         # Prepare the list of tools data with id and name for all relevant fields
#         tools_list = []
#         for tool in my_tools:
#             tools_list.append({
#                 "id": tool.id, 
#                 "vendor": {
#                     "id": tool.vendor.id if tool.vendor else None,
#                     "name": tool.vendor.name if tool.vendor else None
#                 },
#                 "inventory_type": {
#                     "id": tool.inventory_type.id if tool.inventory_type else None,
#                     "name": tool.inventory_type.name if tool.inventory_type else None
#                 },
#                 "inventory_category": {
#                     "id": tool.inventory_category.id if tool.inventory_category else None,
#                     "name": tool.inventory_category.name if tool.inventory_category else None
#                 },
#                 "inventory_items": {
#                     "id": tool.inventory_items.id if tool.inventory_items else None,
#                     "name": tool.inventory_items.name if tool.inventory_items else None
#                 },
#                 "quantity": str(tool.quantity),   
#                 "purchase_amount": str(tool.purchase_amount), 
#                 "date_of_consumption": format_date(tool.date_of_consumption),
#                 "language": {
#                     "default": "en"
#                 }
#             })
        
#         # Return the response with the filtered tools list
#         return Response({"tools": tools_list})

#     except Exception as e:
#         return Response({"error": str(e)}, status=500)


@api_view(['GET'])
def get_tools_by_inventory_type(request, farmer_id):
    try:
        try:
            user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
            language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
        except UserLanguagePreference.DoesNotExist:
            language_code = 'en'

        # Extract 'inventory_type' from the query parameters
        inventory_type_id = request.query_params.get('inventory_type', None)
        
        # Check if 'inventory_type' is provided in the query params
        if inventory_type_id is None:
            return Response({"error": "inventory_type parameter is required."}, status=400)

        # Filter MyTools based on the farmer_id and inventory_type_id
        my_tools = MyTools.objects.filter(farmer_id=farmer_id, inventory_type_id=inventory_type_id, status__in=[0, 1])
        
        # If no tools found for the given filter, return an appropriate messagesd
        if not my_tools:
            return Response({"message": "No tools found for the provided inventory type."}, status=404)

        try:
            settings = GeneralSetting.objects.first()
            date_format = convert_to_strftime_format(settings.date_format) if settings else '%d-%m-%Y'  # Fallback to default format
        except Exception as e:
            date_format = '%d-%m-%Y'

        def format_date(date):
            return date.strftime(date_format) if date else ""    

        # Prepare the list of tools data with id and name for all relevant fields
        tools_list = []
        for tool in my_tools:
            tools_list.append({
                "id": tool.id, 
                "vendor": {
                    "id": tool.vendor.id if tool.vendor else None,
                    "name": tool.vendor.get_translated_value("name", language_code) if tool.vendor else None
                },
                "inventory_type": {
                    "id": tool.inventory_type.id if tool.inventory_type else None,
                    "name": tool.inventory_type.get_translated_value("name", language_code) if tool.inventory_type else None
                },
                "inventory_category": {
                    "id": tool.inventory_category.id if tool.inventory_category else None,
                    "name": tool.inventory_category.get_translated_value("name", language_code) if tool.inventory_category else None
                },
                "inventory_items": {
                    "id": tool.inventory_items.id if tool.inventory_items else None,
                    "name": tool.inventory_items.get_translated_value("name", language_code) if tool.inventory_items else None
                },
                "quantity": str(tool.quantity),   
                "purchase_amount": str(tool.purchase_amount), 
                "date_of_consumption": format_date(tool.date_of_consumption),
                "language": {
                    "default": "en"
                }
            })
        
        # Return the response with the filtered tools list
        return Response({"tools": tools_list})

    except Exception as e:
        return Response({"error": str(e)}, status=500)

@api_view(['GET'])
def get_tools_by_inventory_items(request, farmer_id):
    try:
        # Extract 'inventory_type' and 'inventory_items' from the query parameters
        inventory_type_id = request.query_params.get('inventory_type', None)
        inventory_items_id = request.query_params.get('inventory_items', None)
        
        # Check if 'inventory_type' is provided in the query params
        if inventory_type_id is None:
            return Response({"error": "inventory_type parameter is required."}, status=400)
        
        # Filter MyTools based on the farmer_id and inventory_type_id, and optionally inventory_items_id
        filters = {'farmer_id': farmer_id, 'inventory_type_id': inventory_type_id, 'status__in': [0,1]}
        
        # If 'inventory_items' is provided, add it to the filters
        if inventory_items_id is not None:
            filters['inventory_items_id'] = inventory_items_id
        
        my_tools = MyTools.objects.filter(**filters)
        
        # If no tools found for the given filter, return an appropriate message
        if not my_tools:
            return Response({"message": "No tools found for the provided inventory type and/or inventory items."}, status=404)
        
        try:
            settings = GeneralSetting.objects.first()
            date_format = convert_to_strftime_format(settings.date_format) if settings else '%d-%m-%Y'  # Fallback to default format
        except Exception as e:
            date_format = '%d-%m-%Y'

        def format_date(date):
            return date.strftime(date_format) if date else ""    

        # Prepare the list of tools data with id and name for all relevant fields
        tools_list = []
        for tool in my_tools:
            tools_list.append({
                "id": tool.id, 
                "vendor": {
                    "id": tool.vendor.id if tool.vendor else None,
                    "name": tool.vendor.name if tool.vendor else None
                },
                "inventory_type": {
                    "id": tool.inventory_type.id if tool.inventory_type else None,
                    "name": tool.inventory_type.name if tool.inventory_type else None
                },
                "inventory_category": {
                    "id": tool.inventory_category.id if tool.inventory_category else None,
                    "name": tool.inventory_category.name if tool.inventory_category else None
                },
                "inventory_items": {
                    "id": tool.inventory_items.id if tool.inventory_items else None,
                    "name": tool.inventory_items.name if tool.inventory_items else None
                },
                "quantity": str(tool.quantity),   
                "purchase_amount": str(tool.purchase_amount), 
                "date_of_consumption": format_date(tool.date_of_consumption),
                "language": {
                    "default": "en"
                }
            })
        
        # Return the response with the filtered tools list
        return Response({"tools": tools_list})

    except Exception as e:
        return Response({"error": str(e)}, status=500)
 
# @api_view(['GET'])
# def get_pesticides_by_inventory_type(request, farmer_id):
#     try:
#         # Extract 'inventory_type' from the query parameters
#         inventory_type_id = request.query_params.get('inventory_type', None)
        
#         # Check if 'inventory_type' is provided in the query params
#         if inventory_type_id is None:
#             return Response({"error": "inventory_type parameter is required."}, status=400)

#         # Filter MyPesticides based on the farmer_id and inventory_type_id
#         my_pesticides = MyPesticides.objects.filter(farmer_id=farmer_id, inventory_type_id=inventory_type_id, status__in=[0, 1])
        
#         # If no pesticides found for the given filter, return an appropriate message
#         if not my_pesticides:
#             return Response({"message": "No pesticides found for the provided inventory type."}, status=404)

#         try:
#             settings = GeneralSetting.objects.first()
#             date_format = convert_to_strftime_format(settings.date_format) if settings else '%d-%m-%Y'  # Fallback to default format
#         except Exception as e:
#             date_format = '%d-%m-%Y'

#         def format_date(date):
#             return date.strftime(date_format) if date else ""    

#         # Prepare the list of pesticides data
#         pesticides_list = []
#         for pesticide in my_pesticides:
#             pesticides_list.append({
#                 "id": pesticide.id,
#                 "vendor": {
#                     "id": pesticide.vendor.id if pesticide.vendor else None,
#                     "name": pesticide.vendor.name if pesticide.vendor else None
#                 },
#                 "inventory_type": {
#                     "id": pesticide.inventory_type.id if pesticide.inventory_type else None,
#                     "name": pesticide.inventory_type.name if pesticide.inventory_type else None
#                 },
#                 "inventory_category": {
#                     "id": pesticide.inventory_category.id if pesticide.inventory_category else None,
#                     "name": pesticide.inventory_category.name if pesticide.inventory_category else None
#                 },
#                 "inventory_items": {
#                     "id": pesticide.inventory_items.id if pesticide.inventory_items else None,
#                     "name": pesticide.inventory_items.name if pesticide.inventory_items else None
#                 },
#                 "quantity": str(pesticide.quantity),  # Convert Decimal to string for JSON compatibility
#                 "purchase_amount": str(pesticide.purchase_amount),
#                 "date_of_consumption": format_date(pesticide.date_of_consumption),
#                 "language": {
#                     "default": "en"
#                 }
#             })
        
#         # Return the response with the filtered pesticides list
#         return Response({"pesticides": pesticides_list})

#     except Exception as e:
#         return Response({"error": str(e)}, status=500)

@api_view(['GET'])
def get_pesticides_by_inventory_type(request, farmer_id):
    try:
        # Extract 'inventory_type' from the query parameters
        inventory_type_id = request.query_params.get('inventory_type', None)
        
        try:
            user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
            language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
        except UserLanguagePreference.DoesNotExist:
            language_code = 'en'

        # Check if 'inventory_type' is provided in the query params
        if inventory_type_id is None:
            return Response({"error": "inventory_type parameter is required."}, status=400)

        # Filter MyPesticides based on the farmer_id and inventory_type_id
        my_pesticides = MyPesticides.objects.filter(farmer_id=farmer_id, inventory_type_id=inventory_type_id, status__in=[0, 1])
        
        # If no pesticides found for the given filter, return an appropriate message
        if not my_pesticides:
            return Response({"message": "No pesticides found for the provided inventory type."}, status=404)

        try:
            settings = GeneralSetting.objects.first()
            date_format = convert_to_strftime_format(settings.date_format) if settings else '%d-%m-%Y'  # Fallback to default format
        except Exception as e:
            date_format = '%d-%m-%Y'

        def format_date(date):
            return date.strftime(date_format) if date else ""    

        # Prepare the list of pesticides data
        pesticides_list = []
        for pesticide in my_pesticides:
            pesticides_list.append({
                "id": pesticide.id,
                "vendor": {
                    "id": pesticide.vendor.id if pesticide.vendor else None,
                    "name": pesticide.vendor.get_translated_value("name", language_code) if pesticide.vendor else None
                },
                "inventory_type": {
                    "id": pesticide.inventory_type.id if pesticide.inventory_type else None,
                    "name": pesticide.inventory_type.get_translated_value("name", language_code) if pesticide.inventory_type else None
                },
                "inventory_category": {
                    "id": pesticide.inventory_category.id if pesticide.inventory_category else None,
                    "name": pesticide.inventory_category.get_translated_value("name", language_code) if pesticide.inventory_category else None
                },
                "inventory_items": {
                    "id": pesticide.inventory_items.id if pesticide.inventory_items else None,
                    "name": pesticide.inventory_items.get_translated_value("name", language_code) if pesticide.inventory_items else None
                },
                "quantity": str(pesticide.quantity),  # Convert Decimal to string for JSON compatibility
                "purchase_amount": str(pesticide.purchase_amount),
                "date_of_consumption": format_date(pesticide.date_of_consumption),
                "language": {
                    "default": "en"
                }
            })
        
        # Return the response with the filtered pesticides list
        return Response({"pesticides": pesticides_list})

    except Exception as e:
        return Response({"error": str(e)}, status=500)




@api_view(['GET'])
def get_pesticides_by_inventory_items(request, farmer_id):
    try:
        # Extract 'inventory_type' and 'inventory_items' from the query parameters
        inventory_type_id = request.query_params.get('inventory_type', None)
        inventory_items_id = request.query_params.get('inventory_items', None)
        
        # Check if 'inventory_type' is provided in the query params
        if inventory_type_id is None:
            return Response({"error": "inventory_type parameter is required."}, status=400)
        
        # If inventory_items is provided, ensure it is filtered
        if inventory_items_id:
            my_pesticides = MyPesticides.objects.filter(
                farmer_id=farmer_id, 
                inventory_type_id=inventory_type_id, 
                inventory_items_id=inventory_items_id,  # Apply filter for inventory_items
                status__in=[0, 1]
            )
        else:
            # If inventory_items is not provided, just filter by inventory_type
            my_pesticides = MyPesticides.objects.filter(
                farmer_id=farmer_id, 
                inventory_type_id=inventory_type_id, 
                status__in=[0, 1]
            )

        try:
            settings = GeneralSetting.objects.first()
            date_format = convert_to_strftime_format(settings.date_format) if settings else '%d-%m-%Y'  # Fallback to default format
        except Exception as e:
            date_format = '%d-%m-%Y'

        def format_date(date):
            return date.strftime(date_format) if date else "" 
        
        # If no pesticides found for the given filter, return an appropriate message
        if not my_pesticides:
            return Response({"message": "No pesticides found for the provided filters."}, status=404)

        # Prepare the list of pesticides data
        pesticides_list = []
        for pesticide in my_pesticides:
            pesticides_list.append({
                "id": pesticide.id,
                "vendor": {
                    "id": pesticide.vendor.id if pesticide.vendor else None,
                    "name": pesticide.vendor.name if pesticide.vendor else None
                },
                "inventory_type": {
                    "id": pesticide.inventory_type.id if pesticide.inventory_type else None,
                    "name": pesticide.inventory_type.name if pesticide.inventory_type else None
                },
                "inventory_category": {
                    "id": pesticide.inventory_category.id if pesticide.inventory_category else None,
                    "name": pesticide.inventory_category.name if pesticide.inventory_category else None
                },
                "inventory_items": {
                    "id": pesticide.inventory_items.id if pesticide.inventory_items else None,
                    "name": pesticide.inventory_items.name if pesticide.inventory_items else None
                },
                "quantity": str(pesticide.quantity),  # Convert Decimal to string for JSON compatibility
                "purchase_amount": str(pesticide.purchase_amount),
                "date_of_consumption": format_date(pesticide.date_of_consumption),
                "language": {
                    "default": "en"
                }
            })
        
        # Return the response with the filtered pesticides list
        return Response({"pesticides": pesticides_list})

    except Exception as e:
        return Response({"error": str(e)}, status=500)

# @api_view(['GET'])
# def get_seeds_by_inventory_type(request, farmer_id):
#     try:
#         # Extract 'inventory_type' from the query parameters
#         inventory_type_id = request.query_params.get('inventory_type', None)
        
#         # Check if 'inventory_type' is provided in the query params
#         if inventory_type_id is None:
#             return Response({"error": "inventory_type parameter is required."}, status=400)

#         # Filter MySeeds based on the farmer_id and inventory_type_id
#         my_seeds = MySeeds.objects.filter(farmer_id=farmer_id, inventory_type_id=inventory_type_id, status__in=[0, 1])
         
#         # If no seeds found for the given filter, return an appropriate message
#         if not my_seeds:
#             return Response({"message": "No seeds found for the provided inventory type."}, status=404)

#         try:
#             settings = GeneralSetting.objects.first()
#             date_format = convert_to_strftime_format(settings.date_format) if settings else '%d-%m-%Y'  # Fallback to default format
#         except Exception as e:
#             date_format = '%d-%m-%Y'

#         def format_date(date):
#             return date.strftime(date_format) if date else ""  

#         # Prepare the list of seed data
#         seeds_list = []
#         for seed in my_seeds:
#             seeds_list.append({
#                 "id": seed.id, 
#                 "vendor": {
#                     "id": seed.vendor.id if seed.vendor else None,
#                     "name": seed.vendor.name if seed.vendor else None
#                 },
#                 "inventory_type": {
#                     "id": seed.inventory_type.id if seed.inventory_type else None,
#                     "name": seed.inventory_type.name if seed.inventory_type else None
#                 },
#                 "inventory_category": {
#                     "id": seed.inventory_category.id if seed.inventory_category else None,
#                     "name": seed.inventory_category.name if seed.inventory_category else None
#                 },
#                 "inventory_items": {
#                     "id": seed.inventory_items.id if seed.inventory_items else None,
#                     "name": seed.inventory_items.name if seed.inventory_items else None
#                 },
#                 "quantity": str(seed.quantity),   
#                 "purchase_amount": str(seed.purchase_amount),  
#                 "date_of_consumption": format_date(seed.date_of_consumption),
#                 "language": {
#                     "default": "en"
#                 }
#             })
         
#         # Return the response with the filtered seed list
#         return Response({"seeds": seeds_list})

#     except Exception as e:
#         return Response({"error": str(e)}, status=500)

@api_view(['GET'])
def get_seeds_by_inventory_type(request, farmer_id):
    try:
        try:
            user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
            language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
        except UserLanguagePreference.DoesNotExist:
            language_code = 'en'
        
        # Extract 'inventory_type' from the query parameters
        inventory_type_id = request.query_params.get('inventory_type', None)
        
        # Check if 'inventory_type' is provided in the query params
        if inventory_type_id is None:
            return Response({"error": "inventory_type parameter is required."}, status=400)

        # Filter MySeeds based on the farmer_id and inventory_type_id
        my_seeds = MySeeds.objects.filter(farmer_id=farmer_id, inventory_type_id=inventory_type_id, status__in=[0, 1])
         
        # If no seeds found for the given filter, return an appropriate message
        if not my_seeds:
            return Response({"message": "No seeds found for the provided inventory type."}, status=404)

        try:
            settings = GeneralSetting.objects.first()
            date_format = convert_to_strftime_format(settings.date_format) if settings else '%d-%m-%Y'  # Fallback to default format
        except Exception as e:
            date_format = '%d-%m-%Y'

        def format_date(date):
            return date.strftime(date_format) if date else ""  

        # Prepare the list of seed data
        seeds_list = []
        for seed in my_seeds:
            seeds_list.append({
                "id": seed.id, 
                "vendor": {
                    "id": seed.vendor.id if seed.vendor else None,
                    "name": seed.vendor.get_translated_value("name", language_code) if seed.vendor else None
                },
                "inventory_type": {
                    "id": seed.inventory_type.id if seed.inventory_type else None,
                    "name": seed.inventory_type.get_translated_value("name", language_code) if seed.inventory_type else None
                },
                "inventory_category": {
                    "id": seed.inventory_category.id if seed.inventory_category else None,
                    "name": seed.inventory_category.get_translated_value("name", language_code) if seed.inventory_category else None
                },
                "inventory_items": {
                    "id": seed.inventory_items.id if seed.inventory_items else None,
                    "name": seed.inventory_items.get_translated_value("name", language_code) if seed.inventory_items else None
                },
                "quantity": str(seed.quantity),   
                "purchase_amount": str(seed.purchase_amount),  
                "date_of_consumption": format_date(seed.date_of_consumption),
                "language": {
                    "default": "en"
                }
            })
         
        # Return the response with the filtered seed list
        return Response({"seeds": seeds_list})

    except Exception as e:
        return Response({"error": str(e)}, status=500)




@api_view(['GET'])
def get_seeds_by_inventory_items(request, farmer_id):
    try:
        # Extract 'inventory_type' and 'inventory_items' from the query parameters
        inventory_type_id = request.query_params.get('inventory_type', None)
        inventory_items_id = request.query_params.get('inventory_items', None)
        
        # Check if 'inventory_type' is provided in the query params
        if inventory_type_id is None:
            return Response({"error": "inventory_type parameter is required."}, status=400)

        # Build the filter for MySeeds
        filters = {
            'farmer_id': farmer_id,
            'inventory_type_id': inventory_type_id,
            'status__in': [0, 1]  # Corrected the syntax for the `status__in` filter
        }

        # If 'inventory_items' is provided, add it to the filter
        if inventory_items_id is not None:
            filters['inventory_items_id'] = inventory_items_id

        # Filter MySeeds based on the constructed filters
        my_seeds = MySeeds.objects.filter(**filters)
         
        # If no seeds found for the given filter, return an appropriate message

        try:
            settings = GeneralSetting.objects.first()
            date_format = convert_to_strftime_format(settings.date_format) if settings else '%d-%m-%Y'  # Fallback to default format
        except Exception as e:
            date_format = '%d-%m-%Y'

        def format_date(date):
            return date.strftime(date_format) if date else ""    
        
        if not my_seeds:
            return Response({"message": "No seeds found for the provided parameters."}, status=404)

        # Prepare the list of seed data
        seeds_list = []
        for seed in my_seeds:
            seeds_list.append({
                "id": seed.id, 
                "vendor": {
                    "id": seed.vendor.id if seed.vendor else None,
                    "name": seed.vendor.name if seed.vendor else None
                },
                "inventory_type": {
                    "id": seed.inventory_type.id if seed.inventory_type else None,
                    "name": seed.inventory_type.name if seed.inventory_type else None
                },
                "inventory_category": {
                    "id": seed.inventory_category.id if seed.inventory_category else None,
                    "name": seed.inventory_category.name if seed.inventory_category else None
                },
                "inventory_items": {
                    "id": seed.inventory_items.id if seed.inventory_items else None,
                    "name": seed.inventory_items.name if seed.inventory_items else None
                },
                "quantity": str(seed.quantity),   
                "purchase_amount": str(seed.purchase_amount),  
                "date_of_consumption": format_date(seed.date_of_consumption),
                "language": {
                    "default": "en"
                }
            })
         
        # Return the response with the filtered seed list
        return Response({"seeds": seeds_list})

    except Exception as e:
        return Response({"error": str(e)}, status=500)
 
# @api_view(['GET'])
# def get_fertilizers_by_inventory_type(request, farmer_id):
#     try:
#         # Extract 'inventory_type' from the query parameters
#         inventory_type_id = request.query_params.get('inventory_type', None)
        
#         # Check if 'inventory_type' is provided in the query params
#         if inventory_type_id is None:
#             return Response({"error": "inventory_type parameter is required."}, status=400)
        
#         # Filter MyFertilizers based on the farmer_id and inventory_type_id
#         my_fertilizers = MyFertilizers.objects.filter(farmer_id=farmer_id, inventory_type_id=inventory_type_id,status__in=[0, 1])
         
#         # If no fertilizers found for the given filter, return an appropriate message
#         if not my_fertilizers:
#             return Response({"message": "No fertilizers found for the provided inventory type."}, status=404)

#         try:
#             settings = GeneralSetting.objects.first()
#             date_format = convert_to_strftime_format(settings.date_format) if settings else '%d-%m-%Y'  # Fallback to default format
#         except Exception as e:
#             date_format = '%d-%m-%Y'

#         def format_date(date):
#             return date.strftime(date_format) if date else ""    
 
#         # Prepare the list of fertilizers data
#         fertilizers_list = []
#         for fertilizer in my_fertilizers:
#             fertilizers_list.append({
#                 "id": fertilizer.id,
#                 "vendor": {
#                     "id": fertilizer.vendor.id if fertilizer.vendor else None,
#                     "name": fertilizer.vendor.name if fertilizer.vendor else ""
#                 },
#                 "inventory_type": {
#                     "id": fertilizer.inventory_type.id if fertilizer.inventory_type else None,
#                     "name": fertilizer.inventory_type.name if fertilizer.inventory_type else ""
#                 },
#                 "inventory_category": {
#                     "id": fertilizer.inventory_category.id if fertilizer.inventory_category else None,
#                     "name": fertilizer.inventory_category.name if fertilizer.inventory_category else ""
#                 },
#                 "inventory_items": {
#                     "id": fertilizer.inventory_items.id if fertilizer.inventory_items else None,
#                     "name": fertilizer.inventory_items.name if fertilizer.inventory_items else ""
#                 },
#                 "quantity": str(fertilizer.quantity),
#                 "purchase_amount": str(fertilizer.purchase_amount),
#                 "date_of_consumption": format_date(fertilizer.date_of_consumption),
#                 "language": {
#                     "default": "en"
#                 }
#             })
         
#         # Return the response with the filtered fertilizers list
#         return Response({"fertilizers": fertilizers_list})

#     except Exception as e:
#         return Response({"error": str(e)}, status=500)

@api_view(['GET'])
def get_fertilizers_by_inventory_type(request, farmer_id):
    try:
        try:
            user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
            language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
        except UserLanguagePreference.DoesNotExist:
            language_code = 'en'

        # Extract 'inventory_type' from the query parameters
        inventory_type_id = request.query_params.get('inventory_type', None)
        
        # Check if 'inventory_type' is provided in the query params
        if inventory_type_id is None:
            return Response({"error": "inventory_type parameter is required."}, status=400)
        
        # Filter MyFertilizers based on the farmer_id and inventory_type_id
        my_fertilizers = MyFertilizers.objects.filter(farmer_id=farmer_id, inventory_type_id=inventory_type_id,status__in=[0, 1])
         
        # If no fertilizers found for the given filter, return an appropriate message
        if not my_fertilizers:
            return Response({"message": "No fertilizers found for the provided inventory type."}, status=404)

        try:
            settings = GeneralSetting.objects.first()
            date_format = convert_to_strftime_format(settings.date_format) if settings else '%d-%m-%Y'  # Fallback to default format
        except Exception as e:
            date_format = '%d-%m-%Y'

        def format_date(date):
            return date.strftime(date_format) if date else ""    
 
        # Prepare the list of fertilizers data
        fertilizers_list = []
        for fertilizer in my_fertilizers:
            fertilizers_list.append({
                "id": fertilizer.id,
                "vendor": {
                    "id": fertilizer.vendor.id if fertilizer.vendor else None,
                    "name": fertilizer.vendor.get_translated_value("name", language_code) if fertilizer.vendor else ""
                },
                "inventory_type": {
                    "id": fertilizer.inventory_type.id if fertilizer.inventory_type else None,
                    "name": fertilizer.inventory_type.get_translated_value("name", language_code) if fertilizer.inventory_type else ""
                },
                "inventory_category": {
                    "id": fertilizer.inventory_category.id if fertilizer.inventory_category else None,
                    "name": fertilizer.inventory_category.get_translated_value("name", language_code) if fertilizer.inventory_category else ""
                },
                "inventory_items": {
                    "id": fertilizer.inventory_items.id if fertilizer.inventory_items else None,
                    "name": fertilizer.inventory_items.get_translated_value("name", language_code) if fertilizer.inventory_items else ""
                },
                "quantity": str(fertilizer.quantity),
                "purchase_amount": str(fertilizer.purchase_amount),
                "date_of_consumption": format_date(fertilizer.date_of_consumption),
                "language": {
                    "default": "en"
                }
            })
         
        # Return the response with the filtered fertilizers list
        return Response({"fertilizers": fertilizers_list})

    except Exception as e:
        return Response({"error": str(e)}, status=500)


@api_view(['GET'])
def get_fertilizers_by_inventory_items(request, farmer_id):
    try:
        # Extract 'inventory_type' and 'inventory_items' from the query parameters
        inventory_type_id = request.query_params.get('inventory_type', None)
        inventory_items_id = request.query_params.get('inventory_items', None)
        
        # Check if 'inventory_type' is provided in the query params
        if inventory_type_id is None:
            return Response({"error": "inventory_type parameter is required."}, status=400)
        
        # Filter MyFertilizers based on the farmer_id and inventory_type_id, and inventory_items_id if provided
        # filters = {'farmer_id': farmer_id, 'inventory_type_id': inventory_type_id, 'status__in'=[0, 1]}
        filters = {'farmer_id': farmer_id, 'inventory_type_id': inventory_type_id, 'status__in':[0, 1]}

        
        # If 'inventory_items' is provided in the query parameters, add it to the filter
        if inventory_items_id is not None:
            filters['inventory_items_id'] = inventory_items_id
        
        my_fertilizers = MyFertilizers.objects.filter(**filters)
         
        # If no fertilizers found for the given filter, return an appropriate message
        if not my_fertilizers:
            return Response({"message": "No fertilizers found for the provided inventory type and inventory items."}, status=404)


        try:
            settings = GeneralSetting.objects.first()
            date_format = convert_to_strftime_format(settings.date_format) if settings else '%d-%m-%Y'  # Fallback to default format
        except Exception as e:
            date_format = '%d-%m-%Y'

        def format_date(date):
            return date.strftime(date_format) if date else ""    
 
        # Prepare the list of fertilizers data
        fertilizers_list = []
        for fertilizer in my_fertilizers:
            fertilizers_list.append({
                "id": fertilizer.id,
                "vendor": {
                    "id": fertilizer.vendor.id if fertilizer.vendor else None,
                    "name": fertilizer.vendor.name if fertilizer.vendor else ""
                },
                "inventory_type": {
                    "id": fertilizer.inventory_type.id if fertilizer.inventory_type else None,
                    "name": fertilizer.inventory_type.name if fertilizer.inventory_type else ""
                },
                "inventory_category": {
                    "id": fertilizer.inventory_category.id if fertilizer.inventory_category else None,
                    "name": fertilizer.inventory_category.name if fertilizer.inventory_category else ""
                },
                "inventory_items": {
                    "id": fertilizer.inventory_items.id if fertilizer.inventory_items else None,
                    "name": fertilizer.inventory_items.name if fertilizer.inventory_items else ""
                },
                "quantity": str(fertilizer.quantity),
                "purchase_amount": str(fertilizer.purchase_amount),
                "date_of_consumption": format_date(fertilizer.date_of_consumption),
                "language": {
                    "default": "en"
                }
            })
         
        # Return the response with the filtered fertilizers list
        return Response({"fertilizers": fertilizers_list})

    except Exception as e:
        return Response({"error": str(e)}, status=500)
 
@api_view(['POST'])
def view_fuel(request):
    if request.method == 'POST':
        fuel_id = request.data.get('fuel_id')
        user_id = request.data.get('user_id')

        if fuel_id is None or user_id is None:
            return Response({'error': 'fuel_id and user_id are required.'}, status=status.HTTP_400_BAD_REQUEST)

        try:
            # Fetch the fuel record based on the fuel_id and user_id
            fuel = MyFuel.objects.get(id=fuel_id, farmer=user_id)
            # Fetch associated documents for the fuel record
            documents = MyFuelDocuments.objects.filter(fuel=fuel)

            # Serialize the fuel record and documents
            fuel_serializer = MyFuelSerializer(fuel)
            documents_serializer = MyFuelDocumentsSerializer(documents, many=True)

            # Prepare the response data
            response_data = {
                'fuel': fuel_serializer.data,
                'documents': documents_serializer.data,
                'language':{
                    'default':"en"
                }
            }

            return Response(response_data, status=status.HTTP_200_OK)
        
        except MyFuel.DoesNotExist:
            return Response({'error': 'Fuel record not found or you do not have permission to access it.'}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
  
@api_view(['POST'])
def get_my_fuel(request, farmer_id):
    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'

    try:
        # Get 'MyFuel ID' from the request payload (it's now expected in the POST data)
        my_fuel_id = request.data.get('my_fuel', None)

        if not my_fuel_id:
            return Response({'error': 'MyFuel ID is required in the payload.'}, status=status.HTTP_400_BAD_REQUEST)
        
        # Get the farmer object by farmer_id (from URL)
        try:
            farmer = Farmer.objects.get(id=farmer_id, status=0)
        except Farmer.DoesNotExist:
            return Response({'error': 'Farmer not found.'}, status=status.HTTP_404_NOT_FOUND)
        
        # Get the MyFuel object by MyFuel ID and ensure it belongs to the given farmer
        try:
            my_fuel = MyFuel.objects.get(id=my_fuel_id, farmer=farmer, status__in=[0, 1])
        except MyFuel.DoesNotExist:
            return Response({'error': 'MyFuel record not found for this farmer.'}, status=status.HTTP_404_NOT_FOUND)

        try:
            settings = GeneralSetting.objects.first()
            date_format = convert_to_strftime_format(settings.date_format) if settings else '%d-%m-%Y'  # Fallback to default format
        except Exception as e:
            date_format = '%d-%m-%Y'

        def format_date(date):
            return date.strftime(date_format) if date else ""  

        # Fetch related documents for the given MyFuel
        fuel_documents = MyFuelDocuments.objects.filter(fuel=my_fuel, status=0)

        # Group documents by file type (or document category)
        documents = {}
        for doc in fuel_documents:
            category_id = doc.file_type.id if doc.file_type else None

            if category_id not in documents:
                documents[category_id] = []

            documents[category_id].append({
                "id": doc.id,
                "document_category": {
                    "id": doc.file_type.id if doc.file_type else None,
                    # "name": doc.file_type.name if doc.file_type else None
                    "name": doc.file_type.get_translated_value("name", language_code) if doc.file_type else None
                },
                "upload_document": request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else ""),
                "language": {"default": "en"}
            })

        # Convert documents dictionary to list for the response
        document_data = [{"category_id": category_id, "documents": docs} for category_id, docs in documents.items()]

        # Prepare full fuel data to return
        fuel_data = {
            'farmer': {
                'id': farmer.id,
                # 'name': farmer.name,   
                'name': farmer.get_translated_value("name", language_code) if farmer else "",   
            },
            'fuel_id': my_fuel.id,
            'quantity': my_fuel.quantity,
            'purchase_amount': my_fuel.purchase_amount,
            # 'description': my_fuel.description, 
            'description': my_fuel.get_translated_value("description", language_code) if my_fuel else "", 
            'date': format_date(my_fuel.date_of_consumption), 
            'inventory_item': {
                'id': my_fuel.inventory_items.id if my_fuel.inventory_items else  "",
                # 'name': my_fuel.inventory_items.name if my_fuel.inventory_items else ""
                'name': my_fuel.inventory_items.get_translated_value("name", language_code) if my_fuel.inventory_items else ""
            },
            'inventory_type': {
                'id': my_fuel.inventory_type.id if my_fuel.inventory_type else  "",
                # 'name': my_fuel.inventory_type.name if my_fuel.inventory_type else ""
                'name': my_fuel.inventory_type.get_translated_value("name", language_code) if my_fuel.inventory_type else ""
            },
            'inventory_category': {
                'id': my_fuel.inventory_category.id if my_fuel.inventory_category else  "",
                # 'name': my_fuel.inventory_category.name if my_fuel.inventory_category else ""
                'name': my_fuel.inventory_category.get_translated_value("name", language_code) if my_fuel.inventory_category else ""
            },
            'vendor': {
                'id': my_fuel.vendor.id if my_fuel.vendor else "",
                # 'name': my_fuel.vendor.name if my_fuel.vendor else "",
                'name': my_fuel.vendor.get_translated_value("name", language_code) if my_fuel.vendor else "",
            }, 
            'paid_amount':my_fuel.paid_amount,
            'status': my_fuel.status,
            'documents': document_data,  # Grouped document data
            'language':{
                'default': 'en'
            }
        }

        return Response({'fuel_data': fuel_data}, status=status.HTTP_200_OK)

    except Exception as e:
        return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
 
@api_view(['POST'])
def get_my_vehicle(request, farmer_id):
    try:
        # Get 'MyVehicle ID' from the request payload
        my_vehicle_id = request.data.get('my_vehicle', None)

        if not my_vehicle_id:
            return Response({'error': 'MyVehicle ID is required in the payload.'}, status=status.HTTP_400_BAD_REQUEST)
        
        # Get the farmer object by farmer_id (from URL)
        try:
            farmer = Farmer.objects.get(id=farmer_id)
        except Farmer.DoesNotExist:
            return Response({'error': 'Farmer not found.'}, status=status.HTTP_404_NOT_FOUND)
        
        # Get the MyVehicle object by MyVehicle ID and ensure it belongs to the given farmer
        try:
            my_vehicle = MyVehicle.objects.get(id=my_vehicle_id, farmer=farmer, status__in=[0, 1])
        except MyVehicle.DoesNotExist:
            return Response({'error': 'MyVehicle record not found for this farmer.'}, status=status.HTTP_404_NOT_FOUND)

        try:
            settings = GeneralSetting.objects.first()
            date_format = convert_to_strftime_format(settings.date_format) if settings else '%d-%m-%Y'  # Fallback to default format
        except Exception as e:
            date_format = '%d-%m-%Y'

        def format_date(date):
            return date.strftime(date_format) if date else ""    

        # Fetch related documents for the given MyVehicle
        vehicle_documents = MyVehicleDocuments.objects.filter(vehicle=my_vehicle)

        # Document data
        document_data = []
        for doc in vehicle_documents:
            document_data.append({
                'id': doc.id,
                'document_name': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else ""),
                'file_type': doc.file_type.name if doc.file_type else "", 
            })
        
        # Prepare full vehicle data to return
        vehicle_data = {
            'farmer': {
                'id': farmer.id,
                'name': farmer.name,   
            },
            'vehicle_id': my_vehicle.id,
            'register_number': my_vehicle.register_number,
            'owner_name': my_vehicle.owner_name,
            'date': format_date(my_vehicle.date_of_consumption), 
            'date_of_registration': format_date(my_vehicle.date_of_consumption),
            'registration_valid_till': format_date(my_vehicle.registration_valid_till),
            'engine_number': my_vehicle.engine_number,
            'chasis_number': my_vehicle.chasis_number,
            'running_kilometer': my_vehicle.running_kilometer,
            'service_frequency': my_vehicle.service_frequency,
            'service_frequency_unit': my_vehicle.service_frequency_unit,
            'fuel_capacity': my_vehicle.fuel_capacity,
            'average_mileage': my_vehicle.average_mileage,
            'purchase_amount': my_vehicle.purchase_amount,
            'insurance': my_vehicle.insurance,
            'company_name': my_vehicle.company_name,
            'insurance_no': my_vehicle.insurance_no,
            'insurance_amount': my_vehicle.insurance_amount,
            'insurance_start_date': format_date(my_vehicle.insurance_start_date),
            'insurance_end_date': format_date(my_vehicle.insurance_end_date),
            'insurance_renewal_date': format_date(my_vehicle.insurance_renewal_date),
            'description': my_vehicle.description,
            'status': my_vehicle.status,
            'vendor': {
                'id': my_vehicle.vendor.id if my_vehicle.vendor else "",
                'name': my_vehicle.vendor.name if my_vehicle.vendor else "",
            },
            'inventory_item': {
                'id': my_vehicle.inventory_items.id if my_vehicle.inventory_items else None,
                'name': my_vehicle.inventory_items.name if my_vehicle.inventory_items else None,
            },
            'inventory_type': {
                'id': my_vehicle.inventory_type.id if my_vehicle.inventory_type else None,
                'name': my_vehicle.inventory_type.name if my_vehicle.inventory_type else None,
            },
            'inventory_category': {
                'id': my_vehicle.inventory_category.id if my_vehicle.inventory_category else None,
                'name': my_vehicle.inventory_category.name if my_vehicle.inventory_category else None,
            },
            'paid_amount':my_vehicle.paid_amount,
            'documents': document_data,
            'language': {
                'default': 'en'
            }
        }

        return Response({'vehicle_data': vehicle_data}, status=status.HTTP_200_OK)

    except Exception as e:
        return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
 
@api_view(['POST'])
def get_my_machinery(request, farmer_id):
    try:
        # Get 'MyMachinery ID' from the request payload
        my_machinery_id = request.data.get('my_machinery', None)

        if not my_machinery_id:
            return Response({'error': 'MyMachinery ID is required in the payload.'}, status=status.HTTP_400_BAD_REQUEST)
        
        # Get the farmer object by farmer_id (from URL)
        try:
            farmer = Farmer.objects.get(id=farmer_id)
        except Farmer.DoesNotExist:
            return Response({'error': 'Farmer not found.'}, status=status.HTTP_404_NOT_FOUND)


        try:
            settings = GeneralSetting.objects.first()
            date_format = convert_to_strftime_format(settings.date_format) if settings else '%d-%m-%Y'  # Fallback to default format
        except Exception as e:
            date_format = '%d-%m-%Y'

        def format_date(date):
            return date.strftime(date_format) if date else ""   
        
        # Get the MyMachinery object by MyMachinery ID and ensure it belongs to the given farmer
        try:
            my_machinery = MyMachinery.objects.get(id=my_machinery_id, farmer=farmer, status__in=[0, 1])
        except MyMachinery.DoesNotExist:
            return Response({'error': 'MyMachinery record not found for this farmer.'}, status=status.HTTP_404_NOT_FOUND)

        # Fetch related documents for the given MyMachinery
        machinery_documents = MyMachineryDocuments.objects.filter(machinary=my_machinery)

        # Document data
        document_data = []
        for doc in machinery_documents:
            document_data.append({
                'id': doc.id,
                'document_name': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else ""),
                'file_type': doc.file_type.name if doc.file_type else "",
            })
        
        # Prepare full machinery data to return
        machinery_data = {
            'farmer': {
                'id': farmer.id,
                'name': farmer.name,  # Farmer name
            },
            'machinery_id': my_machinery.id,
            'vendor': {
                'id': my_machinery.vendor.id if my_machinery.vendor else None,
                'name': my_machinery.vendor.name if my_machinery.vendor else "",  # Vendor name
            },
            'inventory_item': {
                'id': my_machinery.inventory_items.id if my_machinery.inventory_items else None,
                'name': my_machinery.inventory_items.name if my_machinery.inventory_items else "",  # Inventory Item name
            },
            'inventory_type': {
                'id': my_machinery.inventory_type.id if my_machinery.inventory_type else None,
                'name': my_machinery.inventory_type.name if my_machinery.inventory_type else "",  # Inventory Type name
            },
            'inventory_category': {
                'id': my_machinery.inventory_category.id if my_machinery.inventory_category else None,
                'name': my_machinery.inventory_category.name if my_machinery.inventory_category else "",  # Inventory Category name
            },
            'machinery_type': my_machinery.machinery_type,
            'fuel_capacity': my_machinery.fuel_capacity,
            'purchase_amount': my_machinery.purchase_amount,
            'paid_amount':my_machinery.paid_amount,
            'warranty_start_date': format_date(my_machinery.warranty_start_date),
            'warranty_end_date': format_date(my_machinery.warranty_end_date),
            'date': format_date(my_machinery.date_of_consumption), 
            'description': my_machinery.description,
            'status': my_machinery.status,
            'available_quantity': my_machinery.available_quans,
            'documents': document_data,
            'language': {
                'default': 'en'
            }
        }

        return Response({'machinery_data': machinery_data}, status=status.HTTP_200_OK)

    except Exception as e:
        return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@api_view(['POST'])
def get_my_tools(request, farmer_id):
    try:
        # Get 'MyTools ID' from the request payload
        my_tools_id = request.data.get('my_tools', None)

        if not my_tools_id:
            return Response({'error': 'MyTools ID is required in the payload.'}, status=status.HTTP_400_BAD_REQUEST)
        
        # Get the farmer object by farmer_id (from URL)
        try:
            farmer = Farmer.objects.get(id=farmer_id,status=0)
        except Farmer.DoesNotExist:
            return Response({'error': 'Farmer not found.'}, status=status.HTTP_404_NOT_FOUND)
        
        # Get the MyTools object by MyTools ID and ensure it belongs to the given farmer
        try:
            my_tools = MyTools.objects.get(id=my_tools_id, farmer=farmer, status__in=[0, 1])
        except MyTools.DoesNotExist:
            return Response({'error': 'MyTools record not found for this farmer.'}, status=status.HTTP_404_NOT_FOUND)

        try:
            settings = GeneralSetting.objects.first()
            date_format = convert_to_strftime_format(settings.date_format) if settings else '%d-%m-%Y'  # Fallback to default format
        except Exception as e:
            date_format = '%d-%m-%Y'

        def format_date(date):
            return date.strftime(date_format) if date else ""    

        # Fetch related documents for the given MyTools
        tools_documents = MyToolsDocuments.objects.filter(tools=my_tools)

        # Document data
        document_data = []
        for doc in tools_documents:
            document_data.append({
                'id': doc.id,
                'document_name': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else ""),
                'file_type': doc.file_type.name if doc.file_type else "", 
            })
        
        # Prepare full tools data to return with id and name for all relevant fields
        tools_data = {
            'farmer': {
                'id': farmer.id,
                'name': farmer.name,   
            },
            'tools_id': my_tools.id,
            'vendor': {
                'id': my_tools.vendor.id if my_tools.vendor else None,
                'name': my_tools.vendor.name if my_tools.vendor else None,
            },
            'inventory_item': {
                'id': my_tools.inventory_items.id if my_tools.inventory_items else None,
                'name': my_tools.inventory_items.name if my_tools.inventory_items else None,
            },
            'inventory_type': {
                'id': my_tools.inventory_type.id if my_tools.inventory_type else None,
                'name': my_tools.inventory_type.name if my_tools.inventory_type else None,
            },
            'inventory_category': {
                'id': my_tools.inventory_category.id if my_tools.inventory_category else None,
                'name': my_tools.inventory_category.name if my_tools.inventory_category else None,
            },
            'date': format_date(my_tools.date_of_consumption), 
            'quantity': my_tools.quantity,
            'purchase_amount': my_tools.purchase_amount,
            'paid_amount':my_tools.paid_amount,
            'description': my_tools.description,
            'status': my_tools.status,
            'available_quantity': my_tools.available_quans,
            'documents': document_data,
            'language': {
                'default': 'en'
            }
        }

        return Response({'tools_data': tools_data}, status=status.HTTP_200_OK)

    except Exception as e:
        return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
  
@api_view(['POST'])
def get_my_pesticides(request, farmer_id):
    try:
        # Get 'MyPesticides ID' from the POST request body
        my_pesticides_id = request.data.get('my_pesticides', None)

        if not my_pesticides_id:
            return Response({'error': 'MyPesticides ID is required in the payload.'}, status=status.HTTP_400_BAD_REQUEST)
        
        # Get the farmer object by farmer_id (from URL)
        try:
            farmer = Farmer.objects.get(id=farmer_id, status=0)
        except Farmer.DoesNotExist:
            return Response({'error': 'Farmer not found.'}, status=status.HTTP_404_NOT_FOUND)
        
        # Get the MyPesticides object by MyPesticides ID and ensure it belongs to the given farmer
        try:
            my_pesticides = MyPesticides.objects.get(id=my_pesticides_id, farmer=farmer, status__in=[0, 1])
        except MyPesticides.DoesNotExist:
            return Response({'error': 'MyPesticides record not found for this farmer.'}, status=status.HTTP_404_NOT_FOUND)

        # Fetch related documents for the given MyPesticides
        pesticides_documents = MyPesticidesDocuments.objects.filter(pest=my_pesticides)

        try:
            settings = GeneralSetting.objects.first()
            date_format = convert_to_strftime_format(settings.date_format) if settings else '%d-%m-%Y'  # Fallback to default format
        except Exception as e:
            date_format = '%d-%m-%Y'

        def format_date(date):
            return date.strftime(date_format) if date else ""   

        # Document data
        document_data = []
        for doc in pesticides_documents:
            document_data.append({
                'id': doc.id,
                'document_name': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else ""),
                'file_type': {
                    'id': doc.file_type.id if doc.file_type else "",
                    'name': doc.file_type.name if doc.file_type else ""
                }
            })
        
        # Prepare full pesticides data to return
        pesticides_data = {
            'farmer': {
                'id': farmer.id,
                'name': farmer.name,
            },
            'pesticides_id': my_pesticides.id,
            'vendor': {
                'id': my_pesticides.vendor.id if my_pesticides.vendor else "",
                'name': my_pesticides.vendor.name if my_pesticides.vendor else "",
            },
            'inventory_item': {
                'id': my_pesticides.inventory_items.id if my_pesticides.inventory_items else "",
                'name': my_pesticides.inventory_items.name if my_pesticides.inventory_items else "",
            },
            'inventory_type': {
                'id': my_pesticides.inventory_type.id if my_pesticides.inventory_type else "",
                'name': my_pesticides.inventory_type.name if my_pesticides.inventory_type else "",
            },
            'inventory_category': {
                'id': my_pesticides.inventory_category.id if my_pesticides.inventory_category else "",
                'name': my_pesticides.inventory_category.name if my_pesticides.inventory_category else "",
            },
            'quantity': my_pesticides.quantity,
            'quantity_unit': {
                'id': my_pesticides.quantity_unit.id if my_pesticides.quantity_unit else "",
                'name': my_pesticides.quantity_unit.name if my_pesticides.quantity_unit else "",
            },
            'purchase_amount': my_pesticides.purchase_amount,
            'paid_amount':my_pesticides.paid_amount,
            'description': my_pesticides.description,
            'status': my_pesticides.status,
            'available_quantity': my_pesticides.available_quans,
            "date_of_consumption": format_date(my_pesticides.date_of_consumption),
            'documents': document_data,
            'language': {
                'default': 'en'
            }
        }

        return Response({'pesticides_data': pesticides_data}, status=status.HTTP_200_OK)

    except Exception as e:
        return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
 
@api_view(['POST'])
def get_my_fertilizers(request, farmer_id):
    try:
        # Get 'MyFertilizers ID' from the request payload
        my_fertilizers_id = request.data.get('my_fertilizers', None)

        if not my_fertilizers_id:
            return Response({'error': 'MyFertilizers ID is required in the payload.'}, status=status.HTTP_400_BAD_REQUEST)
        
        # Get the farmer object by farmer_id (from URL)
        try:
            farmer = Farmer.objects.get(id=farmer_id)
        except Farmer.DoesNotExist:
            return Response({'error': 'Farmer not found.'}, status=status.HTTP_404_NOT_FOUND)
        
        # Get the MyFertilizers object by MyFertilizers ID and ensure it belongs to the given farmer
        try:
            my_fertilizers = MyFertilizers.objects.get(id=my_fertilizers_id, farmer=farmer, status__in=[0, 1])
        except MyFertilizers.DoesNotExist:
            return Response({'error': 'MyFertilizers record not found for this farmer.'}, status=status.HTTP_404_NOT_FOUND)

        # Fetch related documents for the given MyFertilizers
        fertilizers_documents = MyFertilizersDocuments.objects.filter(fertilizers=my_fertilizers)

        try:
            settings = GeneralSetting.objects.first()
            date_format = convert_to_strftime_format(settings.date_format) if settings else '%d-%m-%Y'  # Fallback to default format
        except Exception as e:
            date_format = '%d-%m-%Y'

        def format_date(date):
            return date.strftime(date_format) if date else ""    

        # Document data
        document_data = []
        for doc in fertilizers_documents:
            document_data.append({
                'id': doc.id,
                'document_name': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else ""),
                'file_type': {
                    'id': doc.file_type.id if doc.file_type else "",
                    'name': doc.file_type.name if doc.file_type else ""
                }
            })
        
        # Prepare full fertilizers data to return
        fertilizers_data = {
            'farmer': {
                'id': farmer.id,
                'name': farmer.name,   
            },
            'fertilizer_id': my_fertilizers.id,
            'vendor': {
                'id': my_fertilizers.vendor.id if my_fertilizers.vendor else "",
                'name': my_fertilizers.vendor.name if my_fertilizers.vendor else "",
            },
            'inventory_item': {
                'id': my_fertilizers.inventory_items.id if my_fertilizers.inventory_items else "",
                'name': my_fertilizers.inventory_items.name if my_fertilizers.inventory_items else "",
            },
            'inventory_type': {
                'id': my_fertilizers.inventory_type.id if my_fertilizers.inventory_type else "",
                'name': my_fertilizers.inventory_type.name if my_fertilizers.inventory_type else "",
            },
            'inventory_category': {
                'id': my_fertilizers.inventory_category.id if my_fertilizers.inventory_category else "",
                'name': my_fertilizers.inventory_category.name if my_fertilizers.inventory_category else "",
            },
            'quantity': my_fertilizers.quantity,
            'quantity_unit': {
                'id': my_fertilizers.quantity_unit.id if my_fertilizers.quantity_unit else "",
                'name': my_fertilizers.quantity_unit.name if my_fertilizers.quantity_unit else "",
            },
            'purchase_amount': my_fertilizers.purchase_amount,
            'paid_amount':my_fertilizers.paid_amount,
            'description': my_fertilizers.description,
            'status': my_fertilizers.status,
            'available_quantity': my_fertilizers.available_quans,
            "date_of_consumption": format_date(my_fertilizers.date_of_consumption),
            'documents': document_data,
            'language': {
                'default': 'en'
            }
        }

        return Response({'fertilizers_data': fertilizers_data}, status=status.HTTP_200_OK)

    except Exception as e:
        return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@api_view(['POST'])
def get_my_seeds(request, farmer_id):
    try:
        # Get 'MySeeds ID' from the request payload
        my_seeds_id = request.data.get('my_seeds', None)

        if not my_seeds_id:
            return Response({'error': 'MySeeds ID is required in the payload.'}, status=status.HTTP_400_BAD_REQUEST)
        
        # Get the farmer object by farmer_id (from URL)
        try:
            farmer = Farmer.objects.get(id=farmer_id,status=0)
        except Farmer.DoesNotExist:
            return Response({'error': 'Farmer not found.'}, status=status.HTTP_404_NOT_FOUND)
        
        # Get the MySeeds object by MySeeds ID and ensure it belongs to the given farmer
        try:
            my_seeds = MySeeds.objects.get(id=my_seeds_id, farmer=farmer, status__in=[0, 1])
        except MySeeds.DoesNotExist:
            return Response({'error': 'MySeeds record not found for this farmer.'}, status=status.HTTP_404_NOT_FOUND)

        # Fetch related documents for the given MySeeds
        seeds_documents = MyseedsDocuments.objects.filter(seeds=my_seeds)


        try:
            settings = GeneralSetting.objects.first()
            date_format = convert_to_strftime_format(settings.date_format) if settings else '%d-%m-%Y'  # Fallback to default format
        except Exception as e:
            date_format = '%d-%m-%Y'

        def format_date(date):
            return date.strftime(date_format) if date else ""    
        

        # Document data
        document_data = []
        for doc in seeds_documents:
            document_data.append({
                'id': doc.id,
                'document_name': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else ""),
                'file_type': {
                    'id': doc.file_type.id if doc.file_type else None,
                    'name': doc.file_type.name if doc.file_type else ""
                }, 
            })
        
        # Prepare full seeds data to return
        seeds_data = {
            'farmer': {
                'id': farmer.id,
                'name': farmer.name,   
            },
            'seeds_id': my_seeds.id,
            'vendor': {
                'id': my_seeds.vendor.id if my_seeds.vendor else None,
                'name': my_seeds.vendor.name if my_seeds.vendor else "",
            },
            'inventory_item': {
                'id': my_seeds.inventory_items.id if my_seeds.inventory_items else None,
                'name': my_seeds.inventory_items.name if my_seeds.inventory_items else "",
            },
            'inventory_type': {
                'id': my_seeds.inventory_type.id if my_seeds.inventory_type else None,
                'name': my_seeds.inventory_type.name if my_seeds.inventory_type else "",
            },
            'inventory_category': {
                'id': my_seeds.inventory_category.id if my_seeds.inventory_category else None,
                'name': my_seeds.inventory_category.name if my_seeds.inventory_category else "",
            },
            'quantity': str(my_seeds.quantity),
            'quantity_unit': {
                'id': my_seeds.quantity_unit.id if my_seeds.quantity_unit else None,
                'name': my_seeds.quantity_unit.name if my_seeds.quantity_unit else "",
            },
            'purchase_amount': str(my_seeds.purchase_amount),
            'paid_amount':my_seeds.paid_amount,
            'description': my_seeds.description,
            'status': my_seeds.status,
            'available_quantity': str(my_seeds.available_quans),
            "date_of_consumption": format_date(my_seeds.date_of_consumption),
            'documents': document_data,
            'language': {
                'default': 'en'
            }
        }

        return Response({'seeds_data': seeds_data}, status=status.HTTP_200_OK)

    except Exception as e:
        return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

# @api_view(['POST'])
# def add_expense(request, farmer_id): 

#     try:
#         user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
#         language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
#     except UserLanguagePreference.DoesNotExist:
#         language_code = 'en' 

#     try:
#         # Fetch the farmer object
#         farmer = get_object_or_404(Farmer, id=farmer_id)
#         print(f"Fetching farmer with id: {farmer_id}")

#         # Check the farmer's subscription and package
#         subscription = farmer.subscriptions.filter(status=0).first()
#         if not subscription or not subscription.packages:
#             return Response(
#                 {"success": False, "message": "No active subscription found."},
#                 status=status.HTTP_400_BAD_REQUEST
#             )

#         package = subscription.packages
#         max_expense_count = package.myexpense_count

#         # Count existing expenses of the farmer
#         current_expense_count = MyExpense.objects.filter(farmer=farmer,status=0).count()

#         # Check if expense limit is exceeded
#         if current_expense_count >= max_expense_count:
#             return Response(
#                 {"success": False, "message": f"Expense limit exceeded. You can add up to {max_expense_count} expenses with your current package."},
#                 status=status.HTTP_400_BAD_REQUEST
#             )

#         # Get the expense details from the request
#         my_crop_id = request.data.get('my_crop')  # Crop ID
#         file_data = request.data.get('document', [])  # Document data (file types and files)

#         # Extract additional fields from the request
#         type_expenses_id = request.data.get('type_expenses')  # Type of expense
#         amount = request.data.get('amount')  # Amount
#         description = request.data.get('description')  # Description of the expense
#         created_day = request.data.get('created_day')  # Date when the expense was created

#         # Validate that the required fields are provided
#         # if not my_crop_id or not file_data or not type_expenses_id or amount is None or description is None or not created_day:
#         #     return Response(
#         #         {"success": False, "message": "my_crop, documents, type_expenses, amount, description, and created_day are required."},
#         #         status=status.HTTP_400_BAD_REQUEST
#         #     )

#         if not my_crop_id or not type_expenses_id or amount is None or not created_day:
#             return Response(
#                 {"success": False, "message": "my_crop, type_expenses, amount, and created_day are required."},
#                 status=status.HTTP_400_BAD_REQUEST
#             )


#         # Fetch the expense type (Expenses)
#         type_expenses = get_object_or_404(Expenses, id=type_expenses_id)

#         # Allowed file types and size limit (10MB)
#         allowed_file_types = ['application/pdf', 'image/jpeg', 'image/png']
#         max_file_size = 10 * 1024 * 1024  # 10MB

#         expense_details = []

#         # Check if the expense already exists or create a new expense
#         expense_data = {
#             'farmer': farmer,
#             'my_crop': get_object_or_404(MyCrop, id=my_crop_id),
#             'type_expenses': type_expenses,
#             'amount': amount,
#             'description': description,
#             'created_day': created_day,
#             'created_by': farmer.farmer_user,  # Assuming the farmer has a farmer_user
#         }
#         expense = MyExpense.objects.create(**expense_data)

#         # Process each file type and its corresponding documents
#         for doc_data in file_data:
#             file_type_id = doc_data.get('file_type')
#             documents = doc_data.get('documents', [])

#             # Ensure documents are not empty before processing
#             if not documents:
#                 return Response(
#                     {"success": False, "message": f"No documents provided for file type {file_type_id}."},
#                     status=status.HTTP_400_BAD_REQUEST
#                 )

#             # Fetch the file type (DocumentCategory)
#             file_type = get_object_or_404(DocumentCategory, id=file_type_id)

#             # Loop through the provided documents to create ExpenseFile entries
#             for i, document_base64 in enumerate(documents):
#                 try:
#                     # Validate MIME type for images or PDF
#                     if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
#                         mime_type = validate_image_type(document_base64)  # This should validate the MIME type
#                         if mime_type:
#                             # Extract the base64 data (remove the prefix)
#                             document_data = document_base64.split(';base64,')[1]

#                             # Decode the base64 data to bytes
#                             document_bytes = base64.b64decode(document_data)

#                             # Check file size (after decoding)
#                             if len(document_bytes) > max_file_size:
#                                 return Response({'error': f'File is too large. Max size is 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

#                             # Create a file name
#                             document_name = f"expense_{farmer_id}_{file_type_id}_{i}.{mime_type.split('/')[1]}"

#                             # Create the document file (ContentFile)
#                             document_file = ContentFile(document_bytes, name=document_name)

#                             # Create ExpenseFile entry linked to the farmer, expense, and file type
#                             expense_file = ExpenseFile(
#                                 farmer=farmer,
#                                 my_expense=expense,  # Link the file to the created expense
#                                 file_type=file_type,
#                                 file=document_file,  # Use the ContentFile with the decoded content
#                             )
#                             expense_file.save()

#                             # Add expense file details to the response
#                             expense_details.append({
#                                 'id': expense_file.id,
#                                 'file_name': expense_file.file.name,
#                                 'file_type': expense_file.file_type.name,
#                             })
#                         else:
#                             return Response({'error': 'Invalid MIME type for the document.'}, status=status.HTTP_400_BAD_REQUEST)
#                     else:
#                         return Response({'error': 'Invalid file format. Only image/jpeg, image/png, and application/pdf are allowed.'}, status=status.HTTP_400_BAD_REQUEST)

#                 except Exception as e:
#                     return Response({'error': f"Error processing document: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

#         # Prepare the response with all details
#         response_data = {
#             "success": True,
#             "message": f"{len(expense_details)} expense files uploaded successfully.",
#             "expense_details": expense_details,
#             "expense": {
#                 "id": expense.id,
#                 "farmer": expense.farmer.id,
#                 "my_crop": expense.my_crop.id,
#                 "type_expenses": expense.type_expenses.id,
#                 "amount": expense.amount,
#                 "description": expense.description,
#                 "created_day": expense.created_day, 
#             },
#             "language": {"default": "en"}
#         }

#         return Response(response_data, status=status.HTTP_201_CREATED)

#     except Exception as e:
#         return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@api_view(['POST'])
def add_expense(request, farmer_id): 
    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'

    try:
        farmer = get_object_or_404(Farmer, id=farmer_id)
        vendor_id = request.data.get('vendor')
        my_crop_id = request.data.get('my_crop')
        vendor = None
        if vendor_id:
            try:
                vendor = MyVendor.objects.get(id=vendor_id)
            except MyVendor.DoesNotExist:
                return Response({"success": False, "message": "Vendor not found."}, status=status.HTTP_404_NOT_FOUND)
        crop = None
        if my_crop_id:
            try:
                crop = MyCrop.objects.get(id=my_crop_id)
            except MyCrop.DoesNotExist:
                return Response({"success": False, "message": "crop not found."}, status=status.HTTP_404_NOT_FOUND)


        print(f"Fetching farmer with id: {farmer_id}")

        subscription = farmer.subscriptions.filter(status=0).first()
        if not subscription or not subscription.packages:
            return Response(
                {"success": False, "message": "No active subscription found."},
                status=status.HTTP_400_BAD_REQUEST
            )

        package = subscription.packages
        max_expense_count = package.myexpense_count
        current_expense_count = MyExpense.objects.filter(farmer=farmer, status=0).count()

        if current_expense_count >= max_expense_count:
            return Response(
                {"success": False, "message": f"Expense limit exceeded. You can add up to {max_expense_count} expenses with your current package."},
                status=status.HTTP_400_BAD_REQUEST
            )


        file_data = request.data.get('document', [])
        amount = request.data.get('amount')
        paidAmount = request.data.get('paid_amount')
        description = request.data.get('description', '')  # Optional, default to empty string
        created_day = request.data.get('created_day')

        if  amount is None or not created_day:
            return Response(
                {"success": False, "message": "my_crop, type_expenses, amount, and created_day are required."},
                status=status.HTTP_400_BAD_REQUEST
            )

        allowed_file_types = ['application/pdf', 'image/jpeg', 'image/png']
        max_file_size = 10 * 1024 * 1024  # 10MB
        expense_details = []

        expense_data = {
            'farmer': farmer,
            'my_crop': crop,
            'vendor': vendor,
            'paid_amount': paidAmount,
            'amount': amount,
            'description': description,
            'created_day': created_day,
            'created_by': farmer.farmer_user,
        }
        expense = MyExpense.objects.create(**expense_data)

        if amount != 0 and paidAmount  != 0  and amount != paidAmount and vendor_id:
            if paidAmount > amount:  # Payables
                outstanding = Outstanding.objects.create(
                    farmer= farmer,
                    vendor = vendor,
                    expense=expense,
                    balance= amount,
                    paid= paidAmount,
                    to_pay= float(paidAmount) - float(amount),
                    paid_date=created_day,
                    total_paid=paidAmount,
                    identify=1,
                    created_by=farmer.farmer_user,
                    created_at=timezone.now()
                )
                if float(outstanding.to_pay) > 0:
                    vendor.payables = (float(vendor.payables or 0)) + float(outstanding.to_pay)
                    if vendor.opening_balance and vendor.opening_balance != 0 and vendor.credit:
                        if float(vendor.opening_balance) > float(outstanding.to_pay):
                            vendor.credit = True
                            vendor.debit = False
                            vendor.opening_balance = float(vendor.opening_balance) - float(outstanding.to_pay)
                        else:
                            vendor.credit = False
                            vendor.debit = True
                            vendor.opening_balance = float(outstanding.to_pay) - float(vendor.opening_balance)
                    elif vendor.opening_balance and vendor.opening_balance != 0 and vendor.credit == False and vendor.debit:
                        vendor.opening_balance = float(vendor.opening_balance) + float(outstanding.to_pay)
                        vendor.credit = False
                        vendor.debit = True
                    else:
                        vendor.opening_balance = float(outstanding.to_pay)
                        vendor.credit = False
                        vendor.debit = True
                    vendor.save()

            elif paidAmount <  amount:  # Receivables
                outstanding = Outstanding.objects.create(
                    farmer= farmer,
                    vendor= vendor,
                    expense=expense,
                    balance=float(paidAmount) - float( amount),
                    paid=paidAmount,
                    to_receive=float(paidAmount) - float( amount),
                    paid_date=created_day,
                    received_date=created_day,
                    total_received=paidAmount,
                    identify=1,
                    created_by=farmer.farmer_user,
                    created_at=timezone.now()
                )
                if float(outstanding.to_receive) > 0:
                    vendor.receivables = (float(vendor.receivables or 0)) + float(outstanding.to_receive)
                    if vendor.opening_balance and vendor.opening_balance != 0 and vendor.credit:
                        vendor.opening_balance = float(vendor.opening_balance) + float(outstanding.to_receive)
                        vendor.credit = True
                        vendor.debit = False
                    elif vendor.opening_balance and vendor.opening_balance != 0 and vendor.credit == False and vendor.debit:
                        if float(vendor.opening_balance) > float(outstanding.to_receive):
                            vendor.credit = False
                            vendor.debit = True
                            vendor.opening_balance = float(vendor.opening_balance) - float(outstanding.to_receive)
                        else:
                            vendor.credit = True
                            vendor.debit = False
                            vendor.opening_balance = float(outstanding.to_receive) - float(vendor.opening_balance)
                    else:
                        vendor.opening_balance = float(outstanding.to_receive)
                        vendor.credit = True
                        vendor.debit = False
                    vendor.save()


        FarmerNotification.objects.create(
            farmer=farmer,
            name='Expense',
            message= 'Expense added successfully',
            type='Expence'
        )
        if file_data:
            for doc_data in file_data:
                file_type_id = doc_data.get('file_type')
                documents = doc_data.get('documents', [])

                if not documents:
                    return Response(
                        {"success": False, "message": f"No documents provided for file type {file_type_id}."},
                        status=status.HTTP_400_BAD_REQUEST
                    )

                file_type = get_object_or_404(DocumentCategory, id=file_type_id)

                for i, document_base64 in enumerate(documents):
                    try:
                        if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
                            mime_type = validate_image_type(document_base64)
                            if mime_type:
                                document_data = document_base64.split(';base64,')[1]
                                document_bytes = base64.b64decode(document_data)

                                if len(document_bytes) > max_file_size:
                                    return Response({'error': 'File is too large. Max size is 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

                                document_name = f"expense_{farmer_id}_{file_type_id}_{i}.{mime_type.split('/')[1]}"
                                document_file = ContentFile(document_bytes, name=document_name)

                                expense_file = ExpenseFile(
                                    farmer=farmer,
                                    my_expense=expense,
                                    file_type=file_type,
                                    file=document_file,
                                )
                                expense_file.save()

                                expense_details.append({
                                    'id': expense_file.id,
                                    'file_name': expense_file.file.name,
                                    'file_type': expense_file.file_type.name,
                                })
                            else:
                                return Response({'error': 'Invalid MIME type for the document.'}, status=status.HTTP_400_BAD_REQUEST)
                        else:
                            return Response({'error': 'Invalid file format. Only image/jpeg, image/png, and application/pdf are allowed.'}, status=status.HTTP_400_BAD_REQUEST)
                    except Exception as e:
                        return Response({'error': f"Error processing document: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

        response_data = {
            "success": True,
            "message": f"{len(expense_details)} expense files uploaded successfully." if expense_details else "Expense added successfully.",
            "expense_details": expense_details,
            "expense": {
                "id": expense.id,
                "farmer": expense.farmer.id,
                "my_crop": expense.my_crop.id,
                "amount": expense.amount,
                "description": expense.description,
                "created_day": expense.created_day,
            },
            "language": {"default": "en"}
        }

        return Response(response_data, status=status.HTTP_201_CREATED)

    except Exception as e:
        return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)



@api_view(['PUT'])
def edit_purchase(request, farmer_id): 
    try:
        # Fetch the farmer object
        farmer = get_object_or_404(Farmer, id=farmer_id)
        print(f"Fetching farmer with id: {farmer_id}")

        # Get the expense details from the request
        my_crop_id = request.data.get('my_crop')  # Crop ID
        file_data = request.data.get('document', [])  # Document data (file types and files)

        # Extract additional fields from the request
        expense_id = request.data.get('expense_id')  # Expense ID for the existing purchase
        type_expenses_id = request.data.get('type_expenses')  # Type of expense
        amount = request.data.get('amount')  # Amount
        description = request.data.get('description')  # Description of the expense
        created_day = request.data.get('created_day')  # Date when the expense was created

        # Validate that the required fields are provided
        if not my_crop_id or not file_data or not type_expenses_id or amount is None or description is None or not created_day or not expense_id:
            return Response(
                {"success": False, "message": "my_crop, documents, type_expenses, amount, description, created_day, and expense_id are required."},
                status=status.HTTP_400_BAD_REQUEST
            )

        # Fetch the expense type (Expenses)
        type_expenses = get_object_or_404(Expenses, id=type_expenses_id)

        # Allowed file types and size limit (10MB)
        allowed_file_types = ['application/pdf', 'image/jpeg', 'image/png']
        max_file_size = 10 * 1024 * 1024  # 10MB

        expense_details = []

        # Fetch the existing expense to update
        expense = get_object_or_404(MyExpense, id=expense_id, farmer=farmer)

        # Update the expense fields with new values from the request
        expense.my_crop = get_object_or_404(MyCrop, id=my_crop_id)
        expense.type_expenses = type_expenses
        expense.amount = amount
        expense.description = description
        expense.created_day = created_day
        expense.updated_by = farmer.farmer_user  # Assuming the farmer has a `farmer_user` for tracking
        expense.save()

        # Process each file type and its corresponding documents
        for doc_data in file_data:
            file_type_id = doc_data.get('file_type')
            documents = doc_data.get('documents', [])

            # Ensure documents are not empty before processing
            if not documents:
                return Response(
                    {"success": False, "message": f"No documents provided for file type {file_type_id}."},
                    status=status.HTTP_400_BAD_REQUEST
                )

            # Fetch the file type (DocumentCategory)
            file_type = get_object_or_404(DocumentCategory, id=file_type_id)

            # Loop through the provided documents to create or update ExpenseFile entries
            for i, document_base64 in enumerate(documents):
                try:
                    # Validate MIME type for images or PDF
                    if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
                        mime_type = validate_image_type(document_base64)  # This should validate the MIME type
                        if mime_type:
                            # Extract the base64 data (remove the prefix)
                            document_data = document_base64.split(';base64,')[1]

                            # Decode the base64 data to bytes
                            document_bytes = base64.b64decode(document_data)

                            # Check file size (after decoding)
                            if len(document_bytes) > max_file_size:
                                return Response({'error': f'File is too large. Max size is 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

                            # Create a file name
                            document_name = f"expense_{farmer_id}_{file_type_id}_{i}.{mime_type.split('/')[1]}"

                            # Create the document file (ContentFile)
                            document_file = ContentFile(document_bytes, name=document_name)

                            # Check if the document already exists (update it) or create a new one
                            if 'edit' in doc_data and doc_data['edit']:  # Assuming `edit` flag is passed to identify if document needs to be replaced
                                expense_file_id = doc_data.get('edit')  # The existing document ID to be replaced
                                expense_file = get_object_or_404(ExpenseFile, id=expense_file_id, my_expense=expense)
                                expense_file.file = document_file  # Replace the file content
                                expense_file.save()
                            else:
                                # Create new ExpenseFile entry linked to the farmer, expense, and file type
                                expense_file = ExpenseFile(
                                    farmer=farmer,
                                    my_expense=expense,  # Link the file to the created expense
                                    file_type=file_type,
                                    file=document_file,  # Use the ContentFile with the decoded content
                                )
                                expense_file.save()

                            # Add expense file details to the response
                            expense_details.append({
                                'id': expense_file.id,
                                'file_name': expense_file.file.name,
                                'file_type': expense_file.file_type.name,
                            })
                        else:
                            return Response({'error': 'Invalid MIME type for the document.'}, status=status.HTTP_400_BAD_REQUEST)
                    else:
                        return Response({'error': 'Invalid file format. Only image/jpeg, image/png, and application/pdf are allowed.'}, status=status.HTTP_400_BAD_REQUEST)

                except Exception as e:
                    return Response({'error': f"Error processing document: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

        # Prepare the response with all details
        response_data = {
            "success": True,
            "message": f"{len(expense_details)} expense files uploaded/updated successfully.",
            "expense_details": expense_details,
            "expense": {
                "id": expense.id,
                "farmer": expense.farmer.id,
                "my_crop": expense.my_crop.id,
                "type_expenses": expense.type_expenses.id,
                "amount": expense.amount,
                "description": expense.description,
                "created_day": expense.created_day, 
            },
            "language": {"default": "en"}
        }

        return Response(response_data, status=status.HTTP_200_OK)

    except Exception as e:
        return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
 
def validate_image_type(document_base64):
    """
    This function validates the MIME type of the base64 string
    """
    if document_base64.startswith("data:image/jpeg"):
        return "image/jpeg"
    elif document_base64.startswith("data:image/png"):
        return "image/png"
    elif document_base64.startswith("data:image/heic"):
        return "image/heic"
    elif document_base64.startswith("data:application/pdf"):
        return "application/pdf"
    return None
 
@api_view(['GET'])
def get_purchase(request, farmer_id):
    # Retrieve data filtered by the farmer_id
    fuel_data = MyFuel.objects.filter(farmer_id=farmer_id).select_related('inventory_items', 'vendor')
    vehicle_data = MyVehicle.objects.filter(farmer_id=farmer_id).select_related('inventory_items', 'vendor')
    machinery_data = MyMachinery.objects.filter(farmer_id=farmer_id).select_related('inventory_items', 'vendor')
    tools_data = MyTools.objects.filter(farmer_id=farmer_id).select_related('inventory_items', 'vendor')
    pesticides_data = MyPesticides.objects.filter(farmer_id=farmer_id).select_related('inventory_items', 'vendor')
    fertilizers_data = MyFertilizers.objects.filter(farmer_id=farmer_id).select_related('inventory_items', 'vendor')
    seeds_data = MySeeds.objects.filter(farmer_id=farmer_id).select_related('inventory_items', 'vendor')

    def serialize_data(queryset):
        """Helper function to add inventory item and vendor details to the serialized data."""
        data = []
        for item in queryset:
            serialized_item = {
                "vendor_id": item.vendor.id if item.vendor else None,
                "vendor_name": item.vendor.name if item.vendor else None,  # Adjust to the correct field for vendor name
                "purchase_amount": float(item.purchase_amount) if item.purchase_amount else 0.0,  # Handle None
                "inventory_items": item.inventory_items_id,
                "inventory_item_name": item.inventory_items.name if item.inventory_items else None,
            }
            data.append(serialized_item)
        return data

    # Serialize each dataset and include inventory item names
    fuel_serialized = serialize_data(fuel_data)
    vehicle_serialized = serialize_data(vehicle_data)
    machinery_serialized = serialize_data(machinery_data)
    tools_serialized = serialize_data(tools_data)
    pesticides_serialized = serialize_data(pesticides_data)
    fertilizers_serialized = serialize_data(fertilizers_data)
    seeds_serialized = serialize_data(seeds_data)

    # Create structured response
    response_data = {
        "farmer_id": farmer_id,  # Include farmer_id in the response
        "fuel": {
            "data": fuel_serialized,
            "total_count": len(fuel_serialized),
        },
        "vehicle": {
            "data": vehicle_serialized,
            "total_count": len(vehicle_serialized),
        },
        "machinery": {
            "data": machinery_serialized,
            "total_count": len(machinery_serialized),
        },
        "tools": {
            "data": tools_serialized,
            "total_count": len(tools_serialized),
        },
        "pesticides": {
            "data": pesticides_serialized,
            "total_count": len(pesticides_serialized),
        },
        "fertilizers": {
            "data": fertilizers_serialized,
            "total_count": len(fertilizers_serialized),
        },
        "seeds": {
            "data": seeds_serialized,
            "total_count": len(seeds_serialized),
        },
        "total_sum": sum(
            item["purchase_amount"]
            for data in [
                fuel_serialized,
                vehicle_serialized,
                machinery_serialized,
                tools_serialized,
                pesticides_serialized,
                fertilizers_serialized,
                seeds_serialized,
            ]
            for item in data
        ),
    }

    return Response(response_data, status=status.HTTP_200_OK)
 
# @api_view(['GET'])
# def get_inventory_items(request, inventory_category_id):
#     # Filter InventoryCategory to ensure it exists
#     try:
#         inventory_category = InventoryCategory.objects.get(id=inventory_category_id, status=0)
#     except InventoryCategory.DoesNotExist:
#         return Response({"detail": "Inventory category not found or inactive."}, status=404)
    
#     # Retrieve the inventory items for the given category
#     inventory_items = InventoryItems.objects.filter(inventory_category=inventory_category, status=0)

#     # If no items found, return an appropriate message
#     if not inventory_items:
#         return Response({"detail": "No inventory items found for the given category."}, status=404)
    
#     # Serialize the inventory items
#     serializer = InventoryItemsSerializer(inventory_items, many=True)
    
#     return Response(serializer.data, status=200)
 
@api_view(['GET'])
def get_inventory_items(request, inventory_category_id):
    language_code = request.GET.get('lang', 'en')  # Default to English

    try:
        inventory_category = InventoryCategory.objects.get(id=inventory_category_id, status=0)
    except InventoryCategory.DoesNotExist:
        return Response({"detail": "Inventory category not found or inactive."}, status=404)
    
    inventory_items = InventoryItems.objects.filter(inventory_category=inventory_category, status=0)

    if not inventory_items.exists():
        return Response({"detail": "No inventory items found for the given category."}, status=404)

    serializer = InventoryItemsSerializer(inventory_items, many=True, context={'language_code': language_code})
    
    return Response({
        "language": {
            "default": "en",
            "used": language_code
        },
        "data": serializer.data
    }, status=200)
 


# @api_view(['GET'])
# def get_inventory_category(request, inventory_type_id):
#     # Filter InventoryCategory by specific inventory_type_id and status == 0
#     inventory_categories = InventoryCategory.objects.filter(inventory_type_id=inventory_type_id, status=0)
    
#     # Prepare the category list with inventory_type_id
#     category_list = []
#     for category in inventory_categories:
#         category_data = {
#             'id': category.id,
#             'name': category.name,
#             'inventory_type_id': category.inventory_type.id if category.inventory_type else None  # Add inventory_type ID
#         }
#         category_list.append(category_data)

#     if not category_list:
#         return Response({"detail": "No categories found for the given inventory type."}, status=404)

#     return Response(category_list, status=200)


@api_view(['GET'])
def get_inventory_category(request, inventory_type_id):
    # Get the language code from query params or fallback to 'en' if not provided
    language_code = request.GET.get('lang', 'en')

    # Filter InventoryCategory by specific inventory_type_id and status == 0
    inventory_categories = InventoryCategory.objects.filter(inventory_type_id=inventory_type_id, status=0)

    # Prepare the category list with inventory_type_id
    category_list = []
    for category in inventory_categories:
        # Get the translated value for 'name' based on the language_code
        translated_name = category.get_translated_value("name", language_code)

        category_data = {
            'id': category.id,
            'name': translated_name,  # Use the translated name here
            'inventory_type_id': category.inventory_type.id if category.inventory_type else None  # Add inventory_type ID
        }
        category_list.append(category_data)

    if not category_list:
        return Response({"detail": "No categories found for the given inventory type."}, status=404)

    return Response(category_list, status=200)

@api_view(['GET'])
def get_Expenses(request):
    # Filter InventoryCategory with status == 0
    inventory_category = Expenses.objects.filter(status=0)
    serializer = ExpensesSerializer(inventory_category, many=True)
    return Response(serializer.data, status=200)
 
 
 

@api_view(['GET'])
def get_vendor(request, farmer_id): 
    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en' 

    # Filter the vendor data based on farmer_id and status
    vendor_data = MyVendor.objects.filter(farmer_id=farmer_id, status=0, is_customer_is_vendor=False)

    # Check if no vendors were found
    if not vendor_data:
        return Response({"detail": "No vendors found."}, status=status.HTTP_404_NOT_FOUND)

    # Prepare the response data manually without using serializers
    vendor_details = []
    for vendor in vendor_data:
        inventory_types = [inventory.get_translated_value("name", language_code) if inventory else "" for inventory in vendor.inventory_type.all()]
        
        vendor_details.append({
            'id': vendor.id,
            'farmer': vendor.farmer.get_translated_value("name", language_code) if vendor.farmer else "",
            'type': 'vendor',
            'name': vendor.get_translated_value("name", language_code) if vendor else "",
            'business_name': vendor.get_translated_value("business_name", language_code) if vendor else "",
            'inventory_type': ", ".join(inventory_types) if inventory_types else "",
            'email': vendor.email or "",
            'mobile_no': vendor.mobile_no or "",
            'alter_mobile_no': vendor.alter_mobile_no or "",
            'door_no': vendor.get_translated_value("door_no", language_code) if vendor else "",
            'country': vendor.country.get_translated_value("name", language_code) if vendor.country else "",
            'state': vendor.state.get_translated_value("name", language_code) if vendor.state else "",
            'city': vendor.city.get_translated_value("name", language_code) if vendor.city else "",
            'taluk': vendor.taluk.get_translated_value("name", language_code) if vendor.taluk else "",
            'village': vendor.village.get_translated_value("name", language_code) if vendor.village else "",
            'pincode': vendor.pincode or "",
            'gst_number': vendor.gst_number or "",
            'tax_number': vendor.tax_number or "",
            'credit': '+' if vendor.credit else '-',
            'opening_balance': vendor.opening_balance or 0,
            'vendor_image': request.build_absolute_uri(f'/SuperAdmin{vendor.vendor_image.url}') if vendor.vendor_image else "",
            'description': vendor.get_translated_value("description", language_code) if vendor else "",
            'language': {
                "default": "en"
            }
        })

    return Response(vendor_details, status=status.HTTP_200_OK)


@api_view(['GET'])
def get_vendor_details(request, farmer_id): 
    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en' 

    # Get vendor_id from query parameters
    vendor_id = request.query_params.get('vendor_id')

    if not vendor_id:
        return Response({"detail": "Vendor ID is required."}, status=status.HTTP_400_BAD_REQUEST)
    
    # Try to fetch the vendor based on both farmer_id and vendor_id
    try:
        vendor = MyVendor.objects.get(id=vendor_id, farmer_id=farmer_id, status=0)
    except MyVendor.DoesNotExist:
        return Response({"detail": "Vendor not found."}, status=status.HTTP_404_NOT_FOUND)

    # Get all the inventory types and join them as a string
    # inventory_types = [inventory.name for inventory in vendor.inventory_type.all()]
    inventory_types = [ inventory.get_translated_value("name", language_code) for inventory in vendor.inventory_type.all() ] if vendor else []

    # Prepare the vendor details
    vendor_details = {
        'id': vendor.id,
        'farmer': vendor.farmer.get_translated_value("name", language_code) if vendor.farmer else "", 
        # 'farmer': vendor.farmer.name if vendor.farmer else "",  # Using the farmer's name (or another attribute)
        'type': 'vendor',
        # 'name': vendor.name,
        'name': vendor.get_translated_value("name", language_code) if vendor else "",
        # 'business_name': vendor.business_name,
        'business_name': vendor.get_translated_value("business_name", language_code) if vendor else "",
        'inventory_type': ", ".join(inventory_types) if inventory_types else "",  # Join the names of all inventory types
        'email': vendor.email,
        'mobile_no': vendor.mobile_no,
        'alter_mobile_no': vendor.alter_mobile_no,
        # 'door_no_id': vendor.door_no.id,
        'door_no': vendor.get_translated_value("door_no", language_code) if language_code == 'ta' else vendor.door_no,
        'country_id': vendor.country.id if vendor.country else "",
        'country': vendor.country.get_translated_value("name", language_code) if vendor.country else "",
        'state_id': vendor.state.id if vendor.state else "",
        'state': vendor.state.get_translated_value("name", language_code) if vendor.state else "",
        'city_id': vendor.city.id if vendor.city else "",
        'city': vendor.city.get_translated_value("name", language_code) if vendor.city else "",
        'taluk_id': vendor.taluk.id if vendor.taluk else "",
        'taluk': vendor.taluk.get_translated_value("name", language_code) if vendor.taluk else "",
        'village_id': vendor.village.id if vendor.village else "",
        'village': vendor.village.get_translated_value("name", language_code) if vendor.village else "",
        'pincode': vendor.pincode,
        'gst_number': vendor.gst_number,
        'tax_number': vendor.tax_number,
        # 'credit': vendor.credit,
        # 'debit': vendor.debit,
        'is_credit': '+' if vendor.credit else '-',
        'opening_balance': vendor.opening_balance,
        # 'vendor_image': vendor.vendor_image.url if vendor.vendor_image else "",
        # 'vendor_image': request.build_absolute_uri(f'/assets{vendor.vendor_image.url}' if vendor.vendor_image else vendor.vendor_image.url) if vendor.vendor_image else "",
        "vendor_image": request.build_absolute_uri(f'/SuperAdmin{vendor.vendor_image.url}' if vendor.vendor_image else vendor.vendor_image.url) if vendor.vendor_image else "",
        # 'description': vendor.description,
        'description': vendor.get_translated_value("description", language_code) if vendor else "",
        'language': {
            "default": "en"
        }

    }

    # Return the vendor details in the response
    return Response(vendor_details, status=status.HTTP_200_OK)

@api_view(['GET'])
def get_customers_as_vendors(request, farmer_id):
    # Filter customers where 'is_customer_is_vendor' is True and 'farmer_id' matches
    customers_as_vendors = MyCustomer.objects.filter(farmer_id=farmer_id, is_customer_is_vendor=True, status=0)
    
    # Check if any customers are found
    if not customers_as_vendors:
        return Response({"detail": "No customers found who are marked as vendors."}, status=status.HTTP_404_NOT_FOUND)
    
    # Prepare the response data
    customer_data = []
    for customer in customers_as_vendors:
        customer_data.append({
            "id": customer.id,
            "farmer_id": customer.farmer.id if customer.farmer else None,
            "farmer": customer.farmer.name if customer.farmer else None,
            "customer_name": customer.customer_name,
            "shop_name": customer.shop_name,
            "mobile_no": customer.mobile_no,
            "email": customer.email,
            "market": ", ".join([market.name for market in customer.market.all()]),
            "door_no": customer.door_no,
            "country": customer.country.name if customer.country else None,
            "state": customer.state.name if customer.state else None,
            "city": customer.city.name if customer.city else None,
            "taluk": customer.taluk.name if customer.taluk else None,
            "village": customer.village.name if customer.village else None,
            "post_code": customer.post_code,
            "gst_no": customer.gst_no,
            "tax_no": customer.tax_no,
            "is_credit": customer.is_credit,
            "opening_balance": customer.opening_balance,
            # "customer_img": customer.customer_img.url if customer.customer_img else None,
            "customer_img": request.build_absolute_uri(f'/SuperAdmin{customer.customer_img.url}' if customer.customer_img else customer.customer_img.url) if customer.customer_img else "",
            "description": customer.description,
            "status": customer.status,
            "created_at": customer.created_at,
            "updated_at": customer.updated_at,
            "is_customer_is_vendor": customer.is_customer_is_vendor,
        })
    
    # Return the list of customers marked as vendors
    return Response(customer_data, status=status.HTTP_200_OK)

@api_view(['GET'])
def get_vendors_customer(request, farmer_id):
    # Filter vendors where 'is_customer_is_vendor' is True and 'farmer_id' matches
    vendors = MyVendor.objects.filter(farmer_id=farmer_id, is_customer_is_vendor=True, status=0)
    
    # Check if any vendors are found
    if not vendors:
        return Response({"detail": "No vendors found for this farmer."}, status=status.HTTP_404_NOT_FOUND)
    
    # Prepare the response data
    vendor_data = []
    for vendor in vendors:
        vendor_data.append({
            "id": vendor.id,
            "farmer_id": vendor.farmer.id if vendor.farmer else None,
            "farmer": vendor.farmer.name if vendor.farmer else None,
            "name": vendor.name,  # Mapping from vendor's name (equivalent to customer_name in customer)
            "business_name": vendor.business_name,  # Mapping from customer.shop_name
            "mobile_no": vendor.mobile_no,
            "email": vendor.email,
            "inventory_type": ", ".join([market.name for market in vendor.inventory_type.all()]),  # Assuming inventory_type is the relation field
            "door_no": vendor.door_no,
            "country": vendor.country.name if vendor.country else None,
            "state": vendor.state.name if vendor.state else None,
            "city": vendor.city.name if vendor.city else None,
            "taluk": vendor.taluk.name if vendor.taluk else None,
            "village": vendor.village.name if vendor.village else None,
            "post_code": vendor.pincode,  # Mapping from vendor's post_code
            "gst_no": vendor.gst_number,  # Mapping from customer.gst_no
            "tax_no": vendor.tax_number,  # Mapping from customer.tax_no
            "is_credit": vendor.credit,  # Mapping from customer.is_credit
            "opening_balance": vendor.opening_balance,
            "vendor_img": request.build_absolute_uri(f'/SuperAdmin{vendor.vendor_image.url}' if vendor.vendor_image else vendor.vendor_image.url) if vendor.vendor_image else "",
            "description": vendor.description,
            "status": vendor.status,
            "created_at": vendor.created_at,
            "updated_at": vendor.updated_at,
            "is_customer_is_vendor": vendor.is_customer_is_vendor,
        })
    
    # Return the list of vendors
    return Response(vendor_data, status=status.HTTP_200_OK)

@api_view(['GET'])
def get_vendors_from_customers(request, farmer_id):
    # Filter vendors where 'is_customer_is_vendor' is True and 'farmer_id' matches
    vendors = MyVendor.objects.filter(farmer_id=farmer_id)
    
    # Check if any vendors are found
    if not vendors:
        return Response({"detail": "No vendors found."}, status=status.HTTP_404_NOT_FOUND)
    
    # Prepare the response data
    vendor_data = []
    for vendor in vendors:
        vendor_data.append({
            "id": vendor.id,
            "farmer_id": vendor.farmer.id if vendor.farmer else None,
            "farmer_name": vendor.farmer.name if vendor.farmer else None,
            "vendor_name": vendor.name,
            "shop_name": vendor.business_name,
            "mobile_no": vendor.mobile_no,
            "email": vendor.email,
            "gst_no": vendor.gst_number,
            "tax_no": vendor.tax_number,
            "country": vendor.country.name if vendor.country else None,
            "state": vendor.state.name if vendor.state else None,
            "city": vendor.city.name if vendor.city else None,
            "taluk": vendor.taluk.name if vendor.taluk else None,
            "village": vendor.village.name if vendor.village else None,
            "post_code": vendor.pincode,
            "opening_balance": vendor.opening_balance,
            "status": vendor.status,
            "vendor_image": request.build_absolute_uri(f'/SuperAdmin{vendor.vendor_image.url}' if vendor.vendor_image else ""),
            "description": vendor.description,
            "created_at": vendor.created_at,
            "updated_at": vendor.updated_at
        })
    
    # Return the list of vendors
    return Response(vendor_data, status=status.HTTP_200_OK)

 

@api_view(['GET'])
def get_customer_vendor_details(request, farmer_id):
    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
        language_code = user_language_pref.language_code or 'en'
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'

    customer_id = request.query_params.get('customer_id', None)
    vendor_id = request.query_params.get('vendor_id', None)

    # Use only MyCustomer, assuming that vendor relationship is implied
    customers = MyCustomer.objects.filter(farmer_id=farmer_id, is_customer_is_vendor=True, status=0)
    if customer_id:
        customers = customers.filter(id=customer_id)

    try:
        settings = GeneralSetting.objects.first()
        date_format = convert_to_strftime_format(settings.date_format) if settings else '%d-%m-%Y'
    except Exception:
        date_format = '%d-%m-%Y'

    def format_date(date):
        return date.strftime(date_format) if date else ""

    response_data = []

    for customer in customers:
        # --- Sales Section ---
        customer_sales = MySales.objects.filter(my_customer=customer, status=0)
        sales_details = []
        for sale in customer_sales:
            sales_details.append({
                "sales_id": sale.id,
                "dates_of_sales": format_date(sale.dates_of_sales),
                "my_crop": sale.my_crop.crop.get_translated_value("name", language_code) if sale.my_crop else None,
                "sales_quantity": sale.sales_quantity,
                "sales_unit": sale.sales_unit.get_translated_value("name", language_code) if sale.sales_unit else None,
                "quantity_amount": sale.quantity_amount,
                "total_amount": sale.total_amount,
                "sales_amount": sale.sales_amount,
                "deduction_amount": sale.deduction_amount,
                "total_sales_amount": sale.total_sales_amount,
                "amount_paid": sale.amount_paid,
                "status": sale.status,
                "description": sale.get_translated_value("description", language_code) if sale else None,
                "created_at": sale.created_at,
                "updated_at": sale.updated_at,
            })

        # --- Purchase Section ---
        vendor = MyVendor.objects.filter(id=customer.id, farmer_id=farmer_id, is_customer_is_vendor=True,status=0).first()
        purchase_details = {}
        if vendor:
            def make_purchase_data(model, fields):
                items = model.objects.filter(vendor=vendor, status__in=[0, 1])
                return [
                    {
                        'id': item.id,
                        'purchase_date': format_date(getattr(item, 'date_of_consumption', None)),
                        'quantity': getattr(item, fields.get('quantity'), None),
                        'amount': getattr(item, fields.get('amount'), None),
                        'description': item.get_translated_value("description", language_code) if item else ""
                    } for item in items
                ]

            purchase_details = {
                'fuel': make_purchase_data(MyFuel, {'quantity': 'quantity', 'amount': 'purchase_amount'}),
                'machinery': make_purchase_data(MyMachinery, {'quantity': 'fuel_capacity', 'amount': 'purchase_amount'}),
                'tools': make_purchase_data(MyTools, {'quantity': 'quantity', 'amount': 'purchase_amount'}),
                'pesticides': make_purchase_data(MyPesticides, {'quantity': 'quantity', 'amount': 'purchase_amount'}),
                'seeds': make_purchase_data(MySeeds, {'quantity': 'quantity', 'amount': 'purchase_amount'}),
                'fertilizers': make_purchase_data(MyFertilizers, {'quantity': 'quantity', 'amount': 'purchase_amount'}),
                'vehicles': make_purchase_data(MyVehicle, {'quantity': 'quantity', 'amount': 'purchase_amount'}),
                'inventory_types': [it.name for it in vendor.inventory_type.all()] if vendor else []
            }

        response_data.append({
            "id": customer.id,
            "farmer_id": customer.farmer.id if customer.farmer else None,
            "farmer": customer.farmer.get_translated_value("name", language_code) if customer.farmer else "",
            "customer_name": customer.get_translated_value("customer_name", language_code) if customer else "",
            "shop_name": customer.get_translated_value("shop_name", language_code) if customer else "",
            "mobile_no": customer.mobile_no,
            "email": customer.email,
            "market": ", ".join([market.get_translated_value("name", language_code) for market in customer.market.all()]) if customer else "",
            "door_no": customer.get_translated_value("door_no", language_code) if language_code == 'ta' else customer.door_no,
            "country_id": customer.country.id,
            "country": customer.country.get_translated_value("name", language_code) if customer.country else "",
            "state_id": customer.state.id,
            "state": customer.state.get_translated_value("name", language_code) if customer.state else "",
            "city_id": customer.city.id,
            "city": customer.city.get_translated_value("name", language_code) if customer.city else "",
            "taluk_id": customer.taluk.id,
            "taluk": customer.taluk.get_translated_value("name", language_code) if customer.taluk else "",
            "village_id": customer.village.id,
            "village": customer.village.get_translated_value("name", language_code) if customer.village else "",
            "post_code": customer.post_code,
            "gst_no": customer.gst_no,
            "tax_no": customer.tax_no,
            "is_credit": customer.is_credit,
            "opening_balance": customer.opening_balance,
            "customer_img": request.build_absolute_uri(f'/SuperAdmin{customer.customer_img.url}' if customer.customer_img else "") if customer.customer_img else "",
            "description": customer.get_translated_value("description", language_code) if customer else "",
            "status": customer.status,
            "created_at": customer.created_at,
            "updated_at": customer.updated_at,
            "is_customer_is_vendor": customer.is_customer_is_vendor,
            "sales": sales_details,
            "purchase_details": purchase_details,
        })

    return Response({"data": response_data}, status=status.HTTP_200_OK)



@api_view(['GET'])
def get_vendors_and_purchase_details(request, farmer_id):
    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'

    # Get vendor_id from query parameters (optional)
    vendor_id = request.query_params.get('vendor_id', None)

    # Filter vendors based on farmer_id and other relevant filters
    vendors = MyVendor.objects.filter(farmer_id=farmer_id, status=0, is_customer_is_vendor=True)

    try:
        settings = GeneralSetting.objects.first()
        date_format = convert_to_strftime_format(settings.date_format) if settings else '%d-%m-%Y'  # Fallback to default format
    except Exception as e:
        date_format = '%d-%m-%Y'

    def format_date(date):
        return date.strftime(date_format) if date else ""    

    # If vendor_id is provided, filter further by vendor_id
    if vendor_id:
        vendors = vendors.filter(id=vendor_id)

    purchase_data = []  # This will hold the purchase details for each vendor
    for vendor in vendors:
        # Get purchase related to this vendor (e.g., fuel, machinery, tools, etc.)
        fuel_purchases = MyFuel.objects.filter(vendor=vendor, status__in=[0, 1])
        machinery_purchases = MyMachinery.objects.filter(vendor=vendor, status__in=[0, 1])
        tools_purchases = MyTools.objects.filter(vendor=vendor, status__in=[0, 1])
        pesticides_purchases = MyPesticides.objects.filter(vendor=vendor,status__in=[0, 1])
        seeds_purchases = MySeeds.objects.filter(vendor=vendor, status__in=[0, 1])
        fertilizers_purchases = MyFertilizers.objects.filter(vendor=vendor, status__in=[0, 1])
        vehicle_purchases = MyVehicle.objects.filter(vendor=vendor, status__in=[0, 1])  # New line for vehicle purchases

        # Convert MyFuel objects into JSON serializable format (e.g., dictionary)
        fuel_data = [
            {
                'id': fuel.id,
                'purchase_date': format_date(fuel.date_of_consumption),
                'quantity': fuel.quantity,
                'amount': fuel.purchase_amount,
                # 'description': fuel.description,
                'description': fuel.get_translated_value("description", language_code) if fuel else "",
            }
            for fuel in fuel_purchases
        ]

        machinery_data = [
            {
                'id': machinery.id,
                'purchase_date': format_date(machinery.date_of_consumption),
                'quantity': machinery.fuel_capacity,
                'amount': machinery.purchase_amount,
                # 'description': machinery.description,
                'description': machinery.get_translated_value("description", language_code) if machinery else "",
            }
            for machinery in machinery_purchases
        ]

        # Similarly, convert other purchase objects (tools, pesticides, etc.) to dictionaries
        tools_data = [
            {
                'id': tool.id,
                'purchase_date': format_date(tool.date_of_consumption),
                'quantity': tool.quantity,
                'amount': tool.purchase_amount,
                # 'description': tool.description,
                'description': tool.get_translated_value("description", language_code) if tool else "",
            }
            for tool in tools_purchases
        ]

        pesticides_data = [
            {
                'id': pesticide.id,
                'purchase_date': format_date(pesticide.date_of_consumption),
                'quantity': pesticide.quantity,
                'amount': pesticide.purchase_amount,
                # 'description': pesticide.description,
                'description': pesticide.get_translated_value("description", language_code) if pesticide else "",
            }
            for pesticide in pesticides_purchases
        ]

        seeds_data = [
            {
                'id': seed.id,
                'purchase_date': format_date(seed.date_of_consumption),
                'quantity': seed.quantity,
                'amount': seed.purchase_amount,
                # 'description': seed.description,
                'description': seed.get_translated_value("description", language_code) if seed else "",
            }
            for seed in seeds_purchases
        ]

        fertilizers_data = [
            {
                'id': fertilizer.id,
                'purchase_date': format_date(fertilizer.date_of_consumption),
                'quantity': fertilizer.quantity,
                'amount': fertilizer.purchase_amount,
                # 'description': fertilizer.description,
                'description': fertilizer.get_translated_value("description", language_code) if fertilizer else "",
            }
            for fertilizer in fertilizers_purchases
        ]

        # New block for vehicle purchases
        vehicle_data = [
            {
                'id': vehicle.id,
                'purchase_date': format_date(vehicle.date_of_consumption),
                # 'vehicle_type': vehicle.vehicle_type,
                # 'quantity': vehicle.quantity,
                # 'amount': vehicle.amount,
                # 'description': vehicle.description,
                'description': vehicle.get_translated_value("description", language_code) if vehicle else "",

            }
            for vehicle in vehicle_purchases
        ]

        # Retrieve inventory type names
        inventory_type_names = [inventory_type.name for inventory_type in vendor.inventory_type.all()]

        # Collect purchase details and vendor info into a dictionary
        purchase_details = {
            'fuel': fuel_data,
            'machinery': machinery_data,
            'tools': tools_data,
            'pesticides': pesticides_data,
            'seeds': seeds_data,
            'fertilizers': fertilizers_data,
            'vehicles': vehicle_data,  # Add the vehicles data here
            'inventory_types': inventory_type_names,
        }

        purchase_data.append({
            # 'vendor_id': vendor.id,
            # 'vendor_name': vendor.name,
            "id": vendor.id,
            "farmer_id": vendor.farmer.id if vendor.farmer else None,
            # "farmer": vendor.farmer.name if vendor.farmer else None,
            # "vendor_name": vendor.name,
            # "shop_name": vendor.business_name,
            "farmer": vendor.farmer.get_translated_value("name", language_code) if vendor.farmer else "",
            "vendor_name": vendor.get_translated_value("name", language_code) if vendor.name else "",
            "shop_name": vendor.get_translated_value("business_name", language_code) if vendor.business_name else "",
            "mobile_no": vendor.mobile_no,
            "email": vendor.email,
            "inventory_type": ", ".join(inventory_type_names),  # Use inventory type instead of market 
            # "door_no": vendor.door_no,
            # "country": vendor.country.name if vendor.country else None,
            # "state": vendor.state.name if vendor.state else None,
            # "city": vendor.city.name if vendor.city else None,
            # "taluk": vendor.taluk.name if vendor.taluk else None,
            # "village": vendor.village.name if vendor.village else None,
            "door_no": vendor.get_translated_value("door_no", language_code) if language_code == 'ta' else vendor.door_no,
            "country": vendor.country.get_translated_value("name", language_code) if vendor.country else "",
            "state": vendor.state.get_translated_value("name", language_code) if vendor.state else "",
            "city": vendor.city.get_translated_value("name", language_code) if vendor.city else "",
            "taluk": vendor.taluk.get_translated_value("name", language_code) if vendor.taluk else "",
            "village": vendor.village.get_translated_value("name", language_code) if vendor.village else "",
            "post_code": vendor.pincode,
            "gst_no": vendor.gst_number,
            # "tax_no": vendor.tax_number,
            "is_credit": vendor.credit,
            "opening_balance": vendor.opening_balance,
            "vendor_img": request.build_absolute_uri(f'/SuperAdmin{vendor.vendor_image.url}' if vendor.vendor_image else vendor.vendor_image.url) if vendor.vendor_image else "",
            # "description": vendor.description,
            "description": vendor.get_translated_value("description", language_code) if vendor else "",
            "status": vendor.status,
            "created_at": vendor.created_at,
            "updated_at": vendor.updated_at,
            'purchase_details': purchase_details,
        })

    return Response({'vendors': purchase_data}, status=status.HTTP_200_OK)

@api_view(['GET'])
def get_customers_as_vendors_details(request, farmer_id):
    # Check if customer_id is provided in the query parameters
    customer_id = request.query_params.get('customer_id')
    
    # Filter customers where 'is_customer_is_vendor' is True and 'farmer_id' matches
    if customer_id:
        # If a customer_id is provided, filter by it as well
        customers_as_vendors = MyCustomer.objects.filter(
            farmer_id=farmer_id, 
            is_customer_is_vendor=True, 
            status=0,
            id=customer_id
        )
    else:
        # If no customer_id is provided, get all customers for the farmer marked as vendors
        customers_as_vendors = MyCustomer.objects.filter(
            farmer_id=farmer_id, 
            is_customer_is_vendor=True, 
            status=0
        )
    
    # Check if any customers are found
    if not customers_as_vendors:
        return Response({"detail": "No customers found who are marked as vendors."}, status=status.HTTP_404_NOT_FOUND)
    
    # Prepare the response data
    customer_data = []
    for customer in customers_as_vendors:
        customer_data.append({
            "id": customer.id,
            "farmer_id": customer.farmer.id if customer.farmer else None,
            "farmer": customer.farmer.name if customer.farmer else None,
            "customer_name": customer.customer_name,
            "shop_name": customer.shop_name,
            "mobile_no": customer.mobile_no,
            "email": customer.email,
            "market": ", ".join([market.name for market in customer.market.all()]),
            "door_no": customer.door_no,
            "country": customer.country.name if customer.country else None,
            "state": customer.state.name if customer.state else None,
            "city": customer.city.name if customer.city else None,
            "taluk": customer.taluk.name if customer.taluk else None,
            "village": customer.village.name if customer.village else None,
            "post_code": customer.post_code,
            "gst_no": customer.gst_no,
            "tax_no": customer.tax_no,
            "is_credit": customer.is_credit,
            "opening_balance": customer.opening_balance,
            # If customer_img is available, build absolute URL
            "customer_img": request.build_absolute_uri(f'/SuperAdmin{customer.customer_img.url}' if customer.customer_img else customer.customer_img.url) if customer.customer_img else "",
            "description": customer.description,
            "status": customer.status,
            "created_at": customer.created_at,
            "updated_at": customer.updated_at,
            "is_customer_is_vendor": customer.is_customer_is_vendor,
        })
    
    # Return the list of customers marked as vendors
    return Response(customer_data, status=status.HTTP_200_OK)

@api_view(['POST'])
def get_vendor_purchase_details(request, farmer_id): 
    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en' 

    vendor_id = request.data.get('vendor_id')

    if not vendor_id:
        return Response({"detail": "Vendor ID is required."}, status=status.HTTP_400_BAD_REQUEST)
     
    try:
        vendor = MyVendor.objects.get(id=vendor_id, farmer_id=farmer_id, status=0, is_customer_is_vendor = False)
    except MyVendor.DoesNotExist:
        return Response({"detail": "Vendor not found."}, status=status.HTTP_404_NOT_FOUND)

    
    try:
        settings = GeneralSetting.objects.first()
        date_format = convert_to_strftime_format(settings.date_format) if settings else '%d-%m-%Y'  # Fallback to default format
    except Exception as e:
        date_format = '%d-%m-%Y'

    def format_date(date):
        return date.strftime(date_format) if date else ""  

    inventory_types = [ inventory.get_translated_value("name", language_code) for inventory in vendor.inventory_type.all() ] if vendor else []  
 
    # Get all the inventory types and join them as a string
    # inventory_types = [inventory.name for inventory in vendor.inventory_type.all()]
 
    vendor_details = {
        'id': vendor.id,
        # 'farmer': vendor.farmer.name if vendor.farmer else "",   
        # 'type': 'vendor',
        # 'name': vendor.name, 
        # 'inventory_type': ", ".join(inventory_types) if inventory_types else "",  
        # 'description': vendor.description,
        'farmer': vendor.farmer.get_translated_value("name", language_code) if vendor.farmer else "",   
        'type': { "en": "vendor", "ta": "à®µà®¿à®±à¯à®ªà®©à¯ˆà®¯à®¾à®³à®°à¯" }.get(language_code, "vendor"),
        'name': vendor.get_translated_value("name", language_code) if vendor else "", 
        'inventory_type': ", ".join(inventory_types) if inventory_types else "",  
        'description': vendor.get_translated_value("description", language_code) if vendor else "",
        'language': {
            "default": "en"
        }
    }

    # Fetch related MyFuel records for this vendor
    fuel_records = MyFuel.objects.filter(vendor=vendor, status__in=[0, 1])  # Assuming status 0 means active
    fuel_details = []

    # Prepare fuel details for each MyFuel record
    for fuel in fuel_records:
        fuel_data = {
            'id': fuel.id,
            'date_of_consumption': format_date(fuel.date_of_consumption),
            # 'inventory_type': fuel.inventory_type.name if fuel.inventory_type else "",
            # 'inventory_category': fuel.inventory_category.name if fuel.inventory_category else "",
            # 'inventory_item': fuel.inventory_items.name if fuel.inventory_items else "",
            'inventory_type': fuel.inventory_type.get_translated_value("name", language_code) if fuel.inventory_type else "",
            'inventory_category': fuel.inventory_category.get_translated_value("name", language_code) if fuel.inventory_category else "",
            'inventory_item': fuel.inventory_items.get_translated_value("name", language_code) if fuel.inventory_items else "",
            'quantity': fuel.quantity,
            'purchase_amount': fuel.purchase_amount,
            # 'description': fuel.description,
            'description': fuel.get_translated_value("description", language_code) if fuel else "",
            'available_quantity': fuel.available_quans, 
        }
        fuel_details.append(fuel_data)

    # Fetch related MyVehicle records for this vendor
    vehicle_records = MyVehicle.objects.filter(vendor=vendor, status__in=[0, 1])  # Assuming status 0 means active
    vehicle_details = []

    # Prepare vehicle details for each MyVehicle record
    for vehicle in vehicle_records:
        vehicle_data = {
            'id': vehicle.id,
            'date_of_consumption': format_date(vehicle.date_of_consumption),
            # 'inventory_type': vehicle.inventory_type.name if vehicle.inventory_type else "",
            # 'inventory_category': vehicle.inventory_category.name if vehicle.inventory_category else "",
            # 'inventory_item': vehicle.inventory_items.name if vehicle.inventory_items else "",
            'inventory_type': vehicle.inventory_type.get_translated_value("name", language_code) if vehicle.inventory_type else "",
            'inventory_category': vehicle.inventory_category.get_translated_value("name", language_code) if vehicle.inventory_category else "",
            'inventory_item': vehicle.inventory_items.get_translated_value("name", language_code) if vehicle.inventory_items else "",
            'register_number': vehicle.register_number,
            # 'owner_name': vehicle.owner_name,
            'owner_name': vehicle.get_translated_value("owner_name", language_code) if vehicle.owner_name else "",
            'date_of_registration': format_date(vehicle.date_of_registration),
            'registration_valid_till': format_date(vehicle.registration_valid_till),
            'engine_number': vehicle.engine_number,
            'chasis_number': vehicle.chasis_number,
            'running_kilometer': vehicle.running_kilometer,
            'service_frequency': vehicle.service_frequency,
            'service_frequency_unit': vehicle.service_frequency_unit,
            'fuel_capacity': vehicle.fuel_capacity,
            'average_mileage': vehicle.average_mileage,
            'purchase_amount': vehicle.purchase_amount,
            'insurance': vehicle.insurance,
            # 'company_name': vehicle.company_name,
            'company_name': vehicle.get_translated_value("company_name", language_code) if vehicle.company_name else "",
            'insurance_no': vehicle.insurance_no,
            'insurance_amount': vehicle.insurance_amount,
            'insurance_start_date': format_date(vehicle.insurance_start_date),
            'insurance_end_date': format_date(vehicle.insurance_end_date),
            'insurance_renewal_date': format_date(vehicle.insurance_renewal_date),
            # 'description': vehicle.description,
            'description': vehicle.get_translated_value("description", language_code) if vehicle else "",
            'available_quantity': vehicle.available_quans,
        }
        vehicle_details.append(vehicle_data)

    # Fetch related MyMachinery records for this vendor
    machinery_records = MyMachinery.objects.filter(vendor=vendor, status__in=[0, 1])  # Assuming status 0 means active
    machinery_details = []

    # Prepare machinery details for each MyMachinery record
    for machinery in machinery_records:
        machinery_data = {
            'id': machinery.id,
            'date_of_consumption': format_date(machinery.date_of_consumption), 
            'inventory_type': machinery.inventory_type.get_translated_value("name", language_code) if machinery.inventory_type else "",
            'inventory_category': machinery.inventory_category.get_translated_value("name", language_code) if machinery.inventory_category else "",
            'inventory_item': machinery.inventory_items.get_translated_value("name", language_code) if machinery.inventory_items else "",
            'purchase_amount': machinery.purchase_amount, 
        }
        machinery_details.append(machinery_data)

    # Fetch related MyTools records for this vendor
    tool_records = MyTools.objects.filter(vendor=vendor, status__in=[0, 1])  # Assuming status 0 means active
    tool_details = []

    # Prepare tool details for each MyTool record
    for tool in tool_records:
        tool_data = {
            'id': tool.id,
            'date_of_consumption': format_date(tool.date_of_consumption),
            # 'inventory_type': tool.inventory_type.name if tool.inventory_type else "",
            # 'inventory_category': tool.inventory_category.name if tool.inventory_category else "",
            # 'inventory_item': tool.inventory_items.name if tool.inventory_items else "", 
            'inventory_type': tool.inventory_type.get_translated_value("name", language_code) if tool.inventory_type else "",
            'inventory_category': tool.inventory_category.get_translated_value("name", language_code) if tool.inventory_category else "",
            'inventory_item': tool.inventory_items.get_translated_value("name", language_code) if tool.inventory_items else "", 
            'purchase_amount': tool.purchase_amount, 
        }
        tool_details.append(tool_data)

    # Fetch related MyPesticides records for this vendor
    pesticide_records = MyPesticides.objects.filter(vendor=vendor, status__in=[0, 1])  # Assuming status 0 means active
    pesticide_details = []

    # Prepare pesticide details for each MyPesticides record
    for pesticide in pesticide_records:
        pesticide_data = {
            'id': pesticide.id,
            'date_of_consumption': format_date(pesticide.date_of_consumption),
            # 'inventory_type': pesticide.inventory_type.name if pesticide.inventory_type else "",
            # 'inventory_category': pesticide.inventory_category.name if pesticide.inventory_category else "",
            # 'inventory_item': pesticide.inventory_items.name if pesticide.inventory_items else "", 
            'inventory_type': pesticide.inventory_type.get_translated_value("name", language_code) if pesticide.inventory_type else "",
            'inventory_category': pesticide.inventory_category.get_translated_value("name", language_code) if pesticide.inventory_category else "",
            'inventory_item': pesticide.inventory_items.get_translated_value("name", language_code) if pesticide.inventory_items else "", 
            'purchase_amount': pesticide.purchase_amount, 
        }
        pesticide_details.append(pesticide_data)

    # Fetch related MyFertilizers records for this vendor
    fertilizer_records = MyFertilizers.objects.filter(vendor=vendor, status__in=[0, 1])  # Assuming status 0 means active
    fertilizer_details = []

    # Prepare fertilizer details for each MyFertilizers record
    for fertilizer in fertilizer_records:
        fertilizer_data = {
            'id': fertilizer.id,
            'date_of_consumption': format_date(fertilizer.date_of_consumption),
            # 'inventory_type': fertilizer.inventory_type.name if fertilizer.inventory_type else "",
            # 'inventory_category': fertilizer.inventory_category.name if fertilizer.inventory_category else "",
            # 'inventory_item': fertilizer.inventory_items.name if fertilizer.inventory_items else "", 
            'inventory_type': fertilizer.inventory_type.get_translated_value("name", language_code) if fertilizer.inventory_type else "",
            'inventory_category': fertilizer.inventory_category.get_translated_value("name", language_code) if fertilizer.inventory_category else "",
            'inventory_item': fertilizer.inventory_items.get_translated_value("name", language_code) if fertilizer.inventory_items else "", 
            'purchase_amount': fertilizer.purchase_amount, 
        }
        fertilizer_details.append(fertilizer_data)

    # Fetch related MySeeds records for this vendor
    seed_records = MySeeds.objects.filter(vendor=vendor, status__in=[0, 1])  # Assuming status 0 means active
    seed_details = []

    # Prepare seed details for each MySeeds record
    for seed in seed_records:
        seed_data = {
            'id': seed.id,
            'date_of_consumption': format_date(seed.date_of_consumption),
            # 'inventory_type': seed.inventory_type.name if seed.inventory_type else "",
            # 'inventory_category': seed.inventory_category.name if seed.inventory_category else "",
            # 'inventory_item': seed.inventory_items.name if seed.inventory_items else "", 
            'inventory_type': seed.inventory_type.get_translated_value("name", language_code) if seed.inventory_type else "",
            'inventory_category': seed.inventory_category.get_translated_value("name", language_code) if seed.inventory_category else "",
            'inventory_item': seed.inventory_items.get_translated_value("name", language_code) if seed.inventory_items else "", 
            'purchase_amount': seed.purchase_amount, 
        }
        seed_details.append(seed_data)

    # Add all records to the vendor details
    vendor_details['fuel_records'] = fuel_details
    vendor_details['vehicle_records'] = vehicle_details
    vendor_details['machinery_records'] = machinery_details
    vendor_details['tool_records'] = tool_details
    vendor_details['pesticide_records'] = pesticide_details
    vendor_details['fertilizer_records'] = fertilizer_details
    vendor_details['seed_records'] = seed_details

    # Return the vendor details with all the records in the response
    return Response(vendor_details, status=status.HTTP_200_OK)
 
@api_view(['GET'])
def get_customer_list(request, farmer_id):

    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'

    # Filter customers by farmer_id and status (status=0 is active)
    customers = MyCustomer.objects.filter(farmer_id=farmer_id, status=0, is_customer_is_vendor=False)
    
    # Check if customers exist for the given farmer_id
    if not customers.exists():
        return Response({"message": "No customers found for the given farmer."}, status=status.HTTP_404_NOT_FOUND)
    
    # Prepare the response data manually without using serializers
    customer_details = []
    for customer in customers:
        # Get all the markets associated with the customer and join them as a list of names
        # market_names = [market.name for market in customer.market.all()]
        # market_names = [market.get_translated_value("name", language_code) if language_code == "ta" else market for market in customer.market.all()]
        market_names = [
            market.get_translated_value("name", language_code) if language_code == "ta" else market.name
            for market in customer.market.all()
        ]

        customer_details.append({
            'id': customer.id, 
            'farmer': customer.farmer.get_translated_value("name", language_code) if customer.farmer else "",  
            'customer_name': customer.get_translated_value("customer_name",language_code) if customer else "", 
            # 'farmer': customer.farmer.name if customer.farmer else "",  
            # 'customer_name': customer.customer_name,
            'type': 'customer',   
            # 'shop_name': customer.shop_name,
            'shop_name': customer.get_translated_value("shop_name", language_code) if customer else "",
            'mobile_no': customer.mobile_no,
            'email': customer.email,
            'market': market_names,  # List of markets
            'door_no': customer.get_translated_value("door_no", language_code) if language_code == 'ta' else customer.door_no,
            'country': customer.country.get_translated_value("name", language_code) if customer.country else "", 
            'state': customer.state.get_translated_value("name", language_code) if customer.state else "", 
            'city': customer.city.get_translated_value("name", language_code) if customer.city else "",  
            'taluk': customer.taluk.get_translated_value("name", language_code) if customer.taluk else "",  
            'village': customer.village.get_translated_value("name", language_code) if customer.village else "",
            # 'door_no': customer.door_no,
            # 'country': customer.country.name if customer.country else "", 
            # 'state': customer.state.name if customer.state else "", 
            # 'city': customer.city.name if customer.city else "",  
            # 'taluk': customer.taluk.name if customer.taluk else "",  
            # 'village': customer.village.name if customer.village else "",   
            'post_code': customer.post_code,
            'gst_no': customer.gst_no,
            'tax_no': customer.tax_no,
            'is_credit': customer.is_credit,
            'opening_balance': customer.opening_balance,
            # 'customer_img': customer.customer_img.url if customer.customer_img else "",  
            "customer_img": request.build_absolute_uri(f'/SuperAdmin{customer.customer_img.url}' if customer.customer_img else customer.customer_img.url) if customer.customer_img else "",
            # 'description': customer.description,
            'description': customer.get_translated_value("description", language_code) if customer else "",
            'is_customer_is_vendor': customer.is_customer_is_vendor,
            'language': {
                'default': "en"
            }
        })

    # Return the data as a response
    return Response(customer_details, status=status.HTTP_200_OK)
 
@api_view(['GET'])
def get_customer_details(request, farmer_id): 
    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'

    customer_id = request.query_params.get('customer_id')
     
    if not customer_id:
        return Response({"detail": "customer_id is required."}, status=status.HTTP_400_BAD_REQUEST)
    
    try: 
        customer = MyCustomer.objects.get(farmer_id=farmer_id, id=customer_id, status=0, is_customer_is_vendor=False)
    except MyCustomer.DoesNotExist:
        return Response({"detail": "Customer not found."}, status=status.HTTP_404_NOT_FOUND)
     
    customer_details = {
        'id': customer.id,
        'farmer': customer.farmer.get_translated_value("name", language_code) if customer.farmer else "",
        'customer_name': customer.get_translated_value("customer_name", language_code) if customer else "",
        'shop_name': customer.get_translated_value("shop_name", language_code) if customer else "",
        # 'farmer': customer.farmer.name if customer.farmer else "",
        # 'customer_name': customer.customer_name,
        # 'shop_name': customer.shop_name,
        'mobile_no': customer.mobile_no,
        'email': customer.email,
        # 'market': ", ".join([market.name for market in customer.market.all()]),
        'market': ", ".join([ market.get_translated_value("name", language_code) for market in customer.market.all()]) if customer else "", 
        # 'door_no': customer.door_no,
        'door_no': customer.get_translated_value("door_no", language_code) if customer else "",
        'country_id': customer.country.id,
        'country': customer.country.get_translated_value("name", language_code) if customer.country else "",
        'state_id': customer.state.id,
        'state': customer.state.get_translated_value("name", language_code) if customer.state else "",
        'city_id': customer.city.id,
        'city': customer.city.get_translated_value("name", language_code) if customer.city else "",
        'taluk_id': customer.taluk.id,
        'taluk': customer.taluk.get_translated_value("name", language_code) if customer.taluk else "",
        'village_id': customer.village.id,
        'village': customer.village.get_translated_value("name", language_code) if customer.village else "",
        'post_code': customer.post_code,
        'gst_no': customer.gst_no,
        'tax_no': customer.tax_no,
        'is_credit': customer.is_credit,
        'opening_balance': customer.opening_balance,
        # 'customer_img': customer.customer_img.url if customer.customer_img else "",
        "customer_img": request.build_absolute_uri(f'/SuperAdmin{customer.customer_img.url}' if customer.customer_img else customer.customer_img.url) if customer.customer_img else "",
        # 'description': customer.description,
        'description': customer.get_translated_value("description", language_code) if customer else "",
        'status': customer.status, 
        'created_at': customer.created_at,
        'updated_at': customer.updated_at,
        'is_customer_is_vendor': customer.is_customer_is_vendor,
        'language': {
            "default": "en"
        }
    }
    
    return Response(customer_details, status=status.HTTP_200_OK)

@api_view(['GET'])
def get_crop_list(request):
    # Filter InventoryCategory with status == 0
    inventory_category = Crop.objects.filter(status=0)
    serializer = CropSerializer(inventory_category, many=True)
    return Response(serializer.data, status=200)

@api_view(['GET'])
def get_kilo_list(request):
    # Filter InventoryCategory with status == 0
    inventory_category = AreaUnit.objects.filter(status=0)
    serializer = AreaUnitSerializer(inventory_category, many=True)
    return Response(serializer.data, status=200)

@api_view(['GET'])
def get_maket_name_list(request):
    # Filter InventoryCategory with status == 0
    inventory_category = ManageMarket.objects.filter(status=0)
    serializer = ManageMarketSerializer(inventory_category, many=True)
    return Response(serializer.data, status=200)

@api_view(['POST'])
def get_sales_list(request, farmer_id):
    try:
        # Fetch the farmer by ID
        farmer = Farmer.objects.get(id=farmer_id)
    except Farmer.DoesNotExist:
        return Response({"detail": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)

    # Extract filter type from the payload
    filter_type = request.data.get('filter_type', 'week')  # Default to 'week' if not provided
    sales_queryset = MySales.objects.filter(status=0, farmer=farmer)

    # Calculate date range based on filter type
    if filter_type == 'week':
        start_date = timezone.now() - timedelta(days=7)
    elif filter_type == 'month':
        start_date = timezone.now() - timedelta(days=30)
    elif filter_type == 'year':
        start_date = timezone.now() - timedelta(days=365) 
    else:
        return Response(
            {
                "success": False,
                "message": "Invalid filter type. Must be 'week', 'month', or 'year'."
            },
            status=400
        )

    # Filter sales queryset by date range
    sales_queryset = sales_queryset.filter(dates_of_sales__gte=start_date)

    # Calculate the sum of total_sales_amount
    total_sales_sum = sales_queryset.aggregate(
        total_sales_sum=Sum(
            Cast(F('total_sales_amount'), FloatField())
        )
    )['total_sales_sum'] or 0

    # Prepare the custom response
    response_data = []
    for sale in sales_queryset:
        response_data.append({
            "customer_name": sale.my_customer.customer_name if sale.my_customer else None,
            "sales_id": sale.id if sale.id else None,
            "dates_of_sales": sale.dates_of_sales,
            "state_name": sale.my_customer.state.name if sale.my_customer and sale.my_customer.state else None,
            "village_name": sale.my_customer.village.name if sale.my_customer and sale.my_customer.village else None,
            "taluka_name": sale.my_customer.taluk.name if sale.my_customer and sale.my_customer.taluk else None,
            "total_sales_amount": sale.total_sales_amount,
        })

    # Add total sum to the response
    return Response({
        "sales": response_data,
        "total_sales_sum": total_sales_sum,
    }, status=200)

@api_view(['POST'])
def expenses_dashboard(request, farmer_id):
    try:
        # Fetching farmer data
        farmer = Farmer.objects.get(id=farmer_id)
    except Farmer.DoesNotExist:
        return Response({"message": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)

    # Getting filter type from the request data
    filter_type = request.data.get('filter_type', 'week')

    # Initializing queryset for expenses
    expenses_queryset = MyExpense.objects.filter(farmer=farmer, status=0)

    # Determine the start date based on filter type
    if filter_type == 'week':
        start_date = timezone.now() - timedelta(days=7)
    elif filter_type == 'month':
        start_date = timezone.now() - timedelta(days=30)
    elif filter_type == 'year':
        start_date = timezone.now() - timedelta(days=365)
    else:
        return Response(
            {
                "success": False,
                "message": "Invalid filter type. Must be 'week', 'month', or 'year'."
            },
            status=400
        )

    # Apply date filter to the expenses queryset
    expenses_queryset = expenses_queryset.filter(created_day__gte=start_date)

    # Summing the total expense amount
    total_expense_sum = expenses_queryset.aggregate(total_expense_sum=Sum('amount'))['total_expense_sum'] or 0

    # Building the normal list with expense details
    normal_list = []
    for expense in expenses_queryset:
        normal_list.append({
            "expense_name": expense.type_expenses.name if expense.type_expenses else None,
            "date": expense.created_day,
            "crop_name": expense.my_crop.crop.name if expense.my_crop and expense.my_crop.crop else None,
            "amount": expense.amount,
            "type": "expense"
        })

    # Fetching purchase data (similar to what we had before)
    def serialize_data(queryset):
        data = []
        for item in queryset:
            serialized_item = {
                "vendor_id": item.vendor.id if item.vendor else None,
                "vendor_name": item.vendor.name if item.vendor else None,
                "purchase_amount": float(item.purchase_amount) if item.purchase_amount else 0.0,
                "inventory_items": item.inventory_items_id,
                "inventory_item_name": item.inventory_items.name if item.inventory_items else None,
                "date_of_consumption": item.date_of_consumption,  # Make sure to include this field
            }
            data.append(serialized_item)
        return data

    fuel_data = MyFuel.objects.filter(farmer_id=farmer_id).select_related('inventory_items', 'vendor')
    vehicle_data = MyVehicle.objects.filter(farmer_id=farmer_id).select_related('inventory_items', 'vendor')
    machinery_data = MyMachinery.objects.filter(farmer_id=farmer_id).select_related('inventory_items', 'vendor')
    tools_data = MyTools.objects.filter(farmer_id=farmer_id).select_related('inventory_items', 'vendor')
    pesticides_data = MyPesticides.objects.filter(farmer_id=farmer_id).select_related('inventory_items', 'vendor')
    fertilizers_data = MyFertilizers.objects.filter(farmer_id=farmer_id).select_related('inventory_items', 'vendor')
    seeds_data = MySeeds.objects.filter(farmer_id=farmer_id).select_related('inventory_items', 'vendor')

    fuel_serialized = serialize_data(fuel_data)
    vehicle_serialized = serialize_data(vehicle_data)
    machinery_serialized = serialize_data(machinery_data)
    tools_serialized = serialize_data(tools_data)
    pesticides_serialized = serialize_data(pesticides_data)
    fertilizers_serialized = serialize_data(fertilizers_data)
    seeds_serialized = serialize_data(seeds_data)

    # Add purchase details into the normal list
    total_purchase_sum = 0  # Initialize purchase sum
    for purchase in fuel_serialized + vehicle_serialized + machinery_serialized + tools_serialized + pesticides_serialized + fertilizers_serialized + seeds_serialized:
        normal_list.append({
            "expense_name": purchase.get("inventory_item_name"),
            "date": purchase.get("date_of_consumption") or " ",  # Access the date_of_consumption field
            "crop_name": " ",  # Crop information is not related to purchases directly, can adjust
            "amount": purchase.get("purchase_amount"),
            "type": "purchase"
        })
        total_purchase_sum += purchase.get("purchase_amount", 0)  # Update total purchase sum

    # Formatting formatted purchases (similar to formatted_expenses)
    formatted_purchases = []
    for purchase in fuel_serialized + vehicle_serialized + machinery_serialized + tools_serialized + pesticides_serialized + fertilizers_serialized + seeds_serialized:
        purchase_amount = purchase.get("purchase_amount", 0)
        formatted_amount = f"{purchase_amount / 1000:.1f}k" if purchase_amount >= 1000 else f"{purchase_amount:.0f}"
        percentage = (purchase_amount / total_purchase_sum) * 100 if total_purchase_sum > 0 else 0
        formatted_purchases.append({
            "expense_name": purchase.get("inventory_item_name"),
            "formatted_amount": formatted_amount,
            "percentage": round(percentage, 2),
            "type": "purchase"
        })

    # Grouping expenses by type
    grouped_expenses = defaultdict(lambda: 0)
    for expense in expenses_queryset:
        expense_name = expense.type_expenses.name if expense.type_expenses else None
        grouped_expenses[expense_name] += expense.amount or 0

    # Formatting grouped expenses
    formatted_expenses = []
    for expense_name, total_amount in grouped_expenses.items():
        formatted_amount = f"{total_amount / 1000:.1f}k" if total_amount >= 1000 else f"{total_amount:.0f}"
        percentage = (total_amount / total_expense_sum) * 100 if total_expense_sum > 0 else 0
        formatted_expenses.append({
            "expense_name": expense_name,
            "formatted_amount": formatted_amount,
            "percentage": round(percentage, 2),
            "type": "expense"
        })

    # Combine formatted purchases and formatted expenses into one list
    combined_expenses = formatted_expenses + formatted_purchases

    # Final response
    return Response({
        "success": True,
        "normal_list": normal_list,
        "formatted_expenses": combined_expenses,
        "total_expense_sum": total_expense_sum,
        "total_purchase_sum": total_purchase_sum,
    }, status=200)

@api_view(['GET'])
def get_purchase_list(request, farmer_id):
    # Retrieve data filtered by the farmer_id
    fuel_data = MyFuel.objects.filter(farmer_id=farmer_id).select_related('inventory_items', 'vendor')
    vehicle_data = MyVehicle.objects.filter(farmer_id=farmer_id).select_related('inventory_items', 'vendor')
    machinery_data = MyMachinery.objects.filter(farmer_id=farmer_id).select_related('inventory_items', 'vendor')
    tools_data = MyTools.objects.filter(farmer_id=farmer_id).select_related('inventory_items', 'vendor')
    pesticides_data = MyPesticides.objects.filter(farmer_id=farmer_id).select_related('inventory_items', 'vendor')
    fertilizers_data = MyFertilizers.objects.filter(farmer_id=farmer_id).select_related('inventory_items', 'vendor')
    seeds_data = MySeeds.objects.filter(farmer_id=farmer_id).select_related('inventory_items', 'vendor')

    def serialize_data(queryset):
        " ""Helper function to add inventory item and vendor details to the serialized data."" "
        data = []
        for item in queryset:
            serialized_item = {
                "vendor_id": item.vendor.id if item.vendor else " ",
                "vendor_name": item.vendor.name if item.vendor else " ",
                "purchase_amount": float(item.purchase_amount) if item.purchase_amount else 0.0,
                "inventory_items": item.inventory_items_id,
                "inventory_item_name": item.inventory_items.name if item.inventory_items else " ",
                # "crop_name": item.inventory_items.crop.name if item.inventory_items and item.inventory_items.crop else " ",  # Ensure crop_name is fetched
                "date_of_consumption": item.date_of_consumption if hasattr(item, 'date_of_consumption') else " ",  # Fetch date of consumption correctly
            }
            data.append(serialized_item)
        return data

    # Serialize each dataset
    fuel_serialized = serialize_data(fuel_data)
    vehicle_serialized = serialize_data(vehicle_data)
    machinery_serialized = serialize_data(machinery_data)
    tools_serialized = serialize_data(tools_data)
    pesticides_serialized = serialize_data(pesticides_data)
    fertilizers_serialized = serialize_data(fertilizers_data)
    seeds_serialized = serialize_data(seeds_data)

    # Collect all purchase data
    all_purchase_data = fuel_serialized + vehicle_serialized + machinery_serialized + tools_serialized + pesticides_serialized + fertilizers_serialized + seeds_serialized

    # Create the normal list with expenses and purchases
    normal_list = []
    total_expense_sum = 0  # Sum up total purchases
    for purchase in all_purchase_data:
        normal_list.append({
            "expense_name": purchase.get("inventory_item_name"),
            "date": purchase.get("date_of_consumption") or " ",  # Ensure date is correctly added
            "crop_name": purchase.get("crop_name") or " ",  # Ensure crop_name is included
            "amount": purchase.get("purchase_amount"),
            "type": "purchase"
        })
        total_expense_sum += purchase.get("purchase_amount", 0)

    # Formatting purchases for response
    formatted_expenses = []
    for purchase in all_purchase_data:
        purchase_amount = purchase.get("purchase_amount", 0)
        formatted_amount = f"{purchase_amount / 1000:.1f}k" if purchase_amount >= 1000 else f"{purchase_amount:.0f}"
        percentage = (purchase_amount / total_expense_sum) * 100 if total_expense_sum > 0 else 0
        formatted_expenses.append({
            "expense_name": purchase.get("inventory_item_name"),
            "formatted_amount": formatted_amount,
            "percentage": round(percentage, 2),
            "type": "purchase"
        })

    # Final response
    response_data = {
        "success": True,
        "normal_list": normal_list,
        "formatted_expenses": formatted_expenses,
        "total_expense_sum": total_expense_sum,
    }

    return Response(response_data, status=status.HTTP_200_OK)

@api_view(['POST'])
def view_sales(request, farmer_id):
    # Extract the sales ID from the request payload
    sales_id = request.data.get('id')
    if not sales_id:
        return Response({
            "success": False,
            "message": "Sales ID is required."
        }, status=400)

    try:
        # Fetch the specific sales record where status is active (0) and belongs to the farmer
        sale = MySales.objects.select_related(
            'my_customer__state', 
            'my_customer__village', 
            'my_customer__taluk',
            'my_crop__crop', 
            'my_crop__land'
        ).get(id=sales_id, status=0, my_customer__farmer_id=farmer_id)  # Check via MyCustomer's farmer_id

    except MySales.DoesNotExist:
        return Response({
            "success": False,
            "message": "Sales record not found or does not belong to the specified farmer."
        }, status=404)

    # Prepare the response with all details
    response_data = {
        "customer_name": sale.my_customer.customer_name if sale.my_customer else None,
        "dates_of_sales": sale.dates_of_sales,
        "sales_id": sale.id,
        "customer_id": sale.my_customer.id,
        "state_name": sale.my_customer.state.name if sale.my_customer and sale.my_customer.state else None,
        "state_id": sale.my_customer.state.id if sale.my_customer and sale.my_customer.state else None,
        "village_name": sale.my_customer.village.name if sale.my_customer and sale.my_customer.village else None,
        "village_id": sale.my_customer.village.id if sale.my_customer and sale.my_customer.village else None,
        "taluka_name": sale.my_customer.taluk.name if sale.my_customer and sale.my_customer.taluk else None,
        "taluka_id": sale.my_customer.taluk.id if sale.my_customer and sale.my_customer.taluk else None,
        "total_sales_amount": sale.total_sales_amount,
        "gross_amount": sale.sales_amount,
        "deduction_amount": sale.deduction_amount,
        "crop_details": {
            "crop_name": sale.my_crop.crop.name if sale.my_crop else None,
            "crop_id": sale.my_crop.crop.id if sale.my_crop else None,
            "crop_image_url": sale.my_crop.crop.img if sale.my_crop and hasattr(sale.my_crop, 'img') else None,
        },
        "land_details": {
            "land_name": sale.my_crop.land.name if sale.my_crop and hasattr(sale.my_crop, 'land') else None,
            "land_id": sale.my_crop.land.id if sale.my_crop and hasattr(sale.my_crop, 'land') else None,
        },
        "description": sale.description,
        "documents": [
            {
                "category": doc.document_category.name if doc.document_category else None,
                "category_id": doc.document_category.id if doc.document_category else None,
                "doc_id": doc.id if doc.id else None,
                "file_url": doc.file_upload.url if doc.file_upload else None,
            } for doc in sale.salesdocument_set.all()
        ],
        "deductions": [
            {
                "reason": deduction.reason.name if deduction.reason else None,
                "deduction_id": deduction.id if deduction.id else None,
                "charges": deduction.charges,
                "rupee": deduction.rupee.name if deduction.rupee else None,
                "code": deduction.code,
            } for deduction in sale.deductionreasons_set.all()
        ],
    }

    return Response({
        "success": True,
        "sales": response_data,
    }, status=200)

@api_view(['POST'])
def add_deduction(request):
    many = isinstance(request.data, list)
    data = request.data
    
    # Fetch reason name based on reason_deducation ID
    reason_id = data.get("reason_deducation")
    reason_name = None
    if reason_id:
        try:
            reason_name = Reasons.objects.get(id=reason_id).name  # Adjust model and field name
        except Reasons.DoesNotExist:
            return Response(
                {
                    "success": False,
                    "message": f"Invalid reason ID: {reason_id}", "language":{
                "default":"en"
            }
                },
                
                status=status.HTTP_400_BAD_REQUEST
            )
    else:
        return Response(
            {
                "success": False,
                "message": "Reason ID is required.",
                "language":{
                "default":"en"
            }
            },
             
            status=status.HTTP_400_BAD_REQUEST
        )
    
    # Calculate deduction based on type (percentage or rupees)
    deduction_type = data.get("deducation_precentage_ruppes")  # 1 = percentage, 0 = rupees
    amount = float(data.get("amount", 0))  # Input amount
    deducted_amount = 0

    if deduction_type == 1:  # Percentage
        deduction_percentage = float(data.get("deduction_percentage", 0))  # Assuming percentage is in the payload
        deducted_amount = amount * (deduction_percentage / 100)
    elif deduction_type == 0:  # Rupees
        deducted_amount = float(data.get("deduction_amount", 0))  # Assuming rupee deduction amount in the payload
    else:
        return Response(
            {
                "success": False,
                "message": "Invalid deduction type. Must be 1 (percentage) or 0 (rupees).",
                "language":{
                "default":"en"
            }
            },
            
            status=status.HTTP_400_BAD_REQUEST
        )
    
    # Prepare response data
    processed_data = {
        "reason_name": reason_name,
        "deduction_type": "Percentage" if deduction_type == 1 else "Rupees",
        "original_amount": amount,
        "deducted_amount": deducted_amount,
        "final_amount": amount - deducted_amount
    }

    return Response(
        {
            "success": True,
            "message": "Deduction calculated successfully!",
            "data": processed_data,
            "language":{
                "default":"en"
            }
        },
        status=status.HTTP_200_OK
    )
 
def validate_image_type(document_base64):
    if document_base64.startswith("data:image/"):
        return document_base64.split(';')[0].split(':')[1]
    elif document_base64.startswith("data:application/pdf"):
        return "application/pdf"
    return None

# @api_view(['POST'])
# def add_sales_with_deductions(request, farmer_id):
#     try:
#         # Fetch the farmer object using the farmer_id from the URL
#         farmer = Farmer.objects.get(id=farmer_id)
#     except Farmer.DoesNotExist:
#         return Response({"detail": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)

#     # Fetch active subscription of the farmer
#     subscription = AddSubcription.objects.filter(farmers=farmer, status=0).first()  # Active subscription (status=0)
#     if not subscription:
#         return Response({"detail": "Farmer does not have an active subscription."}, status=status.HTTP_400_BAD_REQUEST)

#     # Check if the farmer has reached their sale limit
#     mysale_count_limit = subscription.packages.mysale_count

#     # Count the number of sales already associated with the farmer
#     current_sales_count = MySales.objects.filter(farmer=farmer).count()  # You may need to adjust this to count sales in the appropriate time frame.

#     if current_sales_count >= mysale_count_limit:
#         return Response({
#             "detail": f"Sales limit reached. Your subscription allows only {mysale_count_limit} sales."
#         }, status=status.HTTP_400_BAD_REQUEST)

#     # Extract the data from the request
#     data = request.data
#     deductions = data.pop("deductions", [])
#     file_data = data.pop("file_data", [])

#     # Retrieve the sales information
#     sales_quantity = float(data.get("sales_quantity", 0))
#     sales_unit = float(data.get("sales_unit", 0))
#     quantity_amount = float(data.get("quantity_amount", 0))

#     # 1. Calculate total_amount: sales_quantity * quantity_amount
#     try:
#         total_amount = sales_quantity * quantity_amount
#     except ValueError:
#         total_amount = 0

#     # 2. Set sales_amount equal to total_amount
#     sales_amount = total_amount

#     # Update total_amount and sales_amount in data
#     data["total_amount"] = str(total_amount)
#     data["sales_amount"] = str(sales_amount)

#     total_deductions = 0

#     # Save sale first
#     with transaction.atomic():
#         # Explicitly include the 'farmer' in the sale creation
#         data["farmer"] = farmer.id  # Add the farmer ID to the data

#         sales_serializer = MySalesAddSerializer(data=data)
#         if sales_serializer.is_valid():
#             sale = sales_serializer.save()  # Create and save the sale

#             # After the sale is saved, process deductions
#             for deduction in deductions:
#                 charges = float(deduction.get("charges", 0))
#                 rupee = int(deduction.get("rupee", 1))  # Default to 1 (flat amount) if not provided

#                 reason_id = deduction.get("reason")
#                 new_reason = deduction.get("new_reason")

#                 if reason_id and new_reason:
#                     return Response({"detail": "You can provide only one of 'reason' or 'new_reason'."}, status=status.HTTP_400_BAD_REQUEST)

#                 if new_reason:
#                     # Create or fetch the new reason
#                     reason, created = Reasons.objects.get_or_create(name=new_reason)
#                     if created:
#                         print(f"New reason created: {reason.name}")
#                     else:
#                         print(f"Reason '{new_reason}' already exists. Using the existing one.")
#                 elif reason_id:
#                     # Fetch the existing reason by ID
#                     try:
#                         reason = Reasons.objects.get(id=reason_id)
#                     except Reasons.DoesNotExist:
#                         return Response({"detail": "No Reasons matches the given query."}, status=status.HTTP_400_BAD_REQUEST)
#                 else:
#                     return Response({"detail": "You must provide either 'reason' or 'new_reason'."}, status=status.HTTP_400_BAD_REQUEST)

#                 # Add deduction to total_deductions
#                 if rupee == 1:  # Flat charge
#                     total_deductions += charges
#                 elif rupee == 2:  # Percentage deduction
#                     percentage_deduction = (charges / 100) * sales_amount
#                     total_deductions += percentage_deduction

#                 # Prepare deduction data for saving
#                 deduction_data = {
#                     "my_sales": sale.id,  # Now that sale is saved, we can reference its ID
#                     "farmer": farmer.id,  # Link deduction to the correct farmer
#                     "reason": reason.id,
#                     "charges": charges,
#                     "rupee": rupee,
#                     "status": deduction.get("status", 0),
#                 }

#                 # Save deduction data
#                 deduction_serializer = DeductionReasonsSerializer(data=deduction_data)
#                 if deduction_serializer.is_valid():
#                     deduction_serializer.save()
#                 else:
#                     transaction.set_rollback(True)
#                     return Response(
#                         {
#                             "success": False,
#                             "message": "Failed to add deductions. Please check the input data.",
#                             "errors": deduction_serializer.errors
#                         },
#                         status=status.HTTP_400_BAD_REQUEST
#                     )

#             # Process documents (same as before)
#             sales_details = []
#             for doc_data in file_data:
#                 file_type_id = doc_data.get('file_type')

#                 if file_type_id is None:
#                     new_file_type = doc_data.get('new_file_type')

#                     if not new_file_type:
#                         return Response({"error": "New file type for document is required."}, status=status.HTTP_400_BAD_REQUEST)

#                     # Check if the file type already exists or create a new one
#                     file_type, created = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=2)

#                     if created:
#                         print(f"New file type created: {file_type.name}")
#                     else:
#                         print(f"File type '{new_file_type}' already exists. Using the existing one.")
#                 else:
#                     file_type = get_object_or_404(DocumentCategory, id=file_type_id)

#                 documents = doc_data.get('documents', [])
#                 if not documents:
#                     return Response({"success": False, "message": f"No documents provided for file type {file_type_id}."}, status=status.HTTP_400_BAD_REQUEST)

#                 for i, document_base64 in enumerate(documents):
#                     try:
#                         # Validate MIME type for images or PDF
#                         if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
#                             mime_type = validate_image_type(document_base64)
#                             if mime_type:
#                                 # Extract the base64 data (remove the prefix)
#                                 document_data = document_base64.split(';base64,')[1]
#                                 document_bytes = base64.b64decode(document_data)

#                                 max_file_size = 10 * 1024 * 1024  # Example max file size (10MB)
#                                 if len(document_bytes) > max_file_size:
#                                     return Response({'error': f'File is too large. Max size is 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

#                                 document_name = f"sales_{farmer_id}_{file_type.id}_{i}.{mime_type.split('/')[1]}"
#                                 document_file = ContentFile(document_bytes, name=document_name)

#                                 sales_document = SalesDocument(
#                                     farmer=farmer,
#                                     my_sales=sale,
#                                     document_category=file_type,
#                                     file_upload=document_file,
#                                 )
#                                 sales_document.save()

#                                 sales_details.append({
#                                     'id': sales_document.id,
#                                     'file_name': sales_document.file_upload.name,
#                                     'file_type': sales_document.document_category.name,
#                                 })
#                             else:
#                                 return Response({'error': 'Invalid MIME type for the document.'}, status=status.HTTP_400_BAD_REQUEST)
#                         else:
#                             return Response({'error': 'Invalid file format. Only image/jpeg, image/png, and application/pdf are allowed.'}, status=status.HTTP_400_BAD_REQUEST)

#                     except Exception as e:
#                         return Response({'error': f"Error processing document: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

#             # Success response
#             return Response(
#                 {
#                     "success": True,
#                     "message": "Sales, deductions, and documents added successfully!",
#                     "data": sales_serializer.data,
#                     "sales_documents": sales_details
#                 },
#                 status=status.HTTP_201_CREATED
#             )
#         else:
#             return Response(
#                 {
#                     "success": False,
#                     "message": "Failed to add sales. Please check the input data.",
#                     "errors": sales_serializer.errors
#                 },
#                 status=status.HTTP_400_BAD_REQUEST
#             )

# @api_view(['POST'])
# def add_sales_with_deductions(request, farmer_id):
#     try:
#         farmer = Farmer.objects.get(id=farmer_id)
#     except Farmer.DoesNotExist:
#         return Response({"detail": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)

#     subscription = AddSubcription.objects.filter(farmers=farmer, status=0).first()
#     if not subscription:
#         return Response({"detail": "Farmer does not have an active subscription."}, status=status.HTTP_400_BAD_REQUEST)

#     mysale_count_limit = subscription.packages.mysale_count
#     current_sales_count = MySales.objects.filter(farmer=farmer).count()

#     if current_sales_count >= mysale_count_limit:
#         return Response({
#             "detail": f"Sales limit reached. Your subscription allows only {mysale_count_limit} sales."
#         }, status=status.HTTP_400_BAD_REQUEST)

#     data = request.data
#     deductions = data.pop("deductions", [])
#     file_data = data.pop("file_data", [])

#     sales_quantity = float(data.get("sales_quantity", 0))
#     quantity_amount = float(data.get("quantity_amount", 0))
#     total_amount = sales_quantity * quantity_amount
#     sales_amount = total_amount

#     data["total_amount"] = str(total_amount)
#     data["sales_amount"] = str(sales_amount)

#     total_deductions = 0
#     deduction_responses = []

#     with transaction.atomic():
#         data["farmer"] = farmer.id
#         sales_serializer = MySalesAddSerializer(data=data)

#         if not sales_serializer.is_valid():
#             return Response({
#                 "success": False,
#                 "message": "Failed to add sales.",
#                 "errors": sales_serializer.errors
#             }, status=status.HTTP_400_BAD_REQUEST)

#         sale = sales_serializer.save()

#         for deduction in deductions:
#             charges = float(deduction.get("charges", 0))
#             rupee = int(deduction.get("rupee", 1))
#             reason_id = deduction.get("reason")
#             new_reason = deduction.get("new_reason")

#             if reason_id and new_reason:
#                 return Response({"detail": "Provide only 'reason' or 'new_reason', not both."}, status=status.HTTP_400_BAD_REQUEST)

#             if new_reason:
#                 reason, _ = Reasons.objects.get_or_create(name=new_reason)
#             elif reason_id:
#                 try:
#                     reason = Reasons.objects.get(id=reason_id)
#                 except Reasons.DoesNotExist:
#                     return Response({"detail": "Invalid reason ID."}, status=status.HTTP_400_BAD_REQUEST)
#             else:
#                 return Response({"detail": "Reason or new reason must be provided."}, status=status.HTTP_400_BAD_REQUEST)

#             if rupee == 1:
#                 deduction_amount = charges
#             elif rupee == 2:
#                 deduction_amount = (charges / 100) * sales_amount
#             else:
#                 deduction_amount = 0

#             total_deductions += deduction_amount

#             deduction_instance = DeductionReasons.objects.create(
#                 my_sales=sale,
#                 farmer=farmer,
#                 reason=reason,
#                 charges=charges,
#                 rupee_id=rupee,
#                 status=deduction.get("status", 0),
#             )

#             deduction_responses.append({
#                 "id": deduction_instance.id,
#                 "reason": reason.name,
#                 "charges": charges,
#                 "rupee": "%" if rupee == 2 else "Rupee",
#                 "deduction_amount": deduction_amount
#             })

#         sale.deduction_amount = total_deductions
#         sale.total_sales_amount = float(sale.sales_amount) - total_deductions
#         sale.save()

#         sales_documents = []
#         for doc_data in file_data:
#             file_type_id = doc_data.get("file_type")
#             new_file_type = doc_data.get("new_file_type")

#             if not file_type_id and not new_file_type:
#                 return Response({"error": "File type is required."}, status=status.HTTP_400_BAD_REQUEST)

#             if new_file_type:
#                 file_type, _ = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=2)
#             else:
#                 file_type = get_object_or_404(DocumentCategory, id=file_type_id)

#             for i, document_base64 in enumerate(doc_data.get("documents", [])):
#                 if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
#                     mime_type = validate_image_type(document_base64)
#                     if not mime_type:
#                         return Response({'error': 'Invalid MIME type.'}, status=status.HTTP_400_BAD_REQUEST)

#                     document_data = document_base64.split(';base64,')[1]
#                     document_bytes = base64.b64decode(document_data)

#                     if len(document_bytes) > 10 * 1024 * 1024:
#                         return Response({'error': 'File too large. Max 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

#                     ext = mime_type.split('/')[-1]
#                     filename = f"sales_{farmer_id}_{file_type.id}_{i}.{ext}"
#                     file = ContentFile(document_bytes, name=filename)

#                     sales_doc = SalesDocument.objects.create(
#                         farmer=farmer,
#                         my_sales=sale,
#                         document_category=file_type,
#                         file_upload=file,
#                     )

#                     sales_documents.append({
#                         "id": sales_doc.id,
#                         "file_name": sales_doc.file_upload.name,
#                         "file_type": sales_doc.document_category.name,
#                     })
#                 else:
#                     return Response({'error': 'Unsupported file format.'}, status=status.HTTP_400_BAD_REQUEST)

#         return Response({
#             "success": True,
#             "message": "Sales, deductions, and documents saved successfully.",
#             "data": sales_serializer.data,
#             "deductions": deduction_responses,
#             "sales_documents": sales_documents
#         }, status=status.HTTP_201_CREATED)

# @api_view(['POST'])
# def add_sales_with_deductions(request, farmer_id):
#     try:
#         farmer = Farmer.objects.get(id=farmer_id)
#     except Farmer.DoesNotExist:
#         return Response({"detail": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)

#     subscription = AddSubcription.objects.filter(farmers=farmer, status=0).first()
#     if not subscription:
#         return Response({"detail": "Farmer does not have an active subscription."}, status=status.HTTP_400_BAD_REQUEST)

#     mysale_count_limit = subscription.packages.mysale_count
#     current_sales_count = MySales.objects.filter(farmer=farmer).count()

#     if current_sales_count >= mysale_count_limit:
#         return Response({
#             "detail": f"Sales limit reached. Your subscription allows only {mysale_count_limit} sales."
#         }, status=status.HTTP_400_BAD_REQUEST)

#     data = request.data
#     deductions = data.pop("deductions", [])
#     file_data = data.pop("file_data", [])

#     sales_quantity = float(data.get("sales_quantity", 0))
#     quantity_amount = float(data.get("quantity_amount", 0))
#     total_amount = sales_quantity * quantity_amount
#     sales_amount = total_amount

#     print(f"[SALES] Quantity: {sales_quantity}, Rate: {quantity_amount}, Total: {total_amount}")

#     data["total_amount"] = str(total_amount)
#     data["sales_amount"] = str(sales_amount)

#     total_deductions = 0
#     deduction_responses = []

#     with transaction.atomic():
#         data["farmer"] = farmer.id
#         sales_serializer = MySalesAddSerializer(data=data)

#         if not sales_serializer.is_valid():
#             return Response({
#                 "success": False,
#                 "message": "Failed to add sales.",
#                 "errors": sales_serializer.errors
#             }, status=status.HTTP_400_BAD_REQUEST)

#         sale = sales_serializer.save()

#         for deduction in deductions:
#             charges = float(deduction.get("charges", 0))
#             rupee = int(deduction.get("rupee", 1))
#             reason_id = deduction.get("reason")
#             new_reason = deduction.get("new_reason")

#             if reason_id and new_reason:
#                 return Response({"detail": "Provide only 'reason' or 'new_reason', not both."}, status=status.HTTP_400_BAD_REQUEST)

#             if new_reason:
#                 reason, _ = Reasons.objects.get_or_create(name=new_reason)
#             elif reason_id:
#                 try:
#                     reason = Reasons.objects.get(id=reason_id)
#                 except Reasons.DoesNotExist:
#                     return Response({"detail": "Invalid reason ID."}, status=status.HTTP_400_BAD_REQUEST)
#             else:
#                 return Response({"detail": "Reason or new reason must be provided."}, status=status.HTTP_400_BAD_REQUEST)

#             if rupee == 1:
#                 deduction_amount = charges
#                 print(f"[DEDUCTION - Flat] Reason: {reason.name}, Charges: {charges}, Deducted: {deduction_amount}")
#             elif rupee == 2:
#                 deduction_amount = (charges / 100) * sales_amount
#                 print(f"[DEDUCTION - %] Reason: {reason.name}, Charges: {charges}%, Deducted: {deduction_amount}")
#             else:
#                 deduction_amount = 0
#                 print(f"[DEDUCTION] Invalid rupee type: {rupee}")

#             total_deductions += deduction_amount

#             deduction_instance = DeductionReasons.objects.create(
#                 my_sales=sale,
#                 farmer=farmer,
#                 reason=reason,
#                 charges=charges,
#                 rupee_id=rupee,
#                 status=deduction.get("status", 0),
#             )

#             deduction_responses.append({
#                 "id": deduction_instance.id,
#                 "reason": reason.name,
#                 "charges": charges,
#                 "rupee": "%" if rupee == 2 else "Rupee",
#                 "deduction_amount": deduction_amount
#             })

#         sale.deduction_amount = total_deductions
#         sale.total_sales_amount = float(sale.sales_amount) - total_deductions

#         print(f"[SALE FINAL] Sales Amount: {sale.sales_amount}, Total Deductions: {total_deductions}, Net Sale: {sale.total_sales_amount}")
#         sale.save()

#         # Document Handling (unchanged except print logs)
#         sales_documents = []
#         for doc_data in file_data:
#             file_type_id = doc_data.get("file_type")
#             new_file_type = doc_data.get("new_file_type")

#             if not file_type_id and not new_file_type:
#                 return Response({"error": "File type is required."}, status=status.HTTP_400_BAD_REQUEST)

#             if new_file_type:
#                 file_type, _ = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=2)
#             else:
#                 file_type = get_object_or_404(DocumentCategory, id=file_type_id)

#             for i, document_base64 in enumerate(doc_data.get("documents", [])):
#                 if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
#                     mime_type = validate_image_type(document_base64)
#                     if not mime_type:
#                         return Response({'error': 'Invalid MIME type.'}, status=status.HTTP_400_BAD_REQUEST)

#                     document_data = document_base64.split(';base64,')[1]
#                     document_bytes = base64.b64decode(document_data)

#                     if len(document_bytes) > 10 * 1024 * 1024:
#                         return Response({'error': 'File too large. Max 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

#                     ext = mime_type.split('/')[-1]
#                     filename = f"sales_{farmer_id}_{file_type.id}_{i}.{ext}"
#                     file = ContentFile(document_bytes, name=filename)

#                     sales_doc = SalesDocument.objects.create(
#                         farmer=farmer,
#                         my_sales=sale,
#                         document_category=file_type,
#                         file_upload=file,
#                     )

#                     sales_documents.append({
#                         "id": sales_doc.id,
#                         "file_name": sales_doc.file_upload.name,
#                         "file_type": sales_doc.document_category.name,
#                     })
#                 else:
#                     return Response({'error': 'Unsupported file format.'}, status=status.HTTP_400_BAD_REQUEST)

#         return Response({
#             "success": True,
#             "message": "Sales, deductions, and documents saved successfully.",
#             "data": sales_serializer.data,
#             "deductions": deduction_responses,
#             "sales_documents": sales_documents
#         }, status=status.HTTP_201_CREATED)

 

@api_view(['POST'])
def add_sales_with_deductions(request, farmer_id):
    try:
        farmer = Farmer.objects.get(id=farmer_id)
    except Farmer.DoesNotExist:
        return Response({"detail": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)

    subscription = AddSubcription.objects.filter(farmers=farmer, status=0).first()
    if not subscription:
        return Response({"detail": "No active subscription."}, status=status.HTTP_400_BAD_REQUEST)

    mysale_count_limit = subscription.packages.mysale_count
    current_sales_count = MySales.objects.filter(farmer=farmer, status=0).count()

    if current_sales_count >= mysale_count_limit:
        return Response({
            "detail": f"Sales limit reached. Max allowed: {mysale_count_limit}"
        }, status=status.HTTP_400_BAD_REQUEST)

    data = request.data
    deductions = data.pop("deductions", [])
    file_data = data.pop("file_data", [])

    sales_quantity = float(data.get("sales_quantity", 0))
    quantity_amount = float(data.get("quantity_amount", 0))
    total_amount = sales_quantity * quantity_amount
    sales_amount = total_amount

    print(f"[SALES] Quantity: {sales_quantity}, Rate: {quantity_amount}, Total: {total_amount}")

    data["total_amount"] = str(total_amount)
    data["sales_amount"] = str(sales_amount)

    total_deductions = 0
    deduction_responses = []

    with transaction.atomic():
        data["farmer"] = farmer.id
        sales_serializer = MySalesAddSerializer(data=data)

        if not sales_serializer.is_valid():
            return Response({
                "success": False,
                "message": "Failed to add sales.",
                "errors": sales_serializer.errors
            }, status=status.HTTP_400_BAD_REQUEST)

        sale = sales_serializer.save()

        for deduction in deductions:
            charges = float(deduction.get("charges", 0))
            rupee = int(deduction.get("rupee", 1))
            reason_id = deduction.get("reason")
            new_reason = deduction.get("new_reason")

            if reason_id and new_reason:
                return Response({"detail": "Provide either 'reason' or 'new_reason', not both."}, status=status.HTTP_400_BAD_REQUEST)

            if new_reason:
                reason, _ = Reasons.objects.get_or_create(name=new_reason)
            elif reason_id:
                reason = get_object_or_404(Reasons, id=reason_id)
            else:
                return Response({"detail": "A reason is required."}, status=status.HTTP_400_BAD_REQUEST)

            if rupee == 1:
                deduction_amount = charges
            elif rupee == 2:
                deduction_amount = (charges / 100) * sales_amount
            else:
                deduction_amount = 0

            total_deductions += deduction_amount

            deduction_instance = DeductionReasons.objects.create(
                my_sales=sale,
                farmer=farmer,
                reason=reason,
                charges=charges,
                rupee_id=rupee,
                status=deduction.get("status", 0),
            )

            deduction_responses.append({
                "id": deduction_instance.id,
                "reason": reason.name,
                "charges": charges,
                "rupee": "%" if rupee == 2 else "â‚¹",
                "deduction_amount": deduction_amount
            })

        # Finalize sale values
        sale.deduction_amount = total_deductions
        sale.total_sales_amount = float(sale.sales_amount) - total_deductions
        sale.save()

        # âœ… Now create Outstanding after final values
        paid = float(sale.amount_paid or 0)
        total = float(sale.total_sales_amount or 0)

        print(f"[OUTSTANDING] Paid: {paid}, Net Sale: {total}, Deductions: {total_deductions}")

        outstanding_data = {
            'farmer': sale.farmer,
            'customer': sale.my_customer,
            'sale': sale,
            'received': paid,
            'received_date': sale.dates_of_sales,
            'total_received': paid,
            'created_by': sale.created_by,
            'created_at': timezone.now()
        }

        if total > paid:
            balance = total
            to_receive = total - paid
            outstanding_data.update({'balance': balance, 'to_receive': to_receive})
            print(f"[RECEIVABLE] To Receive: {to_receive}")
        elif total < paid:
            to_pay = paid - total
            outstanding_data.update({'balance': to_pay, 'to_pay': to_pay, 'paid_date': sale.dates_of_sales})
            print(f"[PAYABLE] To Pay: {to_pay}")
        else:
            outstanding_data.update({'balance': 0})

        outstanding = Outstanding.objects.create(**outstanding_data)

        # Update customer opening balance
        customer = sale.my_customer
        if total > paid:
            if customer.opening_balance and customer.opening_balance != 0:
                if customer.is_credit:
                    customer.opening_balance += to_receive
                else:
                    if customer.opening_balance > to_receive:
                        customer.opening_balance -= to_receive
                    else:
                        customer.opening_balance = to_receive - customer.opening_balance
                        customer.is_credit = True
            else:
                customer.opening_balance = to_receive
                customer.is_credit = True
        elif total < paid:
            if customer.opening_balance and customer.opening_balance != 0:
                if customer.is_credit:
                    if customer.opening_balance > to_pay:
                        customer.opening_balance -= to_pay
                    else:
                        customer.is_credit = False
                        customer.opening_balance = to_pay - customer.opening_balance
                else:
                    customer.opening_balance += to_pay
            else:
                customer.opening_balance = to_pay
                customer.is_credit = False
        customer.save()

        print(f"[CUSTOMER BALANCE] OB: {customer.opening_balance}, Credit: {customer.is_credit}")

        # Handle documents (same as before)
        sales_documents = []
        for doc_data in file_data:
            file_type_id = doc_data.get("file_type")
            new_file_type = doc_data.get("new_file_type")

            if not file_type_id and not new_file_type:
                return Response({"error": "File type is required."}, status=status.HTTP_400_BAD_REQUEST)

            if new_file_type:
                file_type, _ = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=2)
            else:
                file_type = get_object_or_404(DocumentCategory, id=file_type_id)

            for i, document_base64 in enumerate(doc_data.get("documents", [])):
                if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
                    mime_type = validate_image_type(document_base64)
                    if not mime_type:
                        return Response({'error': 'Invalid MIME type.'}, status=status.HTTP_400_BAD_REQUEST)

                    document_data = document_base64.split(';base64,')[1]
                    document_bytes = base64.b64decode(document_data)

                    if len(document_bytes) > 10 * 1024 * 1024:
                        return Response({'error': 'File too large. Max 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

                    ext = mime_type.split('/')[-1]
                    filename = f"sales_{farmer_id}_{file_type.id}_{i}.{ext}"
                    file = ContentFile(document_bytes, name=filename)

                    sales_doc = SalesDocument.objects.create(
                        farmer=farmer,
                        my_sales=sale,
                        document_category=file_type,
                        file_upload=file,
                    )

                    sales_documents.append({
                        "id": sales_doc.id,
                        "file_name": sales_doc.file_upload.name,
                        "file_type": sales_doc.document_category.name,
                    })
                else:
                    return Response({'error': 'Unsupported file format.'}, status=status.HTTP_400_BAD_REQUEST)

        return Response({
            "success": True,
            "message": "Sales, deductions, outstanding, and documents saved successfully.",
            "data": sales_serializer.data,
            "deductions": deduction_responses,
            "sales_documents": sales_documents
        }, status=status.HTTP_201_CREATED)




def calculate_deductions(deductions, total_amount, sale):
    total_deductions = 0
    deduction_details = []  # This will store details for each deduction
    for deduction in deductions:
        deduction_id = deduction.get("id")
        try:
            if deduction_id:
                # Update an existing deduction
                deduction_instance = DeductionReasons.objects.get(id=deduction_id, my_sales=sale)
                deduction_instance.charges = float(deduction.get("charges", deduction_instance.charges))
                deduction_instance.rupee = Rupee.objects.get(id=deduction.get("rupee", deduction_instance.rupee.id))
                deduction_instance.save()
            else:
                # Create a new deduction
                deduction_instance = DeductionReasons.objects.create(
                    my_sales=sale,
                    farmer=sale.farmer,
                    reason=Reasons.objects.get(id=deduction.get("reason")),
                    charges=float(deduction.get("charges", 0)),
                    rupee=Rupee.objects.get(id=deduction.get("rupee", 1)),  # Default rupee if not provided
                    code=deduction.get("code"),
                    status=deduction.get("status", 0),
                )

            # Calculate the deduction based on rupee type
            if deduction_instance.rupee.id == 1:  # Flat charge
                total_deductions += deduction_instance.charges
            elif deduction_instance.rupee.id == 2:  # Percentage deduction
                total_deductions += (deduction_instance.charges / 100) * total_amount

            # Add deduction details with reason
            deduction_details.append({
                'id':deduction_instance.id,
                'reason': deduction_instance.reason.name,  # Include the reason name
                'charges': deduction_instance.charges,
                'rupee': deduction_instance.rupee.name,
                'total_deduction': deduction_instance.charges if deduction_instance.rupee.id == 1 else (deduction_instance.charges / 100) * total_amount
            })

        except Exception as e:
            raise ValueError(f"Error processing deduction {deduction.get('id')}: {str(e)}")
    
    return total_deductions, deduction_details  # Return both total and details

# Helper function to calculate deductions (this needs to be defined based on your logic)
def calculate_deductionss(deductions, total_amount, sale):
    total_deductions = 0
    deduction_details = []
    for deduction in deductions:
        # Extract deduction info
        reason_id = deduction.get('reason')  # Existing deduction reason ID
        new_reason = deduction.get('new_reason')  # New deduction reason
        charges = deduction.get('charges')
        
        # Calculate the deduction based on charges
        total_deductions += float(charges)
        deduction_details.append({
            'charges': charges,
            'reason': reason_id or new_reason,
        })
    return total_deductions, deduction_details

 
@api_view(['PUT'])
def update_sales_with_deductions(request, farmer_id, sale_id):
    try:
        farmer = Farmer.objects.get(id=farmer_id)
        sale = MySales.objects.get(id=sale_id, farmer=farmer)
    except (Farmer.DoesNotExist, MySales.DoesNotExist):
        return Response({"detail": "Farmer or Sale not found."}, status=status.HTTP_404_NOT_FOUND)

    data = request.data
    deductions = data.pop("deductions", [])
    file_data = data.pop("file_data", [])

    # Update crop if needed
    my_crop_id = data.get("my_crop")
    if my_crop_id:
        try:
            sale.my_crop = MyCrop.objects.get(id=my_crop_id,status=0)
        except MyCrop.DoesNotExist:
            return Response({"error": f"MyCrop with id {my_crop_id} not found."}, status=status.HTTP_404_NOT_FOUND)

    # Update customer if needed
    my_customer_id = data.get("my_customer")
    if my_customer_id:
        try:
            sale.my_customer = MyCustomer.objects.get(id=my_customer_id,status=0)
        except MyCustomer.DoesNotExist:
            return Response({"error": f"My Customer with id {my_customer_id} not found."}, status=status.HTTP_404_NOT_FOUND)

    # Update sales unit if needed
    sale_unit_id = data.get("sales_unit")
    if sale_unit_id:
        try:
            sale.sales_unit = AreaUnit.objects.get(id=sale_unit_id,status=0)
        except AreaUnit.DoesNotExist:
            return Response({"error": f"My Sale Unit with id {sale_unit_id} not found."}, status=status.HTTP_404_NOT_FOUND)

    # âœ… Update sales date
    if "dates_of_sales" in data and data["dates_of_sales"]:
        try:
            sale.dates_of_sales = datetime.strptime(data["dates_of_sales"], "%Y-%m-%d").date()
        except ValueError:
            return Response({"error": "Invalid date format. Use YYYY-MM-DD."}, status=status.HTTP_400_BAD_REQUEST)

    # âœ… Update description
    if "description" in data:
        sale.description = data["description"]

    description = request.data.get('description')
    target_languages = ['hi', 'ta']  # Languages to translate to (Hindi and Tamil)
    
    # Retrieve current translation data
    translated_json = sale.translate_json or {'description': {}}

    # If description is provided, translate and update the description field
    if description:
        try:
            # Update the description translations
            for lang in target_languages:
                translated_text = GoogleTranslator(source='auto', target=lang).translate(description)
                translated_json["description"][lang] = translated_text
        except Exception as e:
            return Response({"error": f"Error during translation: {str(e)}"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


    try:
        sales_quantity = float(data.get("sales_quantity", sale.sales_quantity or 0))
        quantity_amount = float(data.get("quantity_amount", sale.quantity_amount or 0))
        total_amount = sales_quantity * quantity_amount

        sale.sales_quantity = sales_quantity
        sale.quantity_amount = str(quantity_amount)
        sale.total_amount = str(total_amount)
        sale.sales_amount = total_amount
    except ValueError as e:
        return Response({"error": f"Invalid input for quantity or amount: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

    # Calculate and save deductions
    try:
        total_deductions, deduction_details = calculate_deductionss(deductions, total_amount, sale)
        sale.deduction_amount = str(total_deductions)
        sale.total_sales_amount = total_amount - total_deductions
    except Exception as e:
        return Response({"error": f"Error calculating deductions: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

    sale.save()

    sales_details = []

    # Handle documents
    for doc_data in file_data:
        file_type_id = doc_data.get('file_type')
        if not file_type_id:
            new_file_type = doc_data.get('new_file_type')
            if not new_file_type:
                return Response({"error": "Document file type missing."}, status=status.HTTP_400_BAD_REQUEST)
            file_type, _ = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=2)
        else:
            file_type = get_object_or_404(DocumentCategory, id=file_type_id)

        documents = doc_data.get('documents', [])
        if not documents:
            return Response({"error": f"No documents for file type {file_type.name}"}, status=status.HTTP_400_BAD_REQUEST)

        for i, document_base64 in enumerate(documents):
            try:
                if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
                    mime_type = validate_image_type(document_base64)
                    document_data = document_base64.split(';base64,')[1]
                    document_bytes = base64.b64decode(document_data)

                    if len(document_bytes) > 10 * 1024 * 1024:
                        return Response({'error': 'Document too large (max 10MB)'}, status=status.HTTP_400_BAD_REQUEST)

                    document_name = f"sales_{farmer_id}_{file_type.id}_{i}.{mime_type.split('/')[1]}"
                    document_file = ContentFile(document_bytes, name=document_name)

                    document_id = doc_data.get("document_id")
                    if document_id:
                        doc = SalesDocument.objects.filter(id=document_id, my_sales=sale).first()
                        if doc:
                            doc.file_upload = document_file
                            doc.document_category = file_type
                            doc.save()
                        else:
                            return Response({'error': f"Document ID {document_id} not found."}, status=status.HTTP_404_NOT_FOUND)
                    else:
                        doc = SalesDocument.objects.create(
                            farmer=farmer,
                            my_sales=sale,
                            document_category=file_type,
                            file_upload=document_file
                        )
 
                    sales_details.append({
                        "id": doc.id,
                        "name": doc.file_upload.name,
                        "type": doc.document_category.name
                    })
                else:
                    return Response({'error': 'Unsupported file type.'}, status=status.HTTP_400_BAD_REQUEST)
            except Exception as e:
                return Response({'error': f"Error processing document: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

    # Prepare response
    sale_data = model_to_dict(sale)
    sale_data['farmer'] = sale.farmer.id if sale.farmer else None
    sale_data['my_crop'] = sale.my_crop.id if sale.my_crop else None
    sale_data['my_customer'] = sale.my_customer.id if sale.my_customer else None
    sale_data['sales_unit'] = sale.sales_unit.id if sale.sales_unit else None
    sale_data['sales_amount'] = str(sale.sales_amount) if sale.sales_amount else "0.00"
    sale_data['deduction_amount'] = sale.deduction_amount 
    sale_data['total_sales_amount'] = str(sale.total_sales_amount) if sale.total_sales_amount else "0.00"
    sale_data['amount_paid'] = str(sale.amount_paid) if sale.amount_paid else "0.00"
    sale_data['created_by'] = sale.created_by.id if sale.created_by else None
    sale_data['updated_by'] = sale.updated_by.id if sale.updated_by else None
    sale_data['created_at'] = sale.created_at.isoformat() if hasattr(sale.created_at, 'isoformat') else str(sale.created_at)
    sale_data['updated_at'] = sale.updated_at.isoformat() if hasattr(sale.updated_at, 'isoformat') else str(sale.updated_at)
    sale_data['dates_of_sales'] = sale.dates_of_sales.isoformat() if hasattr(sale.dates_of_sales, 'isoformat') else str(sale.dates_of_sales)
    sale_data['description'] = sale.description

    return Response({
        "success": True,
        "message": "Sale updated successfully.",
        "sale": sale_data,
        "documents": sales_details
    }, status=status.HTTP_200_OK)
 
def fix_base64_padding(base64_string): 
    padding_needed = len(base64_string) % 4
    if padding_needed:
        base64_string += '=' * (4 - padding_needed)
    return base64_string


def validate_base64_image(base64_string):
    try: 
        base64_string = fix_base64_padding(base64_string)
         
        image_data = base64.b64decode(base64_string.split(';base64,')[1])
        image = Image.open(io.BytesIO(image_data))
         
        image.verify()   
        return True
    except Exception as e:
        return False, str(e)
  
@api_view(['POST'])
@parser_classes([MultiPartParser, JSONParser])   
def add_customer(request, farmer_id):
    try: 
        farmer = Farmer.objects.get(id=farmer_id)
    except Farmer.DoesNotExist:
        return Response({"detail": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)

    # Check the farmer's subscription and customer limit
    subscription = AddSubcription.objects.filter(farmers=farmer, status=0).first()
    if subscription:
        customer_limit = subscription.packages.customer_count or 0
        current_customer_count = MyCustomer.objects.filter(
            Q(status=0) | Q(status=1), farmer=farmer
        ).count()

        if current_customer_count >= customer_limit:
            return Response({
                'detail': f"You have already reached the maximum customer limit of {customer_limit} for your subscription package."
            }, status=status.HTTP_400_BAD_REQUEST)

    data = request.data.copy()  # Make mutable copy

    # --- Handle location names ---
    country_name = data.get('country_name')
    if country_name and country_name.strip():
        country_obj, _ = Country.objects.get_or_create(name=country_name.strip())
        data['country'] = country_obj.id

    state_name = data.get('state_name')
    if state_name and state_name.strip():
        state_obj, _ = State.objects.get_or_create(name=state_name.strip(), country_id=data.get('country'))
        data['state'] = state_obj.id

    city_name = data.get('city_name')
    if city_name and city_name.strip():
        city_obj, _ = City.objects.get_or_create(name=city_name.strip(), state_id=data.get('state'), country_id=data.get('country'))
        data['city'] = city_obj.id

    taluk_name = data.get('taluk_name')
    if taluk_name and taluk_name.strip():
        taluk_obj, _ = Taluk.objects.get_or_create(name=taluk_name.strip(), city_id=data.get('city'), state_id=data.get('state'), country_id=data.get('country'))
        data['taluk'] = taluk_obj.id

    village_name = data.get('village_name')
    if village_name and village_name.strip():
        village_obj, _ = Village.objects.get_or_create(
            name=village_name.strip(),
            taluk_id=data.get('taluk'),
            city_id=data.get('city'),
            state_id=data.get('state'),
            country_id=data.get('country')
        )
        data['village'] = village_obj.id

    # --- Handle base64 image ---
    customer_img = data.get('customer_img', None)
    if customer_img and isinstance(customer_img, str):
        try:
            customer_img = fix_base64_padding(customer_img.strip())
            img_data = base64.b64decode(customer_img.split(';base64,')[1])

            image = Image.open(io.BytesIO(img_data))
            image.verify()

            image_name = f'customer_image_{timezone.now().strftime("%Y%m%d%H%M%S")}.png'
            image_file = InMemoryUploadedFile(io.BytesIO(img_data), None, image_name, 'image/png', len(img_data), None)
            data['customer_img'] = image_file
        except Exception as e:
            return Response({"error": f"Invalid base64 image format: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)
    elif 'customer_img' in request.FILES:
        pass  # File upload will be handled by serializer
    else:
        pass  # No image provided

    # Add farmer reference
    data['farmer'] = farmer.id
    many = isinstance(data, list)

    serializer = MyCustomerAddSerializer(data=data, many=many)

    if serializer.is_valid():
        serializer.save()
        return Response(
            {
                "success": True,
                "message": "Customer added successfully!",
                "data": serializer.data,
                "language": {
                    "default": "en"
                }
            },
            status=status.HTTP_201_CREATED
        )

    return Response(
        {
            "success": False,
            "message": "Failed to add Customer. Please check the input data.",
            "errors": serializer.errors
        },
        status=status.HTTP_400_BAD_REQUEST
    )
 

@api_view(['GET'])
def get_places(request):
    # Query to get nearby locations with their category counts
    nearby_locations = ManageNearByLocations.objects.values(
        'category__name'  # This assumes 'name' is a field in NearByLocationCategory
    ).annotate(
        count=Count('id')  # Count the number of locations in each category
    ).filter(status=0)  # You can add any other filters here as necessary

    # Prepare the response data
    response_data = []
    for location in nearby_locations:
        response_data.append({
            "category_name": location['category__name'],
            "count": location['count'],
        })

    return Response({
        "success": True,
        "places": response_data,
    }, status=200)

 

@api_view(['GET'])
def get_man_power(request):
    language_code = request.GET.get('lang', 'en')  # default to English

    workers_queryset = ManageWorkers.objects.filter(status=0).prefetch_related('worker')

    response_data = []
    for worker in workers_queryset:
        worker_details = worker.get_worker_details(language_code=language_code)
        if worker_details:
            response_data.append({
                "worker_id": worker.worker.id if worker.worker else None,
                "worker_details": worker_details,
                "worker_type": worker.workerstype.name if worker.workerstype else None,
                "person_count": worker.person
            })

    return Response({
        "success": True,
        "man_power": response_data,
    }, status=200)



@api_view(['GET'])
def delete_sales(request, sales_id):
    try:
        # Fetch the MySales instance by ID
        my_sales = get_object_or_404(MySales, pk=sales_id)

        # Mark the sales as deleted (status = 2)
        my_sales.status = 2
        my_sales.save()

        return Response(
            {
                "success": True,
                "message": "My Sales has been deleted successfully."
            },
            status=status.HTTP_200_OK
        )
    except MySales.DoesNotExist:
        return Response(
            {
                "success": False,
                "message": "My Sales record not found."
            },
            status=status.HTTP_404_NOT_FOUND
        )
 
@api_view(['GET'])
def get_package_management(request, farmer_id):
    # Query to get package management data
    package_management = PackageManagement.objects.filter(status=0)

    # Structure the response data
    response_data = []
    for package in package_management:
        is_using_package = False
        subscription_info = None  # Will hold subscription details if the farmer is using this package

        # Check if the farmer has a subscription for the package
        try:
            subscription = AddSubcription.objects.filter(farmers_id=farmer_id, packages=package, status=0).first()  # Adjust status as needed
            if subscription:
                is_using_package = True
                subscription_info = {
                    "subscription_id": subscription.id,
                    "startdate": subscription.startdate,
                    "enddate": subscription.enddate,
                    "remainingdays": subscription.remainingdays,
                    "renewal": subscription.renewal,
                    "payment_status": subscription.payment_status,
                    "payment_mode": subscription.payment_mode,
                    "transaction_id": subscription.transaction_id,
                }
        except AttributeError:
            is_using_package = False
        
        # Prepare the package data
        data = {
            "id":package.id,
            "name": package.name,
            "code": package.code,
            "package_validity": package.package_validity,
            "package_duration": package.package_duration.name if package.package_duration else None,
            "amount": package.amount,
            "offer": package.offer,
            "percentage": package.percentage,
            "sub_amount": package.sub_amount,
            "status": package.status,
            "myland_count": package.myland_count,
            "mycrops_count": package.mycrops_count,
            "myexpense_count": package.myexpense_count,
            "mysale_count": package.mysale_count,
            "customer_count": package.customer_count,
            "is_myvechicle": package.is_myvechicle,
            "myvechicle_count": package.myvechicle_count,
            "is_mymachinery": package.is_mymachinery,
            "mymachinery_count": package.mymachinery_count,
            "is_mytools": package.is_mytools,
            "mytools_count": package.mytools_count,
            "is_myinventory": package.is_myinventory,
            "myinventory_products": package.myinventory_products,
            "myinventory_purchase": package.myinventory_purchase,
            "myinventory_vendors": package.myinventory_vendors,
            "is_attendance": package.is_attendance,
            "employee_count": package.employee_count,
            "is_payouts": package.is_payouts,
            "is_widget": package.is_widget,
            "is_using_package": is_using_package,  # Add this field
            # "subscription_info": subscription_info  # Add the subscription info if available
        }

        response_data.append({
            "title": package.name,  # You can use any field for title
            "data": data,
        })

    return Response({
        "success": True,
        "packages": response_data,
        "language": {
            "default": "en"
        }
    }, status=200)

@api_view(['POST'])
def get_purchase_fuel(request): 
    inventory_items_id = request.data.get('inventory_items_id')
 
    if inventory_items_id:
        purchase_fuel = MyFuel.objects.filter(inventory_items_id=inventory_items_id)
    else:
        purchase_fuel = MyFuel.objects.all()  # Fallback to all records if no ID provided

    # Calculate total liters
    total_liter = sum(fuel.quantity for fuel in purchase_fuel if fuel.quantity is not None)

    # Structure the response data
    response_data = []
    for fuel in purchase_fuel:
        data = {
            "date_of_consumption": fuel.date_of_consumption,
            "vendor": fuel.vendor.name if fuel.vendor else None,  # Assuming vendor has a 'name' field
            "inventory_type": fuel.inventory_type.name if fuel.inventory_type else None,  # Assuming it has a 'name' field
            "inventory_category": fuel.inventory_category.name if fuel.inventory_category else None,  # Assuming it has a 'name' field
            "inventory_items": fuel.inventory_items.name if fuel.inventory_items else None,  # Assuming it has a 'name' field
            "quantity": str(fuel.quantity) if fuel.quantity is not None else None,  # Convert Decimal to string if needed
            "purchase_amount": str(fuel.purchase_amount) if fuel.purchase_amount is not None else None,
            "description": fuel.description,
            "status": fuel.status,
            "document": fuel.document.url if fuel.document else None,  # Get the URL of the uploaded document
        }

        response_data.append({
            "data": data,
        })

    return Response({
        "success": True,
        "total_liter": str(total_liter),  # Include total liters in the response
        "purchase": response_data,
    }, status=200)

 

 
@api_view(['POST'])
def get_guidelines(request):
    language_code = request.query_params.get('lang', 'en') 
    crop_id = request.data.get('crop_id')
    guidelines_category_id = request.data.get('guidelines_category_id')  
    
    guidelines_query = Guidelines.objects.filter(status=0)

    if crop_id:
        guidelines_query = guidelines_query.filter(crop_id=crop_id)
    
    if guidelines_category_id:
        guidelines_query = guidelines_query.filter(guidelinescategory_id=guidelines_category_id)
    
    guidelines_query = guidelines_query.order_by('-created_at')

    GUIDELINES_TYPE_TRANSLATIONS = {
        "General": {
            "en": "General",
            "ta": "à®ªà¯Šà®¤à¯à®µà®¾à®•",
        },
        "Based On Crop": {
            "en": "Based On Crop",
            "ta": "à®µà¯†à®³à®¿à®ªà¯à®ªà®Ÿà¯ˆà®¯à®¾à®© à®ªà®¯à®¿à®°à®¿à®©à¯ à®…à®Ÿà®¿à®ªà¯à®ªà®Ÿà¯ˆà®¯à®¿à®²à¯",
        },
    }


    def translate_guidelines_type(guidelines_type, language_code):
        return GUIDELINES_TYPE_TRANSLATIONS.get(guidelines_type, {}).get(language_code, guidelines_type)


    response_data = []

    for guideline in guidelines_query:
        parsed_video_url = urlparse(guideline.video_url) if guideline.video_url else None
        query_value = ""
        
        if parsed_video_url and parsed_video_url.query:
            # Extract query parameters using parse_qs
            parsed_query = parse_qs(parsed_video_url.query)
            # Safely extract the value of 'si' query parameter
            query_value = parsed_query.get('si', [""])[0]

        data = {
            "id": guideline.id,
            "name": guideline.get_translated_value("name", language_code) if guideline else "",
            "guidelines_type": translate_guidelines_type(guideline.guidelinestype.name, language_code) if guideline.guidelinestype else " ",
            "guidelines_category": {
                "id": guideline.guidelinescategory.id if guideline.guidelinescategory else None,
                "name": guideline.guidelinescategory.get_translated_value("name", language_code) if guideline.guidelinescategory else " "
            },
            "crop": {
                "id": guideline.crop.id if guideline.crop else None,
                "name": guideline.crop.get_translated_value("name", language_code) if guideline.crop else " "
            },
            "description": guideline.get_translated_value("description", language_code) if guideline.description else " ",
            "video_url":  guideline.video_url,
            "document": request.build_absolute_uri(f'/SuperAdmin{guideline.document.url}' if guideline.document else guideline.document.url) if guideline.document else "",
            "media_type": guideline.media_type
        }
        response_data.append(data)

    return Response({ 
        "success": True,
        "guidelines": response_data,
        "language": {
            "default": "en"
        }
    }, status=200)



@api_view(['GET'])
def help_desk_list(request):
    " ""Retrieve all help desk records."" "
    help_desks = HelpDesk.objects.all()
    serializer = HelpDeskSerializer(help_desks, many=True)
    return Response(serializer.data, status=status.HTTP_200_OK)

def get_week_dates(): 
    today = now().date()
    start_date = today - timedelta(days=today.weekday())  # Monday
    end_date = start_date + timedelta(days=6)  # Sunday
    return start_date, end_date
 
def get_expense_data(start_date, end_date, farmer):
    """Fetches expenses data for the week for a specific farmer."""
    expenses = MyExpense.objects.filter(farmer=farmer, created_day__range=(start_date, end_date)).values('created_day').annotate(total_amount=Sum('amount'))
    
    expense_week = {day.strftime('%a').lower(): 0 for day in (start_date + timedelta(days=i) for i in range(7))}
    
    for expense in expenses:
        day_of_week = expense['created_day'].strftime('%a').lower()
        expense_week[day_of_week] = expense['total_amount'] or 0

    return expense_week

def get_sales_data(start_date, end_date, farmer):
    """Fetches sales data for the week for a specific farmer."""
    sales = MySales.objects.filter(farmer=farmer, dates_of_sales__range=(start_date, end_date)).values('dates_of_sales').annotate(total_amount=Sum('sales_amount'))
    
    sales_week = {day.strftime('%a').lower(): 0 for day in (start_date + timedelta(days=i) for i in range(7))}
    
    for sale in sales:
        day_of_week = sale['dates_of_sales'].strftime('%a').lower()
        # Handle None value for total_amount
        sales_week[day_of_week] = float(sale['total_amount']) if sale['total_amount'] is not None else 0

    return sales_week
 
@api_view(['GET'])
def get_weekly_sales_expenses(request, farmer_id):
    try:
        # Get the farmer using the farmer_id
        farmer = Farmer.objects.get(id=farmer_id)
    except Farmer.DoesNotExist:
        return Response({"detail": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)

    # Get the start and end date of the current week
    start_date, end_date = get_week_dates()
    
    # Get sales and expense data for the week for this specific farmer
    expense_week = get_expense_data(start_date, end_date, farmer)
    sales_week = get_sales_data(start_date, end_date, farmer)
    
    # Calculate total expenses and sales
    expense_total = sum(expense_week.values())
    sales_total = sum(sales_week.values())
    
    response_data = {
        "farmer_id": farmer.id,
        "farmer_name": farmer.name,  # Include the farmer's name or any other relevant data
        "start_date": start_date.isoformat(),  # ISO format for consistent representation
        "end_date": end_date.isoformat(),
        "data": [
            {
                "expense_week": [
                    {"x": "mon", "y": expense_week.get("mon", 0)},
                    {"x": "tue", "y": expense_week.get("tue", 0)},
                    {"x": "wed", "y": expense_week.get("wed", 0)},
                    {"x": "thu", "y": expense_week.get("thu", 0)},
                    {"x": "fri", "y": expense_week.get("fri", 0)},
                    {"x": "sat", "y": expense_week.get("sat", 0)},
                    {"x": "sun", "y": expense_week.get("sun", 0)}
                ],
                "sales_week": [
                    {"x": "mon", "y": sales_week.get("mon", 0)},
                    {"x": "tue", "y": sales_week.get("tue", 0)},
                    {"x": "wed", "y": sales_week.get("wed", 0)},
                    {"x": "thu", "y": sales_week.get("thu", 0)},
                    {"x": "fri", "y": sales_week.get("fri", 0)},
                    {"x": "sat", "y": sales_week.get("sat", 0)},
                    {"x": "sun", "y": sales_week.get("sun", 0)}
                ]
            }
        ],
        "sales_expense": [
            {
                "expense_total": expense_total,
                "sales_total": sales_total
            }
        ]
    }

    return Response(response_data, status=status.HTTP_200_OK)
 
@api_view(['GET'])
def get_customer_balances(request, farmer_id):
    # Fetch the farmer's customers based on the farmer_id
    customers = MyCustomer.objects.filter(farmer_id=farmer_id)

    # If no customers are found for the given farmer_id, return a 404 response
    if not customers.exists():
        return Response({"message": "No customers found for the given farmer."}, status=status.HTTP_404_NOT_FOUND)
    
    # Calculate total payables (is_credit=False) for this farmer
    total_payables = customers.filter(is_credit=False).aggregate(total_amount=Sum('opening_balance'))['total_amount'] or 0

    # Calculate total receivables (is_credit=True) for this farmer
    total_receivables = customers.filter(is_credit=True).aggregate(total_amount=Sum('opening_balance'))['total_amount'] or 0

    # Format with and without 'K'
    response_data = {
        "payables": {
            "with_k": f"{total_payables}K" if total_payables >= 1000 else f"{total_payables}",
            "without_k": total_payables
        },
        "receivables": {
            "with_k": f"{total_receivables}K" if total_receivables >= 1000 else f"{total_receivables}",
            "without_k": total_receivables
        }
    }

    return Response(response_data, status=status.HTTP_200_OK)
 
@api_view(['GET'])
def get_widget_config(request, farmer_id=None):
    try:
        if farmer_id:
            # Retrieve the widget configuration for the specific farmer
            widget_config = WidgetConfig.objects.get(farmer_id=farmer_id)
        else:
            # Retrieve the first widget configuration (if no farmer is specified)
            widget_config = WidgetConfig.objects.first()
        
        response_data = {
            "farmer_id": widget_config.farmer.id if widget_config.farmer else "",
            "farmer_name": widget_config.farmer.name if widget_config.farmer else "",
            "weather_date & receivables_payables": widget_config.weather_date,
            # "receivables_payables": widget_config.receivables_payables,
            "expenses_sales": widget_config.expenses_sales,
            "near_by_market_price": widget_config.near_by_market_price,
            "schedulr_task": widget_config.schedulr_task,
            "guidelines": widget_config.guideliness,
            # "vendor": widget_config.vendor,
            "language":{
                "default":"en"
            }
        }
        
        return Response(response_data, status=status.HTTP_200_OK)
    except WidgetConfig.DoesNotExist:
        return Response({"detail": "Widget configuration not found."}, status=status.HTTP_404_NOT_FOUND)
      
@api_view(['PUT'])
def update_widget_config(request, farmer_id):
    # Retrieve or create the widget configuration for the specific farmer
    widget_config, created = WidgetConfig.objects.update_or_create(
        farmer_id=farmer_id,  # If a WidgetConfig with this farmer_id exists, it will update it; otherwise, it will create a new one
        defaults={} 
    )
    
    # List of boolean fields to update
    boolean_fields = [
        'weather_date',
        # 'receivables_payables',
        'expenses_sales',
        'near_by_market_price',
        'schedulr_task',
        'guideliness',
        # 'vendor'
    ]

    # Update fields based on the request data
    for field in boolean_fields:
        value = request.data.get(field)
        if value is not None:
            # Convert value to a boolean (handles strings like "true" or "false")
            widget_config.__setattr__(field, value.lower() == 'true' if isinstance(value, str) else bool(value))

    # Save the updated configuration
    widget_config.save()

    # Manually format the updated widget_config data
    updated_data = {
        "id": widget_config.id,
        "farmer_id": widget_config.farmer.id if widget_config.farmer else "",
        "farmer-name": widget_config.farmer.name if widget_config.farmer else "",
        "weather_date & receivables_payables": widget_config.weather_date,
        # "receivables_payables": widget_config.receivables_payables,
        "expenses_sales": widget_config.expenses_sales,
        "near_by_market_price": widget_config.near_by_market_price,
        "schedulr_task": widget_config.schedulr_task,
        "Guidelines": widget_config.guideliness,
        # "vendor": widget_config.vendor,
        "language": {
            "default": "en"
        }
    }

    # Return the updated (or newly created) configuration in the response
    return Response({
        "detail": "Widget configuration updated successfully." if not created else "Widget configuration created successfully.",
        "widget_config": updated_data
    }, status=status.HTTP_200_OK)

@api_view(['GET'])
def get_notifications(request, farmer_id=None):

    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'

    try:
        if farmer_id:
            # Retrieve notifications for a specific farmer
            notifications = FarmerNotification.objects.filter(farmer_id=farmer_id).order_by('-created_at')
        else:
            # Retrieve all notifications if no farmer is specified
            notifications = FarmerNotification.objects.all().order_by('-created_at')

        # Group notifications by date
        grouped_notifications = defaultdict(list)
        for notification in notifications:
            date_key = notification.created_at.date()  # Extract the date part
            grouped_notifications[date_key].append({
                # "title": notification.name,
                # "description": notification.message,
                "title": notification.get_translated_value("name", language_code) if language_code == 'ta' else notification.name,
                "description": notification.get_translated_value("message", language_code) if language_code == 'ta' else notification.message,
                "timeStamp": notification.created_at.isoformat(),
            })

        # Format the response
        response_data = [
            {
                "timeStamp": datetime.combine(date, datetime.min.time()).isoformat(),
                "notification": grouped_notifications[date]
            }
            for date in sorted(grouped_notifications.keys(), reverse=True)
        ]

        return Response(response_data, status=status.HTTP_200_OK)
    except Exception as e:
        return Response({"detail": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
 
@api_view(['POST'])
def get_inventory_and_crop_details(request, inventory_id):
    # Retrieve the request data for filtering
    inventory_type = request.data.get('inventory_type')
    inventory_category = request.data.get('inventory_category')
    inventory_items = request.data.get('inventory_items')

    # Filter the inventory items based on the given parameters
    inventories = MyInventory.objects.filter(
        id=inventory_id,   
        inventory_type=inventory_type,
        inventory_category=inventory_category,
        inventory_items=inventory_items
    )

    # Check if any matching inventory items exist
    if not inventories.exists():
        return Response({"detail": "No matching inventory found."}, status=404)

    # Prepare the response data
    response_data = []

    # Iterate over each inventory item
    for inventory in inventories:
        # Get the related crop for this inventory item (assuming it's a ForeignKey)
        crop = inventory.crop

        # Serialize the crop using MyCropDetailsSerializer
        crop_data = MyCropDetailsSerializer(crop).data

        # Add the grouped inventory and crop details to the response data
        response_data.append({
            'inventory_type': inventory.inventory_type.name if inventory.inventory_type else None,
            'inventory_category': inventory.inventory_category.name if inventory.inventory_category else None,
            'inventory_items': inventory.inventory_items.name if inventory.inventory_items else None,
            'crop': crop_data,  # Serialize the crop with detailed information
        })

    # Return the response as a JSON object
    return Response(response_data) 


import requests

 
# # Function to generate OTP
def generate_otp():
    otp_value = random.randint(1000, 9999)  
    print(f"Generated OTP: {otp_value}")  
    return otp_value

def send_otp_sms(mobile_number, otp_value): 
    SMS_TEMPLATE = {
        'authkey': '155099Ajzgw9B8dfq6737236aP1',  
        'sender_id': 'ELYSIU',   
        'template_id': '1007049094377493090',  
        'country_code': '91',  
        'message_content': 'Dear User, Your One Time Password (OTP) for logging into the Elysium Academy Application is {#var#}'  
    }
 
    formatted_mobile_number = SMS_TEMPLATE['country_code'] + str(mobile_number)
 
    message_content = SMS_TEMPLATE['message_content'].replace("{#var#}", str(otp_value))
 
    url = f"https://api.msg91.com/api/sendhttp.php?authkey={SMS_TEMPLATE['authkey']}&sender={SMS_TEMPLATE['sender_id']}&route=default&message={message_content}&mobiles={formatted_mobile_number}&DLT_TE_ID={SMS_TEMPLATE['template_id']}"

    response = requests.get(url)
 
    print(f"Response Text: {response.text}")
    print(f"Response Status Code: {response.status_code}")
 
    if response.status_code == 200:
        response_text = response.text.strip()  
        print(f"Raw Response: {response_text}")
 
        if response_text and len(response_text) > 10:  
            print(f"OTP sent successfully to {formatted_mobile_number}. OTP: {otp_value}")  
            return {"message": "OTP sent successfully.", "status": "success", "otp": otp_value}
        else:
            print(f"Error: {response_text}")
            return {"message": f"Failed to send OTP. {response_text}", "status": "failed"}
    else:
        print(f"Error: Unable to connect to Msg91. HTTP Status Code: {response.status_code}")
        return {"message": "Failed to connect to Msg91.", "status": "failed"}

  
OTP_STORAGE = {}
 
# @api_view(['POST'])
# def verify_otp(request):
#     # Extract mobile number and OTP from the request
#     mobile_number = request.data.get('mobile_number', None)
#     otp = request.data.get('otp', None)
    

#     # Validation for mobile number and OTP
#     if not mobile_number:
#         return Response({"detail": "Mobile number is required."}, status=status.HTTP_400_BAD_REQUEST)
    
#     if not otp:
#         return Response({"detail": "OTP is required."}, status=status.HTTP_400_BAD_REQUEST)
    
#     # Check if OTP exists for this mobile number in FarmerOTP
#     try:
#         otp_record = FarmerOTP.objects.filter(mobile_number=mobile_number).order_by('-created_at').first()
#     except FarmerOTP.DoesNotExist:
#         return Response({"detail": "No OTP request found for this mobile number."}, status=status.HTTP_400_BAD_REQUEST)

#     if not otp_record:
#         return Response({"detail": "No OTP request found for this mobile number."}, status=status.HTTP_400_BAD_REQUEST)

#     # Debug: print OTP values to verify
#     print(f"Stored OTP: {otp_record.otp}, Received OTP: {otp}")

#     # Ensure both stored OTP and received OTP are strings and stripped of any spaces
#     stored_otp = str(otp_record.otp).strip()  # Ensure OTP is a string and strip any extra spaces
#     received_otp = str(otp).strip()  # Ensure OTP is a string and strip any extra spaces

#     # Compare the OTP entered with the stored OTP
#     if stored_otp == received_otp:
#         print("OTP Verified Successfully!")

#         # Fetch the Farmer instance associated with this mobile number
#         try:
#             mobile_instance = Farmer.objects.get(phone=mobile_number)
#             return Response({
#                 "message": "OTP Authenticated successfully",
#                 "status": "existing",
#                 "farmer_details": {"id": mobile_instance.id}
#             }, status=status.HTTP_200_OK)
#         except Farmer.DoesNotExist:
#             return Response({"detail": "Farmer not found for this mobile number."}, status=status.HTTP_400_BAD_REQUEST)
#     else:
#         print("OTP Mismatch!")
#         return Response({"detail": "Invalid OTP."}, status=status.HTTP_400_BAD_REQUEST)

# @api_view(['POST'])
# def verify_otp(request):
#     # Extract mobile number and OTP from the request
#     mobile_number = request.data.get('mobile_number', None)
#     otp = request.data.get('otp', None)
#     fcm_token = request.data.get('token', None)

#     # Validation for mobile number and OTP
#     if not mobile_number:
#         return Response({"detail": "Mobile number is required."}, status=status.HTTP_400_BAD_REQUEST)
    
#     if not otp:
#         return Response({"detail": "OTP is required."}, status=status.HTTP_400_BAD_REQUEST)
    
#     # Check if OTP exists for this mobile number in FarmerOTP
#     try:
#         otp_record = FarmerOTP.objects.filter(mobile_number=mobile_number).order_by('-created_at').first()
#     except FarmerOTP.DoesNotExist:
#         return Response({"detail": "No OTP request found for this mobile number."}, status=status.HTTP_400_BAD_REQUEST)

#     if not otp_record:
#         return Response({"detail": "No OTP request found for this mobile number."}, status=status.HTTP_400_BAD_REQUEST)

#     # Debug: print OTP values to verify
#     print(f"Stored OTP: {otp_record.otp}, Received OTP: {otp}")

#     # Ensure both stored OTP and received OTP are strings and stripped of any spaces
#     stored_otp = str(otp_record.otp).strip()
#     received_otp = str(otp).strip()

#     # Compare the OTP entered with the stored OTP
#     if stored_otp == received_otp:
#         print("OTP Verified Successfully!")

#         try:
#             # Get the Farmer instance
#             mobile_instance = Farmer.objects.get(phone=mobile_number)

#             # Save the FCM token if it's provided
#             if fcm_token:
#                 mobile_instance.fcm_token = fcm_token
#                 mobile_instance.save()

#                 # Optionally send a welcome notification
#                 fcm_response = send_fcm_message(
#                     token=fcm_token,
#                     title="Welcome Back!",
#                     body="You have successfully logged in as a farmer."
#                 )
#                 # print(send_fcm_message)

#                 print(f"FCM Token: {fcm_token}")
#                 print(f"FCM Message Sent Response: {fcm_response}")

#                 if fcm_response.get('success'):
#                     print("âœ… FCM message sent successfully.")
#                 else:
#                     print("âŒ FCM message failed to send.")

#             return Response({
#                 "message": "OTP Authenticated successfully",
#                 "status": "existing",
#                 "farmer_details": {"id": mobile_instance.id}
#             }, status=status.HTTP_200_OK)
#         except Farmer.DoesNotExist:
#             return Response({"detail": "Farmer not found for this mobile number."}, status=status.HTTP_400_BAD_REQUEST)
#     else:
#         print("OTP Mismatch!")
#         return Response({"detail": "Invalid OTP."}, status=status.HTTP_400_BAD_REQUEST)



# @api_view(['POST'])
# def verify_otp(request):
#     mobile_number = request.data.get('mobile_number', None)
#     otp = request.data.get('otp', None)
#     fcm_token = request.data.get('token', None)

#     print(f"Received mobile_number: {mobile_number}")
#     print(f"Received otp: {otp}")
#     print(f"Received FCM token: {fcm_token}")

#     if not mobile_number:
#         return Response({"detail": "Mobile number is required."}, status=status.HTTP_400_BAD_REQUEST)
#     if not otp:
#         return Response({"detail": "OTP is required."}, status=status.HTTP_400_BAD_REQUEST)

#     try:
#         otp_record = FarmerOTP.objects.filter(mobile_number=mobile_number).order_by('-created_at').first()
#     except FarmerOTP.DoesNotExist:
#         return Response({"detail": "No OTP request found for this mobile number."}, status=status.HTTP_400_BAD_REQUEST)

#     if not otp_record:
#         return Response({"detail": "No OTP request found for this mobile number."}, status=status.HTTP_400_BAD_REQUEST)

#     print(f"Stored OTP: {otp_record.otp}, Received OTP: {otp}")

#     stored_otp = str(otp_record.otp).strip()
#     received_otp = str(otp).strip()

#     if stored_otp == received_otp:
#         print("OTP Verified Successfully!")

#         try:
#             mobile_instance = Farmer.objects.get(phone=mobile_number)

#             if fcm_token:
#                 print(f"Preparing to send FCM message to token: {fcm_token}")
#                 mobile_instance.fcm_token = fcm_token
#                 mobile_instance.save()

#                 fcm_response = send_fcm_message(
#                     token=fcm_token,
#                     title="Welcome Back!",
#                     body="You have successfully logged in as a farmer."
#                 )

#                 print(f"FCM Token: {fcm_token}")
#                 print(f"FCM Message Sent Response: {fcm_response}")

#                 # Check if 'name' key exists in response -> success
#                 if 'name' in fcm_response:
#                     print("âœ… FCM message sent successfully.")
#                 else:
#                     print("âŒ FCM message failed to send.")
#             else:
#                 print("No FCM token provided, skipping FCM message.")

#             return Response({
#                 "message": "OTP Authenticated successfully",
#                 "status": "existing",
#                 "farmer_details": {"id": mobile_instance.id}
#             }, status=status.HTTP_200_OK)
#         except Farmer.DoesNotExist:
#             return Response({"detail": "Farmer not found for this mobile number."}, status=status.HTTP_400_BAD_REQUEST)
#     else:
#         print("OTP Mismatch!")
#         return Response({"detail": "Invalid OTP."}, status=status.HTTP_400_BAD_REQUEST)

# @api_view(['POST'])
# def verify_otp(request):
#     mobile_number = request.data.get('mobile_number', None)
#     email = request.data.get('email', None)
#     otp = request.data.get('otp', None)
#     fcm_token = request.data.get('token', None)

#     print(f"Received mobile_number: {mobile_number}")
#     print(f"Received email: {email}")
#     print(f"Received otp: {otp}")
#     print(f"Received FCM token: {fcm_token}")

#     if not mobile_number and not email:
#         return Response({"detail": "Mobile number or email is required."}, status=status.HTTP_400_BAD_REQUEST)
#     if not otp:
#         return Response({"detail": "OTP is required."}, status=status.HTTP_400_BAD_REQUEST)

#     # Fetch OTP record by mobile_number or email
#     otp_record = None
#     if mobile_number:
#         otp_record = FarmerOTP.objects.filter(mobile_number=mobile_number).order_by('-created_at').first()
#     elif email:
#         otp_record = FarmerOTP.objects.filter(email=email.lower()).order_by('-created_at').first()

#     if not otp_record:
#         return Response({"detail": "No OTP request found for the provided identifier."}, status=status.HTTP_400_BAD_REQUEST)

#     print(f"Stored OTP: {otp_record.otp}, Received OTP: {otp}")

#     stored_otp = str(otp_record.otp).strip()
#     received_otp = str(otp).strip()

#     if stored_otp == received_otp:
#         print("OTP Verified Successfully!")

#         # Fetch Farmer instance by mobile_number or email
#         try:
#             if mobile_number:
#                 farmer_instance = Farmer.objects.get(phone=mobile_number)
#             else:
#                 farmer_instance = Farmer.objects.get(email=email.lower())

#             if fcm_token:
#                 print(f"Preparing to send FCM message to token: {fcm_token}")
#                 farmer_instance.fcm_token = fcm_token
#                 farmer_instance.save()

#                 fcm_response = send_fcm_message(
#                     token=fcm_token,
#                     title="Welcome Back!",
#                     body="You have successfully logged in as a farmer."
#                 )

#                 print(f"FCM Token: {fcm_token}")
#                 print(f"FCM Message Sent Response: {fcm_response}")

#                 if 'name' in fcm_response:
#                     print("âœ… FCM message sent successfully.")
#                 else:
#                     print("âŒ FCM message failed to send.")
#             else:
#                 print("No FCM token provided, skipping FCM message.")

#             return Response({
#                 "message": "OTP Authenticated successfully",
#                 "status": "existing",
#                 "farmer_details": {"id": farmer_instance.id}
#             }, status=status.HTTP_200_OK)

#         except Farmer.DoesNotExist:
#             return Response({"detail": "Farmer not found for the provided identifier."}, status=status.HTTP_400_BAD_REQUEST)

#     else:
#         print("OTP Mismatch!")
#         return Response({"detail": "Invalid OTP."}, status=status.HTTP_400_BAD_REQUEST)

# @api_view(['POST'])
# def verify_otp(request):
#     mobile_number = request.data.get('mobile_number', None)
#     email = request.data.get('email', None)
#     otp = request.data.get('otp', None)

#     print(f"Received mobile_number: {mobile_number}")
#     print(f"Received email: {email}")
#     print(f"Received otp: {otp}")

#     if not mobile_number and not email:
#         return Response({"detail": "Mobile number or email is required."}, status=status.HTTP_400_BAD_REQUEST)
#     if not otp:
#         return Response({"detail": "OTP is required."}, status=status.HTTP_400_BAD_REQUEST)

#     # Fetch OTP record by mobile_number or email
#     otp_record = None
#     if mobile_number:
#         otp_record = FarmerOTP.objects.filter(mobile_number=mobile_number).order_by('-created_at').first()
#     elif email:
#         otp_record = FarmerOTP.objects.filter(email=email.lower()).order_by('-created_at').first()

#     if not otp_record:
#         return Response({"detail": "No OTP request found for the provided identifier."}, status=status.HTTP_400_BAD_REQUEST)

#     print(f"Stored OTP: {otp_record.otp}, Received OTP: {otp}")

#     stored_otp = str(otp_record.otp).strip()
#     received_otp = str(otp).strip()

#     if stored_otp == received_otp:
#         print("OTP Verified Successfully!") 

#         # Fetch Farmer instance by mobile_number or email
#         try:
#             if mobile_number:
#                 farmer_instance = Farmer.objects.get(phone=mobile_number)
#             else:
#                 farmer_instance = Farmer.objects.get(email=email.lower())

#             return Response({
#                 "message": "OTP Authenticated successfully",
#                 "status": "existing",
#                 "farmer_details": {"id": farmer_instance.id}
#             }, status=status.HTTP_200_OK)

#         except Farmer.DoesNotExist:
#             return Response({"detail": "Farmer not found for the provided identifier."}, status=status.HTTP_400_BAD_REQUEST)

#     else:
#         print("OTP Mismatch!")
#         return Response({"detail": "Invalid OTP."}, status=status.HTTP_400_BAD_REQUEST)

# @api_view(['POST'])
# def verify_otp(request):
#     mobile_number = request.data.get('mobile_number')
#     email = request.data.get('email')
#     otp = request.data.get('otp')
#     google_login = request.data.get('google_login', False)  # âœ… flag carried forward

#     if not mobile_number and not email:
#         return Response({"detail": "Mobile number or email is required."}, status=status.HTTP_400_BAD_REQUEST)
#     if not otp:
#         return Response({"detail": "OTP is required."}, status=status.HTTP_400_BAD_REQUEST)

#     # Fetch OTP record
#     otp_record = None
#     if mobile_number:
#         otp_record = FarmerOTP.objects.filter(mobile_number=mobile_number).order_by('-created_at').first()
#     elif email:
#         otp_record = FarmerOTP.objects.filter(email=email.lower()).order_by('-created_at').first()

#     if not otp_record:
#         return Response({"detail": "No OTP request found for the provided identifier."}, status=status.HTTP_400_BAD_REQUEST)

#     stored_otp = str(otp_record.otp).strip()
#     received_otp = str(otp).strip()

#     if stored_otp != received_otp:
#         return Response({"detail": "Invalid OTP."}, status=status.HTTP_400_BAD_REQUEST)

#     # âœ… OTP verified
#     try:
#         if mobile_number:
#             farmer_instance = Farmer.objects.get(phone=mobile_number)
#         else:
#             farmer_instance = Farmer.objects.get(email=email.lower())

#         # If this is Google login, update flag
#         if google_login:
#             farmer_instance.google_login = True
#             farmer_instance.save(update_fields=["google_login"])

#         return Response({
#             "message": "OTP Authenticated successfully",
#             "status": "existing",
#             "farmer_details": {"id": farmer_instance.id, "google_login": farmer_instance.google_login}
#         }, status=status.HTTP_200_OK)

#     except Farmer.DoesNotExist:
#         # If farmer doesnâ€™t exist â†’ create one (especially for Google login)
#         farmer_instance = Farmer.objects.create(
#             phone=mobile_number if mobile_number else None,
#             email=email.lower() if email else None,
#             google_login=google_login
#         )
#         return Response({
#             "message": "OTP Authenticated successfully",
#             "status": "new",
#             "farmer_details": {"id": farmer_instance.id, "google_login": farmer_instance.google_login}
#         }, status=status.HTTP_201_CREATED)

@api_view(['POST'])
def verify_otp(request):
    mobile_number = request.data.get('mobile_number')
    email = request.data.get('email')
    otp = request.data.get('otp')
    google_login = request.data.get('google_login', False)  # âœ… flag

    # If Google login, skip OTP verification
    if google_login:
        try:
            if mobile_number:
                farmer_instance = Farmer.objects.get(phone=mobile_number)
            elif email:
                farmer_instance = Farmer.objects.get(email=email.lower())
            else:
                return Response({"detail": "Mobile number or email is required."}, status=status.HTTP_400_BAD_REQUEST)

            # Update Google login flag
            farmer_instance.google_login = True
            farmer_instance.save(update_fields=["google_login"])

            return Response({
                "message": "Google login successful",
                "status": "existing",
                "farmer_details": {"id": farmer_instance.id, "google_login": farmer_instance.google_login}
            }, status=status.HTTP_200_OK)

        except Farmer.DoesNotExist:
            # Create new farmer for Google login
            farmer_instance = Farmer.objects.create(
                phone=mobile_number if mobile_number else None,
                email=email.lower() if email else None,
                google_login=True
            )
            return Response({
                "message": "Google login successful",
                "status": "new",
                "farmer_details": {"id": farmer_instance.id, "google_login": farmer_instance.google_login}
            }, status=status.HTTP_201_CREATED)

    # ðŸ”¹ Fallback to OTP verification flow for normal login
    if not mobile_number and not email:
        return Response({"detail": "Mobile number or email is required."}, status=status.HTTP_400_BAD_REQUEST)
    if not otp:
        return Response({"detail": "OTP is required."}, status=status.HTTP_400_BAD_REQUEST)

    # Fetch OTP record
    otp_record = None
    if mobile_number:
        otp_record = FarmerOTP.objects.filter(mobile_number=mobile_number).order_by('-created_at').first()
    elif email:
        otp_record = FarmerOTP.objects.filter(email=email.lower()).order_by('-created_at').first()

    if not otp_record:
        return Response({"detail": "No OTP request found for the provided identifier."}, status=status.HTTP_400_BAD_REQUEST)

    stored_otp = str(otp_record.otp).strip()
    received_otp = str(otp).strip()

    if stored_otp != received_otp:
        return Response({"detail": "Invalid OTP."}, status=status.HTTP_400_BAD_REQUEST)

    # OTP verified
    try:
        if mobile_number:
            farmer_instance = Farmer.objects.get(phone=mobile_number)
        else:
            farmer_instance = Farmer.objects.get(email=email.lower())

        return Response({
            "message": "OTP Authenticated successfully",
            "status": "existing",
            "farmer_details": {"id": farmer_instance.id, "google_login": farmer_instance.google_login}
        }, status=status.HTTP_200_OK)

    except Farmer.DoesNotExist:
        farmer_instance = Farmer.objects.create(
            phone=mobile_number if mobile_number else None,
            email=email.lower() if email else None,
            google_login=False
        )
        return Response({
            "message": "OTP Authenticated successfully",
            "status": "new",
            "farmer_details": {"id": farmer_instance.id, "google_login": farmer_instance.google_login}
        }, status=status.HTTP_201_CREATED)



OTP_STORAGE = {}  # In-memory storage for OTPs

 
# mobile_number
# @api_view(['POST'])
# def get_otp(request):
#     mobile_number = request.data.get('mobile_number', None)
#     name = request.data.get('name', None)
#     # fcm_token = request.data.get('fcm_token', None)

#     if not mobile_number:
#         return Response({"detail": "Mobile number is required."}, status=status.HTTP_400_BAD_REQUEST)

#     try:
#         mobile_number = str(mobile_number).strip()
#     except Exception as e:
#         return Response({"detail": f"Invalid mobile number: {e}"}, status=status.HTTP_400_BAD_REQUEST)

#     if not mobile_number.startswith(('9', '8', '7', '6')):
#         return Response({"detail": "Mobile number must start with 9, 8, 7, or 6."}, status=status.HTTP_400_BAD_REQUEST)
 
#     if len(mobile_number) > 15:
#         return Response({"detail": "Mobile number exceeds maximum length of 15 characters."}, status=status.HTTP_400_BAD_REQUEST)
 
#     existing_farmer = Farmer.objects.filter(
#         Q(phone=mobile_number) & (Q(status=0) | Q(status=7))
#     ).first()

#     if existing_farmer: 
#         if existing_farmer.status == 1:
#             return Response({"detail": "This Farmer is Inactive."}, status=status.HTTP_400_BAD_REQUEST)
#         elif existing_farmer.status == 2:
#             return Response({"detail": "No Such Farmer Found."}, status=status.HTTP_400_BAD_REQUEST) 
 
#         has_my_land = MyLand.objects.filter(farmer=existing_farmer, status=0).exists()
#         land_details = None

#         if has_my_land:
#             land = MyLand.objects.filter(farmer=existing_farmer, status=0).first()
#             land_details = {
#                 "latitude": land.latitude,
#                 "longitude": land.longitude,
#             }

#         has_my_crop = MyCrop.objects.filter(farmer=existing_farmer, status=0).exists()

#         has_details = all([
#             existing_farmer.name,
#             existing_farmer.phone,
#             # existing_farmer.email,
#             existing_farmer.country,
#             existing_farmer.state,
#             existing_farmer.city,
#             existing_farmer.taluk,
#             existing_farmer.village,
#             # existing_farmer.door_no,
#             existing_farmer.pincode,
#         ])

#         name_to_display = "" if existing_farmer.status == 7 else existing_farmer.name
 
         
#         otp_record = FarmerOTP.objects.filter(mobile_number=mobile_number).first()

#         if otp_record: 
#             # If OTP record exists, just use the existing OTP
#             otp_value = otp_record.otp
#             otp_sent = False   
#         else: 
#             # If no OTP record exists, generate a new OTP and update the record
#             otp_value = generate_otp()
#             otp_expiry_time = timezone.now() + timedelta(days=365) 
            
#             # Update the existing OTP record if it exists or create one if not
#             otp_record = FarmerOTP.objects.update_or_create(
#                 mobile_number=mobile_number,
#                 defaults={
#                     'otp': otp_value,
#                     'created_at': timezone.now(), 
#                     'expires_at': otp_expiry_time,
#                 }
#             )
#             otp_sent = True

#         # Store the OTP in memory for later use
#         OTP_STORAGE[mobile_number] = otp_value

#         # Send the OTP to the mobile number
#         otp_response = send_otp_sms(mobile_number, otp_value)
#         # existing_farmer.fcm_token = fcm_token
#         existing_farmer.save()

#         # send_fcm_message(
#         #     token=fcm_token,
#         #     title="Welcome Back!",
#         #     body="You have successfully logged in as a farmer."
#         # )

#         return Response({
#             "message": "Existing Farmer",
#             "user": False,
#             "details": has_details,
#             "land": has_my_land,
#             "land_details": land_details,
#             "crop": has_my_crop,
#             "farmer": {
#                 "id": existing_farmer.id,
#                 "name": name_to_display,
#                 "phone": existing_farmer.phone,
#                 "email": existing_farmer.email,
#                 "country": {
#                     "id": existing_farmer.country.id if existing_farmer.country else None,
#                     "name": existing_farmer.country.name if existing_farmer.country else ""
#                 },
#                 "state": {
#                     "id": existing_farmer.state.id if existing_farmer.state else None,
#                     "name": existing_farmer.state.name if existing_farmer.state else ""
#                 },
#                 "city": {
#                     "id": existing_farmer.city.id if existing_farmer.city else None,
#                     "name": existing_farmer.city.name if existing_farmer.city else ""
#                 },
#                 "taluk": {
#                     "id": existing_farmer.taluk.id if existing_farmer.taluk else None,
#                     "name": existing_farmer.taluk.name if existing_farmer.taluk else ""
#                 },
#                 "village": {
#                     "id": existing_farmer.village.id if existing_farmer.village else None,
#                     "name": existing_farmer.village.name if existing_farmer.village else ""
#                 },
#                 "door_no": existing_farmer.door_no,
#                 "pincode": existing_farmer.pincode,
#                 "description": existing_farmer.description,
#                 "img": existing_farmer.img.url if existing_farmer.img else None,
#                 "company_name": existing_farmer.company_name,
#                 "tax_no": existing_farmer.tax_no,
#                 "username": existing_farmer.username,
#                 "subscription_package": {
#                     "id": existing_farmer.subscription_package.id if existing_farmer.subscription_package else None,
#                     "name": existing_farmer.subscription_package.name if existing_farmer.subscription_package else ""
#                 },
#                 "subscription_start_date": existing_farmer.subscription_start_date,
#                 "subscription_end_date": existing_farmer.subscription_end_date,
#                 "remaining_days": existing_farmer.remaining_days,
#                 "amounts": existing_farmer.amounts,
#                 "status": existing_farmer.status,
#                 "language": {
#                     "default": "en"
#                 },
#                   "otp": otp_value
#             }, 
#         }, status=status.HTTP_200_OK)
 
 

#     with transaction.atomic():
#         if name is None:
#             base_name = "Farmer"
#             base_len = len(base_name) + 1

#             max_suffix = Farmer.objects.filter(name__startswith=base_name) \
#                 .annotate(
#                     suffix_str=Substr('name', base_len)
#                 ).filter(
#                     suffix_str__regex=r'^\d+$'  # Only numeric suffixes
#                 ).annotate(
#                     suffix=Cast('suffix_str', output_field=IntegerField())
#                 ).aggregate(
#                     max_suffix=Max('suffix')
#                 )['max_suffix'] or 0

#             name = f"{base_name}{max_suffix + 1}"
 
#         farmer = Farmer.objects.create(
#             phone=mobile_number,
#             name=name,
#             status=7,   
#             created_at=timezone.now(),
#             # fcm_token=fcm_token
#         )
 
#         farmer.save()

#         create_default_subscription(farmer)
 
#     otp_value = generate_otp()
#     otp_expiry_time = timezone.now() + timedelta(days=365)
#     otp_record = FarmerOTP.objects.create(
#         mobile_number=mobile_number,
#         otp=otp_value,
#         created_at=timezone.now(),
#         expires_at=otp_expiry_time,
#     )
#     otp_record.save()
 
#     OTP_STORAGE[mobile_number] = otp_value
 
#     otp_response = send_otp_sms(mobile_number, otp_value)

#     # send_fcm_message(
#     #             token=fcm_token,
#     #             title="Welcome New Farmer",
#     #             body="You have been successfully registered as a Farmer!"
#     #         )

#     name_to_display = "" if farmer.status == 7 else farmer.name

#     response_data = {
#         "message": "New Farmer",
#         "user": True,
#         "details": False,
#         "has_my_land": False,
#         "has_my_crop": False,
#         "farmer": {
#             "id": farmer.id,
#             "name": name_to_display,
#             "phone": farmer.phone,
#             "email": farmer.email,
#             "country": {
#                 "id": farmer.country.id if farmer.country else None,
#                 "name": farmer.country.name if farmer.country else ""
#             },
#             "state": {
#                 "id": farmer.state.id if farmer.state else None,
#                 "name": farmer.state.name if farmer.state else ""
#             },
#             "city": {
#                 "id": farmer.city.id if farmer.city else None,
#                 "name": farmer.city.name if farmer.city else ""
#             },
#             "taluk": {
#                 "id": farmer.taluk.id if farmer.taluk else None,
#                 "name": farmer.taluk.name if farmer.taluk else ""
#             },
#             "village": {
#                 "id": farmer.village.id if farmer.village else None,
#                 "name": farmer.village.name if farmer.village else ""
#             },
#             "door_no": farmer.door_no,
#             "pincode": farmer.pincode,
#             "description": farmer.description,
#             "img": farmer.img.url if farmer.img else "",
#             "company_name": farmer.company_name,
#             "tax_no": farmer.tax_no,
#             "username": farmer.username,
#             "subscription_package": {
#                 "id": farmer.subscription_package.id if farmer.subscription_package else None,
#                 "name": farmer.subscription_package.name if farmer.subscription_package else ""
#             },
#             "subscription_start_date": farmer.subscription_start_date,
#             "subscription_end_date": farmer.subscription_end_date,
#             "remaining_days": farmer.remaining_days,
#             "amounts": farmer.amounts,
#             "status": farmer.status,
#             "language": {
#                 "default": "en"
#             }
#         },
#         "otp_sent": True,
#           "otp": otp_value,
#     }

#     return Response(response_data, status=status.HTTP_201_CREATED)

# email
 
# @api_view(['POST'])
# def get_otp(request):
#     mobile_number = request.data.get('mobile_number')
#     email = request.data.get('email')
#     name = request.data.get('name')

#     if not mobile_number and not email:
#         return Response({"detail": "Mobile number or email is required."}, status=status.HTTP_400_BAD_REQUEST)

#     existing_farmer = None

#     # Validate mobile number if provided
#     if mobile_number:
#         mobile_number = str(mobile_number).strip()
#         if not mobile_number.startswith(('9', '8', '7', '6')):
#             return Response({"detail": "Mobile number must start with 9, 8, 7, or 6."}, status=status.HTTP_400_BAD_REQUEST)
#         if len(mobile_number) > 10:
#             return Response({"detail": "Mobile number exceeds maximum length of 10 characters."}, status=status.HTTP_400_BAD_REQUEST)
#         existing_farmer = Farmer.objects.filter(Q(phone=mobile_number) & (Q(status=0) | Q(status=7))).first()

#     # Validate email if provided
#     if email and not existing_farmer:
#         email = email.strip().lower()
#         existing_farmer = Farmer.objects.filter(Q(email=email) & (Q(status=0) | Q(status=7))).first()

#     # Existing Farmer logic
#     if existing_farmer:
#         if existing_farmer.status == 1:
#             return Response({"detail": "This Farmer is Inactive."}, status=status.HTTP_400_BAD_REQUEST)
#         elif existing_farmer.status == 2:
#             return Response({"detail": "No Such Farmer Found."}, status=status.HTTP_400_BAD_REQUEST)

#         has_my_land = MyLand.objects.filter(farmer=existing_farmer, status=0).exists()
#         land_details = None
#         if has_my_land:
#             land = MyLand.objects.filter(farmer=existing_farmer, status=0).first()
#             land_details = {"latitude": land.latitude, "longitude": land.longitude}

#         has_my_crop = MyCrop.objects.filter(farmer=existing_farmer, status=0).exists()
#         has_details = all([
#             existing_farmer.name,
#             existing_farmer.phone or True,
#             existing_farmer.email or True,
#             existing_farmer.country,
#             existing_farmer.state,
#             existing_farmer.city,
#             existing_farmer.taluk,
#             existing_farmer.village,
#             existing_farmer.pincode,
#         ])
#         name_to_display = "" if existing_farmer.status == 7 else existing_farmer.name

#         # Get or create OTP
#         otp_record = FarmerOTP.objects.filter(
#             mobile_number=mobile_number if mobile_number else None,
#             email=email if email else None
#         ).first()

#         if otp_record:
#             otp_value = otp_record.otp
#             otp_sent = False
#         else:
#             otp_value = generate_otp()
#             otp_expiry_time = timezone.now() + timedelta(days=365)
#             FarmerOTP.objects.update_or_create(
#                 mobile_number=mobile_number if mobile_number else None,
#                 email=email if email else None,
#                 defaults={'otp': otp_value, 'created_at': timezone.now(), 'expires_at': otp_expiry_time}
#             )
#             otp_sent = True

#         OTP_STORAGE[mobile_number or email] = otp_value
#         if mobile_number:
#             send_otp_sms(mobile_number, otp_value)
#         else:
#             send_otp_email(email, otp_value)

#         existing_farmer.save()

#         return Response({
#             "message": "Existing Farmer",
#             "user": False,
#             "details": has_details,
#             "land": has_my_land,
#             "land_details": land_details,
#             "crop": has_my_crop,
#             "farmer": {
#                 "id": existing_farmer.id,
#                 "name": name_to_display,
#                 "phone": existing_farmer.phone,
#                 "email": existing_farmer.email,
#                 "country": {"id": existing_farmer.country.id if existing_farmer.country else None,
#                             "name": existing_farmer.country.name if existing_farmer.country else ""},
#                 "state": {"id": existing_farmer.state.id if existing_farmer.state else None,
#                           "name": existing_farmer.state.name if existing_farmer.state else ""},
#                 "city": {"id": existing_farmer.city.id if existing_farmer.city else None,
#                          "name": existing_farmer.city.name if existing_farmer.city else ""},
#                 "taluk": {"id": existing_farmer.taluk.id if existing_farmer.taluk else None,
#                           "name": existing_farmer.taluk.name if existing_farmer.taluk else ""},
#                 "village": {"id": existing_farmer.village.id if existing_farmer.village else None,
#                             "name": existing_farmer.village.name if existing_farmer.village else ""},
#                 "door_no": existing_farmer.door_no,
#                 "pincode": existing_farmer.pincode,
#                 "description": existing_farmer.description,
#                 "img": existing_farmer.img.url if existing_farmer.img else None,
#                 "company_name": existing_farmer.company_name,
#                 "tax_no": existing_farmer.tax_no,
#                 "username": existing_farmer.username,
#                 "subscription_package": {
#                     "id": existing_farmer.subscription_package.id if existing_farmer.subscription_package else None,
#                     "name": existing_farmer.subscription_package.name if existing_farmer.subscription_package else ""
#                 },
#                 "subscription_start_date": existing_farmer.subscription_start_date,
#                 "subscription_end_date": existing_farmer.subscription_end_date,
#                 "remaining_days": existing_farmer.remaining_days,
#                 "amounts": existing_farmer.amounts,
#                 "status": existing_farmer.status,
#                 "language": {"default": "en"},
#                 "otp": otp_value
#             }
#         }, status=status.HTTP_200_OK)

#     # New Farmer creation
#     with transaction.atomic():
#         if not name:
#             base_name = "Farmer"
#             base_len = len(base_name) + 1
#             max_suffix = Farmer.objects.filter(name__startswith=base_name) \
#                 .annotate(suffix_str=Substr('name', base_len)) \
#                 .filter(suffix_str__regex=r'^\d+$') \
#                 .annotate(suffix=Cast('suffix_str', IntegerField())) \
#                 .aggregate(max_suffix=Max('suffix'))['max_suffix'] or 0
#             name = f"{base_name}{max_suffix + 1}"

#         farmer_data = {"name": name, "status": 7, "created_at": timezone.now()}
#         if mobile_number:
#             farmer_data["phone"] = mobile_number
#         if email:
#             farmer_data["email"] = email

#         farmer = Farmer.objects.create(**farmer_data)
#         create_default_subscription(farmer)

#         otp_value = generate_otp()
#         otp_expiry_time = timezone.now() + timedelta(days=365)
#         FarmerOTP.objects.create(
#             mobile_number=mobile_number if mobile_number else None,
#             email=email if email else None,
#             otp=otp_value,
#             created_at=timezone.now(),
#             expires_at=otp_expiry_time
#         )
#         OTP_STORAGE[mobile_number or email] = otp_value

#         if mobile_number:
#             send_otp_sms(mobile_number, otp_value)
#         else:
#             send_otp_email(email, otp_value)

#     name_to_display = "" if farmer.status == 7 else farmer.name

#     response_data = {
#         "message": "New Farmer",
#         "user": True,
#         "details": False,
#         "has_my_land": False,
#         "has_my_crop": False,
#         "farmer": {
#             "id": farmer.id,
#             "name": name_to_display,
#             "phone": farmer.phone,
#             "email": farmer.email,
#             "country": {"id": farmer.country.id if farmer.country else None,
#                         "name": farmer.country.name if farmer.country else ""},
#             "state": {"id": farmer.state.id if farmer.state else None,
#                       "name": farmer.state.name if farmer.state else ""},
#             "city": {"id": farmer.city.id if farmer.city else None,
#                      "name": farmer.city.name if farmer.city else ""},
#             "taluk": {"id": farmer.taluk.id if farmer.taluk else None,
#                       "name": farmer.taluk.name if farmer.taluk else ""},
#             "village": {"id": farmer.village.id if farmer.village else None,
#                         "name": farmer.village.name if farmer.village else ""},
#             "door_no": farmer.door_no,
#             "pincode": farmer.pincode,
#             "description": farmer.description,
#             "img": farmer.img.url if farmer.img else "",
#             "company_name": farmer.company_name,
#             "tax_no": farmer.tax_no,
#             "username": farmer.username,
#             "subscription_package": {
#                 "id": farmer.subscription_package.id if farmer.subscription_package else None,
#                 "name": farmer.subscription_package.name if farmer.subscription_package else ""
#             },
#             "subscription_start_date": farmer.subscription_start_date,
#             "subscription_end_date": farmer.subscription_end_date,
#             "remaining_days": farmer.remaining_days,
#             "amounts": farmer.amounts,
#             "status": farmer.status,
#             "language": {"default": "en"},
#         },
#         "otp_sent": True,
#         "otp": otp_value,
#     }

#     return Response(response_data, status=status.HTTP_201_CREATED)

@api_view(['POST'])
def get_otp(request):
    mobile_number = request.data.get('mobile_number')
    email = request.data.get('email')
    name = request.data.get('name')
    google_login = request.data.get('google_login', False)

    if not mobile_number and not email:
        return Response({"detail": "Mobile number or email is required."}, status=status.HTTP_400_BAD_REQUEST)

    existing_farmer = None

    # Validate mobile number if provided
    if mobile_number:
        mobile_number = str(mobile_number).strip()
        if not google_login:
            if not mobile_number.startswith(('9', '8', '7', '6')):
                return Response({"detail": "Mobile number must start with 9, 8, 7, or 6."}, status=status.HTTP_400_BAD_REQUEST)
            if len(mobile_number) > 10:
                return Response({"detail": "Mobile number exceeds maximum length of 10 characters."}, status=status.HTTP_400_BAD_REQUEST)
        existing_farmer = Farmer.objects.filter(Q(phone=mobile_number) & (Q(status=0) | Q(status=7))).first()

    # Validate email if provided
    if email and not existing_farmer:
        email = email.strip().lower()
        existing_farmer = Farmer.objects.filter(Q(email=email) & (Q(status=0) | Q(status=7))).first()

    # -------------------- GOOGLE LOGIN FLOW --------------------
    if google_login:
        # Existing farmer
        if existing_farmer:
            existing_farmer.google_login = True
            existing_farmer.save()

            has_my_land = MyLand.objects.filter(farmer=existing_farmer, status=0).exists()
            land_details = None
            if has_my_land:
                land = MyLand.objects.filter(farmer=existing_farmer, status=0).first()
                land_details = {"latitude": land.latitude, "longitude": land.longitude}

            has_my_crop = MyCrop.objects.filter(farmer=existing_farmer, status=0).exists()
            has_details = all([
                existing_farmer.name,
                existing_farmer.phone or True,
                existing_farmer.email or True,
                existing_farmer.pincode,
            ])
            name_to_display = "" if existing_farmer.status == 7 else existing_farmer.name

            return Response({
                "message": "Existing Farmer",
                "user": False,
                "details": has_details,
                "land": has_my_land,
                "land_details": land_details,
                "crop": has_my_crop,
                "farmer": {
                    "id": existing_farmer.id,
                    "language": {"default": "en"},
                    "otp": ""
                }
            }, status=status.HTTP_200_OK)

        # New farmer via Google login
        with transaction.atomic():
            if not name:
                base_name = "Farmer"
                base_len = len(base_name) + 1
                max_suffix = Farmer.objects.filter(name__startswith=base_name) \
                    .annotate(suffix_str=Substr('name', base_len)) \
                    .filter(suffix_str__regex=r'^\d+$') \
                    .annotate(suffix=Cast('suffix_str', IntegerField())) \
                    .aggregate(max_suffix=Max('suffix'))['max_suffix'] or 0
                name = f"{base_name}{max_suffix + 1}"

            farmer_data = {"name": name, "status": 7, "created_at": timezone.now(), "google_login": True}
            if mobile_number:
                farmer_data["phone"] = mobile_number
            if email:
                farmer_data["email"] = email

            farmer = Farmer.objects.create(**farmer_data)
            create_default_subscription(farmer)

        name_to_display = "" if farmer.status == 7 else farmer.name
        return Response({
            "message": "New Farmer",
            "user": True,
            "details": False,
            "has_my_land": False,
            "has_my_crop": False,
            "farmer": {
                "id": farmer.id,
                "language": {"default": "en"},
                "otp": ""
            },
            "otp_sent": False
        }, status=status.HTTP_201_CREATED)

    # -------------------- OTP LOGIN FLOW --------------------
    if existing_farmer:
        if existing_farmer.status == 1:
            return Response({"detail": "This Farmer is Inactive."}, status=status.HTTP_400_BAD_REQUEST)
        elif existing_farmer.status == 2:
            return Response({"detail": "No Such Farmer Found."}, status=status.HTTP_400_BAD_REQUEST)

        has_my_land = MyLand.objects.filter(farmer=existing_farmer, status=0).exists()
        land_details = None
        if has_my_land:
            land = MyLand.objects.filter(farmer=existing_farmer, status=0).first()
            land_details = {"latitude": land.latitude, "longitude": land.longitude}

        has_my_crop = MyCrop.objects.filter(farmer=existing_farmer, status=0).exists()
        has_details = all([
            existing_farmer.name,
            existing_farmer.phone or True,
            existing_farmer.email or True,
            existing_farmer.pincode,
        ])
        name_to_display = "" if existing_farmer.status == 7 else existing_farmer.name

        otp_record = FarmerOTP.objects.filter(
            mobile_number=mobile_number if mobile_number else None,
            email=email if email else None
        ).first()

        if otp_record:
            otp_value = otp_record.otp
            otp_sent = False
        else:
            otp_value = generate_otp()
            otp_expiry_time = timezone.now() + timedelta(days=365)
            FarmerOTP.objects.update_or_create(
                mobile_number=mobile_number if mobile_number else None,
                email=email if email else None,
                defaults={'otp': otp_value, 'created_at': timezone.now(), 'expires_at': otp_expiry_time}
            )
            otp_sent = True

        OTP_STORAGE[mobile_number or email] = otp_value
        if mobile_number:
            send_otp_sms(mobile_number, otp_value)
        else:
            send_otp_email(email, otp_value)

        return Response({
            "message": "Existing Farmer",
            "user": False,
            "details": has_details,
            "land": has_my_land,
            "land_details": land_details,
            "crop": has_my_crop,
            "farmer": {
                "id": existing_farmer.id,
                "otp": otp_value
            },
            "otp_sent": otp_sent
        }, status=status.HTTP_200_OK)

    # -------------------- NEW FARMER OTP FLOW --------------------
    with transaction.atomic():
        if not name:
            base_name = "Farmer"
            base_len = len(base_name) + 1
            max_suffix = Farmer.objects.filter(name__startswith=base_name) \
                .annotate(suffix_str=Substr('name', base_len)) \
                .filter(suffix_str__regex=r'^\d+$') \
                .annotate(suffix=Cast('suffix_str', IntegerField())) \
                .aggregate(max_suffix=Max('suffix'))['max_suffix'] or 0
            name = f"{base_name}{max_suffix + 1}"

        farmer_data = {"name": name, "status": 7, "created_at": timezone.now()}
        if mobile_number:
            farmer_data["phone"] = mobile_number
        if email:
            farmer_data["email"] = email

        farmer = Farmer.objects.create(**farmer_data)
        create_default_subscription(farmer)

        otp_value = generate_otp()
        otp_expiry_time = timezone.now() + timedelta(days=365)
        FarmerOTP.objects.create(
            mobile_number=mobile_number if mobile_number else None,
            email=email if email else None,
            otp=otp_value,
            created_at=timezone.now(),
            expires_at=otp_expiry_time
        )
        OTP_STORAGE[mobile_number or email] = otp_value

        if mobile_number:
            send_otp_sms(mobile_number, otp_value)
        else:
            send_otp_email(email, otp_value)

    return Response({
        "message": "New Farmer",
        "user": True,
        "details": False,
        "has_my_land": False,
        "has_my_crop": False,
        "farmer": {
            "id": farmer.id,
            "language": {"default": "en"},
            "otp": otp_value
        },
        "otp_sent": True
    }, status=status.HTTP_201_CREATED)


def create_default_subscription(farmer):
    # Create a default subscription for the farmer
    package = PackageManagement.objects.first()  # Example: Get the first available package as the default
    if package:
        # Calculate start and end dates for the subscription
        start_date = timezone.now().date()
        end_date = start_date + timedelta(days=package.package_validity)  # Example: adding package validity in days
        remaining_days = (end_date - start_date).days

        # Create the subscription for the farmer
        subscription = AddSubcription.objects.create(
            farmers=farmer,
            packages=package,
            status=7,  # Default status (active)
            startdate=start_date,
            enddate=end_date,
            remainingdays=remaining_days,
            renewal=False,  # Not a renewal, it's the initial subscription
            created_by=None,  # Assuming no user is creating it at this stage
            created_at=timezone.now()
        )

        # Update farmer details with subscription info
        farmer.subscription_package = package
        farmer.subscription_start_date = start_date
        farmer.subscription_end_date = end_date
        farmer.remaining_days = remaining_days
        farmer.save()  # Save the farmer with updated subscription information

        # Create a notification for the newly created farmer
        notification = FarmerNotification.objects.create(
            farmer=farmer,
            name="New Farmer Created",
            type="Creation",
            message=f"A new farmer named {farmer.name} has been created.",
        )
        notification.save()

        # Fetch the superadmin user (you can modify this part as needed)
        superadmin_user = CustomUser.objects.filter(is_superuser=True).first()
        if superadmin_user:
            # Create a notification for the superadmin about the new farmer
            superadmin_notification = Notification.objects.create(
                user=superadmin_user,
                name="New Farmer Created",
                message=f"A new farmer named {farmer.name} has been created.",
            )
            superadmin_notification.save()



@api_view(['PUT', 'DELETE'])
def manage_my_land(request,id):

    try:
        farmer = Farmer.objects.get(id=id)
    except Farmer.DoesNotExist:
        return Response({"error": "Farmer not found"}, status=status.HTTP_400_BAD_REQUEST)
    
    if request.method == 'POST':
        land_data = request.data
        survey_details = land_data.pop('survey_details', [])
        serializer = MyLandInsertionSerializer(data=land_data)
        
        try:
            farmer = Farmer.objects.get(id=land_data['farmer'])
        except Farmer.DoesNotExist:
            return Response({"error": "Farmer not found"}, status=status.HTTP_400_BAD_REQUEST)
        
        if serializer.is_valid():
            created_by = updated_by = farmer.farmer_user
            land = serializer.save(created_at=timezone.now(), created_by=created_by, updated_by=updated_by)
             
            for survey_data in survey_details:
                survey_data['farmer'] = farmer.id
                id = MyLand.objects.get(id = land.id)
                survey_serializer = MyLandSurveyInsertionSerializer(data=survey_data)
                
                if survey_serializer.is_valid():
                    survey_serializer.save(
                        MyLand = id,
                        created_at=timezone.now(),
                        created_by=farmer.farmer_user,
                        updated_at=timezone.now(),
                        updated_by=farmer.farmer_user
                    )
                else:
                    return Response(survey_serializer.errors, status=status.HTTP_400_BAD_REQUEST)
            
            response_data = {
                "land_details": MyLandDetailsSerializer(land).data
            }
            return Response(response_data, status=status.HTTP_201_CREATED)
        
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    
 
    elif request.method == 'PUT':
        land_id = request.data.get('id')
        if not land_id:
            return Response({"error": "Land id is required for update"}, status=status.HTTP_400_BAD_REQUEST)
    
        try:
            my_land = MyLand.objects.get(id=land_id, farmer=farmer)
        except MyLand.DoesNotExist:
            return Response({"detail": "MyLand not found."}, status=status.HTTP_404_NOT_FOUND)
    
        serializer = MyLandInsertionSerializer(my_land, data=request.data)
        if serializer.is_valid():
            #  updated_by = farmer.farmer_user
            updated_land = serializer.save(updated_at=timezone.now())
            
            survey_details = request.data.get('survey_details', [])
    
            # Add new survey details
            for survey_data in survey_details:
                # Create new MyLandSurveyDetails instead of updating
                survey_serializer = MyLandSurveyInsertionSerializer(data=survey_data)
                if survey_serializer.is_valid():
                    survey_serializer.save(
                        MyLand=my_land,  # Associate survey with the current land
                        updated_at=timezone.now(), 
                        #  updated_by=farmer.farmer_user
                    )
                else:
                    return Response(survey_serializer.errors, status=status.HTTP_400_BAD_REQUEST)
            
            response_data = {"land_details": MyLandDetailsSerializer(updated_land).data}
            return Response(response_data, status=status.HTTP_200_OK)
    
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
 
@api_view(['POST'])
def delete_my_land(request, id):
    try:
        farmer = Farmer.objects.get(id=id)
    except Farmer.DoesNotExist:
        return Response({"detail": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)

    land_id = request.data.get('id')
    if not land_id:
        return Response({"error": "Land id is required for delete"}, status=status.HTTP_400_BAD_REQUEST)
    try:
        my_land = MyLand.objects.get(id=land_id, farmer=id)
    except MyLand.DoesNotExist:
        return Response({"detail": "MyLand not found."}, status=status.HTTP_404_NOT_FOUND)
    try:
        if my_land.status == 2:
            return Response({"message": "The land is already deleted."}, status=status.HTTP_400_BAD_REQUEST)
        my_land.status = 2
        my_land.updated_at = timezone.now()
        my_land.updated_by = farmer.farmer_user
        my_land.save()
        return Response({"message": "Your land has been deleted successfully."}, status=status.HTTP_200_OK)
    except Exception as e:
        return Response({"error": f"Something went wrong: {str(e)}"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
 
@api_view(['GET'])
def get_farmer_lands(request, farmer_id): 
    # Retrieve lands for the given farmer_id with status 0
    lands = MyLand.objects.filter(farmer_id=farmer_id, status=0).values('id', 'name')

    # If no lands are found, return an error message
    if not lands:
        return Response({
            "error": "No lands found for this farmer.",
            "language": {"default": "en"}
        }, status=status.HTTP_404_NOT_FOUND)
    
    # Return the lands list along with the language key
    return Response({
        "lands": list(lands),
        "language": {"default": "en"}
    })
 
 
@api_view(['GET'])
def get_land_with_survey_details(request, farmer_id=None, land_id=None):
    if not farmer_id:
        return Response({"error": "farmer_id is required"}, status=400)

    lands = MyLand.objects.filter(farmer_id=farmer_id, status=0)
    if land_id:
        lands = lands.filter(id=land_id)

    result = []
    for land in lands:
        survey_details = [
            {
                'id': survey.id,
                'survey_no': survey.survey_no,
                'survey_measurement_value': survey.survey_measurement_value,
                'survey_measurement_unit': survey.survey_measurement_unit.name if survey.survey_measurement_unit else None,
                'status': survey.status,
                'created_at': survey.created_at,
                'updated_at': survey.updated_at
            }
            for survey in land.survey_details.all()
        ]

        crops = MyCrop.objects.filter(land=land, status=0)
        crop_list = []
        for crop in crops:
            crop_img_url = (
                request.build_absolute_uri('/SuperAdmin' + crop.crop.img.url)
                if crop.crop and getattr(crop.crop, 'img', None)
                else request.build_absolute_uri('/assets/images/product_img/crop_default.png')
            )


            crop_list.append({
                'crop_id': crop.id,
                'crop_type': crop.crop_type.name if crop.crop_type else None,
                'crop_name': crop.crop.name if crop.crop else None,
                'geo_marks': crop.geo_marks,
                'crop_image': crop_img_url,
            })

        result.append({
            'land_id': land.id,
            'land_name': land.name,
            'farmer_id': land.farmer.id if land.farmer else None,
            'geo_marks': land.geo_marks,
            'survey_details': survey_details,
            'crops': crop_list if crop_list else [],
            'language': {'default': 'en'}
        })

    return Response(result)

@api_view(['GET'])
def get_land_with_crop_geo_marks_details(request, farmer_id=None, land_id=None):
    if not farmer_id:
        return Response({"error": "farmer_id is required"}, status=400)

    lands = MyLand.objects.filter(farmer_id=farmer_id, status=0)
    if land_id:
        lands = lands.filter(id=land_id)

    result = []
    for land in lands:
        crops = MyCrop.objects.filter(land=land, status=0)
        crop_list = []
        for crop in crops:
            crop_img_url = (
                request.build_absolute_uri('/SuperAdmin' + crop.crop.img.url)
                if crop.crop and getattr(crop.crop, 'img', None)
                else request.build_absolute_uri('/assets/images/product_img/crop_default.png')
            )

            crop_list.append({
                'crop_id': crop.id,
                'crop_type': crop.crop_type.name if crop.crop_type else None,
                'crop_name': crop.crop.name if crop.crop else None,
                'geo_marks': crop.geo_marks,
                'crop_image': crop_img_url,
            })

        result.append({
            'land_id': land.id,
            'land_name': land.name,
            'farmer_id': land.farmer.id if land.farmer else None,
            'geo_marks': land.geo_marks,
            'crops': crop_list if crop_list else [],
            'language': {'default': 'en'}
        })

    return Response(result)


def convert_to_sqft(value, unit_id):
    """
    Convert any land unit (by ID) to square feet for calculation.
    LandUnit:
        1 = Acres
        2 = Hectares
        3 = Square Feet
    """
    if unit_id == 1:  # Acres
        return value * 43560
    elif unit_id == 2:  # Hectares
        return value * 107639
    elif unit_id == 3:  # Sqft
        return value
    else:
        raise ValueError(f"Unsupported unit ID: {unit_id}")
    
# Utility function for conversion
# Utility function remains the same
def convert_value(value, from_unit, to_unit):
    from_unit = from_unit.lower()
    to_unit = to_unit.lower()

    if from_unit == to_unit:
        return value

    if from_unit not in CONVERSION_FACTORS:
        raise ValueError(f"Unsupported from_unit: {from_unit}")
    
    if to_unit not in CONVERSION_FACTORS[from_unit]:
        raise ValueError(f"Cannot convert from {from_unit} to {to_unit}")
    
    factor = Decimal(str(CONVERSION_FACTORS[from_unit][to_unit]))  # convert float to Decimal
    if not isinstance(value, Decimal):
        value = Decimal(str(value))  # ensure value is Decimal too

    return value * factor
 
@api_view(['POST'])
def add_crop(request, farmer_id):
    if request.method != 'POST':
        return JsonResponse({"error": "Invalid request method."}, status=405)

    print("\n--- START ADD CROP PROCESS ---")

    # ------------------ INPUT DATA ------------------
    farmer_id_from_payload = request.data.get('farmer', farmer_id)
    crop_type_id = request.data.get('crop_type')
    existing_crop_id = request.data.get('crop')
    new_crop_name = request.data.get('new_crop')
    harvesting_type_id = request.data.get('harvesting_type')
    plantation_date = request.data.get('plantation_date')
    measurement_value = Decimal(str(request.data.get('measurement_value', 0)))
    measurement_unit_id = request.data.get('measurement_unit')
    description = request.data.get('description')
    land_id = request.data.get('land')
    survey_details_ids = request.data.get('survey_details')
    geo_marks = request.data.get('geo_marks')

    print(f"Inputs received: farmer={farmer_id_from_payload}, crop_type={crop_type_id}, "
          f"existing_crop={existing_crop_id}, new_crop={new_crop_name}, "
          f"measurement={measurement_value} unit={measurement_unit_id}, land={land_id}")

    # ------------------ LANGUAGE ------------------
    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
        language_code = user_language_pref.language_code or 'en'
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'

    # ------------------ CROP TYPE ------------------
    crop_type = get_object_or_404(CropType, id=crop_type_id, status=0)
    if existing_crop_id:
        crop_instance = get_object_or_404(Crop, id=existing_crop_id, croptype=crop_type, status=0)
    else:
        crop_instance, created = Crop.objects.get_or_create(name=new_crop_name, croptype=crop_type, status=0)

    # ------------------ HARVESTING TYPE ------------------
    harvesting_type = get_object_or_404(HarvestingType, id=harvesting_type_id, status=0) if harvesting_type_id else None

    # ------------------ LAND ------------------
    land = get_object_or_404(MyLand, id=land_id, status=0)
    soil_type = land.soil_type
    # taluk = land.taluk
    # village = land.village
    measurement_unit = get_object_or_404(LandUnit, id=measurement_unit_id, status=0)

    # ------------------ VALIDATE CROP GEO MARKS ------------------
    if geo_marks:
        try:
            land_polygon_points = [(point['lat'], point['lng']) for point in land.geo_marks]
            land_polygon = Polygon(land_polygon_points)

            crop_points = [(point['lat'], point['lng']) for point in geo_marks]

            for pt in crop_points:
                point = Point(pt)
                if not land_polygon.contains(point):
                    return JsonResponse(
                        {"message": "Crop geo marks must be within the boundaries of the land."},
                        status=400
                    )
        except (KeyError, TypeError, ValueError):
            return JsonResponse({"error": "Invalid geo_marks format."}, status=400)

    # ------------------ LAND CAPACITY CHECK ------------------
    land_capacity_value = land.measurement_value
    land_capacity_unit = land.measurement_unit.landunitdef.lower()

    # Calculate used capacity
    used_capacity = Decimal('0')
    existing_crops = MyCrop.objects.filter(land=land, status=0)
    for crop in existing_crops:
        converted_value = convert_value(Decimal(crop.measurement_value), crop.measurement_unit.landunitdef, land_capacity_unit)
        used_capacity += converted_value

    remaining_capacity = land_capacity_value - used_capacity

    # Convert requested crop to land unit
    requested_crop_value = convert_value(measurement_value, measurement_unit.landunitdef, land_capacity_unit)

    # ------------------ ALLOCATE CROP EVEN IF EXCEEDS LAND ------------------
    allocated_crop_value = requested_crop_value
    remaining_capacity_after_add = remaining_capacity - allocated_crop_value

    # ------------------ SURVEY DETAILS ------------------
    survey_details = MyLandSurveyDetails.objects.filter(id__in=survey_details_ids, status=0) if survey_details_ids else []

    # ------------------ SUBSCRIPTION CHECK ------------------
    subscription = AddSubcription.objects.filter(farmers=farmer_id_from_payload, status=0).first()
    farmer_status = Farmer.objects.get(id=farmer_id_from_payload).status
    if farmer_status in [4, 6]:
        return JsonResponse({"error": "Farmer subscription issue."}, status=400)

    if subscription:
        mycrop_limit = subscription.packages.mycrops_count
        current_mycrop_count = MyCrop.objects.filter(farmer_id=farmer_id_from_payload, status=0).count()
        if current_mycrop_count >= mycrop_limit:
            return JsonResponse({'error': f"Maximum crop limit of {mycrop_limit} reached."}, status=400)

    # ------------------ CREATE MYCROP ------------------
    mycrop_instance = MyCrop.objects.create(
        farmer_id=farmer_id_from_payload,
        crop_type=crop_type,
        crop=crop_instance,
        harvesting_type=harvesting_type,
        plantation_date=plantation_date,
        measurement_value=measurement_value,
        measurement_unit=measurement_unit,
        description=description,
        status=0,
        land=land,
        # taluk=taluk,
        # village=village,
        geo_marks=geo_marks
    )
    if survey_details:
        mycrop_instance.survey_details.set(survey_details)

    # ------------------ REMAINING LAND ------------------
    remaining_land = {
        "value": max(remaining_capacity_after_add, 0),
        "unit": land_capacity_unit,
        "acre": convert_value(max(remaining_capacity_after_add, 0), land_capacity_unit, "acre"),
        "hectares": convert_value(max(remaining_capacity_after_add, 0), land_capacity_unit, "hectare")
    }

    # ------------------ RESPONSE ------------------
    response_data = {
        "id": mycrop_instance.id,
        "farmer": farmer_id_from_payload,
        "crop_type": crop_type.name,
        "crop": crop_instance.name,
        "harvesting_type": harvesting_type.name if harvesting_type else None,
        "plantation_date": plantation_date,
        "land": land.name,
        # "taluk": taluk.name,
        # "village": village.name,
        "measurement_value": measurement_value,
        "measurement_unit": measurement_unit.name,
        "geo_marks": geo_marks,
        "c_status": "0",
        "expense": "0",
        "sales": "0",
        "days_since_plantation": plantation_date,
        "survey_details": [s.id for s in survey_details],
        "language": {"default": language_code},
        "remaining_land": remaining_land
    }

    print("\n--- END ADD CROP PROCESS ---\n")
    return JsonResponse(response_data, status=200)



@api_view(['POST', 'PUT', 'DELETE'])
def manage_my_crop(request, id):   
    try: 
        farmer = Farmer.objects.get(id=id)
    except Farmer.DoesNotExist:
        return Response({"detail": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)

    if request.method == 'POST': 
        # Retrieve the crop_type (assuming it's a valid ID passed in the payload)
        crop_type_id = request.data.get('crop_type', None)
        new_crop_name = request.data.get('new_crop', None)

        # If 'new_crop' is provided, create the crop
        if new_crop_name:
            # Ensure crop_type exists before creating the crop
            try:
                crop_type_instance = CropType.objects.get(id=crop_type_id)
            except CropType.DoesNotExist:
                return Response({"detail": "Crop type not found."}, status=status.HTTP_404_NOT_FOUND)

            # Create the new crop
            crop, created = Crop.objects.get_or_create(
                name=new_crop_name,  # Set the name of the new crop
                crop_type=crop_type_instance  # Set the crop type
            )
            if created:
                crop.save()  # Save the new crop if it was created

        else:
            # Otherwise, get the existing crop from the provided crop ID
            crop_id = request.data.get('crop')
            try:
                crop = Crop.objects.get(id=crop_id)
            except Crop.DoesNotExist:
                return Response({"detail": "Crop not found."}, status=status.HTTP_404_NOT_FOUND)

        

        # Now pass validated data for MyCrop creation
        serializer = MyCropInsertionSerializer(data=request.data)
        if serializer.is_valid(): 
            # Create the MyCrop instance and associate the created or existing crop
            crop_instance = serializer.save(
                farmer=farmer,  
                created_at=timezone.now(),
                created_by=farmer.farmer_user,   
                updated_at=timezone.now(),
                updated_by=farmer.farmer_user,
                crop=crop  # Associate the crop (either new or existing) with MyCrop instance
            )

            if serializer.validated_data.get('survey_details'):
                crop_instance.survey_details.set(serializer.validated_data['survey_details'])

            crop_details_serializer = MyCropDetailsSerializer(crop_instance)

            response_data = {
                "crop": crop_details_serializer.data,
                "language": {
                    "default": "en"
                },
            }

            return Response(response_data, status=status.HTTP_201_CREATED)

        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
 

    # elif request.method == 'PUT':
    #     pk = request.data.get('crop_id')
    #     if not pk:
    #         return Response({"error": "crop_id is required for update"}, status=status.HTTP_400_BAD_REQUEST)

    #     try:
    #         my_crop = MyCrop.objects.get(pk=pk)
    #     except MyCrop.DoesNotExist:
    #         return Response({"detail": "MyCrop not found."}, status=status.HTTP_404_NOT_FOUND)

    #     # ------------------ INPUT DATA ------------------
    #     farmer = request.user  # Assuming user is the farmer
    #     if not farmer:
    #         return Response({"error": "Farmer is required."}, status=status.HTTP_400_BAD_REQUEST)

    #     crop_type_id = request.data.get('crop_type')
    #     existing_crop_id = request.data.get('crop')
    #     new_crop_name = request.data.get('new_crop')
    #     harvesting_type_id = request.data.get('harvesting_type')
    #     plantation_date = request.data.get('plantation_date')
    #     measurement_value = Decimal(str(request.data.get('measurement_value', my_crop.measurement_value)))
    #     measurement_unit_id = request.data.get('measurement_unit')
    #     description = request.data.get('description')
    #     land_id = request.data.get('land')
    #     survey_details_ids = request.data.get('survey_details')
    #     geo_marks = request.data.get('geo_marks')

    #     # ------------------ CROP TYPE ------------------
    #     if crop_type_id:
    #         crop_type = get_object_or_404(CropType, id=crop_type_id, status=0)
    #         if existing_crop_id:
    #             crop_instance = get_object_or_404(Crop, id=existing_crop_id, croptype=crop_type, status=0)
    #         else:
    #             crop_instance, _ = Crop.objects.get_or_create(name=new_crop_name, croptype=crop_type, status=0)
    #     else:
    #         crop_type = my_crop.crop_type
    #         crop_instance = my_crop.crop

    #     # ------------------ HARVESTING TYPE ------------------
    #     harvesting_type = get_object_or_404(HarvestingType, id=harvesting_type_id, status=0) if harvesting_type_id else my_crop.harvesting_type

    #     # ------------------ LAND ------------------
    #     land = get_object_or_404(MyLand, id=land_id, status=0) if land_id else my_crop.land
    #     measurement_unit = get_object_or_404(LandUnit, id=measurement_unit_id, status=0) if measurement_unit_id else my_crop.measurement_unit

    #     # ------------------ VALIDATE GEO MARKS ------------------
    #     if geo_marks:
    #         try:
    #             land_polygon_points = [(point['lat'], point['lng']) for point in land.geo_marks]
    #             land_polygon = Polygon(land_polygon_points)
    #             crop_points = [(point['lat'], point['lng']) for point in geo_marks]

    #             for pt in crop_points:
    #                 point = Point(pt)
    #                 if not land_polygon.contains(point):
    #                     return Response({"message": "Crop geo marks must be within the land boundaries."}, status=status.HTTP_400_BAD_REQUEST)
    #         except (KeyError, TypeError, ValueError):
    #             return Response({"error": "Invalid geo_marks format."}, status=status.HTTP_400_BAD_REQUEST)

    #     # ------------------ LAND CAPACITY CHECK ------------------
    #     land_capacity_value = land.measurement_value
    #     land_capacity_unit = land.measurement_unit.landunitdef.lower()
    #     used_capacity = Decimal('0')
    #     existing_crops = MyCrop.objects.filter(land=land, status=0).exclude(pk=my_crop.pk)
    #     for crop in existing_crops:
    #         converted_value = convert_value(Decimal(crop.measurement_value), crop.measurement_unit.landunitdef, land_capacity_unit)
    #         used_capacity += converted_value

    #     remaining_capacity = land_capacity_value - used_capacity
    #     requested_crop_value = convert_value(measurement_value, measurement_unit.landunitdef, land_capacity_unit)
    #     allocated_crop_value = requested_crop_value
    #     remaining_capacity_after_add = remaining_capacity - allocated_crop_value

    #     # ------------------ SURVEY DETAILS ------------------
    #     survey_details = MyLandSurveyDetails.objects.filter(id__in=survey_details_ids, status=0) if survey_details_ids else []

    #     # ------------------ TRANSLATE DESCRIPTION ------------------
    #     translated_json = my_crop.translate_json or {'description': {}}
    #     target_languages = ['hi', 'ta']  # Hindi, Tamil
    #     if description:
    #         for lang in target_languages:
    #             try:
    #                 translated_text = GoogleTranslator(source='auto', target=lang).translate(description)
    #                 translated_json["description"][lang] = translated_text
    #             except Exception as e:
    #                 return Response({"error": f"Translation error: {str(e)}"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    #     # ------------------ UPDATE MYCROP ------------------
    #     my_crop.crop_type = crop_type
    #     my_crop.crop = crop_instance
    #     my_crop.harvesting_type = harvesting_type
    #     my_crop.plantation_date = plantation_date or my_crop.plantation_date
    #     my_crop.measurement_value = measurement_value
    #     my_crop.measurement_unit = measurement_unit
    #     my_crop.description = description or my_crop.description
    #     my_crop.land = land
    #     my_crop.taluk = land.taluk
    #     my_crop.village = land.village
    #     my_crop.geo_marks = geo_marks or my_crop.geo_marks
    #     my_crop.translate_json = translated_json
    #     my_crop.updated_at = timezone.now()
    #     my_crop.save()

    #     if survey_details:
    #         my_crop.survey_details.set(survey_details)

    #     # ------------------ RESPONSE ------------------
    #     remaining_land = {
    #         "value": max(remaining_capacity_after_add, 0),
    #         "unit": land_capacity_unit,
    #         "acre": convert_value(max(remaining_capacity_after_add, 0), land_capacity_unit, "acre"),
    #         "hectares": convert_value(max(remaining_capacity_after_add, 0), land_capacity_unit, "hectare")
    #     }

    #     response_data = {
    #         "id": my_crop.id,
    #         "farmer": farmer.id,
    #         "crop_type": crop_type.name,
    #         "crop": crop_instance.name,
    #         "harvesting_type": harvesting_type.name if harvesting_type else None,
    #         "plantation_date": my_crop.plantation_date,
    #         "land": land.name,
    #         "taluk": land.taluk.name,
    #         "village": land.village.name,
    #         "measurement_value": my_crop.measurement_value,
    #         "measurement_unit": measurement_unit.name,
    #         "geo_marks": my_crop.geo_marks,
    #         "description": my_crop.description,
    #         "survey_details": [s.id for s in survey_details],
    #         "translate_json": my_crop.translate_json,
    #         "remaining_land": remaining_land
    #     }

    #     return Response(response_data, status=status.HTTP_200_OK)

    elif request.method == 'PUT':
        pk = request.data.get('crop_id')
        if not pk:
            return Response({"error": "crop_id is required for update"}, status=status.HTTP_400_BAD_REQUEST)

        try:
            my_crop = MyCrop.objects.get(pk=pk)
        except MyCrop.DoesNotExist:
            return Response({"detail": "MyCrop not found."}, status=status.HTTP_404_NOT_FOUND)

        # ------------------ INPUT DATA ------------------
        farmer = request.user  # Assuming user is the farmer
        if not farmer:
            return Response({"error": "Farmer is required."}, status=status.HTTP_400_BAD_REQUEST)

        crop_type_id = request.data.get('crop_type')
        existing_crop_id = request.data.get('crop')
        new_crop_name = request.data.get('new_crop')
        harvesting_type_id = request.data.get('harvesting_type')
        plantation_date = request.data.get('plantation_date')
        measurement_value = Decimal(str(request.data.get('measurement_value', my_crop.measurement_value)))
        measurement_unit_id = request.data.get('measurement_unit')
        description = request.data.get('description')
        land_id = request.data.get('land')
        survey_details_ids = request.data.get('survey_details')
        geo_marks = request.data.get('geo_marks')

        # ------------------ CROP TYPE ------------------
        if crop_type_id:
            crop_type = get_object_or_404(CropType, id=crop_type_id, status=0)
            if existing_crop_id:
                crop_instance = get_object_or_404(Crop, id=existing_crop_id, croptype=crop_type, status=0)
            else:
                crop_instance, _ = Crop.objects.get_or_create(name=new_crop_name, croptype=crop_type, status=0)
        else:
            crop_type = my_crop.crop_type
            crop_instance = my_crop.crop

        # ------------------ HARVESTING TYPE ------------------
        harvesting_type = get_object_or_404(HarvestingType, id=harvesting_type_id, status=0) if harvesting_type_id else my_crop.harvesting_type

        # ------------------ LAND ------------------
        land = get_object_or_404(MyLand, id=land_id, status=0) if land_id else my_crop.land
        measurement_unit = get_object_or_404(LandUnit, id=measurement_unit_id, status=0) if measurement_unit_id else my_crop.measurement_unit

        # ------------------ VALIDATE GEO MARKS ------------------
        # if geo_marks:
        #     try:
        #         # Swap lat/lng to lng/lat for Shapely
        #         land_polygon_points = [(point['lng'], point['lat']) for point in land.geo_marks]
        #         land_polygon = Polygon(land_polygon_points)
        #         crop_points = [(point['lng'], point['lat']) for point in geo_marks]

        #         for pt in crop_points:
        #             point = Point(pt)
        #             if not land_polygon.contains(point):
        #                 return Response({"message": "Crop geo marks must be within the land boundaries."}, status=status.HTTP_400_BAD_REQUEST)
        #     except (KeyError, TypeError, ValueError):
        #         return Response({"error": "Invalid geo_marks format."}, status=status.HTTP_400_BAD_REQUEST)

        if geo_marks:
            try:
                # Ensure land.geo_marks is a list of dicts with lat/lng
                if not isinstance(land.geo_marks, list) or not all(isinstance(p, dict) and 'lat' in p and 'lng' in p for p in land.geo_marks):
                    return Response({"error": "Invalid format in land geo_marks."}, status=status.HTTP_400_BAD_REQUEST)

                land_polygon_points = [(point['lng'], point['lat']) for point in land.geo_marks]
                land_polygon = Polygon(land_polygon_points)

                # Validate input geo_marks
                if not isinstance(geo_marks, list) or not all(isinstance(p, dict) and 'lat' in p and 'lng' in p for p in geo_marks):
                    return Response({"error": "Invalid geo_marks format."}, status=status.HTTP_400_BAD_REQUEST)

                crop_points = [(point['lng'], point['lat']) for point in geo_marks]

                for pt in crop_points:
                    point = Point(pt)
                    if not land_polygon.contains(point):
                        return Response({"message": "Crop geo marks must be within the land boundaries."}, status=status.HTTP_400_BAD_REQUEST)
            except Exception as e:
                return Response({"error": f"Invalid geo_marks format: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)


        # ------------------ LAND CAPACITY CHECK ------------------
        land_capacity_value = land.measurement_value
        land_capacity_unit = land.measurement_unit.landunitdef.lower()
        used_capacity = Decimal('0')
        existing_crops = MyCrop.objects.filter(land=land, status=0).exclude(pk=my_crop.pk)
        for crop in existing_crops:
            converted_value = convert_value(Decimal(crop.measurement_value), crop.measurement_unit.landunitdef, land_capacity_unit)
            used_capacity += converted_value

        remaining_capacity = land_capacity_value - used_capacity
        requested_crop_value = convert_value(measurement_value, measurement_unit.landunitdef, land_capacity_unit)
        allocated_crop_value = requested_crop_value
        remaining_capacity_after_add = remaining_capacity - allocated_crop_value

        # ------------------ SURVEY DETAILS ------------------
        survey_details = MyLandSurveyDetails.objects.filter(id__in=survey_details_ids, status=0) if survey_details_ids else []

        # ------------------ TRANSLATE DESCRIPTION ------------------
        translated_json = my_crop.translate_json or {'description': {}}
        target_languages = ['hi', 'ta']  # Hindi, Tamil
        if description:
            for lang in target_languages:
                try:
                    translated_text = GoogleTranslator(source='auto', target=lang).translate(description)
                    translated_json["description"][lang] = translated_text
                except Exception as e:
                    return Response({"error": f"Translation error: {str(e)}"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        # ------------------ UPDATE MYCROP ------------------
        my_crop.crop_type = crop_type
        my_crop.crop = crop_instance
        my_crop.harvesting_type = harvesting_type
        my_crop.plantation_date = plantation_date or my_crop.plantation_date
        my_crop.measurement_value = measurement_value
        my_crop.measurement_unit = measurement_unit
        my_crop.description = description or my_crop.description
        my_crop.land = land
        # my_crop.taluk = land.taluk
        # my_crop.village = land.village
        my_crop.geo_marks = geo_marks or my_crop.geo_marks
        my_crop.translate_json = translated_json
        my_crop.updated_at = timezone.now()
        my_crop.save()

        if survey_details:
            my_crop.survey_details.set(survey_details)

        # ------------------ RESPONSE ------------------
        remaining_land = {
            "value": max(remaining_capacity_after_add, 0),
            "unit": land_capacity_unit,
            "acre": convert_value(max(remaining_capacity_after_add, 0), land_capacity_unit, "acre"),
            "hectares": convert_value(max(remaining_capacity_after_add, 0), land_capacity_unit, "hectare")
        }

        response_data = {
            "id": my_crop.id,
            "farmer": farmer.id,
            "crop_type": crop_type.name,
            "crop": crop_instance.name,
            "harvesting_type": harvesting_type.name if harvesting_type else None,
            "plantation_date": my_crop.plantation_date,
            "land": land.name,
            # "taluk": land.taluk.name,
            # "village": land.village.name,
            "measurement_value": my_crop.measurement_value,
            "measurement_unit": measurement_unit.name,
            "geo_marks": my_crop.geo_marks,
            "description": my_crop.description,
            "survey_details": [s.id for s in survey_details],
            "translate_json": my_crop.translate_json,
            "remaining_land": remaining_land
        }

        return Response(response_data, status=status.HTTP_200_OK)


    elif request.method == 'DELETE':
        pk = request.data.get('crop_id')
        if not pk:
            return Response({"error": "crop_id is required for delete"}, status=status.HTTP_400_BAD_REQUEST)
        try:
            my_crop = MyCrop.objects.get(pk=pk,farmer=1)
        except MyCrop.DoesNotExist:
            return Response({"detail": "MyCrop not found."}, status=status.HTTP_404_NOT_FOUND)
        my_crop.status = 2
        my_crop.save(updated_at=timezone.now(), updated_by=farmer.farmer_user)
        return Response({"detail": "MyCrop status updated to deleted."}, status=status.HTTP_200_OK)



@api_view(['POST', 'PUT', 'DELETE'])
def manage_schedule(request, id):
    try:
        farmer_instance = Farmer.objects.get(id=id)
    except Farmer.DoesNotExist:
        return Response({"error": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)
    if request.method == 'POST':
        serializer = MyScheduleInsertionSerializer(data=request.data)
        schedule_status = get_object_or_404(ScheduleStatus, code=1)
        if serializer.is_valid():
            schedule_details = serializer.save(
                created_at=timezone.now(),
                created_by=farmer_instance.farmer_user,
                updated_at=timezone.now(),
                # updated_by=farmer_instance.farmer_user,
                schedule_status=schedule_status
            )
            schedule_instance_data = MyScheduleDetailsSerializer(schedule_details).data
            return Response(schedule_instance_data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    
    elif request.method == 'PUT':
        task_id = request.data.get('id', None)
        if not task_id:
            return Response({"error": "Task ID is required."}, status=status.HTTP_400_BAD_REQUEST)
        try:
            schedule_instance = MySchedule.objects.get(id=task_id, farmer=id)
        except MySchedule.DoesNotExist:
            return Response({"error": "Task not found."}, status=status.HTTP_404_NOT_FOUND)
        serializer = MyScheduleInsertionSerializer(schedule_instance, data=request.data, partial=True)
        if serializer.is_valid():
            schedule_instance = serializer.save(
                updated_at=timezone.now(),
                # updated_by=farmer_instance.farmer_user
            )
            schedule_instance_data = MyScheduleDetailsSerializer(schedule_instance).data
            return Response(schedule_instance_data, status=status.HTTP_200_OK)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    
    elif request.method == 'DELETE':
        task_id = request.data.get('id', None)
        if not task_id:
            return Response({"error": "Task ID is required."}, status=status.HTTP_400_BAD_REQUEST)
        try:
            schedule_instance = MySchedule.objects.get(id=task_id, farmer=farmer_instance)
        except MySchedule.DoesNotExist:
            return Response({"error": "Task not found."}, status=status.HTTP_404_NOT_FOUND)
        schedule_instance.status = 2
        schedule_instance.updated_at = timezone.now()
        # schedule_instance.updated_by = farmer_instance.farmer_user
        schedule_instance.save()
        return Response({"message": "Task Deleted."}, status=status.HTTP_200_OK)
 
 
 
def convert_to_strftime_format(format_str):
    # Map human-readable format strings to strftime-compatible format strings
    format_map = {
        'dd': '%d',        # day of the month (zero-padded)
        'd': '%d',         # day of the month (no padding)
        'MM': '%m',        # month (zero-padded, e.g. 03 for March)
        'M': '%m',         # month (with padding)
        'm': '%m',         # month (with padding)
        'YYYY': '%Y',      # year (four digits)
        'YY': '%y',        # year (last two digits)
        'MMM': '%b',       # month abbreviation (e.g., Mar)
        'MMMM': '%B',      # full month name (e.g., March)
        'Y': '%Y',         # four-digit year (e.g., 2025)
        'y': '%y',         # two-digit year (e.g., 25)
    }
    
    # Replace all the format strings with their strftime equivalents
    for human, strftime in format_map.items():
        format_str = format_str.replace(human, strftime)
    
    # Handle 'M' and 'm' (non-padded month)
    # The idea is to replace 'M' with a non-padded month format manually
    # if itâ€™s not zero-padded, we can post-process the date string for 'M' or 'm'

    if '%m' in format_str:  # If there's a month format, replace it manually
        format_str = format_str.replace('%m','%m') 
    
    return format_str
 
 

@api_view(['GET'])
def get_task_list(request, id):

    try:
        user_language_pref = UserLanguagePreference.objects.get(user=id)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'  # Fallback to 'en' if no preference is found

    user_id = id
    land_id = request.query_params.get('land_id')   
    month = request.query_params.get('month')  

    try:
        farmer_instance = Farmer.objects.get(id=user_id, status=0)
    except Farmer.DoesNotExist:
        return Response({"error": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)

    try:
        settings = GeneralSetting.objects.first()
        date_format = convert_to_strftime_format(settings.date_format)
    except Exception as e:
        # In case of error (e.g., no GeneralSetting found or invalid format), fallback to a default
        date_format = '%d-%m-%Y'  # You can choose any fallback format you prefer

    # Filter tasks by farmer and status, only if a land_id is provided filter by that as well
    tasks = MySchedule.objects.filter(farmer=farmer_instance, status=0)

    if land_id:
        tasks = tasks.filter(my_land__id=land_id)  # Filter by land_id

    if month:
        try:
            month_int = datetime.strptime(month, "%b").month  # Convert month (e.g., 'Jan') to integer
            tasks = tasks.filter(start_date__month=month_int)  # Filter by the provided month
        except ValueError:
            return Response({"error": "Invalid month format. Use the 3-letter month abbreviation (e.g., 'Jan')."}, status=status.HTTP_400_BAD_REQUEST)

    if not tasks:
        return Response({"error": "No tasks found for this farmer."}, status=status.HTTP_404_NOT_FOUND)

    grouped_tasks = defaultdict(list)
    for task in tasks:
        try:
            # Format the actual date using the date_format
            date_str = task.start_date.strftime(date_format)  # Apply the custom format
        except ValueError:
            return Response({"error": "Invalid date format in General Settings."}, status=status.HTTP_400_BAD_REQUEST)

        day_name = task.start_date.strftime('%a')  # Get day name (e.g., 'Mon', 'Tue', etc.)

        # crop_info = {
        #     "id": task.id if task.id else None,
        #     "crop_type": (
        #         f"{task.my_crop.land.name} - {task.my_crop.crop.name} "
        #         if task.my_crop and task.my_crop.crop and task.my_crop.land
        #         else "No Crop Available"
        #     ),
        #     "crop_image": request.build_absolute_uri(f'/assets{task.my_crop.crop.img.url}') if task.my_crop.crop.img else "",
        #     "description": task.schedule if task.schedule else "No Description Available",
        # }

        crop_info = {
            "id": task.id if task.id else None,
            "crop_type": (
                f"{task.my_crop.land.get_translated_value('name', language_code)} - {task.my_crop.crop.get_translated_value('name', language_code)}"
                if task.my_crop and task.my_crop.crop and task.my_crop.land
                else "No Crop Available"
            ),
            "crop_image": request.build_absolute_uri(f'/assets{task.my_crop.crop.img.url}') if task.my_crop.crop.img else "",
            "description": (
                task.get_translated_value('schedule', language_code)
                if hasattr(task, 'get_translated_value') else (task.schedule or "No Description Available")
            ),
        }


        grouped_tasks[date_str].append({"Day": day_name, "crop": [crop_info]})

    # Prepare response data
    response_data = [
        {
            "Date": date,  # This will now be formatted properly using date_format
            "Day": day_info[0]['Day'],
            "crop": [item['crop'][0] for item in day_info],  # Extracting the first crop info for each day
            "language": {
                "default": "en"
            }
        }
        for date, day_info in grouped_tasks.items()
    ]

    return Response(response_data, status=status.HTTP_200_OK)

 
@api_view(['GET'])
def get_task_list_for_month(request, id):
    try:
        user_language_pref = UserLanguagePreference.objects.get(user=id)
        language_code = user_language_pref.language_code or 'en'
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'

    land_id = request.query_params.get('land_id')
    month = request.query_params.get('month')

    if not land_id or not month:
        return Response({"error": "Both land_id and month parameters are required."}, status=status.HTTP_400_BAD_REQUEST)

    try:
        month = int(month)
        if not 1 <= month <= 12:
            return Response({"error": "Month should be between 1 and 12."}, status=status.HTTP_400_BAD_REQUEST)
    except ValueError:
        return Response({"error": "'month' parameter should be an integer."}, status=status.HTTP_400_BAD_REQUEST)

    farmer_instance = get_object_or_404(Farmer, id=id, status=0)
    tasks = MySchedule.objects.filter(farmer=farmer_instance, my_land_id=land_id, status=0)

    start_date = datetime(farmer_instance.created_at.year, month, 1)
    if month == 12:
        end_date = datetime(farmer_instance.created_at.year + 1, 1, 1)
    else:
        end_date = datetime(farmer_instance.created_at.year, month + 1, 1)

    tasks = tasks.filter(start_date__gte=start_date, start_date__lt=end_date)

    task_serializer = MyScheduleDetailsSerializer(tasks, many=True, context={'language_code': language_code})

    status_map = {
        "Waiting Completion": {"id": 1, "name": {"en": "Waiting Completion", "ta": "à®¨à®¿à®±à¯ˆà®µà¯ à®•à®¾à®¤à¯à®¤à®¿à®°à¯à®•à¯à®•à®¿à®±à®¤à¯"}},
        "Completed": {"id": 2, "name": {"en": "Completed", "ta": "à®¨à®¿à®±à¯ˆà®µà®Ÿà¯ˆà®¨à¯à®¤à®¤à¯"}},
        "In Progress": {"id": 3, "name": {"en": "In Progress", "ta": "à®šà¯†à®¯à®²à®¿à®²à¯ à®‰à®³à¯à®³à®¤à¯"}},
        "Pending": {"id": 4, "name": {"en": "Pending", "ta": "à®¨à®¿à®²à¯à®µà¯ˆà®¯à®¿à®²à¯ à®‰à®³à¯à®³à®¤à¯"}},
        "Cancelled": {"id": 5, "name": {"en": "Cancelled", "ta": "à®°à®¤à¯à®¤à¯ à®šà¯†à®¯à¯à®¯à®ªà¯à®ªà®Ÿà¯à®Ÿà®¤à¯"}},
    }

    response_by_date = defaultdict(lambda: {
        "task_count": 0,
        "tasks": [],
        "Completed": 0,
        "Waiting Completion": 0,
        "Cancelled": 0,
        "Pending": 0,
        "In Progress": 0
    })

    for task in task_serializer.data:
        task_date_raw = task.get('start_date')
        try:
            task_date = datetime.strptime(task_date_raw, '%Y-%m-%d').date() if isinstance(task_date_raw, str) else task_date_raw
        except Exception:
            continue  # skip invalid dates

        schedule_status = task.get('schedule_status')
        status_info = status_map.get(schedule_status)
        if not status_info:
            continue  # skip unknown statuses

        localized_status_name = status_info["name"].get(language_code, status_info["name"]["en"])

        response_by_date[task_date]["task_count"] += 1
        response_by_date[task_date]["tasks"].append({
            "task_id": task.get('id'),
            "activity_type_name": task.get('schedule_activity_type'),
            "description": task.get('schedule'),
            "status_id": status_info["id"],
            "status": localized_status_name
        })

        response_by_date[task_date][schedule_status] += 1

    completed, waiting, cancelled, pending, in_progress, events = [], [], [], [], [], []

    for date, data in sorted(response_by_date.items()):
        date_str = date.strftime('%Y-%m-%d')

        events.append({
            "Date": date_str,
            "count": data["task_count"],
            "status": next((key.lower().replace(" ", "_") for key in status_map if data[key] > 0), "status_of_red_color"),
            "tasks": data["tasks"]
        })

        if data["Completed"] > 0:
            completed.append({"Date": date_str, "tasks": data["tasks"], "count": data["task_count"]})
        if data["Waiting Completion"] > 0:
            waiting.append({"Date": date_str, "tasks": data["tasks"], "count": data["task_count"]})
        if data["Cancelled"] > 0:
            cancelled.append({"Date": date_str, "tasks": data["tasks"], "count": data["task_count"]})
        if data["Pending"] > 0:
            pending.append({"Date": date_str, "tasks": data["tasks"], "count": data["task_count"]})
        if data["In Progress"] > 0:
            in_progress.append({"Date": date_str, "tasks": data["tasks"], "count": data["task_count"]})

    return Response({
        "completed_task": completed,
        "waiting_task": waiting,
        "cancelled_task": cancelled,
        "pending_task": pending,
        "in_progress_task": in_progress,
        "events": events,
        "language": {"default": language_code}
    }, status=status.HTTP_200_OK)


@api_view(['GET'])
def monthly_schedules(request): 
    year = request.GET.get('year', datetime.now().year)
    month = request.GET.get('month', datetime.now().month)
    crop_id = request.GET.get('crop_id', None)
    
    try:
        year = int(year)
        month = int(month)
        if crop_id:
            crop_id = int(crop_id)
    except ValueError:
        return Response(
            {"error": "Invalid year, month, or crop_id provided."},
            status=status.HTTP_400_BAD_REQUEST
        )
 
    schedules = MySchedule.objects.filter(
        start_date__year=year,
        start_date__month=month
    )
     
    if crop_id:
        schedules = schedules.filter(my_crop__id=crop_id)
 
    grouped_schedules = {}
    for schedule in schedules:
        crop = schedule.my_crop
        # land = schedule.my_land  # Assuming the schedule has a reference to the land
        farmer = schedule.farmer
        schedule_activity_type = schedule.schedule_activity_type
        schedule_status = schedule.schedule_status

        crop_id = crop.id if crop else None
        crop_name = crop.crop.name if crop else None
        # land_id = land.id if land else None
        # land_name = land.name if land else None
        farmer_id = farmer.id if farmer else None
        farmer_name = farmer.name if farmer else None
        schedule_activity_type_id = schedule_activity_type.id if schedule_activity_type else None
        schedule_activity_type_name = schedule_activity_type.name if schedule_activity_type else None
        schedule_status_id = schedule_status.id if schedule_status else None
        schedule_status_name = schedule_status.name if schedule_status else None

        if crop_id not in grouped_schedules:
            grouped_schedules[crop_id] = {
                'crop': {
                    'id': crop_id,
                    'name': crop_name
                },
                'schedules': [],
                'schedule_count': 0
            }

        grouped_schedules[crop_id]['schedules'].append({
            'id': schedule.id,
            'farmer': {
                'id': farmer_id,
                'name': farmer_name
            },
            'my_crop': {
                'id': crop_id,
                'name': crop_name
            },
            # 'my_land': {
            #     'id': land_id,
            #     'name': land_name
            # },
            'schedule_activity_type': {
                'id': schedule_activity_type_id,
                'name': schedule_activity_type_name
            },
            'schedule_status': {
                'id': schedule_status_id,
                'name': schedule_status_name
            },
            'start_date': schedule.start_date,
            'end_date': schedule.end_date,
            'schedule': schedule.schedule,
            'status': schedule.status,
            'description': schedule.description
        })

        # Increment the schedule count for this crop
        grouped_schedules[crop_id]['schedule_count'] += 1

    # Now return the grouped schedules with the schedule count for each crop_id
    return Response(grouped_schedules, status=status.HTTP_200_OK)
 
@api_view(['GET'])
def get_farmer_crops(request, farmer_id):
    # Filter MyCrop based on the farmer_id
    crops = MyCrop.objects.filter(farmer_id=farmer_id)
 

    crops_data = []
    for crop in crops:
        crops_data.append({
            'farmer_id': crop.farmer.id if crop.farmer else None,  # Get farmer's id (if associated)
            'id': crop.id,  # Crop ID
            # Concatenating crop name with land name
            "name": f"{crop.crop.name if crop.crop else 'No Crop'} - {crop.land.name if crop.land else 'No Land'}",
            'description': crop.description,  # Crop description (if any)
            # Add other fields from MyCrop as needed (e.g., plantation_date, crop_img, etc.)
        })
    
    # Return the response with the farmer and their crops
    return JsonResponse({
        'success': True,
        'message': 'Crops retrieved successfully!',
        'data': crops_data
    }, status=status.HTTP_200_OK)

@api_view(['GET'])
def get_crop_types_with_crops(request):
    # Fetch all CropType objects and prefetch related crops
    crop_types = CropType.objects.prefetch_related('crop_set').all()

    # Manually build the response
    response_data = []
    for crop_type in crop_types:
        crop_data = []
        for crop in crop_type.crop_set.all():
            crop_data.append({
                "id": crop.id,
                "name": crop.name,
                "description": crop.description,
                "croptype": crop.croptype.id,   
                "status": crop.status
            })

        response_data.append({
            "id": crop_type.id,
            "name": crop_type.name,
            "description": crop_type.description,
            "crops": crop_data
        })

    # Return the manually constructed response data
    return Response(response_data, status=status.HTTP_200_OK)

@api_view(['GET'])
def get_customers_by_farmer(request, farmer_id):
    print(f"Received farmer_id: {farmer_id}")  # Log the farmer_id
    customers = MyCustomer.objects.filter(farmer_id=farmer_id, status=0)

    # Check if any customers exist
    if not customers.exists():
        return Response({"message": "No customers found for the given farmer."}, status=status.HTTP_404_NOT_FOUND)

    serializer = MyCustomerDetailsSerializer(customers, many=True)
    return Response(serializer.data, status=status.HTTP_200_OK)
 
@api_view(['GET'])
def get_schedule_weekly(request):
    if request.method == 'GET':
        schedules = ScheduleWeekly.objects.all()  # Get all weekly schedules
        schedule_list = []
        
        for schedule in schedules:
            schedule_list.append({
                'id': schedule.id,
                'name': schedule.name,
                'status': schedule.status,
                'code': schedule.code,
                'created_at': schedule.created_at,
                'updated_at': schedule.updated_at,
                'language':{
                    "default":"en"
                }
            })
        
        return Response(schedule_list, status=status.HTTP_200_OK)

@api_view(['GET'])
def get_schedule_monthly(request):
    if request.method == 'GET':
        schedules = ScheduleMonthly.objects.all()  # Get all monthly schedules
        schedule_list = []
        
        for schedule in schedules:
            schedule_list.append({
                'id': schedule.id,
                'name': schedule.name,
                'status': schedule.status,
                'code': schedule.code,
                'created_at': schedule.created_at,
                'updated_at': schedule.updated_at,
                'language':{
                    "default":"en"
                }
            })
        
        return Response(schedule_list, status=status.HTTP_200_OK)

@api_view(['GET'])
def get_schedule_year(request):
    if request.method == 'GET':
        schedules = ScheduleYear.objects.all()  # Get all year schedules
        schedule_list = []
        
        for schedule in schedules:
            schedule_list.append({
                'id': schedule.id,
                'name': schedule.name,
                'status': schedule.status,
                'code': schedule.code,
                'created_at': schedule.created_at,
                'updated_at': schedule.updated_at,
                'language':{
                    "default":"en"
                }
            })
        
        return Response(schedule_list, status=status.HTTP_200_OK)
 
MONTH_NAME_TO_NUMBER = {
    'January': 1,
    'February': 2,
    'March': 3,
    'April': 4,
    'May': 5,
    'June': 6,
    'July': 7,
    'August': 8,
    'September': 9,
    'October': 10,
    'November': 11,
    'December': 12
}
 
 

@api_view(['POST'])
def new_task(request):
    if request.method == 'POST':
        # Extracting data from the request body
        farmer_id = request.data.get('farmer')
        my_crop_id = request.data.get('my_crop')
        schedule_activity_type_id = request.data.get('schedule_activity_type')
        start_date = request.data.get('start_date')
        end_date = request.data.get('end_date')
        # schedule_choice = request.data.get('schedule_choice')
        schedule_choice = request.data.get('schedule_choice', 0)
        schedule_weekly_ids = request.data.get('schedule_weekly', [])
        schedule_monthly_ids = request.data.get('schedule_monthly', [])
        schedule_year_ids = request.data.get('schedule_year', [])
        schedule_status_id = request.data.get('schedule_status')
        schedule = request.data.get('schedule')
        comment = request.data.get('comment')

        try:
            user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
            language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
        except UserLanguagePreference.DoesNotExist:
            language_code = 'en'  # Fallback to 'en' if no preference is found
 
        if not farmer_id or not my_crop_id or not schedule_activity_type_id or not start_date:
            return Response({'error': 'Farmer, crop, activity type, and start date are required'}, status=status.HTTP_400_BAD_REQUEST)
         
        try:
            start_date = datetime.strptime(start_date, '%Y-%m-%d').date()
            end_date = datetime.strptime(end_date, '%Y-%m-%d').date() if end_date else None
        except ValueError:
            return Response({'error': 'Invalid date format, use YYYY-MM-DD'}, status=status.HTTP_400_BAD_REQUEST)

        # Ensure that end_date is only compared to start_date if it's not None
        if end_date and end_date < start_date:
            return Response({'error': 'End date cannot be before start date'}, status=status.HTTP_400_BAD_REQUEST)
 
        farmer = get_object_or_404(Farmer, id=farmer_id)
        my_crop = get_object_or_404(MyCrop, id=my_crop_id)
        schedule_activity_type = get_object_or_404(ScheduleActivityType, id=schedule_activity_type_id)
        schedule_status = get_object_or_404(ScheduleStatus, id=schedule_status_id)
        my_land = my_crop.land
        schedules = []

        target_language = ['ta','hi',]  # Example target languages
        translate_json = {
            "schedule": {},
            "comment": {}
        }

        if schedule:
            for lang in target_language:
                try:
                    translated_schedule = GoogleTranslator(source='auto', target=lang).translate(schedule)
                    print(f"Translated schedule '{schedule}' to {lang}: {translated_schedule}")
                    translate_json["schedule"][lang] = translated_schedule
                except Exception as e:
                    print(f"Error translating schedule '{schedule}' to {lang}: {e}")

        if comment:
            for lang in target_language:
                try:
                    translated_comment = GoogleTranslator(source='auto', target=lang).translate(comment)
                    print(f"Translated comment '{comment}' to {lang}: {translated_comment}")
                    translate_json["comment"][lang] = translated_comment
                except Exception as e:
                    print(f"Error translating comment '{comment}' to {lang}: {e}")

        
        if schedule_choice == 0:  # Daily schedule
            current_date = start_date
            # while current_date <= end_date:
            while current_date <= (end_date or current_date):
                my_schedule = MySchedule(
                    farmer=farmer,
                    my_crop=my_crop,
                    my_land=my_land,
                    schedule_activity_type=schedule_activity_type,
                    start_date=current_date,
                    end_date=current_date if not end_date else end_date,
                    # start_date=current_date,
                    # end_date=current_date,
                    schedule_choice=schedule_choice,
                    schedule_status=schedule_status,
                    schedule=schedule,
                    comment=comment,
                    # created_by=request.user,
                )
                my_schedule.save()
                schedules.append({
                    'id': my_schedule.id,
                    'farmer': farmer.id,
                    'my_crop': my_crop.id,
                    'my_land':my_land.id,
                    'schedule_activity_type': schedule_activity_type.id,
                    'start_date': current_date,
                    'end_date': current_date if not end_date else end_date,
                    # 'start_date': current_date,
                    # 'end_date': current_date,
                    'schedule_choice': schedule_choice,
                    'schedule_status': schedule_status.id,
                    'schedule': schedule,
                    'comment': comment,
                    'weekday': current_date.strftime('%A'), 
                    "language": {
                        "default": "en"
                    }
                })
                current_date += timedelta(days=1)
 
        elif schedule_choice == 1:  # Weekly schedule
            if not schedule_weekly_ids:
                return Response({'error': 'At least one weekly schedule must be selected'}, status=status.HTTP_400_BAD_REQUEST)
            if not end_date:
                return Response({'error': 'End date is required for weekly schedules'}, status=status.HTTP_400_BAD_REQUEST)

            weekday_map = {1: 'Monday', 2: 'Tuesday', 3: 'Wednesday', 4: 'Thursday', 5: 'Friday', 6: 'Saturday', 7: 'Sunday'}
            selected_week_days = schedule_weekly_ids

            schedules = []
             
            current_date = start_date
            schedule_dates = []

            for week_day in selected_week_days:
                temp_date = current_date
                while temp_date.weekday() + 1 != week_day:
                    temp_date += timedelta(days=1)
                 
                schedule_dates.append(temp_date)
             
            schedule_dates.sort()
 
            for start_day in schedule_dates: 
                current_date = start_day

                while current_date <= end_date:
                    weekday_name = weekday_map[current_date.weekday() + 1]
                    
                    # Create the schedule entry
                    my_schedule = MySchedule(
                        farmer=farmer,
                        my_crop=my_crop,
                        my_land=my_land,
                        schedule_activity_type=schedule_activity_type,
                        start_date=current_date,
                        end_date=current_date,
                        schedule_choice=schedule_choice,
                        schedule_status=schedule_status,
                        schedule=schedule,
                        comment=comment,
                        # created_by=request.user,
                    )
                    my_schedule.save()

                    schedules.append({
                        'id': my_schedule.id,
                        'farmer': farmer.id,
                        'my_crop': my_crop.id,
                        'my_land': my_land.id, 
                        'schedule_activity_type': schedule_activity_type.id,
                        'start_date': current_date,
                        'end_date': current_date,
                        'schedule_choice': schedule_choice,
                        'schedule_status': schedule_status.id,
                        # 'schedule': schedule,
                        'schedule':  my_schedule.get_translated_value("schedule", language_code) if my_schedule.schedule and language_code == 'ta' else my_schedule.schedule if my_schedule.schedule else None,
                        'comment': comment,
                        'weekday': weekday_name,
                        "language": {
                            "default": "en"
                        }
                    })
 
                    current_date += timedelta(days=7)
 
        elif schedule_choice == 2:   
            if not schedule_monthly_ids or not schedule_year_ids:
                return Response({'error': 'At least one monthly schedule and year must be selected'}, status=status.HTTP_400_BAD_REQUEST)
 
            start_year = start_date.year 
            schedules = []
 
            if isinstance(start_date, datetime):
                start_date = start_date.date()
 
            schedule_year_ids.append(1)   
 
            for month_number in schedule_monthly_ids:
                for day_of_month in schedule_year_ids: 
                    try:
                        month_date = date(start_year, month_number, day_of_month)
                    except ValueError: 
                        continue
 
                    if (end_date and start_date <= month_date <= end_date) or (not end_date and start_date <= month_date):
               
                        my_schedule = MySchedule(
                            farmer=farmer,
                            my_crop=my_crop,
                            my_land=my_land,
                            schedule_activity_type=schedule_activity_type,
                            start_date=month_date,
                            end_date=month_date,
                            schedule_choice=schedule_choice,
                            schedule_status=schedule_status,
                            schedule=schedule,
                            comment=comment,
                        )
                        my_schedule.save()
 
                        schedules.append({
                            'id': my_schedule.id,
                            'farmer': farmer.id,
                            'my_crop': my_crop.id, 
                            'my_land': my_land.id, 
                            'schedule_activity_type': schedule_activity_type.id,
                            'start_date': month_date,
                            'schedule_choice': schedule_choice,
                            'schedule_status': schedule_status.id,
                            'schedule': schedule,
                            'comment': comment,
                            'weekday': month_date.strftime('%A'),
                            "language": {
                                "default": "en"
                            }
                        })


                     # Notification for new task
        notification_message = f"New task created for crop {my_crop.crop.name} on {start_date} for activity: {schedule_activity_type.name}."
        FarmerNotification.objects.create(
            farmer=farmer,
            name="New Task Created",
            type="Task Management",
            message=notification_message,
            is_read=False  # Notification is unread by default
        )

        return Response(schedules, status=status.HTTP_201_CREATED)           
 
            # return Response(schedules, status=status.HTTP_201_CREATED)
        
    return Response(schedules, status=status.HTTP_201_CREATED)


@api_view(['GET'])
def get_all_details_view(request, id):
    # Fetching Farmer data
    try:
        farmer = Farmer.objects.get(id=id)
    except Farmer.DoesNotExist:
        return Response({"detail": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)

    # Fetching all data for ManageMarket
    try:
        markets = ManageMarket.objects.filter(village=farmer.village)
        all_market_details = [
            {
                'name': market.name,
                'markettype': market.markettype.name if market.markettype else None,
                'products': [product.name for product in market.products.all()],
                'openingtime': market.openingtime,
                'closingtime': market.closingtime,
                'days': [day.name for day in market.days.all()],
                'description': market.description,
                'phone': market.phone,
                'address': market.address,
                'latitude': market.latitude,
                'longitude': market.longitude,
                'status': market.status,
                'created_at': market.created_at,
                'updated_at': market.updated_at,
            }
            for market in markets
        ]
    except ManageMarket.DoesNotExist:
        all_market_details = []

    # Fetching all data for ManageNearByLocations
    try:
        nearby_locations = ManageNearByLocations.objects.all()
        all_nearby_location_details = [
            {
                'category': location.category.name if location.category else None,
                'name': location.name,
                'contact': location.contact,
                'address': location.address,
                'description': location.description,
                'openingtime': location.openingtime,
                'closingtime': location.closingtime,
                'days': [day.name for day in location.days.all()],
                'latitude': location.latitude,
                'longitude': location.longitude,
                'status': location.status,
                'created_at': location.created_at,
                'updated_at': location.updated_at,
            }
            for location in nearby_locations
        ]
    except ManageNearByLocations.DoesNotExist:
        all_nearby_location_details = []

    # Fetching all data for ManageWorkers
    try:
        workers = ManageWorkers.objects.all()
        all_worker_details = [
            {
                'name': worker.worker.name,
                'mobile_no': worker.worker.mobile_no,
                'village': worker.worker.village.name if worker.worker.village else None,
                'taluk': worker.worker.taluk.name if worker.worker.taluk else None,
                'employee_type': worker.workerstype.name if worker.workerstype else None,
                'status': worker.status,
                'created_at': worker.created_at,
                'updated_at': worker.updated_at,
            }
            for worker in workers
        ]
    except ManageWorkers.DoesNotExist:
        all_worker_details = []

    # Fetching rentals data (Including vehicles, machinery, and tools)
    try:
        rentals = MyInventory.objects.filter(rental=1)
        rental_data = []

        # Loop through the rentals and add vehicle, machinery, or tool data based on the associated purchase
        for inventory_item in rentals:
            rental_details = {
                'inventory_item_name': inventory_item.inventory_items.name,
                'inventory_item_id': inventory_item.inventory_items.id,
                'type': 'vehicle' if inventory_item.vehicle_purchase else 'machinery' if inventory_item.machinery_purchase else 'tool',
                'count': MyInventory.objects.filter(inventory_items=inventory_item.inventory_items).count(),
                'details': [],
            }

            # Add serialized details for vehicle, machinery, or tool based on the type
            if inventory_item.id == 1:
                vehicle_details = MyVehicle.objects.filter(inventory_items=1)
                rental_details['details'] = MyVehicleSerializer(vehicle_details, many=True).data
            elif inventory_item.id == 2:
                machinery_details = MyMachinery.objects.filter(inventory_items=2)
                rental_details['details'] = MyMachinerySerializer(machinery_details, many=True).data
            elif inventory_item.id == 3:
                tool_details = MyTools.objects.filter(inventory_items=3)
                rental_details['details'] = MyToolsSerializer(tool_details, many=True).data

            rental_data.append(rental_details)

    except MyInventory.DoesNotExist:
        rental_data = []

    # Combining the data for all models
    all_details = {
        'markets': all_market_details,
        'nearby_locations': all_nearby_location_details,
        'workers': all_worker_details,
        "rentals": rental_data,
    }

    # Returning the combined data as a JSON response
    return Response(all_details, status=status.HTTP_200_OK)

@api_view(['GET'])
def fuel_consumption_items(request, id):  
    inventory_items = MyInventory.objects.filter(farmer=id, inventory_type=6)  

    # if not inventory_items:
    #     return Response({"detail": "No inventory records found for this farmer."}, status=status.HTTP_404_NOT_FOUND)
 
    fuel_items = MyFuel.objects.filter(farmer=id)   

    inventory_data = []
 
    for inventory_item in inventory_items: 
        if inventory_item.quantity_utilized > 0:   
            crop = inventory_item.crop

            response_item = {
                "id": inventory_item.id,
                "date_of_consumption": inventory_item.date_of_consumption,
                "inventory_type": inventory_item.inventory_type.name if inventory_item.inventory_type else None,
                "inventory_category": inventory_item.inventory_category.name if inventory_item.inventory_category else None,
                "inventory_items": inventory_item.inventory_items.name if inventory_item.inventory_items else None,
                "inventory_id": inventory_item.inventory_items.id if inventory_item.inventory_items else None,
                "available_quans": inventory_item.available_quans,
                "quantity_utilized": inventory_item.quantity_utilized,
                "description": inventory_item.description,
                "start_kilometer": inventory_item.start_kilometer,
                "end_kilometer": inventory_item.end_kilometer,
                "usage_hours": inventory_item.usage_hours,
                "status": inventory_item.status, 
                "crop": {
                    "crop": crop.crop.name if crop else None,
                    "land": crop.land.name if crop else None
                }
            }

            inventory_data.append(response_item)

    # Only fetch fuel details if fuel_items is not empty
    if fuel_items:
        fuel_details = [ 
              {
                "id": fuel_item.id,
                "date_of_consumption": fuel_item.date_of_consumption,
                "vendor": fuel_item.vendor.name if fuel_item.vendor else None,
                "inventory_type": fuel_item.inventory_type.name if fuel_item.inventory_type else None,
                "inventory_category": fuel_item.inventory_category.name if fuel_item.inventory_category else None,
                "inventory_items": fuel_item.inventory_items.name if fuel_item.inventory_items else None,
                "inventory_id": fuel_item.inventory_items.id if fuel_item.inventory_items else None,
                "quantity": fuel_item.quantity,
                "purchase_amount": fuel_item.purchase_amount,
                "description": fuel_item.description,
                "status": fuel_item.status,
            }
            for fuel_item in fuel_items
        ]
    else:
        fuel_details = []

    # If no items were added to inventory_data due to quantity_utilized being 0, return empty list
    if not inventory_data:
        inventory_data = []

    return Response({
        "inventory_data": inventory_data,
        "fuel_details": fuel_details
    }, status=status.HTTP_200_OK)

@api_view(['GET'])
def vehicle_consumption_items(request, id): 
    inventory_items = MyInventory.objects.filter(farmer=id, inventory_type=1)  

    vehicle_items = MyVehicle.objects.filter(farmer=id)   
    
    # if not inventory_items:
    #     return Response({"detail": "No inventory records found for this farmer."}, status=status.HTTP_404_NOT_FOUND)

    

    inventory_data = []

    # Loop over inventory items and check quantity_utilized
    for inventory_item in inventory_items: 
        if inventory_item.quantity_utilized > 0:  # Only add to response if quantity_utilized is greater than 0
            crop = inventory_item.crop

            response_item = {
                "id": inventory_item.id,
                "date_of_consumption": inventory_item.date_of_consumption,
                "inventory_type": inventory_item.inventory_type.name if inventory_item.inventory_type else None,
                "inventory_category": inventory_item.inventory_category.name if inventory_item.inventory_category else None,
                "inventory_items": inventory_item.inventory_items.name if inventory_item.inventory_items else None,
                "inventory_id": inventory_item.inventory_items.id if inventory_item.inventory_items else None,
                "available_quans": inventory_item.available_quans,
                "quantity_utilized": inventory_item.quantity_utilized,
                "description": inventory_item.description,
                "start_kilometer": inventory_item.start_kilometer,
                "end_kilometer": inventory_item.end_kilometer,
                "usage_hours": inventory_item.usage_hours,
                "status": inventory_item.status, 
                "crop": {
                    "crop": crop.crop.name if crop else None,
                    "land": crop.land.name if crop else None
                }
            }

            inventory_data.append(response_item)

    # Only fetch vehicle details if vehicle_items is not empty
    if vehicle_items:
        vehicle_details = [
            {
                "id": vehicle_item.id,
                "date_of_consumption": vehicle_item.date_of_consumption,
                "inventory_type": vehicle_item.inventory_type.name if vehicle_item.inventory_type else None,
                "inventory_category": vehicle_item.inventory_category.name if vehicle_item.inventory_category else None,
                "inventory_items": vehicle_item.inventory_items.name if vehicle_item.inventory_items else None,
                "inventory_id": vehicle_item.inventory_items.id if vehicle_item.inventory_items else None,
                "fuel_capacity": vehicle_item.fuel_capacity,
                "average_mileage": vehicle_item.average_mileage,
                "purchase_amount": vehicle_item.purchase_amount,
                "description": vehicle_item.description,
                "status": vehicle_item.status,
                "vendor": vehicle_item.vendor.name if vehicle_item.vendor else None,
                "company_name": vehicle_item.company_name,
                "insurance": vehicle_item.insurance,
                "insurance_no": vehicle_item.insurance_no,
                "insurance_amount": vehicle_item.insurance_amount,
                "insurance_start_date": vehicle_item.insurance_start_date,
                "insurance_end_date": vehicle_item.insurance_end_date,
                "insurance_renewal_date": vehicle_item.insurance_renewal_date,
                "register_number": vehicle_item.register_number,
                "owner_name": vehicle_item.owner_name,
                "date_of_registration": vehicle_item.date_of_registration,
                "registration_valid_till": vehicle_item.registration_valid_till,
                "engine_number": vehicle_item.engine_number,
                "chasis_number": vehicle_item.chasis_number,
                "running_kilometer": vehicle_item.running_kilometer,
                "service_frequency": vehicle_item.service_frequency,
                "service_frequency_unit": vehicle_item.service_frequency_unit,
                "purchase_amount": vehicle_item.purchase_amount,
                "description": vehicle_item.description,
                "status": vehicle_item.status,
            }
            for vehicle_item in vehicle_items
        ]
    else:
        vehicle_details = {}

    # If no items were added to inventory_data due to quantity_utilized being 0, return empty list
    if not inventory_data:
        inventory_data = []

    return Response({
        "inventory_data": inventory_data,
        "vehicle_details": vehicle_details
    }, status=status.HTTP_200_OK)

@api_view(['GET'])
def machinery_consumption_items(request, id):
    # Fetch the inventory items for the given farmer and inventory_type=2 (assuming 2 is for machinery)
    inventory_items = MyInventory.objects.filter(farmer=id, inventory_type=2)

    # if not inventory_items:
    #     return Response({"detail": "No inventory records found for this farmer."}, status=status.HTTP_404_NOT_FOUND)

    machinery_items = MyMachinery.objects.filter(farmer=id)

    inventory_data = []

    # Loop over inventory items and check quantity_utilized
    for inventory_item in inventory_items:
        if inventory_item.quantity_utilized > 0:  # Only add to response if quantity_utilized is greater than 0
            crop = inventory_item.crop

            response_item = {
                "id": inventory_item.id,
                "date_of_consumption": inventory_item.date_of_consumption,
                "inventory_type": inventory_item.inventory_type.name if inventory_item.inventory_type else None,
                "inventory_category": inventory_item.inventory_category.name if inventory_item.inventory_category else None,
                "inventory_items": inventory_item.inventory_items.name if inventory_item.inventory_items else None,
                "inventory_id": inventory_item.inventory_items.id if inventory_item.inventory_items else None,
                "available_quans": inventory_item.available_quans,
                "quantity_utilized": inventory_item.quantity_utilized,
                "description": inventory_item.description,
                "start_kilometer": inventory_item.start_kilometer,
                "end_kilometer": inventory_item.end_kilometer,
                "usage_hours": inventory_item.usage_hours,
                "status": inventory_item.status,
                "crop": {
                    "crop": crop.crop.name if crop else None,
                    "land": crop.land.name if crop else None
                }
            }

            inventory_data.append(response_item)

    # Only fetch machinery details if machinery_items is not empty
    if machinery_items:
        machinery_details = [ 
            {
            "id": machinery_item.id,
            "machinery_type": machinery_item.machinery_type,
            "fuel_capacity": machinery_item.fuel_capacity,
            "purchase_amount": machinery_item.purchase_amount,
            "warranty_start_date": machinery_item.warranty_start_date,
            "warranty_end_date": machinery_item.warranty_end_date,
            "description": machinery_item.description,
            "status": machinery_item.status,
            # "document_url": machinery_item.document.url if machinery_item.document else None,
            "inventory_items": machinery_item.inventory_items.name if machinery_item.inventory_items else None,
            "vendor": machinery_item.vendor.name if machinery_item.vendor else None,
            "inventory_type": machinery_item.inventory_type.name if machinery_item.inventory_type else None,
            "inventory_category": machinery_item.inventory_category.name if machinery_item.inventory_category else None,
            "inventory_id": machinery_item.inventory_items.id if machinery_item.inventory_items else None
        }
            for machinery_item in machinery_items
        ]
    else:
        machinery_details = {}

    # If no items were added to inventory_data due to quantity_utilized being 0, return empty list
    if not inventory_data:
        inventory_data = []

    return Response({
        "inventory_data": inventory_data,
        "machinery_details": machinery_details
    }, status=status.HTTP_200_OK)

@api_view(['GET'])
def tools_consumption_items(request, id):
    # Fetch the inventory items for the given farmer and inventory_type=3 (assuming 3 is for tools)
    inventory_items = MyInventory.objects.filter(farmer=id, inventory_type=3)

    # if not inventory_items:
    #     return Response({"detail": "No inventory records found for this farmer."}, status=status.HTTP_404_NOT_FOUND)

    tools_items = MyTools.objects.filter(farmer=id)

    inventory_data = []

    # Loop over inventory items and check quantity_utilized
    for inventory_item in inventory_items:
        if inventory_item.quantity_utilized > 0:  # Only add to response if quantity_utilized is greater than 0
            crop = inventory_item.crop

            response_item = {
                "id": inventory_item.id,
                "date_of_consumption": inventory_item.date_of_consumption,
                "inventory_type": inventory_item.inventory_type.name if inventory_item.inventory_type else None,
                "inventory_category": inventory_item.inventory_category.name if inventory_item.inventory_category else None,
                "inventory_items": inventory_item.inventory_items.name if inventory_item.inventory_items else None,
                "inventory_id": inventory_item.inventory_items.id if inventory_item.inventory_items else None,
                "available_quans": inventory_item.available_quans,
                "quantity_utilized": inventory_item.quantity_utilized,
                "description": inventory_item.description,
                "start_kilometer": inventory_item.start_kilometer,
                "end_kilometer": inventory_item.end_kilometer,
                "usage_hours": inventory_item.usage_hours,
                "status": inventory_item.status,
                "crop": {
                    "crop": crop.crop.name if crop else None,
                    "land": crop.land.name if crop else None
                }
            }

            inventory_data.append(response_item)

    # Only fetch tools details if tools_items is not empty
    if tools_items:
        tools_details = [
             {
            "id": tool.id,
            "inventory_type": tool.inventory_type.name,
            "inventory_category": tool.inventory_category.name,
            "inventory_items": tool.inventory_items.name,
            "inventory_id": tool.inventory_items.id if tool.inventory_items else None,
            "purchase_amount": tool.purchase_amount,
            "vendor": tool.vendor.name,
            "description": tool.description,
            "status": tool.status,
            # "document_url": tool.document.url if tool.document else None,
            "inventory_items": tool.inventory_items.name if tool.inventory_items else None
        }
            for tool in tools_items
        ]
    else:
        tools_details = {}

    # If no items were added to inventory_data due to quantity_utilized being 0, return empty list
    if not inventory_data:
        inventory_data = []

    return Response({
        "inventory_data": inventory_data,
        "tools_details": tools_details
    }, status=status.HTTP_200_OK)

@api_view(['GET'])
def pesticides_consumption_items(request, id):
    # Fetch the inventory items for the given farmer and inventory_type=4 (assuming 4 is for pesticides)
    inventory_items = MyInventory.objects.filter(farmer=id, inventory_type=4)

    # if not inventory_items:
    #     return Response({"detail": "No inventory records found for this farmer."}, status=status.HTTP_404_NOT_FOUND)

    pesticides_items = MyPesticides.objects.filter(farmer=id)

    inventory_data = []

    # Loop over inventory items and check quantity_utilized
    for inventory_item in inventory_items:
        if inventory_item.quantity_utilized > 0:  # Only add to response if quantity_utilized is greater than 0
            crop = inventory_item.crop

            response_item = {
                "id": inventory_item.id,
                "date_of_consumption": inventory_item.date_of_consumption,
                "inventory_type": inventory_item.inventory_type.name if inventory_item.inventory_type else None,
                "inventory_category": inventory_item.inventory_category.name if inventory_item.inventory_category else None,
                "inventory_items": inventory_item.inventory_items.name if inventory_item.inventory_items else None,
                "inventory_id": inventory_item.inventory_items.id if inventory_item.inventory_items else None,
                "available_quans": inventory_item.available_quans,
                "quantity_utilized": inventory_item.quantity_utilized,
                "description": inventory_item.description,
                "start_kilometer": inventory_item.start_kilometer,
                "end_kilometer": inventory_item.end_kilometer,
                "usage_hours": inventory_item.usage_hours,
                "status": inventory_item.status,
                "crop": {
                    "crop": crop.crop.name if crop else None,
                    "land": crop.land.name if crop else None
                }
            }

            inventory_data.append(response_item)

    # Only fetch pesticides details if pesticides_items is not empty
    if pesticides_items:
        pesticides_details = [
            {
            "id": pesticide.id,
            "inventory_type": pesticide.inventory_type.name,
            "inventory_category": pesticide.inventory_category.name,
            "inventory_items": pesticide.inventory_items.name,
            "inventory_id": pesticide.inventory_items.id if pesticide.inventory_items else None,
            "vendor": pesticide.vendor.name,
            "quantity":pesticide.quantity,
            "purchase_amount": pesticide.purchase_amount,
            "description": pesticide.description,
            "status": pesticide.status,
            # "document_url": pesticide.document.url if pesticide.document else None,
            "inventory_items": pesticide.inventory_items.name if pesticide.inventory_items else None
        }
       
            for pesticide in pesticides_items
        ]
    else:
        pesticides_details = {}

    # If no items were added to inventory_data due to quantity_utilized being 0, return empty list
    if not inventory_data:
        inventory_data = []

    return Response({
        "inventory_data": inventory_data,
        "pesticides_details": pesticides_details
    }, status=status.HTTP_200_OK)

@api_view(['GET'])
def fertilizers_consumption_items(request, id): 
    inventory_items = MyInventory.objects.filter(farmer=id, inventory_type=5) 

    fertilizers_items = MyFertilizers.objects.filter(farmer=id)

    inventory_data = []
 
    for inventory_item in inventory_items:
        if inventory_item.quantity_utilized > 0:  # Only add to response if quantity_utilized is greater than 0
            crop = inventory_item.crop

            response_item = {
                "id": inventory_item.id,
                "date_of_consumption": inventory_item.date_of_consumption,
                "inventory_type": inventory_item.inventory_type.name if inventory_item.inventory_type else None,
                "inventory_category": inventory_item.inventory_category.name if inventory_item.inventory_category else None,
                "inventory_items": inventory_item.inventory_items.name if inventory_item.inventory_items else None,
                "inventory_id": inventory_item.inventory_items.id if inventory_item.inventory_items else None,
                "available_quans": inventory_item.available_quans,
                "quantity_utilized": inventory_item.quantity_utilized,
                "description": inventory_item.description,
                "start_kilometer": inventory_item.start_kilometer,
                "end_kilometer": inventory_item.end_kilometer,
                "usage_hours": inventory_item.usage_hours,
                "status": inventory_item.status,
                "crop": {
                    "crop": crop.crop.name if crop else None,
                    "land": crop.land.name if crop else None
                }
            }

            inventory_data.append(response_item)
 
    if fertilizers_items:
        fertilizers_details = [
           
            {
            "id": fertilizer.id,
            "inventory_type": fertilizer.inventory_type.name if fertilizer.inventory_type else None,
            "inventory_category": fertilizer.inventory_category.name if fertilizer.inventory_category else None,
            "inventory_items": fertilizer.inventory_items.name if fertilizer.inventory_items else None,
            "inventory_id": fertilizer.inventory_items.id if fertilizer.inventory_items else None,
            "vendor": fertilizer.vendor.name if fertilizer.vendor else None,
            "purchase_amount": fertilizer.purchase_amount,
            "description": fertilizer.description,
            "status": fertilizer.status,
            # "document_url": fertilizer.document.url if fertilizer.document else None,
            "inventory_items": fertilizer.inventory_items.name if fertilizer.inventory_items else None
        }
            for fertilizer in fertilizers_items
        ]
    else:
        fertilizers_details = {}
 
    if not inventory_data:
        inventory_data = []

    return Response({
        "inventory_data": inventory_data,
        "fertilizers_details": fertilizers_details
    }, status=status.HTTP_200_OK)

@api_view(['GET'])
def seeds_consumption_items(request, id): 
    inventory_items = MyInventory.objects.filter(farmer=id, inventory_type=7)
 

    seeds_items = MySeeds.objects.filter(farmer=id)

    inventory_data = []
 
    for inventory_item in inventory_items:
        if inventory_item.quantity_utilized > 0:  
            crop = inventory_item.crop

            response_item = {
                "id": inventory_item.id,
                "date_of_consumption": inventory_item.date_of_consumption,
                "inventory_type": inventory_item.inventory_type.name if inventory_item.inventory_type else None,
                "inventory_category": inventory_item.inventory_category.name if inventory_item.inventory_category else None,
                "inventory_items": inventory_item.inventory_items.name if inventory_item.inventory_items else None,
                "inventory_id": inventory_item.inventory_items.id if inventory_item.inventory_items else None,
                "available_quans": inventory_item.available_quans,
                "quantity_utilized": inventory_item.quantity_utilized,
                "description": inventory_item.description,
                "start_kilometer": inventory_item.start_kilometer,
                "end_kilometer": inventory_item.end_kilometer,
                "usage_hours": inventory_item.usage_hours,
                "status": inventory_item.status,
                "crop": {
                    "crop": crop.crop.name if crop else None,
                    "land": crop.land.name if crop else None
                }
            }

            inventory_data.append(response_item)
 
    if seeds_items:
        seeds_details = [
      
            {
                "id": seed.id,
                "inventory_type": seed.inventory_type.name if seed.inventory_type else None,
                "inventory_category": seed.inventory_category.name if seed.inventory_category else None,
                "inventory_items": seed.inventory_items.name if seed.inventory_items else None,
                "inventory_id": seed.inventory_items.id if seed.inventory_items else None,
                "vendor": seed.vendor.name if seed.vendor else None,
                "purchase_amount": seed.purchase_amount,
                "description": seed.description,
                "status": seed.status,
                # "document_url": seed.document.url if seed.document else None,
                "inventory_items": seed.inventory_items.name if seed.inventory_items else None
            }
            for seed in seeds_items
        ]
    else:
        seeds_details = {}

    # If no items were added to inventory_data due to quantity_utilized being 0, return empty list
    if not inventory_data:
        inventory_data = []

    return Response({
        "inventory_data": inventory_data,
        "seeds_details": seeds_details
    }, status=status.HTTP_200_OK)
 
@api_view(['GET'])
def get_near_by_locations(request, id, farmer_id):
    # Fetching the Farmer using the provided farmer_id
    try:
        farmer = Farmer.objects.get(id=farmer_id, status=0)
    except Farmer.DoesNotExist:
        return Response({"detail": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)
    
        # Fetching the language preference for the farmer
    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'   
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'   

    try:
        # Fetching the MyLand based on the provided ID and ensuring it belongs to the specified farmer
        my_land = MyLand.objects.get(id=id, farmer=farmer, status=0)
    except MyLand.DoesNotExist:
        return Response({"detail": "MyLand not found for the specified farmer."}, status=status.HTTP_404_NOT_FOUND)

    try:
        # Fetching all nearby locations based on the village associated with the MyLand
        nearby_locations = ManageNearByLocations.objects.filter(village=my_land.village, status=0)
        grouped_locations = {}

        for location in nearby_locations:

             # Constructing the address with translation for door_no only if needed
            address_parts = []
            if location.door_no:
                address_parts.append(location.get_translated_value("door_no", language_code) if language_code == 'ta' else str(location.door_no))
            if location.village:
                village_name = location.village.get_translated_value("name", language_code)  # Translate the village name
                address_parts.append(village_name)
            else:
                village_name = None
            if location.taluk:
                taluk_name = location.taluk.get_translated_value("name", language_code)   
                address_parts.append(taluk_name)
            else:
                taluk_name = None
            if location.city:
                city_name = location.city.get_translated_value("name", language_code)   
                address_parts.append(city_name)
            else:
                city_name = None
            if location.state:
                state_name = location.state.get_translated_value("name", language_code)  # Translate the village name
                address_parts.append(state_name)
            else:
                state_name = None
            if location.country:
                country_name = location.country.get_translated_value("name", language_code)  # Translate the village name
                address_parts.append(country_name)
            else:
                country_name = None
            if location.pincode:
                address_parts.append(str(location.pincode))

            address = ", ".join(address_parts)
            # Get the category name, or set to 'Unknown' if not available
            # category_name = location.category.name if location.category else 'Unknown'
            category_name = location.category.get_translated_value("name", language_code) if language_code == 'ta' else location.category.name

            # Initialize the category if it does not exist in the dictionary
            if category_name not in grouped_locations:
                grouped_locations[category_name] = []

            # Prepare the location details to append under the respective category
            location_details = {
                'id': location.id, 
                'name': location.get_translated_value("name", language_code) if language_code == 'ta' else location.name,
                'contact': location.contact,
                # 'address': ', '.join(filter(None, [
                #     location.door_no,
                #     location.village.name if location.village else '',
                #     location.taluk.name if location.taluk else '',
                #     location.city.name if location.city else '',
                #     location.state.name if location.state else '',
                #     location.country.name if location.country else ''
                # ])), 
                'address': address,
                "images": request.build_absolute_uri(f'/SuperAdmin{location.img.url}' if location.img else location.img.url) if location.img else "",
           
                'description': location.get_translated_value("description", language_code) if language_code == 'ta' else location.description,
                'openingtime': location.openingtime,
                'closingtime': location.closingtime, 
                'days': [get_translated_value(day.name, language_code) if language_code == 'ta' else day.name for day in location.days.all()],
                'latitude': location.latitude,
                'longitude': location.longitude,
                'status': location.status,
            }

            # Append the location details to the appropriate category
            grouped_locations[category_name].append(location_details)

        # Prepare the final response, including the count of locations per category
        category_details = [
            {
                'category_name': category_name, 
                
                'count': len(locations),
                'details': locations,
                "language": {
                    "default": "en"
                }
            }
            for category_name, locations in grouped_locations.items()
        ]

    except ManageNearByLocations.DoesNotExist:
        category_details = []

    # Returning the response with the category details
    return Response(category_details, status=status.HTTP_200_OK)

# @api_view(['GET'])
# def get_near_by_locations_details(request, id, farmer_id, manage_nearby_location_id):
#     # Fetching the Farmer using the provided farmer_id
#     try:
#         farmer = Farmer.objects.get(id=farmer_id, status=0)
#     except Farmer.DoesNotExist:
#         return Response({"detail": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)

#     try:
#         user_language_pref = UserLanguagePreference.objects.get(user=farmer)
#         language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
#     except UserLanguagePreference.DoesNotExist:
#         language_code = 'en'  # Fallback to 'en' if no preference is found
    
#     try:
#         # Fetching the MyLand based on the provided ID and ensuring it belongs to the specified farmer
#         my_land = MyLand.objects.get(id=id, farmer=farmer, status=0)
#     except MyLand.DoesNotExist:
#         return Response({"detail": "MyLand not found for the specified farmer."}, status=status.HTTP_404_NOT_FOUND)

#     try:
#         # Fetching all nearby locations based on the village associated with the MyLand
#         # Filter locations using the given manage_nearby_location_id
#         nearby_location = ManageNearByLocations.objects.get(id=manage_nearby_location_id, village=my_land.village, status=0)
        
#         # Get the category name, or set to 'Unknown' if not available
#         # category_name = nearby_location.category.name if nearby_location.category else 'Unknown'
#         category_name = nearby_location.category.get_translated_value("name", language_code) if language_code == 'ta' else nearby_location.category.name

#         # Prepare the location details
#         location_details = {
#             'id': nearby_location.id,
#             # 'name': nearby_location.name,
#             'name': nearby_location.get_translated_value("name", language_code) if language_code == 'ta' else nearby_location.name,
#             'contact': nearby_location.contact,
#             'address': ', '.join(filter(None, [
#                 nearby_location.door_no,
#                 nearby_location.village.name if nearby_location.village else '',
#                 nearby_location.taluk.name if nearby_location.taluk else '',
#                 nearby_location.city.name if nearby_location.city else '',
#                 nearby_location.state.name if nearby_location.state else '',
#                 nearby_location.country.name if nearby_location.country else ''
#             ])),
#             "images": request.build_absolute_uri(f'/SuperAdmin{nearby_location.img.url}' if nearby_location.img else nearby_location.img.url) if nearby_location.img else "",
#             # 'description': nearby_location.description,
#             'description': nearby_location.get_translated_value("description", language_code) if language_code == 'ta' else nearby_location.description,
#             'openingtime': nearby_location.openingtime,
#             'closingtime': nearby_location.closingtime,
#             # 'days': [day.name for day in nearby_location.days.all()],
#             'days': [get_translated_value(day.name, language_code) if language_code == 'ta' else day.name for day in nearby_location.days.all()],
#             'latitude': nearby_location.latitude,
#             'longitude': nearby_location.longitude,
#             'status': nearby_location.status,
#         }

#         # Returning the location details in the response
#         return Response({
#             'category_name': category_name,
#             'details': location_details,
#             'language': {
#                 'default': 'en'
#             }
#         }, status=status.HTTP_200_OK)
    
#     except ManageNearByLocations.DoesNotExist:
#         return Response({"detail": "Nearby location not found for the specified location."}, status=status.HTTP_404_NOT_FOUND)


@api_view(['GET'])
def get_near_by_locations_details(request, id, farmer_id, manage_nearby_location_id):
    # Fetching the Farmer using the provided farmer_id
    try:
        farmer = Farmer.objects.get(id=farmer_id, status=0)
    except Farmer.DoesNotExist:
        return Response({"detail": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)

    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'  # Fallback to 'en' if no preference is found
    
    try:
        # Fetching the MyLand based on the provided ID and ensuring it belongs to the specified farmer
        my_land = MyLand.objects.get(id=id, farmer=farmer, status=0)
    except MyLand.DoesNotExist:
        return Response({"detail": "MyLand not found for the specified farmer."}, status=status.HTTP_404_NOT_FOUND)

    try:
        # Fetching all nearby locations based on the village associated with the MyLand
        # Filter locations using the given manage_nearby_location_id
        nearby_location = ManageNearByLocations.objects.get(id=manage_nearby_location_id, village=my_land.village, status=0)
        
        # Get the category name, or set to 'Unknown' if not available
        category_name = nearby_location.category.get_translated_value("name", language_code) if language_code == 'ta' else nearby_location.category.name

        # Constructing the address with translation for each part
        address_parts = []

        if nearby_location.door_no:
            address_parts.append(nearby_location.get_translated_value("door_no", language_code) if language_code == 'ta' else str(nearby_location.door_no))

        if nearby_location.village:
            village_name = nearby_location.village.get_translated_value("name", language_code) if language_code == 'ta' else nearby_location.village.name
            address_parts.append(village_name)

        if nearby_location.taluk:
            taluk_name = nearby_location.taluk.get_translated_value("name", language_code) if language_code == 'ta' else nearby_location.taluk.name
            address_parts.append(taluk_name)

        if nearby_location.city:
            city_name = nearby_location.city.get_translated_value("name", language_code) if language_code == 'ta' else nearby_location.city.name
            address_parts.append(city_name)

        if nearby_location.state:
            state_name = nearby_location.state.get_translated_value("name", language_code) if language_code == 'ta' else nearby_location.state.name
            address_parts.append(state_name)

        if nearby_location.country:
            country_name = nearby_location.country.get_translated_value("name", language_code) if language_code == 'ta' else nearby_location.country.name
            address_parts.append(country_name)

        if nearby_location.pincode:
            address_parts.append(str(nearby_location.pincode))

        address = ", ".join(address_parts)

        # Prepare the location details
        location_details = {
            'id': nearby_location.id,
            'name': nearby_location.get_translated_value("name", language_code) if language_code == 'ta' else nearby_location.name,
            'contact': nearby_location.contact,
            'address': address,
            "images": request.build_absolute_uri(f'/SuperAdmin{nearby_location.img.url}' if nearby_location.img else nearby_location.img.url) if nearby_location.img else "",
            'description': nearby_location.get_translated_value("description", language_code) if language_code == 'ta' else nearby_location.description,
            'openingtime': nearby_location.openingtime,
            'closingtime': nearby_location.closingtime,
            'days': [get_translated_value(day.name, language_code) if language_code == 'ta' else day.name for day in nearby_location.days.all()],
            'latitude': nearby_location.latitude,
            'longitude': nearby_location.longitude,
            'status': nearby_location.status,
        }

        # Returning the location details in the response
        return Response({
            'category_name': category_name,
            'details': location_details,
            'language': {
                'default': 'en'
            }
        }, status=status.HTTP_200_OK)

    except ManageNearByLocations.DoesNotExist:
        return Response({"detail": "Nearby location not found for the specified location."}, status=status.HTTP_404_NOT_FOUND)


# @api_view(['GET'])
# def get_near_by_users_workers(request, farmer_id, id):
#     try:
#         user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
#         language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
#     except UserLanguagePreference.DoesNotExist:
#         language_code = 'en'

#     try:
#         # Fetch the MyLand using the provided ID
#         my_land = MyLand.objects.get(id=id, status=0)

#         # Ensure that the MyLand belongs to the provided farmer_id
#         if my_land.farmer.id != farmer_id:
#             return Response({"detail": "This land does not belong to the specified farmer."}, status=status.HTTP_400_BAD_REQUEST)

#     except MyLand.DoesNotExist:
#         return Response({"detail": "MyLand not found."}, status=status.HTTP_404_NOT_FOUND)

#     try:
#         # Fetch users who are associated with this land
#         users = ManageUser.objects.filter(village=my_land.village, usertype=2, status=0)
#         all_user_details = []

#         for user in users:
#             # Get workers associated with each user
#             workers = ManageWorkers.objects.filter(worker=user, status=0)

#             # Calculate the total person count for the workers
#             total_person_count = workers.aggregate(total_persons=Sum('person'))['total_persons'] or 0

#             user_data = {
#                 "id": user.id,
#                 'name': user.get_translated_value("name", language_code) if user.name and language_code == 'ta' else user.name,
#                 'taluk': user.taluk.get_translated_value("name", language_code) if user.taluk and language_code == 'ta' else user.taluk.name,
#                 # 'name': user.name,
#                 # 'taluk': user.taluk.name,
#                 'mobile_no': user.mobile_no,
#                 'status': user.status,
#                 'workers_count': total_person_count,  # Including the total person count as workers_count
#                 'farmer_id': farmer_id,  # Including the farmer_id in the user data
#                 'land_id': my_land.id,  # Including the land ID in the user data
#                 'language': {
#                     'default': 'en'
#                 }
#             }

#             all_user_details.append(user_data)

#     except ManageWorkers.DoesNotExist:
#         all_user_details = []

#     return Response(all_user_details, status=status.HTTP_200_OK)


@api_view(['GET'])
def get_near_by_users_workers(request, farmer_id, id):
    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'

    try:
        my_land = MyLand.objects.get(id=id, status=0)
        if my_land.farmer.id != farmer_id:
            return Response({"detail": "This land does not belong to the specified farmer."}, status=status.HTTP_400_BAD_REQUEST)
    except MyLand.DoesNotExist:
        return Response({"detail": "MyLand not found."}, status=status.HTTP_404_NOT_FOUND)

    users = ManageUser.objects.filter(village=my_land.village, usertype=2, status=0)
    all_user_details = []

    for user in users:
        workers = ManageWorkers.objects.filter(worker=user, status=0)

        total_person_count = workers.aggregate(total_persons=Sum('person'))['total_persons'] or 0

        all_worker_details = []
        for worker in workers:
            work_types = WorkerWorkType.objects.filter(worker=worker)

            work_type_details = []
            for work_type in work_types:
                translated_work_type = (
                    work_type.work_type.get_translated_value("name", language_code)
                    if work_type.work_type and language_code == 'ta'
                    else (work_type.work_type.name if work_type.work_type else None)
                )
                work_type_details.append({
                    'work_type': translated_work_type,
                    'person_count': work_type.person_count
                })

            all_worker_details.append({
                'worker_id': worker.id,
                'worker_name': worker.worker.get_translated_value("name", language_code)
                    if worker.worker and language_code == 'ta'
                    else (worker.worker.name if worker.worker else None),
                'worker_mobile': worker.worker.mobile_no,
                'work_types': work_type_details
            })

        user_data = {
            "id": user.id,
            'name': user.get_translated_value("name", language_code) if user.name and language_code == 'ta' else user.name,
            'taluk': user.taluk.get_translated_value("name", language_code) if user.taluk and language_code == 'ta' else user.taluk.name,
            'mobile_no': user.mobile_no,
            'status': user.status,
            'workers_count': total_person_count,
            'farmer_id': farmer_id,
            'land_id': my_land.id,
            'workers': all_worker_details,  # Include full worker info
            'language': {
                'default': 'en'
            }
        }

        all_user_details.append(user_data)

    return Response(all_user_details, status=status.HTTP_200_OK)


@api_view(['GET'])
def get_near_by_users_workerss(request, farmer_id, id, user_id):
    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'

    try:
        # Fetch the MyLand using the provided ID
        my_land = MyLand.objects.get(id=id, status=0)

        # Ensure that the MyLand belongs to the provided farmer_id
        if my_land.farmer.id != farmer_id:
            return Response({"detail": "This land does not belong to the specified farmer."}, status=status.HTTP_400_BAD_REQUEST)

    except MyLand.DoesNotExist:
        return Response({"detail": "MyLand not found."}, status=status.HTTP_404_NOT_FOUND)

    try:
        # Fetch the user using the provided user_id
        user = ManageUser.objects.get(id=user_id, village=my_land.village, usertype=2, status=0)

        # Fetch workers associated with this user
        workers = ManageWorkers.objects.filter(worker=user, status=0)

        if not workers:
            return Response({"detail": f"No workers found for the user with ID {user_id}."}, status=status.HTTP_404_NOT_FOUND)

        # Get full details for each worker
        all_worker_details = []
        for worker in workers:
            # Fetch associated work types for the worker
            work_types = WorkerWorkType.objects.filter(worker=worker)

            work_type_details = []
            for work_type in work_types:
                work_type_details.append({
                    # 'work_type': work_type.work_type.name,
                    'work_type': work_type.work_type.get_translated_value("name", language_code) if work_type.work_type and language_code == 'ta' else (work_type.work_type.name if work_type.work_type else None),
                    'person_count': work_type.person_count
                })

            # Add worker details including their associated work types
            all_worker_details.append({
                'worker_id': worker.id,
                # 'worker_name': worker.worker.name,
                'worker_name': worker.worker.get_translated_value("name", language_code) if worker.worker and language_code == 'ta' else (worker.worker.name if worker.worker else None),
                'worker_mobile': worker.worker.mobile_no,
                'work_types': work_type_details
            })

        # Calculate the total person count for the workers
        total_person_count = workers.aggregate(total_persons=Sum('person'))['total_persons'] or 0

        user_data = {
            'id': user.id,
            'name': user.get_translated_value("name", language_code) if user.name and language_code == 'ta' else user.name,
            'taluk': user.taluk.get_translated_value("name", language_code) if user.taluk and language_code == 'ta' else user.taluk.name,
            # 'name': user.name,
            # 'taluk': user.taluk.name,
            'mobile_no': user.mobile_no,
            'status': user.status,
            'workers_count': total_person_count,  # Total workers count
            'farmer_id': farmer_id,  # Including the farmer_id in the user data
            'land_id': my_land.id,  # Including the land ID in the user data
            'workers': all_worker_details,  # Including full worker details
            'language': {
                'default': 'en'
            }
        }

        return Response(user_data, status=status.HTTP_200_OK)

    except ManageUser.DoesNotExist:
        return Response({"detail": f"User with ID {user_id} not found."}, status=status.HTTP_404_NOT_FOUND)
    except ManageWorkers.DoesNotExist:
        return Response({"detail": "ManageWorkers not found."}, status=status.HTTP_404_NOT_FOUND)




@api_view(['POST'])
def get_users_workers_details(request, id):
    user_id = request.data.get('id')
    if not user_id:
        return Response({"detail": "User ID is required."}, status=status.HTTP_400_BAD_REQUEST)
    try:
        farmer = Farmer.objects.get(id=id)
    except Farmer.DoesNotExist:
        return Response({"detail": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)
    try:
        workers = WorkerWorkType.objects.filter(worker=user_id)
        worker_details = []
        for worker in workers:
            worker_details.append({
                "work_type": worker.work_type.name,
                "count": worker.person_count,
                "language": {
                    "default": "en"
                }
            })
    except WorkerWorkType.DoesNotExist:
        worker_details = []
    if not worker_details:
        return Response({"detail": "No workers found for this user."}, status=status.HTTP_404_NOT_FOUND)
    return Response(worker_details, status=status.HTTP_200_OK)
 
# @api_view(['GET'])
# def get_near_by_rentals(request, farmer_id, land_id):
    
#     try:
#         # Fetch the Farmer using the provided farmer_id
#         farmer = Farmer.objects.get(id=farmer_id, status=0)
#     except Farmer.DoesNotExist:
#         return Response({"detail": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)

#     rental_data = []

#     try:
#         # Fetch MyLand for the farmer using the provided land_id
#         try:
#             my_land = MyLand.objects.get(id=land_id, farmer=farmer, status=0)
#         except MyLand.DoesNotExist:
#             return Response({"detail": "Land not found for this farmer."}, status=status.HTTP_404_NOT_FOUND)

#         # Now filtering the inventory based on MyLand's village
#         rentals = MyInventory.objects.filter(rental=0, farmer=farmer, status=0)

#         for inventory_item in rentals:
#             rental_count = MyInventory.objects.filter(inventory_items=inventory_item.inventory_items, rental=0, farmer=farmer, status=0).count()

#             rental_details = {
#                 'inventory_item_id': inventory_item.id,
#                 'inventory_item_name': inventory_item.inventory_items.name,
#                 'count': rental_count,
#                 'details': [],
#                 "language": {
#                     "default": "en"
#                 }
#             }

#             if inventory_item.inventory_type.code == 0:  # Vehicle
#                 vehicle_data = MyVehicle.objects.filter(inventory_items=inventory_item.inventory_items, status=0)
#                 rental_details['details'] = [{
#                     "id": vehicle.id,
#                     "vendor_name": vehicle.vendor.name,
#                     "vendor_phone": vehicle.vendor.mobile_no,
#                     "vendor_address": vehicle.vendor.door_no,
#                     "register_number": vehicle.register_number,
#                     "inventory_item_name": vehicle.inventory_items.name,
#                     'image_url': request.build_absolute_uri('/assets/images/sa_login_bg.jpg'),
#                     "language": {
#                         "default": "en"
#                     }
#                 } for vehicle in vehicle_data]

#             elif inventory_item.inventory_type.code == 1:  # Machinery
#                 machinery_data = MyMachinery.objects.filter(inventory_items=inventory_item.inventory_items, status=0)
#                 rental_details['details'] = [{
#                     "id": machinery.id,
#                     "vendor_name": machinery.vendor.name,
#                     "vendor_phone": machinery.vendor.mobile_no,
#                     "vendor_address": machinery.vendor.door_no,
#                     "inventory_item_name": machinery.inventory_items.name,
#                     'image_url': request.build_absolute_uri('/assets/images/sa_login_bg.jpg'),
#                     "language": {
#                         "default": "en"
#                     }
#                 } for machinery in machinery_data]

#             elif inventory_item.inventory_type.code == 2:  # Tools
#                 tools_data = MyTools.objects.filter(inventory_items=inventory_item.inventory_items)
#                 rental_details['details'] = [{
#                     "id": tool.id,
#                     "vendor_name": tool.vendor.name,
#                     "vendor_phone": tool.vendor.mobile_no,
#                     "vendor_address": tool.vendor.door_no,
#                     "inventory_item_name": tool.inventory_items.name,
#                     'image_url': request.build_absolute_uri('/assets/images/sa_login_bg.jpg'),
#                     "language": {
#                         "default": "en"
#                     }
#                 } for tool in tools_data]

#             # Append the rental details to the rental_data
#             rental_data.append(rental_details)

#     except MyInventory.DoesNotExist:
#         rental_data = []

#     return Response(rental_data, status=status.HTTP_200_OK)

@api_view(['GET'])
def get_near_by_rentals(request, farmer_id, land_id):
    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'  # Fallback to 'en' if no preference is found
    try:
        # Fetch the Farmer using the provided farmer_id
        farmer = Farmer.objects.get(id=farmer_id, status=0)
    except Farmer.DoesNotExist:
        return Response({"detail": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)

    rental_data = []

    address_parts = []

    # Adding translated door_no to the address
    address_parts.append(farmer.get_translated_value("door_no", language_code) if farmer.door_no else None)

    # Translate country, state, city, taluk, and village as you were doing before
    if farmer.village:
        village_name = farmer.village.get_translated_value("name", language_code)  # Translate the village name
        address_parts.append(village_name)
    else:
        village_name = None

    if farmer.taluk:
        taluk_name = farmer.taluk.get_translated_value("name", language_code)  # Translate the taluk name
        address_parts.append(taluk_name)
    else:
        taluk_name = None

    if farmer.city:
        city_name = farmer.city.get_translated_value("name", language_code)  # Translate the city name
        address_parts.append(city_name)
    else:
        city_name = None

    if farmer.state:
        state_name = farmer.state.get_translated_value("name", language_code)  # Translate the state name
        address_parts.append(state_name)
    else:
        state_name = None

    if farmer.country:
        country_name = farmer.country.get_translated_value("name", language_code)  # Translate the country name
        address_parts.append(country_name)
    else:
        country_name = None

    # Join the address parts into a single string
    address = ", ".join(address_parts)

    try:
        # Fetch MyLand for the farmer using the provided land_id
        try:
            my_land = MyLand.objects.get(id=land_id, farmer=farmer, status=0)
        except MyLand.DoesNotExist:
            return Response({"detail": "Land not found for this farmer."}, status=status.HTTP_404_NOT_FOUND)

        # Now filtering the inventory based on MyLand's village
        rentals = MyInventory.objects.filter(rental=0, farmer=farmer, status=0)

        for inventory_item in rentals:
            rental_count = MyInventory.objects.filter(inventory_items=inventory_item.inventory_items, rental=0, farmer=farmer, status=0).count()

            rental_details = {
                'inventory_item_id': inventory_item.id,
                'inventory_item_name': inventory_item.inventory_items.get_translated_value("name", language_code) if inventory_item.inventory_items and language_code == 'ta' else (inventory_item.inventory_items.name if inventory_item.inventory_items else None),
                'count': rental_count,
                'details': [],
                "language": {
                    "default": "en"
                }
            }

            if inventory_item.inventory_type.code == 0:  # Vehicle
                vehicle_data = MyVehicle.objects.filter(inventory_items=inventory_item.inventory_items, status=0)
                rental_details['details'] = [{
                    "id": vehicle.id,
                    'vendor_name': vehicle.vendor.get_translated_value("name", language_code) if vehicle.vendor and language_code == 'ta' else (vehicle.vendor.name if vehicle.vendor else None),
                    "vendor_phone": vehicle.vendor.mobile_no,
                    'vendor_address': address,
                    "register_number": vehicle.register_number,
                    'inventory_item_name': vehicle.inventory_items.get_translated_value("name", language_code) if vehicle.inventory_items and language_code == 'ta' else (vehicle.inventory_items.name if vehicle.inventory_items else None),
                    "language": {
                        "default": "en"
                    }
                } for vehicle in vehicle_data]

            elif inventory_item.inventory_type.code == 1:  # Machinery
                machinery_data = MyMachinery.objects.filter(inventory_items=inventory_item.inventory_items, status=0)
                rental_details['details'] = [{
                    "id": machinery.id,
                    'vendor_name': machinery.vendor.get_translated_value("name", language_code) if machinery.vendor and language_code == 'ta' else (machinery.vendor.name if machinery.vendor else None),
                    "vendor_phone": machinery.vendor.mobile_no,
                    'vendor_address': address,
                    'inventory_item_name': machinery.inventory_items.get_translated_value("name", language_code) if machinery.inventory_items and language_code == 'ta' else (machinery.inventory_items.name if machinery.inventory_items else None),
                    "language": {
                        "default": "en"
                    }
                } for machinery in machinery_data]

            elif inventory_item.inventory_type.code == 2:  # Tools
                tools_data = MyTools.objects.filter(inventory_items=inventory_item.inventory_items)
                rental_details['details'] = [{
                    "id": tool.id,
                    'vendor_name': tool.vendor.get_translated_value("name", language_code) if tool.vendor and language_code == 'ta' else (tool.vendor.name if tool.vendor else None),
                    "vendor_phone": tool.vendor.mobile_no,
                    'vendor_address': address,
                    'inventory_item_name': tool.inventory_items.get_translated_value("name", language_code) if tool.inventory_items and language_code == 'ta' else (tool.inventory_items.name if tool.inventory_items else None),
                    "language": {
                        "default": "en"
                    }
                } for tool in tools_data]

            # Append the rental details to the rental_data
            rental_data.append(rental_details)

    except MyInventory.DoesNotExist:
        rental_data = []

    return Response(rental_data, status=status.HTTP_200_OK)



@api_view(['GET'])
def get_near_by_rentals_details(request, farmer_id, land_id, inventory_item_id):
    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'  # Fallback to 'en' if no preference is found
    try:
        # Fetch the Farmer using the provided farmer_id
        farmer = Farmer.objects.get(id=farmer_id, status=0)
    except Farmer.DoesNotExist:
        return Response({"detail": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)

    rental_data = []
    address_parts = []

    # Adding translated door_no to the address
    address_parts.append(farmer.get_translated_value("door_no", language_code) if farmer.door_no else None)

    # Translate country, state, city, taluk, and village as you were doing before
    if farmer.village:
        village_name = farmer.village.get_translated_value("name", language_code)  # Translate the village name
        address_parts.append(village_name)
    else:
        village_name = None

    if farmer.taluk:
        taluk_name = farmer.taluk.get_translated_value("name", language_code)  # Translate the taluk name
        address_parts.append(taluk_name)
    else:
        taluk_name = None

    if farmer.city:
        city_name = farmer.city.get_translated_value("name", language_code)  # Translate the city name
        address_parts.append(city_name)
    else:
        city_name = None

    if farmer.state:
        state_name = farmer.state.get_translated_value("name", language_code)  # Translate the state name
        address_parts.append(state_name)
    else:
        state_name = None

    if farmer.country:
        country_name = farmer.country.get_translated_value("name", language_code)  # Translate the country name
        address_parts.append(country_name)
    else:
        country_name = None

    # Join the address parts into a single string
    address = ", ".join(address_parts)
    try:
        # Fetch MyLand for the farmer using the provided land_id
        try:
            my_land = MyLand.objects.get(id=land_id, farmer=farmer, status=0)
        except MyLand.DoesNotExist:
            return Response({"detail": "Land not found for this farmer."}, status=status.HTTP_404_NOT_FOUND)

        # Now filtering the inventory based on the inventory_item_id and the farmer
        try:
            inventory_item = MyInventory.objects.get(id=inventory_item_id, farmer=farmer, status=0)
        except MyInventory.DoesNotExist:
            return Response({"detail": "Inventory item not found."}, status=status.HTTP_404_NOT_FOUND)

        rental_count = MyInventory.objects.filter(inventory_items=inventory_item.inventory_items, rental=0, farmer=farmer, status=0).count()

        rental_details = {
            'inventory_item_id': inventory_item.id,
            'inventory_item_name': inventory_item.inventory_items.get_translated_value("name", language_code) if inventory_item.inventory_items and language_code == 'ta' else (inventory_item.inventory_items.name if inventory_item.inventory_items else None),
            'inventory_item_description': inventory_item.inventory_items.get_translated_value("description", language_code) if inventory_item.inventory_items and language_code == 'ta' else (inventory_item.inventory_items.description if inventory_item.inventory_items else None),  # Add description if needed
            'inventory_item_code': inventory_item.inventory_items.code,  # Add any other field you need
            'count': rental_count,
            'details': [],
            "language": {
                "default": "en"
            }
        }

        if inventory_item.inventory_type.code == 0:  # Vehicle
            vehicle_data = MyVehicle.objects.filter(inventory_items=inventory_item.inventory_items, status=0)
            rental_details['details'] = [{
                "id": vehicle.id,
                'vendor_name': vehicle.vendor.get_translated_value("name", language_code) if vehicle.vendor and language_code == 'ta' else (vehicle.vendor.name if vehicle.vendor else None),
                "vendor_phone": vehicle.vendor.mobile_no,
                'vendor_address': address,
                "register_number": vehicle.register_number,
                'inventory_item_name': vehicle.inventory_items.get_translated_value("name", language_code) if vehicle.inventory_items and language_code == 'ta' else (vehicle.inventory_items.name if vehicle.inventory_items else None),
                "language": {
                    "default": "en"
                }
            } for vehicle in vehicle_data]

        elif inventory_item.inventory_type.code == 1:  # Machinery
            machinery_data = MyMachinery.objects.filter(inventory_items=inventory_item.inventory_items, status=0)
            rental_details['details'] = [{
                "id": machinery.id,
                'vendor_name': machinery.vendor.get_translated_value("name", language_code) if machinery.vendor and language_code == 'ta' else (machinery.vendor.name if machinery.vendor else None),
                "vendor_phone": machinery.vendor.mobile_no,
                'vendor_address': address,
                'inventory_item_name': machinery.inventory_items.get_translated_value("name", language_code) if machinery.inventory_items and language_code == 'ta' else (machinery.inventory_items.name if machinery.inventory_items else None),
                "language": {
                    "default": "en"
                }
            } for machinery in machinery_data]

        elif inventory_item.inventory_type.code == 2:  # Tools
            tools_data = MyTools.objects.filter(inventory_items=inventory_item.inventory_items)
            rental_details['details'] = [{
                "id": tool.id,
                'vendor_name': tool.vendor.get_translated_value("name", language_code) if tool.vendor and language_code == 'ta' else (tool.vendor.name if tool.vendor else None),
                "vendor_phone": tool.vendor.mobile_no,
                'vendor_address': address,
                'inventory_item_name': tool.inventory_items.get_translated_value("name", language_code) if tool.inventory_items and language_code == 'ta' else (tool.inventory_items.name if tool.inventory_items else None),
                "language": {
                    "default": "en"
                }
            } for tool in tools_data]

        rental_data.append(rental_details)

    except MyInventory.DoesNotExist:
        rental_data = []

    return Response(rental_data, status=status.HTTP_200_OK)



# @api_view(['GET'])
# def get_near_by_rentals_details(request, farmer_id, land_id, inventory_item_id):
#     try:
#         # Fetch the Farmer using the provided farmer_id
#         farmer = Farmer.objects.get(id=farmer_id, status=0)
#     except Farmer.DoesNotExist:
#         return Response({"detail": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)

#     rental_data = []

#     try:
#         # Fetch MyLand for the farmer using the provided land_id
#         try:
#             my_land = MyLand.objects.get(id=land_id, farmer=farmer, status=0)
#         except MyLand.DoesNotExist:
#             return Response({"detail": "Land not found for this farmer."}, status=status.HTTP_404_NOT_FOUND)

#         # Now filtering the inventory based on the inventory_item_id and the farmer
#         try:
#             inventory_item = MyInventory.objects.get(id=inventory_item_id, farmer=farmer, status=0)
#         except MyInventory.DoesNotExist:
#             return Response({"detail": "Inventory item not found."}, status=status.HTTP_404_NOT_FOUND)

#         rental_count = MyInventory.objects.filter(inventory_items=inventory_item.inventory_items, rental=0, farmer=farmer, status=0).count()

#         rental_details = {
#             'inventory_item_id': inventory_item.id,
#             'inventory_item_name': inventory_item.inventory_items.name,
#             'inventory_item_description': inventory_item.inventory_items.description,  # Add description if needed
#             'inventory_item_code': inventory_item.inventory_items.code,  # Add any other field you need
            
#             'count': rental_count,
#             'details': [],
#             "language": {
#                 "default": "en"
#             }
#         }

#         if inventory_item.inventory_type.code == 0:  # Vehicle
#             vehicle_data = MyVehicle.objects.filter(inventory_items=inventory_item.inventory_items, status=0)
#             rental_details['details'] = [{
#                 "id": vehicle.id,
#                 "vendor_name": vehicle.vendor.name,
#                 "vendor_phone": vehicle.vendor.mobile_no,
#                 "vendor_address": vehicle.vendor.door_no,
#                 "register_number": vehicle.register_number,
#                 "inventory_item_name": vehicle.inventory_items.name,
#                 'image_url': request.build_absolute_uri('/assets/images/sa_login_bg.jpg'),
#                 "language": {
#                     "default": "en"
#                 }
#             } for vehicle in vehicle_data]

#         elif inventory_item.inventory_type.code == 1:  # Machinery
#             machinery_data = MyMachinery.objects.filter(inventory_items=inventory_item.inventory_items, status=0)
#             rental_details['details'] = [{
#                 "id": machinery.id,
#                 "vendor_name": machinery.vendor.name,
#                 "vendor_phone": machinery.vendor.mobile_no,
#                 "vendor_address": machinery.vendor.door_no,
#                 "inventory_item_name": machinery.inventory_items.name,
#                 'image_url': request.build_absolute_uri('/assets/images/sa_login_bg.jpg'),
#                 "language": {
#                     "default": "en"
#                 }
#             } for machinery in machinery_data]

#         elif inventory_item.inventory_type.code == 2:  # Tools
#             tools_data = MyTools.objects.filter(inventory_items=inventory_item.inventory_items)
#             rental_details['details'] = [{
#                 "id": tool.id,
#                 "vendor_name": tool.vendor.name,
#                 "vendor_phone": tool.vendor.mobile_no,
#                 "vendor_address": tool.vendor.door_no,
#                 "inventory_item_name": tool.inventory_items.name,
#                 'image_url': request.build_absolute_uri('/assets/images/sa_login_bg.jpg'),
#                 "language": {
#                     "default": "en"
#                 }
#             } for tool in tools_data]

#         rental_data.append(rental_details)

#     except MyInventory.DoesNotExist:
#         rental_data = []

#     return Response(rental_data, status=status.HTTP_200_OK)

def validate_image_type(base64_string):
    mime_type = base64_string.split(';')[0].split(':')[1]  # Extract MIME type
    if mime_type not in ['image/jpeg', 'image/png','image/heic']:
        raise ValueError("Invalid file type for image. Only JPEG and PNG are allowed.")
    return mime_type
 
# @api_view(['POST'])
# def manage_my_land(request):
#     # Extract data from request
#     farmer = request.data.get('farmer')
#     name = request.data.get('name')
#     measurement_value = request.data.get('measurement_value')
#     measurement_unit = request.data.get('measurement_unit')
#     soil_type = request.data.get('soil_type')
#     country = request.data.get('country')
#     state = request.data.get('state')
#     city = request.data.get('city')
#     taluk = request.data.get('taluk')
#     village = request.data.get('village')
#     door_no = request.data.get('door_no')   
#     locations = request.data.get('locations')
#     latitude = request.data.get('latitude')
#     longitude = request.data.get('longitude')
#     patta_number = request.data.get('patta_number')
#     description = request.data.get('description')

#     # Validation errors
#     errors = {}

#     # Required Fields Validation
#     if not name:
#         errors['name'] = 'This field is required.'
#     if not measurement_value:
#         errors['measurement_value'] = 'This field is required.'
#     if not measurement_unit:
#         errors['measurement_unit'] = 'This field is required.'
#     if latitude is None:
#         errors['latitude'] = 'This field is required.'
#     if longitude is None:
#         errors['longitude'] = 'This field is required.'

#     if errors:
#         return Response({'errors': errors}, status=status.HTTP_400_BAD_REQUEST)

#     # Get related objects
#     farmer_obj = Farmer.objects.get(id=farmer) if farmer else None
#     measurement_unit_obj = LandUnit.objects.get(id=measurement_unit) if measurement_unit else None
#     soil_type_obj = SoilType.objects.get(id=soil_type) if soil_type else None

#     # Check the farmer's subscription status
#     if farmer_obj.status == 4:
#         return Response({'error': 'Farmer is expired.'}, status=status.HTTP_400_BAD_REQUEST)
#     if farmer_obj.status == 6:
#         return Response({'error': 'Farmer is unsubscribed.'}, status=status.HTTP_400_BAD_REQUEST)
 
#     subscription = AddSubcription.objects.filter(farmers=farmer_obj, status=0).first()  
#     if subscription:
#         myland_limit = subscription.packages.myland_count 
#         current_myland_count = MyLand.objects.filter(Q(status=0) | Q(status=1), farmer=farmer_obj).count()

#         if current_myland_count >= myland_limit:
#             errors['myland_limit'] = f"You have already reached the maximum land limit of {myland_limit} for your package."
#             return Response({'errors': errors}, status=status.HTTP_400_BAD_REQUEST)

#     # If country, state, city, taluk, and village are not provided, use farmer's details
#     country_obj = Country.objects.get(id=country) if country else farmer_obj.country
#     state_obj = State.objects.get(id=state) if state else farmer_obj.state
#     city_obj = City.objects.get(id=city) if city else farmer_obj.city
#     taluk_obj = Taluk.objects.get(id=taluk) if taluk else farmer_obj.taluk
#     village_obj = Village.objects.get(id=village) if village else farmer_obj.village

#     # If door_no is not provided, use the farmer's door_no
#     door_no = door_no or farmer_obj.door_no

#     # Create MyLand instance
#     my_land = MyLand.objects.create(
#         farmer=farmer_obj,
#         name=name,
#         measurement_value=measurement_value,
#         measurement_unit=measurement_unit_obj,
#         soil_type=soil_type_obj,
#         country=country_obj,
#         state=state_obj,
#         city=city_obj,
#         taluk=taluk_obj,
#         village=village_obj,
#         door_no=door_no,  # Door number added
#         locations=locations,
#         latitude=latitude,
#         longitude=longitude,
#         patta_number=patta_number,
#         description=description,
#         created_at=timezone.now(),
#         # updated_at=timezone.now(),
#         created_by=farmer_obj.farmer_user if farmer_obj.farmer_user else farmer_obj.sub_admin_user,
#     )

#     # Create notification for the farmer
#     notification_message = f"New land added: {name} at {village_obj.name if village_obj else ''}."
#     FarmerNotification.objects.create(
#         farmer=farmer_obj,
#         name="Land Added",
#         type="Land Management",
#         message=notification_message,
#         is_read=False  # notification is unread by default
#     )

#     # Handling survey details (optional)
#     survey_details = []
#     for key in request.data.keys():
#         if key.startswith('survey_details'):
#             survey_value = request.data.get(key)

#             if survey_value:
#                 survey_data = survey_value.split(',')
#                 survey_dict = {}
#                 for item in survey_data:
#                     key_value = item.split(':')
#                     if len(key_value) == 2:
#                         survey_dict[key_value[0].strip()] = key_value[1].strip()
#                 survey_details.append(survey_dict)
#             else:
#                 errors[key] = f"{key} is empty or invalid"

#     # Handling document details (optional)
#     documents_data = request.data.get('document', [])
#     document_details = []

#     # Process each file type and its corresponding documents
#     for doc_data in documents_data:
#         file_type_id = doc_data.get('file_type')
#         documents = doc_data.get('documents', [])

#         # Check if file_type_id is None and create new file type if necessary
#         if file_type_id is None:
#             new_file_type = doc_data.get('new_file_type')  # Assuming you send new file types like "new_file_type_0"
#             if not new_file_type:
#                 return Response({"error": f"New file type for document is required."}, status=status.HTTP_400_BAD_REQUEST)

#             # Check if the file type already exists
#             file_type, created = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=0)

#             if created:
#                 print(f"New file type created: {file_type.name}")
#             else:
#                 print(f"File type '{new_file_type}' already exists. Using the existing one.")
#         else:
#             # Fetch the existing file type
#             file_type = get_object_or_404(DocumentCategory, id=file_type_id)

#         # Loop through the provided documents to create document entries
#         for document_base64 in documents:
#             try:
#                 if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
#                     # Validate MIME type for images or PDF
#                     mime_type = validate_image_type(document_base64)  # This should validate the MIME type
#                     if mime_type:
#                         # Extract the base64 data (remove the prefix)
#                         document_data = document_base64.split(';base64,')[1]

#                         # Decode the base64 data to bytes
#                         document_bytes = base64.b64decode(document_data)

#                         # Create a file name
#                         document_name = f"document_{timezone.now().strftime('%Y%m%d%H%M%S')}.{mime_type.split('/')[1]}"

#                         # Create the document file (ContentFile)
#                         document_file = ContentFile(document_bytes, name=document_name)

#                         # Create the document instance in the database
#                         document_instance = MyLandDocument.objects.create(
#                             farmer=farmer_obj,
#                             myland=my_land,
#                             document_category=file_type,  # Use the file_type from DocumentCategory
#                             upload_document=document_file,
#                             created_at=timezone.now(),
#                             created_by=farmer_obj.farmer_user
#                         )

#                         # Collect document details for the response
#                         document_details.append({
#                             'id': document_instance.id,
#                             'document_name': request.build_absolute_uri(f'/SuperAdmin{document_instance.upload_document.url}' if document_instance.upload_document else ""),
#                             'file_type': document_instance.document_category.name,
#                             'created_at': document_instance.created_at,
#                         })
#                     else:
#                         # If MIME type is invalid
#                         errors['documents'] = "Invalid MIME type for the document."
#                         return Response({'errors': errors}, status=status.HTTP_400_BAD_REQUEST)
#             except Exception as e:
#                 errors['document_processing'] = f"Error processing document: {str(e)}"
#                 return Response({'errors': errors}, status=status.HTTP_400_BAD_REQUEST)

#     # Survey details handling
#     survey_response = []
#     for survey in survey_details:
#         survey_no = survey.get('survey_no')
#         survey_measurement_value = survey.get('survey_measurement_value')
#         survey_measurement_unit_id = survey.get('survey_measurement_unit_id')
#         survey_measurement_unit = LandUnit.objects.get(id=survey_measurement_unit_id) if survey_measurement_unit_id else None

#         survey_instance = MyLandSurveyDetails.objects.create(
#             farmer=farmer_obj,
#             MyLand=my_land,
#             survey_no=survey_no,
#             survey_measurement_value=survey_measurement_value,
#             survey_measurement_unit=survey_measurement_unit,
#             created_at=timezone.now(),
#             updated_at=timezone.now(),
#         )

#         survey_response.append({
#             'id': survey_instance.id,
#             'survey_no': survey_instance.survey_no,
#             'survey_measurement_value': survey_instance.survey_measurement_value,
#             'survey_measurement_unit': survey_instance.survey_measurement_unit.name if survey_instance.survey_measurement_unit else None,
#             'language': {
#                 "default": "en"
#             }
#         })

#     # Return response with details
#     return Response({
#         'message': 'MyLand and Documents created successfully!',
#         'my_land': {
#             'id': my_land.id,
#             'name': my_land.name,
#             'measurement_value': my_land.measurement_value,
#             'measurement_unit': my_land.measurement_unit.name if my_land.measurement_unit else None,
#             'soil_type': my_land.soil_type.name if my_land.soil_type else None,
#             'country': my_land.country.name if my_land.country else None,
#             'state': my_land.state.name if my_land.state else None,
#             'city': my_land.city.name if my_land.city else None,
#             'taluk': my_land.taluk.name if my_land.taluk else None,
#             'village': my_land.village.name if my_land.village else None,
#             'door_no': my_land.door_no,  # Door number in the response
#             'locations': my_land.locations,
#             'latitude': my_land.latitude,
#             'longitude': my_land.longitude,
#             'patta_number': my_land.patta_number,
#             'description': my_land.description,
#         },
#         'survey_details': survey_response, 
#         'documents': document_details,
#     }, status=status.HTTP_201_CREATED)

# @api_view(['POST'])
# def manage_my_land(request):
#     # Extract data from request
#     farmer = request.data.get('farmer')
#     name = request.data.get('name')
#     measurement_value = request.data.get('measurement_value')
#     measurement_unit = request.data.get('measurement_unit')
#     soil_type = request.data.get('soil_type')
#     country = request.data.get('country')
#     state = request.data.get('state')
#     city = request.data.get('city')
#     taluk = request.data.get('taluk')
#     village = request.data.get('village')
#     door_no = request.data.get('door_no')   
#     locations = request.data.get('locations')
#     latitude = request.data.get('latitude')
#     longitude = request.data.get('longitude')
#     patta_number = request.data.get('patta_number')
#     description = request.data.get('description')
#     geo_marks = request.data.get('geo_marks', None)

#     # --- Handle country_name ---
#     country_name = request.data.get('country_name')
#     if country_name and country_name.strip():
#         country_obj, created = Country.objects.get_or_create(name=country_name.strip())
#         country = country_obj.id

#     # --- Handle state_name ---
#     state_name = request.data.get('state_name')
#     if state_name and state_name.strip():
#         country_id_for_state = country if country else None
#         state_obj, created = State.objects.get_or_create(name=state_name.strip(), country_id=country_id_for_state)
#         state = state_obj.id

#     # --- Handle city_name ---
#     city_name = request.data.get('city_name')
#     if city_name and city_name.strip():
#         state_id_for_city = state if state else None
#         country_id_for_city = country if country else None
#         city_obj, created = City.objects.get_or_create(name=city_name.strip(), state_id=state_id_for_city, country_id=country_id_for_city)
#         city = city_obj.id

#     # --- Handle taluk_name ---
#     taluk_name = request.data.get('taluk_name')
#     if taluk_name and taluk_name.strip():
#         city_id_for_taluk = city if city else None
#         state_id_for_taluk = state if state else None
#         country_id_for_taluk = country if country else None
#         taluk_obj, created = Taluk.objects.get_or_create(name=taluk_name.strip(), city_id=city_id_for_taluk,state_id=state_id_for_taluk,
#             country_id=country_id_for_taluk)
#         taluk = taluk_obj.id

#     # --- Handle village_name ---
#     village_name = request.data.get('village_name')
#     if village_name and village_name.strip():
#         taluk_id_for_village = taluk if taluk else None
#         city_id_for_village = city if city else None
#         state_id_for_village = state if state else None
#         country_id_for_village = country if country else None

#         # Adjust the Village get_or_create fields according to your model fields
#         village_obj, created = Village.objects.get_or_create(
#             name=village_name.strip(),
#             taluk_id=taluk_id_for_village,
#             city_id=city_id_for_village,
#             state_id=state_id_for_village,
#             country_id=country_id_for_village,
#         )
#         village = village_obj.id

#     # Validation errors
#     errors = {}

#     # Required Fields Validation
#     if not name:
#         errors['name'] = 'This field is required.'
#     if not measurement_value:
#         errors['measurement_value'] = 'This field is required.'
#     if not measurement_unit:
#         errors['measurement_unit'] = 'This field is required.'
#     if latitude is None:
#         errors['latitude'] = 'This field is required.'
#     if longitude is None:
#         errors['longitude'] = 'This field is required.'

#     if errors:
#         return Response({'errors': errors}, status=status.HTTP_400_BAD_REQUEST)

#     # Get related objects
#     farmer_obj = Farmer.objects.get(id=farmer) if farmer else None
#     measurement_unit_obj = LandUnit.objects.get(id=measurement_unit) if measurement_unit else None
#     soil_type_obj = SoilType.objects.get(id=soil_type) if soil_type else None

#     # Check the farmer's subscription status
#     if farmer_obj.status == 4:
#         return Response({'error': 'Farmer is expired.'}, status=status.HTTP_400_BAD_REQUEST)
#     if farmer_obj.status == 6:
#         return Response({'error': 'Farmer is unsubscribed.'}, status=status.HTTP_400_BAD_REQUEST)
 
#     subscription = AddSubcription.objects.filter(farmers=farmer_obj, status=0).first()  
#     if subscription:
#         myland_limit = subscription.packages.myland_count 
#         current_myland_count = MyLand.objects.filter(Q(status=0) | Q(status=1), farmer=farmer_obj).count()

#         if current_myland_count >= myland_limit:
#             errors['myland_limit'] = f"You have already reached the maximum land limit of {myland_limit} for your package."
#             return Response({'errors': errors}, status=status.HTTP_400_BAD_REQUEST)

#     # If country, state, city, taluk, and village are not provided, use farmer's details
#     country_obj = Country.objects.get(id=country) if country else farmer_obj.country
#     state_obj = State.objects.get(id=state) if state else farmer_obj.state
#     city_obj = City.objects.get(id=city) if city else farmer_obj.city
#     taluk_obj = Taluk.objects.get(id=taluk) if taluk else farmer_obj.taluk
#     village_obj = Village.objects.get(id=village) if village else farmer_obj.village

#     # If door_no is not provided, use the farmer's door_no
#     door_no = door_no or farmer_obj.door_no

#     # Create MyLand instance
#     my_land = MyLand.objects.create(
#         farmer=farmer_obj,
#         name=name,
#         measurement_value=measurement_value,
#         measurement_unit=measurement_unit_obj,
#         soil_type=soil_type_obj,
#         country=country_obj,
#         state=state_obj,
#         city=city_obj,
#         taluk=taluk_obj,
#         village=village_obj,
#         door_no=door_no,
#         locations=locations,
#         latitude=latitude,
#         longitude=longitude,
#         patta_number=patta_number,
#         description=description,
#         geo_marks=geo_marks,
#         created_at=timezone.now(),
#         created_by=farmer_obj.farmer_user if farmer_obj.farmer_user else farmer_obj.sub_admin_user,
#     )

#     # Create notification for the farmer
#     notification_message = f"New land added: {name} at {village_obj.name if village_obj else ''}."
#     FarmerNotification.objects.create(
#         farmer=farmer_obj,
#         name="Land Added",
#         type="Land Management",
#         message=notification_message,
#         is_read=False
#     )

#     # Handling survey details (optional)
#     survey_details = []
#     for key in request.data.keys():
#         if key.startswith('survey_details'):
#             survey_value = request.data.get(key)

#             if survey_value:
#                 survey_data = survey_value.split(',')
#                 survey_dict = {}
#                 for item in survey_data:
#                     key_value = item.split(':')
#                     if len(key_value) == 2:
#                         survey_dict[key_value[0].strip()] = key_value[1].strip()
#                 survey_details.append(survey_dict)
#             else:
#                 errors[key] = f"{key} is empty or invalid"

#     # Handling document details (optional)
#     documents_data = request.data.get('document', [])
#     document_details = []

#     for doc_data in documents_data:
#         file_type_id = doc_data.get('file_type')
#         documents = doc_data.get('documents', [])

#         if file_type_id is None:
#             new_file_type = doc_data.get('new_file_type')
#             if not new_file_type:
#                 return Response({"error": f"New file type for document is required."}, status=status.HTTP_400_BAD_REQUEST)

#             file_type, created = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=0)

#         else:
#             file_type = get_object_or_404(DocumentCategory, id=file_type_id)

#         for document_base64 in documents:
#             try:
#                 if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
#                     mime_type = validate_image_type(document_base64)
#                     if mime_type:
#                         document_data = document_base64.split(';base64,')[1]
#                         document_bytes = base64.b64decode(document_data)
#                         document_name = f"document_{timezone.now().strftime('%Y%m%d%H%M%S')}.{mime_type.split('/')[1]}"
#                         document_file = ContentFile(document_bytes, name=document_name)

#                         document_instance = MyLandDocument.objects.create(
#                             farmer=farmer_obj,
#                             myland=my_land,
#                             document_category=file_type,
#                             upload_document=document_file,
#                             created_at=timezone.now(),
#                             created_by=farmer_obj.farmer_user
#                         )

#                         document_details.append({
#                             'id': document_instance.id,
#                             'document_name': request.build_absolute_uri(f'/SuperAdmin{document_instance.upload_document.url}' if document_instance.upload_document else ""),
#                             'file_type': document_instance.document_category.name,
#                             'created_at': document_instance.created_at,
#                         })
#                     else:
#                         errors['documents'] = "Invalid MIME type for the document."
#                         return Response({'errors': errors}, status=status.HTTP_400_BAD_REQUEST)
#             except Exception as e:
#                 errors['document_processing'] = f"Error processing document: {str(e)}"
#                 return Response({'errors': errors}, status=status.HTTP_400_BAD_REQUEST)

#     # Survey details handling
#     survey_response = []
#     for survey in survey_details:
#         survey_no = survey.get('survey_no')
#         survey_measurement_value = survey.get('survey_measurement_value')
#         survey_measurement_unit_id = survey.get('survey_measurement_unit_id')
#         survey_measurement_unit = LandUnit.objects.get(id=survey_measurement_unit_id) if survey_measurement_unit_id else None

#         survey_instance = MyLandSurveyDetails.objects.create(
#             farmer=farmer_obj,
#             MyLand=my_land,
#             survey_no=survey_no,
#             survey_measurement_value=survey_measurement_value,
#             survey_measurement_unit=survey_measurement_unit,
#             created_at=timezone.now(),
#             updated_at=timezone.now(),
#         )

#         survey_response.append({
#             'id': survey_instance.id,
#             'survey_no': survey_instance.survey_no,
#             'survey_measurement_value': survey_instance.survey_measurement_value,
#             'survey_measurement_unit': survey_instance.survey_measurement_unit.name if survey_instance.survey_measurement_unit else None,
#             'language': {
#                 "default": "en"
#             }
#         })

#     # Return response with details
#     return Response({
#         'message': 'MyLand and Documents created successfully!',
#         'my_land': {
#             'id': my_land.id,
#             'name': my_land.name,
#             'measurement_value': my_land.measurement_value,
#             'measurement_unit': my_land.measurement_unit.name if my_land.measurement_unit else None,
#             'soil_type': my_land.soil_type.name if my_land.soil_type else None,
#             'country': my_land.country.name if my_land.country else None,
#             'state': my_land.state.name if my_land.state else None,
#             'city': my_land.city.name if my_land.city else None,
#             'taluk': my_land.taluk.name if my_land.taluk else None,
#             'village': my_land.village.name if my_land.village else None,
#             'door_no': my_land.door_no,
#             'locations': my_land.locations,
#             'latitude': my_land.latitude,
#             'longitude': my_land.longitude,
#             'patta_number': my_land.patta_number,
#             'description': my_land.description,
#             'geo_marks': my_land.geo_marks,
#         },
#         'survey_details': survey_response, 
#         'documents': document_details,
#     }, status=status.HTTP_201_CREATED)



 

# @api_view(['POST'])
# def manage_my_land(request):
#     # Extract data from request
#     farmer = request.data.get('farmer')
#     name = request.data.get('name')
#     measurement_value = request.data.get('measurement_value')
#     measurement_unit = request.data.get('measurement_unit')
#     soil_type = request.data.get('soil_type')
#     country = request.data.get('country')
#     state = request.data.get('state')
#     city = request.data.get('city')
#     taluk = request.data.get('taluk')
#     village = request.data.get('village')
#     door_no = request.data.get('door_no')   
#     locations = request.data.get('locations')
#     latitude = request.data.get('latitude')
#     longitude = request.data.get('longitude')
#     patta_number = request.data.get('patta_number')
#     description = request.data.get('description')
#     geo_marks = request.data.get('geo_marks', None)

#     # --- Handle country_name ---
#     country_name = request.data.get('country_name')
#     if country_name and country_name.strip():
#         country_obj, created = Country.objects.get_or_create(name=country_name.strip())
#         country = country_obj.id

#     # --- Handle state_name ---
#     state_name = request.data.get('state_name')
#     if state_name and state_name.strip():
#         country_id_for_state = country if country else None
#         state_obj, created = State.objects.get_or_create(name=state_name.strip(), country_id=country_id_for_state)
#         state = state_obj.id

#     # --- Handle city_name ---
#     city_name = request.data.get('city_name')
#     if city_name and city_name.strip():
#         state_id_for_city = state if state else None
#         country_id_for_city = country if country else None
#         city_obj, created = City.objects.get_or_create(name=city_name.strip(), state_id=state_id_for_city, country_id=country_id_for_city)
#         city = city_obj.id

#     # --- Handle taluk_name ---
#     taluk_name = request.data.get('taluk_name')
#     if taluk_name and taluk_name.strip():
#         city_id_for_taluk = city if city else None
#         state_id_for_taluk = state if state else None
#         country_id_for_taluk = country if country else None
#         taluk_obj, created = Taluk.objects.get_or_create(name=taluk_name.strip(), city_id=city_id_for_taluk,state_id=state_id_for_taluk,
#             country_id=country_id_for_taluk)
#         taluk = taluk_obj.id

#     # --- Handle village_name ---
#     village_name = request.data.get('village_name')
#     if village_name and village_name.strip():
#         taluk_id_for_village = taluk if taluk else None
#         city_id_for_village = city if city else None
#         state_id_for_village = state if state else None
#         country_id_for_village = country if country else None

#         village_obj, created = Village.objects.get_or_create(
#             name=village_name.strip(),
#             taluk_id=taluk_id_for_village,
#             city_id=city_id_for_village,
#             state_id=state_id_for_village,
#             country_id=country_id_for_village,
#         )
#         village = village_obj.id

#     # Validation errors
#     errors = {}

#     # Required Fields Validation
#     if not name:
#         errors['name'] = 'This field is required.'
#     if not measurement_value:
#         errors['measurement_value'] = 'This field is required.'
#     if not measurement_unit:
#         errors['measurement_unit'] = 'This field is required.'
#     if latitude is None:
#         errors['latitude'] = 'This field is required.'
#     if longitude is None:
#         errors['longitude'] = 'This field is required.'

#     # geo_marks format validation
#     if geo_marks:
#         if not isinstance(geo_marks, list):
#             errors['geo_marks'] = 'geo_marks must be a list of coordinates.'
#         else:
#             for idx, point in enumerate(geo_marks):
#                 if not isinstance(point, dict) or 'lat' not in point or 'lng' not in point:
#                     errors['geo_marks'] = (
#                         "Each geo_mark must be an object with 'lat' and 'lng' keys. "
#                         f"Invalid entry at index {idx}: {point}"
#                     )
#                     break

#     if errors:
#         return Response({'errors': errors}, status=status.HTTP_400_BAD_REQUEST)

#     # Get related objects
#     farmer_obj = Farmer.objects.get(id=farmer) if farmer else None
#     measurement_unit_obj = LandUnit.objects.get(id=measurement_unit) if measurement_unit else None
#     soil_type_obj = SoilType.objects.get(id=soil_type) if soil_type else None

#     if farmer_obj.status == 4:
#         return Response({'error': 'Farmer is expired.'}, status=status.HTTP_400_BAD_REQUEST)
#     if farmer_obj.status == 6:
#         return Response({'error': 'Farmer is unsubscribed.'}, status=status.HTTP_400_BAD_REQUEST)
 
#     subscription = AddSubcription.objects.filter(farmers=farmer_obj, status=0).first()  
#     if subscription:
#         myland_limit = subscription.packages.myland_count 
#         current_myland_count = MyLand.objects.filter(Q(status=0) | Q(status=1), farmer=farmer_obj).count()

#         if current_myland_count >= myland_limit:
#             errors['myland_limit'] = f"You have already reached the maximum land limit of {myland_limit} for your package."
#             return Response({'errors': errors}, status=status.HTTP_400_BAD_REQUEST)

#     country_obj = Country.objects.get(id=country) if country else farmer_obj.country
#     state_obj = State.objects.get(id=state) if state else farmer_obj.state
#     city_obj = City.objects.get(id=city) if city else farmer_obj.city
#     taluk_obj = Taluk.objects.get(id=taluk) if taluk else farmer_obj.taluk
#     village_obj = Village.objects.get(id=village) if village else farmer_obj.village

#     door_no = door_no or farmer_obj.door_no

#     my_land = MyLand.objects.create(
#         farmer=farmer_obj,
#         name=name,
#         measurement_value=measurement_value,
#         measurement_unit=measurement_unit_obj,
#         soil_type=soil_type_obj,
#         country=country_obj,
#         state=state_obj,
#         city=city_obj,
#         taluk=taluk_obj,
#         village=village_obj,
#         door_no=door_no,
#         locations=locations,
#         latitude=latitude,
#         longitude=longitude,
#         patta_number=patta_number,
#         description=description,
#         geo_marks=geo_marks,
#         created_at=timezone.now(),
#         created_by=farmer_obj.farmer_user if farmer_obj.farmer_user else farmer_obj.sub_admin_user,
#     )

#     notification_message = f"New land added: {name} at {village_obj.name if village_obj else ''}."
#     FarmerNotification.objects.create(
#         farmer=farmer_obj,
#         name="Land Added",
#         type="Land Management",
#         message=notification_message,
#         is_read=False
#     )

#     survey_details = []
#     for key in request.data.keys():
#         if key.startswith('survey_details'):
#             survey_value = request.data.get(key)
#             if survey_value:
#                 survey_data = survey_value.split(',')
#                 survey_dict = {}
#                 for item in survey_data:
#                     key_value = item.split(':')
#                     if len(key_value) == 2:
#                         survey_dict[key_value[0].strip()] = key_value[1].strip()
#                 survey_details.append(survey_dict)
#             else:
#                 errors[key] = f"{key} is empty or invalid"

#     documents_data = request.data.get('document', [])
#     document_details = []

#     for doc_data in documents_data:
#         file_type_id = doc_data.get('file_type')
#         documents = doc_data.get('documents', [])

#         if file_type_id is None:
#             new_file_type = doc_data.get('new_file_type')
#             if not new_file_type:
#                 return Response({"error": f"New file type for document is required."}, status=status.HTTP_400_BAD_REQUEST)
#             file_type, created = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=0)
#         else:
#             file_type = get_object_or_404(DocumentCategory, id=file_type_id)

#         for document_base64 in documents:
#             try:
#                 if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
#                     mime_type = validate_image_type(document_base64)
#                     if mime_type:
#                         document_data = document_base64.split(';base64,')[1]
#                         document_bytes = base64.b64decode(document_data)
#                         document_name = f"document_{timezone.now().strftime('%Y%m%d%H%M%S')}.{mime_type.split('/')[1]}"
#                         document_file = ContentFile(document_bytes, name=document_name)

#                         document_instance = MyLandDocument.objects.create(
#                             farmer=farmer_obj,
#                             myland=my_land,
#                             document_category=file_type,
#                             upload_document=document_file,
#                             created_at=timezone.now(),
#                             created_by=farmer_obj.farmer_user
#                         )

#                         document_details.append({
#                             'id': document_instance.id,
#                             'document_name': request.build_absolute_uri(f'/SuperAdmin{document_instance.upload_document.url}' if document_instance.upload_document else ""),
#                             'file_type': document_instance.document_category.name,
#                             'created_at': document_instance.created_at,
#                         })
#                     else:
#                         errors['documents'] = "Invalid MIME type for the document."
#                         return Response({'errors': errors}, status=status.HTTP_400_BAD_REQUEST)
#             except Exception as e:
#                 errors['document_processing'] = f"Error processing document: {str(e)}"
#                 return Response({'errors': errors}, status=status.HTTP_400_BAD_REQUEST)

#     survey_response = []
#     for survey in survey_details:
#         survey_no = survey.get('survey_no')
#         survey_measurement_value = survey.get('survey_measurement_value')
#         survey_measurement_unit_id = survey.get('survey_measurement_unit_id')
#         survey_measurement_unit = LandUnit.objects.get(id=survey_measurement_unit_id) if survey_measurement_unit_id else None

#         survey_instance = MyLandSurveyDetails.objects.create(
#             farmer=farmer_obj,
#             MyLand=my_land,
#             survey_no=survey_no,
#             survey_measurement_value=survey_measurement_value,
#             survey_measurement_unit=survey_measurement_unit,
#             created_at=timezone.now(),
#             updated_at=timezone.now(),
#         )

#         survey_response.append({
#             'id': survey_instance.id,
#             'survey_no': survey_instance.survey_no,
#             'survey_measurement_value': survey_instance.survey_measurement_value,
#             'survey_measurement_unit': survey_instance.survey_measurement_unit.name if survey_instance.survey_measurement_unit else None,
#             'language': {
#                 "default": "en"
#             }
#         })

#     return Response({
#         'message': 'MyLand and Documents created successfully!',
#         'my_land': {
#             'id': my_land.id,
#             'name': my_land.name,
#             'measurement_value': my_land.measurement_value,
#             'measurement_unit': my_land.measurement_unit.name if my_land.measurement_unit else None,
#             'soil_type': my_land.soil_type.name if my_land.soil_type else None,
#             'country': my_land.country.name if my_land.country else None,
#             'state': my_land.state.name if my_land.state else None,
#             'city': my_land.city.name if my_land.city else None,
#             'taluk': my_land.taluk.name if my_land.taluk else None,
#             'village': my_land.village.name if my_land.village else None,
#             'door_no': my_land.door_no,
#             'locations': my_land.locations,
#             'latitude': my_land.latitude,
#             'longitude': my_land.longitude,
#             'patta_number': my_land.patta_number,
#             'description': my_land.description,
#             'geo_marks': my_land.geo_marks,
#         },
#         'survey_details': survey_response, 
#         'documents': document_details,
#     }, status=status.HTTP_201_CREATED)

@api_view(['POST'])
def manage_my_land(request):
    # Extract data from request
    farmer = request.data.get('farmer')
    name = request.data.get('name')
    measurement_value = request.data.get('measurement_value')
    measurement_unit = request.data.get('measurement_unit')
    soil_type = request.data.get('soil_type')
    door_no = request.data.get('door_no')   
    locations = request.data.get('locations')  # URL containing coordinates
    patta_number = request.data.get('patta_number')
    description = request.data.get('description')
    geo_marks = request.data.get('geo_marks', None)

    # Parse latitude and longitude from the locations URL if provided
    latitude = None
    longitude = None

    if locations:
        try:
            # Example URL format with '@lat,long'
            match = re.search(r'@(-?\d+\.\d+),(-?\d+\.\d+)', locations)
            if match:
                latitude = float(match.group(1))
                longitude = float(match.group(2))
        except Exception:
            latitude = None
            longitude = None

    # Validation errors
    errors = {}

    # Required Fields Validation
    if not name:
        errors['name'] = 'This field is required.'
    if not measurement_value:
        errors['measurement_value'] = 'This field is required.'
    if not measurement_unit:
        errors['measurement_unit'] = 'This field is required.'
    if latitude is None:
        errors['latitude'] = 'Latitude could not be determined from locations URL.'
    if longitude is None:
        errors['longitude'] = 'Longitude could not be determined from locations URL.'

    # geo_marks format validation
    if geo_marks:
        if not isinstance(geo_marks, list):
            errors['geo_marks'] = 'geo_marks must be a list of coordinates.'
        else:
            for idx, point in enumerate(geo_marks):
                if not isinstance(point, dict) or 'lat' not in point or 'lng' not in point:
                    errors['geo_marks'] = (
                        "Each geo_mark must be an object with 'lat' and 'lng' keys. "
                        f"Invalid entry at index {idx}: {point}"
                    )
                    break

    if errors:
        return Response({'errors': errors}, status=status.HTTP_400_BAD_REQUEST)

    # Get related objects
    farmer_obj = Farmer.objects.get(id=farmer) if farmer else None
    measurement_unit_obj = LandUnit.objects.get(id=measurement_unit) if measurement_unit else None
    soil_type_obj = SoilType.objects.get(id=soil_type) if soil_type else None

    if farmer_obj.status == 4:
        return Response({'error': 'Farmer is expired.'}, status=status.HTTP_400_BAD_REQUEST)
    if farmer_obj.status == 6:
        return Response({'error': 'Farmer is unsubscribed.'}, status=status.HTTP_400_BAD_REQUEST)
 
    subscription = AddSubcription.objects.filter(farmers=farmer_obj, status=0).first()  
    if subscription:
        myland_limit = subscription.packages.myland_count 
        current_myland_count = MyLand.objects.filter(Q(status=0) | Q(status=1), farmer=farmer_obj).count()

        if current_myland_count >= myland_limit:
            errors['myland_limit'] = f"You have already reached the maximum land limit of {myland_limit} for your package."
            return Response({'errors': errors}, status=status.HTTP_400_BAD_REQUEST)

    door_no = door_no or farmer_obj.door_no

    my_land = MyLand.objects.create(
        farmer=farmer_obj,
        name=name,
        measurement_value=measurement_value,
        measurement_unit=measurement_unit_obj,
        soil_type=soil_type_obj,
        # Removed country, state, city, taluk, village fields
        door_no=door_no,
        locations=locations,
        latitude=latitude,
        longitude=longitude,
        patta_number=patta_number,
        description=description,
        geo_marks=geo_marks,
        created_at=timezone.now(),
        created_by=farmer_obj.farmer_user if farmer_obj.farmer_user else farmer_obj.sub_admin_user,
    )

    notification_message = f"New land added: {name}."
    FarmerNotification.objects.create(
        farmer=farmer_obj,
        name="Land Added",
        type="Land Management",
        message=notification_message,
        is_read=False
    )

    # Process survey details
    survey_details = []
    errors = {}
    for key in request.data.keys():
        if key.startswith('survey_details'):
            survey_value = request.data.get(key)
            if survey_value:
                survey_data = survey_value.split(',')
                survey_dict = {}
                for item in survey_data:
                    key_value = item.split(':')
                    if len(key_value) == 2:
                        survey_dict[key_value[0].strip()] = key_value[1].strip()
                survey_details.append(survey_dict)
            else:
                errors[key] = f"{key} is empty or invalid"

    if errors:
        return Response({'errors': errors}, status=status.HTTP_400_BAD_REQUEST)

    # Process documents
    documents_data = request.data.get('document', [])
    document_details = []

    for doc_data in documents_data:
        file_type_id = doc_data.get('file_type')
        documents = doc_data.get('documents', [])

        if file_type_id is None:
            new_file_type = doc_data.get('new_file_type')
            if not new_file_type:
                return Response({"error": f"New file type for document is required."}, status=status.HTTP_400_BAD_REQUEST)
            file_type, created = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=0)
        else:
            file_type = get_object_or_404(DocumentCategory, id=file_type_id)

        for document_base64 in documents:
            try:
                if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
                    mime_type = validate_image_type(document_base64)
                    if mime_type:
                        document_data = document_base64.split(';base64,')[1]
                        document_bytes = base64.b64decode(document_data)
                        document_name = f"document_{timezone.now().strftime('%Y%m%d%H%M%S')}.{mime_type.split('/')[1]}"
                        document_file = ContentFile(document_bytes, name=document_name)

                        document_instance = MyLandDocument.objects.create(
                            farmer=farmer_obj,
                            myland=my_land,
                            document_category=file_type,
                            upload_document=document_file,
                            created_at=timezone.now(),
                            created_by=farmer_obj.farmer_user
                        )

                        document_details.append({
                            'id': document_instance.id,
                            'document_name': request.build_absolute_uri(f'/SuperAdmin{document_instance.upload_document.url}' if document_instance.upload_document else ""),
                            'file_type': document_instance.document_category.name,
                            'created_at': document_instance.created_at,
                        })
                    else:
                        errors['documents'] = "Invalid MIME type for the document."
                        return Response({'errors': errors}, status=status.HTTP_400_BAD_REQUEST)
            except Exception as e:
                errors['document_processing'] = f"Error processing document: {str(e)}"
                return Response({'errors': errors}, status=status.HTTP_400_BAD_REQUEST)

    # Create survey detail records
    survey_response = []
    for survey in survey_details:
        survey_no = survey.get('survey_no')
        survey_measurement_value = survey.get('survey_measurement_value')
        survey_measurement_unit_id = survey.get('survey_measurement_unit_id')
        survey_measurement_unit = LandUnit.objects.get(id=survey_measurement_unit_id) if survey_measurement_unit_id else None

        survey_instance = MyLandSurveyDetails.objects.create(
            farmer=farmer_obj,
            MyLand=my_land,
            survey_no=survey_no,
            survey_measurement_value=survey_measurement_value,
            survey_measurement_unit=survey_measurement_unit,
            created_at=timezone.now(),
            updated_at=timezone.now(),
        )

        survey_response.append({
            'id': survey_instance.id,
            'survey_no': survey_instance.survey_no,
            'survey_measurement_value': survey_instance.survey_measurement_value,
            'survey_measurement_unit': survey_instance.survey_measurement_unit.name if survey_instance.survey_measurement_unit else None,
            'language': {
                "default": "en"
            }
        })

    return Response({
        'message': 'MyLand and Documents created successfully!',
        'my_land': {
            'id': my_land.id,
            'name': my_land.name,
            'measurement_value': my_land.measurement_value,
            'measurement_unit': my_land.measurement_unit.name if my_land.measurement_unit else None,
            'soil_type': my_land.soil_type.name if my_land.soil_type else None,
            # country, state, city, taluk, village removed
            'door_no': my_land.door_no,
            'locations': my_land.locations,
            'latitude': my_land.latitude,
            'longitude': my_land.longitude,
            'patta_number': my_land.patta_number,
            'description': my_land.description,
            'geo_marks': my_land.geo_marks,
        },
        'survey_details': survey_response, 
        'documents': document_details,
    }, status=status.HTTP_201_CREATED)

# @api_view(['PUT'])
# def update_my_schedule(request, id):
#     task_id = request.data.get('id')
#     try:
#         farmer_instance = Farmer.objects.get(id=id)
#     except Farmer.DoesNotExist:
#         return Response({"error": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)
    
#     try:
#         my_schedule = MySchedule.objects.get(id=task_id, farmer=id)
#     except MySchedule.DoesNotExist:
#         return Response({"detail": "Schedule not found."}, status=status.HTTP_404_NOT_FOUND)

#     crop_id = request.data.get('my_crop', None)
#     start_date = request.data.get('start_date', None)
#     schedule = request.data.get('schedule', None)
#     schedule_status_id = request.data.get('schedule_status', None)
#     schedule_choice = request.data.get('schedule_choice', None)
#     comment = request.data.get('comment', None)

#     # Update crop if provided
#     if crop_id:
#         try:
#             my_crop_instance = MyCrop.objects.get(id=crop_id)
#             my_schedule.my_crop = my_crop_instance  # Assign the actual MyCrop instance
#         except MyCrop.DoesNotExist:
#             return Response({"error": "MyCrop not found."}, status=status.HTTP_404_NOT_FOUND)

#         # Update the associated land (my_land) with the land of the new crop
#         my_schedule.my_land = my_crop_instance.land  # Assuming each MyCrop has a land field that links to MyLand
#         my_schedule.save()  # Save the changes after updating the land

#     # Update schedule status if provided
#     if schedule_status_id:
#         try:
#             schedule_status_instance = ScheduleStatus.objects.get(id=schedule_status_id)
#             my_schedule.schedule_status = schedule_status_instance  # Assign the actual ScheduleStatus instance
#         except ScheduleStatus.DoesNotExist:
#             return Response({"error": "ScheduleStatus not found."}, status=status.HTTP_404_NOT_FOUND)

#     # Update other fields
#     if start_date:
#         my_schedule.start_date = start_date
#     if schedule:
#         my_schedule.schedule = schedule
#     if schedule_choice is not None:
#         my_schedule.schedule_choice = schedule_choice

#     # Update the user who updated this schedule
#     try:
#         username = CustomUser.objects.get(id=farmer_instance.farmer_user.id)
#         my_schedule.updated_by = username
#     except CustomUser.DoesNotExist:
#         return Response({"error": "User not found."}, status=status.HTTP_404_NOT_FOUND)

#     # Update the timestamp
#     my_schedule.updated_at = timezone.now()
#     my_schedule.end_date = start_date
#     # my_schedule.comment = comment

#     # Save the updated schedule
#     my_schedule.save()

#     # Create a notification for the farmer about the update
#     notification_message = f"Your schedule for crop {my_schedule.my_crop.crop.name} has been updated. The task on {my_schedule.start_date} has new details."
#     FarmerNotification.objects.create(
#         farmer=farmer_instance,
#         name="Schedule Updated",
#         type="Task Management",
#         message=notification_message,
#         is_read=False  # Notification is unread by default
#     )
 
#     # Serialize and return the updated schedule
#     serializer = MyScheduleDetailsSerializer(my_schedule)

#     return Response({
#         "message": "Schedule updated successfully.","language": {
#         "default": "en"
#     },
#         "updated_schedule": serializer.data
#     }, status=status.HTTP_200_OK)


@api_view(['PUT'])
def update_my_schedule(request, id):
    task_id = request.data.get('id')
    try:
        farmer_instance = Farmer.objects.get(id=id)
    except Farmer.DoesNotExist:
        return Response({"error": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)
    
    try:
        my_schedule = MySchedule.objects.get(id=task_id, farmer=id)
    except MySchedule.DoesNotExist:
        return Response({"detail": "Schedule not found."}, status=status.HTTP_404_NOT_FOUND)

    translate_json = my_schedule.translate_json or {
        "schedule": {},
        # "comment": {}
    }

    schedule = request.data.get('schedule')
    if schedule:
        for lang in target_language:
            try:
                translated_schedule = GoogleTranslator(source='auto', target=lang).translate(schedule)
                print(f"Translated schedule '{schedule}' to {lang}: {translated_schedule}")
                translate_json["schedule"][lang] = translated_schedule
            except Exception as e:
                print(f"Error translating schedule '{schedule}' to {lang}: {e}")

    crop_id = request.data.get('my_crop', None)
    start_date = request.data.get('start_date', None)
    schedule = request.data.get('schedule', None)
    schedule_status_id = request.data.get('schedule_status', None)
    schedule_choice = request.data.get('schedule_choice', None)
    schedule_activity_type_id = request.data.get('schedule_activity_type', None)  # Add this line
    comment = request.data.get('comment', None)

    # Update crop if provided
    if crop_id:
        try:
            my_crop_instance = MyCrop.objects.get(id=crop_id)
            my_schedule.my_crop = my_crop_instance  # Assign the actual MyCrop instance
        except MyCrop.DoesNotExist:
            return Response({"error": "MyCrop not found."}, status=status.HTTP_404_NOT_FOUND)
 
        my_schedule.my_land = my_crop_instance.land   
        my_schedule.save()   
 
    if schedule_status_id:
        try:
            schedule_status_instance = ScheduleStatus.objects.get(id=schedule_status_id)
            my_schedule.schedule_status = schedule_status_instance  
        except ScheduleStatus.DoesNotExist:
            return Response({"error": "ScheduleStatus not found."}, status=status.HTTP_404_NOT_FOUND)
 
    if schedule_activity_type_id:   
        try:
            schedule_activity_type_instance = ScheduleActivityType.objects.get(id=schedule_activity_type_id)
            my_schedule.schedule_activity_type = schedule_activity_type_instance  
        except ScheduleActivityType.DoesNotExist:
            return Response({"error": "ScheduleActivityType not found."}, status=status.HTTP_404_NOT_FOUND)
 
    if start_date:
        my_schedule.start_date = start_date
    if schedule:
        my_schedule.schedule = schedule
    if schedule_choice is not None:
        my_schedule.schedule_choice = schedule_choice

    # Update the user who updated this schedule
    try:
        username = CustomUser.objects.get(id=farmer_instance.farmer_user.id)
        my_schedule.updated_by = username
    except CustomUser.DoesNotExist:
        return Response({"error": "User not found."}, status=status.HTTP_404_NOT_FOUND)

    # Update the timestamp
    my_schedule.updated_at = timezone.now()
    my_schedule.end_date = start_date
    my_schedule.translate_json = translate_json

    # Save the updated schedule
    my_schedule.save()

    # Create a notification for the farmer about the update
    notification_message = f"Your schedule for crop {my_schedule.my_crop.crop.name} has been updated. The task on {my_schedule.start_date} has new details."
    FarmerNotification.objects.create(
        farmer=farmer_instance,
        name="Schedule Updated",
        type="Task Management",
        message=notification_message,
        is_read=False  # Notification is unread by default
    )
 
    # Serialize and return the updated schedule
    serializer = MyScheduleDetailsSerializer(my_schedule)

    return Response({
        "message": "Schedule updated successfully.",
        "language": {"default": "en"},
        "updated_schedule": serializer.data
    }, status=status.HTTP_200_OK)

 
@api_view(['GET'])
def get_near_by_markets(request, id, farmer_id):
    # Fetching the Farmer using the provided farmer_id
    try:
        farmer = Farmer.objects.get(id=farmer_id, status=0)
    except Farmer.DoesNotExist:
        return Response({"detail": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)

    # Fetching the language preference for the farmer
    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'  # Fallback to 'en' if no preference is found

    # Fetching the MyLand data for the specific farmer using the farmer_id
    try:
        my_land = MyLand.objects.get(id=id, farmer=farmer, status=0)
    except MyLand.DoesNotExist:
        return Response({"detail": "MyLand not found for the specified farmer."}, status=status.HTTP_404_NOT_FOUND)

    # Fetching all markets for the village of the MyLand
    try:
        markets = ManageMarket.objects.filter(village=my_land.village, status=0)
        all_market_details = []
        
        for market in markets:
            # Constructing the address with translation for door_no only if needed
            address_parts = []
            if market.door_no:
                address_parts.append(market.get_translated_value("door_no", language_code) if language_code == 'ta' else str(market.door_no))
            if market.village:
                village_name = market.village.get_translated_value("name", language_code)  # Translate the village name
                address_parts.append(village_name)
            else:
                village_name = None
            if market.taluk:
                taluk_name = market.taluk.get_translated_value("name", language_code)   
                address_parts.append(taluk_name)
            else:
                taluk_name = None
            if market.city:
                city_name = market.city.get_translated_value("name", language_code)   
                address_parts.append(city_name)
            else:
                city_name = None
            if market.state:
                state_name = market.state.get_translated_value("name", language_code)  # Translate the village name
                address_parts.append(state_name)
            else:
                state_name = None
            if market.country:
                country_name = market.country.get_translated_value("name", language_code)  # Translate the village name
                address_parts.append(country_name)
            else:
                country_name = None
            if market.pincode:
                address_parts.append(str(market.pincode))

            address = ", ".join(address_parts)

            market_data = {
                'land_id': my_land.id,  
                'land_name': my_land.get_translated_value("name", language_code) if language_code == 'ta' else my_land.name,  # Translate land name if 'ta'
                
                'farmer_id': farmer_id,  
                'farmer_land': {  
                    'land_name': farmer.get_translated_value("name", language_code) if language_code == 'ta' else farmer.name,  # Translate farmer name if 'ta'
                },
                'id': market.id,
                'name': market.get_translated_value("name", language_code) if language_code == 'ta' else market.name,  # Translate market name if 'ta'
                "market_img": request.build_absolute_uri(f'/assets{market.img.url}' if market.img else market.img.url) if market.img else "/assets/images/default.png", 
                'products': [product.get_translated_value("name", language_code) if language_code == 'ta' else product.name for product in market.products.all()],
                'openingtime': market.openingtime,
                'closingtime': market.closingtime,
                'days': [get_translated_value(day.name, language_code) if language_code == 'ta' else day.name for day in market.days.all()],
                'description': market.get_translated_value("description", language_code) if language_code == 'ta' else market.description,  # Translate description if 'ta'
                'phone': market.phone,
                
                # Using the constructed address
                'address': address,
                'latitude': market.latitude,
                'longitude': market.longitude,
                'status': market.status,
            }

            all_market_details.append(market_data)
        
    except ManageMarket.DoesNotExist:
        all_market_details = []

    # Get the market count
    market_count = len(all_market_details)

    # Returning the list of nearby markets and market count as a JSON response
    return Response({
        "market_count": market_count,
        "markets": all_market_details,
        "language": {
            "default": language_code
        }
    }, status=status.HTTP_200_OK)



# @api_view(['GET'])
# def get_near_by_markets_details(request, id, farmer_id, market_id):
#     # Fetching the Farmer using the provided farmer_id
#     try:
#         farmer = Farmer.objects.get(id=farmer_id, status=0)
#     except Farmer.DoesNotExist:
#         return Response({"detail": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)

#     try:
#         user_language_pref = UserLanguagePreference.objects.get(user=farmer)
#         language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
#     except UserLanguagePreference.DoesNotExist:
#         language_code = 'en'  # Fallback to 'en' if no preference is found
    
#     # Fetching the MyLand data for the specific farmer using the farmer_id
#     try:
#         my_land = MyLand.objects.get(id=id, farmer=farmer, status=0)
#     except MyLand.DoesNotExist:
#         return Response({"detail": "MyLand not found for the specified farmer."}, status=status.HTTP_404_NOT_FOUND)

#     # Fetching the specific market by market_id
#     try:
#         market = ManageMarket.objects.get(id=market_id, village=my_land.village, status=0)
#         market_details = {
#             'land_id': my_land.id,  # Adding land id to the response
#             # 'land_name': my_land.name,  # Adding land name to the response
#             'land_name': my_land.get_translated_value("name", language_code) if language_code == 'ta' else my_land.name, 
#             'farmer_id': farmer_id,  # Adding farmer id to the response
#             'farmer_land': {  # Adding farmer land details to the response
#                 'land_name': farmer.get_translated_value("name", language_code) if language_code == 'ta' else farmer.name,  # Assuming 'name' is a field in the MyLand model 
#             },
#             'market_id': market.id,  # Adding market_id explicitly
#             'id': market.id,  # Including the market id
#             'name': market.get_translated_value("name", language_code) if language_code == 'ta' else market.name,
#             "market_img": request.build_absolute_uri(f'/assets{market.img.url}' if market.img else market.img.url) if market.img else "/assets/images/default.png", 
#             'products': [product.name for product in market.products.all()],
#             'openingtime': market.openingtime,
#             'closingtime': market.closingtime,
#             'days': [get_translated_value(day.name, language_code) if language_code == 'ta' else day.name for day in market.days.all()],
#             'description': market.get_translated_value("description", language_code) if language_code == 'ta' else market.description,  
#             'phone': market.phone,
#             'address': f"{market.door_no}, {market.village.name if market.village else ''}, {market.taluk.name if market.taluk else ''}, {market.city.name if market.city else ''}, {market.state.name if market.state else ''}, {market.country.name if market.country else ''} - {market.pincode if market.pincode else ''}",
#             'latitude': market.latitude,
#             'longitude': market.longitude,
#             'status': market.status,
#         }
#     except ManageMarket.DoesNotExist:
#         return Response({"detail": "Market not found for the specified MyLand."}, status=status.HTTP_404_NOT_FOUND)

#     # Returning the specific market details as a JSON response
#     return Response({
#         "market": market_details,
#         "language": {
#             "default": "en"
#         }
#     }, status=status.HTTP_200_OK)

@api_view(['GET'])
def get_near_by_markets_details(request, id, farmer_id, market_id):
    # Fetching the Farmer using the provided farmer_id
    try:
        farmer = Farmer.objects.get(id=farmer_id, status=0)
    except Farmer.DoesNotExist:
        return Response({"detail": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)

    # Fetching the language preference for the farmer
    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'  # Fallback to 'en' if no preference is found
    
    # Fetching the MyLand data for the specific farmer using the farmer_id
    try:
        my_land = MyLand.objects.get(id=id, farmer=farmer, status=0)
    except MyLand.DoesNotExist:
        return Response({"detail": "MyLand not found for the specified farmer."}, status=status.HTTP_404_NOT_FOUND)

    # Fetching the specific market by market_id
    try:
        market = ManageMarket.objects.get(id=market_id, village=my_land.village, status=0)
        
        # Constructing the address with translated 'door_no'
        address_parts = []

        if market.door_no:
            address_parts.append(market.get_translated_value("door_no", language_code) if language_code == 'ta' else str(market.door_no))
        if market.village:
            village_name = market.village.get_translated_value("name", language_code)  # Translate the village name
            address_parts.append(village_name)
        else:
            village_name = None
        if market.taluk:
            taluk_name = market.taluk.get_translated_value("name", language_code)  # Translate the village name
            address_parts.append(taluk_name)
        else:
            taluk_name = None
        if market.city:
            city_name = market.city.get_translated_value("name", language_code)  # Translate the village name
            address_parts.append(city_name)
        else:
            city_name = None
        if market.state:
            state_name = market.state.get_translated_value("name", language_code)  # Translate the village name
            address_parts.append(state_name)
        else:
            state_name = None
        if market.country:
            country_name = market.country.get_translated_value("name", language_code)  # Translate the village name
            address_parts.append(country_name)
        else:
            country_name = None
        if market.pincode:
            address_parts.append(str(market.pincode))

        address = ", ".join(address_parts)

        market_details = {
            'land_id': my_land.id,  # Adding land id to the response
            'land_name': my_land.get_translated_value("name", language_code) if language_code == 'ta' else my_land.name,  # Translate land name if 'ta'
            'farmer_id': farmer_id,  # Adding farmer id to the response
            'farmer_land': {  # Adding farmer land details to the response
                'land_name': farmer.get_translated_value("name", language_code) if language_code == 'ta' else farmer.name,  # Assuming 'name' is a field in the MyLand model 
            },
            'market_id': market.id,  # Adding market_id explicitly
            'id': market.id,  # Including the market id
            'name': market.get_translated_value("name", language_code) if language_code == 'ta' else market.name,
            "market_img": request.build_absolute_uri(f'/assets{market.img.url}' if market.img else market.img.url) if market.img else "/assets/images/default.png", 
            # 'products': [product.name for product in market.products.all()],
            'products': [product.get_translated_value("name", language_code) if language_code == 'ta' else product.name for product in market.products.all()],
            'openingtime': market.openingtime,
            'closingtime': market.closingtime,
            'days': [get_translated_value(day.name, language_code) if language_code == 'ta' else day.name for day in market.days.all()],
            'description': market.get_translated_value("description", language_code) if language_code == 'ta' else market.description,  
            'phone': market.phone,
            'address': address,  # Use the newly constructed address here
            'latitude': market.latitude,
            'longitude': market.longitude,
            'status': market.status,
        }
    except ManageMarket.DoesNotExist:
        return Response({"detail": "Market not found for the specified MyLand."}, status=status.HTTP_404_NOT_FOUND)

    # Returning the specific market details as a JSON response
    return Response({
        "market": market_details,
        "language": {
            "default": language_code
        }
    }, status=status.HTTP_200_OK)


@api_view(['POST'])
def delete_schedule(request, id):
        try:
         farmer_instance = Farmer.objects.get(id=id)
        except Farmer.DoesNotExist:
           return Response({"error": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)
        task_id = request.data.get('id', None)
        if not task_id:
            return Response({"error": "Task ID is required."}, status=status.HTTP_400_BAD_REQUEST)
        try:
            schedule_instance = MySchedule.objects.get(id=task_id, farmer=farmer_instance)
        except MySchedule.DoesNotExist:
            return Response({"error": "Task not found."}, status=status.HTTP_404_NOT_FOUND)
        schedule_instance.status = 2
        schedule_instance.updated_at = timezone.now()
        schedule_instance.updated_by = farmer_instance.farmer_user
        schedule_instance.save()

        notification_message = f"Your schedule for crop {schedule_instance.my_crop.crop.name} on {schedule_instance.start_date} has been deleted."
        FarmerNotification.objects.create(
            farmer=farmer_instance,
            name="Schedule Deleted",
            type="Task Management",
            message=notification_message,
            is_read=False  # Notification is unread by default
        )

        return Response({"message": "Task Deleted."}, status=status.HTTP_200_OK)

@api_view(['POST'])
def task_completed(request, id):
    try:
        farmer_instance = Farmer.objects.get(id=id)
    except Farmer.DoesNotExist:
        return Response({"error": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)

    task_id = request.data.get('id', None)
    if not task_id:
        return Response({"error": "Task ID is required."}, status=status.HTTP_400_BAD_REQUEST)

    try:
        schedule_instance = MySchedule.objects.get(id=task_id, farmer=id)
    except MySchedule.DoesNotExist:
        return Response({"error": "Task not found."}, status=status.HTTP_404_NOT_FOUND)

    schedule_instance.schedule_status = 0  # Set schedule_status to 0
    schedule_instance.updated_at = timezone.now()  # Update the timestamp
    schedule_instance.updated_by = farmer_instance.farmer_user  # Set the user who updated the task

    schedule_instance.save()

    schedule_instance_data = MyScheduleDetailsSerializer(schedule_instance).data
    return Response(schedule_instance_data, status=status.HTTP_200_OK)



# @api_view(['PUT'])
# def add_comments(request, id):
#     task_id = request.data.get('id')
#     comment = request.data.get('comment')  # Extract comments from the request data
    
#     try:
#         farmer = Farmer.objects.get(id=id)
#     except Farmer.DoesNotExist:
#         return Response({"detail": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)
    
#     try:
#         task = MySchedule.objects.get(id=task_id, farmer=farmer, status=0)
#     except MySchedule.DoesNotExist:
#         return Response({"detail": "Task not found."}, status=status.HTTP_404_NOT_FOUND)
    
#     # Update only the comments field
#     task.comment = comment
#     task.updated_at = timezone.now()
#     task.updated_by = farmer.farmer_user
    
#     task.save()

#     # Manually construct the response data
#     task_data = {
#         "id": task.id,
#         "farmer": task.farmer.id,
#         "my_crop": task.my_crop.id,
#         "my_land": task.my_land.id,
#         "schedule_activity_type": task.schedule_activity_type.id,
#         "start_date": task.start_date,
#         "end_date": task.end_date,
#         "schedule_choice": task.schedule_choice,
#         "schedule_status": task.schedule_status.id,
#         "schedule": task.schedule,
#         "comment": task.comment,
#         "created_at": task.created_at,
#         "updated_at": task.updated_at,
#         "updated_by": task.updated_by.id if task.updated_by else None,
#         "language": {
#             "default": "en"
#         }
#     }

#     # Return updated task data, including the updated comments
#     return Response({
#         "detail": "Comments updated successfully",
#         "task": task_data
#     }, status=status.HTTP_200_OK)
 
@api_view(['PUT'])
def add_comments(request, id):
    task_id = request.data.get('id')
    comment = request.data.get('comment')  # Extract comments from the request data
    
    try:
        farmer = Farmer.objects.get(id=id)
    except Farmer.DoesNotExist:
        return Response({"detail": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)
    
    try:
        task = MySchedule.objects.get(id=task_id, farmer=farmer, status=0)
    except MySchedule.DoesNotExist:
        return Response({"detail": "Task not found."}, status=status.HTTP_404_NOT_FOUND)


    translate_json = task.translate_json or {
        # "schedule": {},
        "comment": {}
    }

    comment = request.data.get('comment')
    if comment:
        for lang in target_language:
            try:
                translated_comment = GoogleTranslator(source='auto', target=lang).translate(comment)
                print(f"Translated comment '{comment}' to {lang}: {translated_comment}")
                translate_json["comment"][lang] = translated_comment
            except Exception as e:
                print(f"Error translating comment '{comment}' to {lang}: {e}")
    
    # Update only the comments field
    task.comment = comment
    task.updated_at = timezone.now()
    task.updated_by = farmer.farmer_user
    task.translate_json = translate_json
    
    task.save()

    # Manually construct the response data
    task_data = {
        "id": task.id,
        "farmer": task.farmer.id,
        "my_crop": task.my_crop.id,
        "my_land": task.my_land.id,
        "schedule_activity_type": task.schedule_activity_type.id,
        "start_date": task.start_date,
        "end_date": task.end_date,
        "schedule_choice": task.schedule_choice,
        "schedule_status": task.schedule_status.id,
        "schedule": task.schedule,
        "comment": task.comment,
        "created_at": task.created_at,
        "updated_at": task.updated_at,
        "updated_by": task.updated_by.id if task.updated_by else None,
        "language": {
            "default": "en"
        }
    }

    # Return updated task data, including the updated comments
    return Response({
        "detail": "Comments updated successfully",
        "task": task_data
    }, status=status.HTTP_200_OK)
 



@api_view(['GET'])
def guidelines_list(request):  
    guidelines = Guidelines.objects.filter(status=0)
    
    # Prepare the list of guidelines as a list of dictionaries
    guidelines_list = []
    for guideline in guidelines:
        guidelines_list.append({
            'id': guideline.id,
            'name': guideline.name,
            'guidelinestype': guideline.guidelinestype.name if guideline.guidelinestype else " ",
            'guidelinescategory': {
                'id': guideline.guidelinescategory.id if guideline.guidelinescategory else " ",
                'name': guideline.guidelinescategory.name if guideline.guidelinescategory else " ",
            },
            'crop': {
                'id': guideline.crop.id if guideline.crop else " ",
                'name': guideline.crop.name if guideline.crop else " ",
            },
            'description': guideline.description,
            'status': guideline.status,
            'created_at': guideline.created_at,
            'updated_at': guideline.updated_at, 
            'video_url': guideline.video_url if guideline.video_url else " ",
            # 'document': guideline.document.url if guideline.document else " ",
            "document": request.build_absolute_uri(f'/SuperAdmin{guideline.document.url}' if guideline.document else guideline.document.url) if guideline.document else "",
            'media_type': guideline.media_type,
        })
    
    # Return the list of guidelines as a JSON response
    return Response(guidelines_list, status=status.HTTP_200_OK)
 
# @api_view(['PUT'])
# def update_my_land(request, farmer_id):
     
#     try:
#         farmer_obj = Farmer.objects.get(id=farmer_id)
#     except Farmer.DoesNotExist:
#         return Response({"error": f"Farmer with id {farmer_id} does not exist."}, status=status.HTTP_404_NOT_FOUND)
#     # Fetch the land object
#     land_id = request.data.get('id')
#     if not land_id:
#         return Response({"error": "Land id is required for update"}, status=status.HTTP_400_BAD_REQUEST)
    
#     try:
#         my_land = MyLand.objects.get(id=land_id, farmer_id=farmer_id)
#     except MyLand.DoesNotExist:
#         return Response({"detail": "MyLand not found."}, status=status.HTTP_404_NOT_FOUND)

#     # Handle the update for land fields like soil_type, measurement_unit, etc.
#     soil_type_id = request.data.get('soil_type')
#     if soil_type_id:
#         try:
#             soil_type = SoilType.objects.get(id=soil_type_id)
#             my_land.soil_type = soil_type
#         except SoilType.DoesNotExist:
#             return Response({"error": f"SoilType with id {soil_type_id} does not exist."}, status=status.HTTP_400_BAD_REQUEST)

#     measurement_unit_id = request.data.get('measurement_unit')
#     if measurement_unit_id:
#         try:
#             measurement_unit = LandUnit.objects.get(id=measurement_unit_id)
#             my_land.measurement_unit = measurement_unit
#         except LandUnit.DoesNotExist:
#             return Response({"error": f"LandUnit with id {measurement_unit_id} does not exist."}, status=status.HTTP_400_BAD_REQUEST)

#     country_id = request.data.get('country')
#     if country_id:
#         try:
#             country = Country.objects.get(id=country_id)
#             my_land.country = country
#         except Country.DoesNotExist:
#             return Response({"error": f"Country with id {country_id} does not exist."}, status=status.HTTP_400_BAD_REQUEST)

#     state_id = request.data.get('state')
#     if state_id:
#         try:
#             state = State.objects.get(id=state_id)
#             my_land.state = state
#         except State.DoesNotExist:
#             return Response({"error": f"State with id {state_id} does not exist."}, status=status.HTTP_400_BAD_REQUEST)

#     city_id = request.data.get('city')
#     if city_id:
#         try:
#             city = City.objects.get(id=city_id)
#             my_land.city = city
#         except City.DoesNotExist:
#             return Response({"error": f"City with id {city_id} does not exist."}, status=status.HTTP_400_BAD_REQUEST)

#     taluk_id = request.data.get('taluk')
#     if taluk_id:
#         try:
#             taluk = Taluk.objects.get(id=taluk_id)
#             my_land.taluk = taluk
#         except Taluk.DoesNotExist:
#             return Response({"error": f"Taluk with id {taluk_id} does not exist."}, status=status.HTTP_400_BAD_REQUEST)

#     village_id = request.data.get('village')
#     if village_id:
#         try:
#             village = Village.objects.get(id=village_id)
#             my_land.village = village
#         except Village.DoesNotExist:
#             return Response({"error": f"Village with id {village_id} does not exist."}, status=status.HTTP_400_BAD_REQUEST)

#     # Other fields
#     my_land.id = request.data.get('id', my_land.id)
#     my_land.name = request.data.get('name', my_land.name)
#     my_land.measurement_value = request.data.get('measurement_value', my_land.measurement_value)
#     my_land.door_no = request.data.get('door_no', my_land.door_no)
#     my_land.locations = request.data.get('locations', my_land.locations)
#     my_land.latitude = request.data.get('latitude', my_land.latitude)
#     my_land.longitude = request.data.get('longitude', my_land.longitude)
#     my_land.patta_number = request.data.get('patta_number', my_land.patta_number)
#     my_land.description = request.data.get('description', my_land.description)
#     my_land.l_status = request.data.get('l_status', my_land.l_status)

#     # Save the updated land object
#     my_land.updated_at = timezone.now()
#     my_land.save()

#     notification_message = f"Your land '{my_land.name}' has been successfully updated."
#     FarmerNotification.objects.create(
#         farmer=farmer_obj,
#         name=f"Land Update: {my_land.name}",
#         type="Land Update",
#         message=notification_message,
#         created_at=timezone.now(),
#         is_read=False
#     )

#     # Handle Survey Details (modify the survey data accordingly)
#     survey_details = request.data.get('survey_details', [])
#     for survey_data in survey_details:
#         survey_id = survey_data.get('id')

#         # Handle survey_measurement_unit field as a ForeignKey (LandUnit)
#         survey_measurement_unit_id = survey_data.get('survey_measurement_unit')
#         if survey_measurement_unit_id:
#             try:
#                 land_unit_instance = LandUnit.objects.get(id=survey_measurement_unit_id)
#                 survey_data['survey_measurement_unit'] = land_unit_instance
#             except LandUnit.DoesNotExist:
#                 return Response({"error": f"LandUnit with id {survey_measurement_unit_id} does not exist."}, status=status.HTTP_400_BAD_REQUEST)

#         if survey_id:  # If there's an ID, update the existing survey
#             try:
#                 survey = MyLandSurveyDetails.objects.get(id=survey_id, MyLand=my_land)
#                 # Update the survey fields
#                 survey.survey_no = survey_data.get('survey_no', survey.survey_no)
#                 survey.survey_measurement_value = survey_data.get('survey_measurement_value', survey.survey_measurement_value)
#                 survey.survey_measurement_unit = survey_data.get('survey_measurement_unit', survey.survey_measurement_unit)
#                 survey.save()
#             except MyLandSurveyDetails.DoesNotExist:
#                 return Response({"error": f"Survey with id {survey_id} not found."}, status=status.HTTP_404_NOT_FOUND)
#         else:  # If no ID exists, create a new survey
#             try:
#                 survey_measurement_unit = LandUnit.objects.get(id=survey_measurement_unit_id)
#                 new_survey = MyLandSurveyDetails(
#                     survey_no=survey_data.get('survey_no'),
#                     survey_measurement_value=survey_data.get('survey_measurement_value'),
#                     survey_measurement_unit=survey_measurement_unit,
#                     MyLand=my_land
#                 )
#                 new_survey.save()
#             except LandUnit.DoesNotExist:
#                 return Response({"error": f"LandUnit with id {survey_data['survey_measurement_unit']} does not exist."}, status=status.HTTP_400_BAD_REQUEST)

#     # Handle MyLand Documents (create or update documents)
#     document_details = []
#     errors = {}
#     # Delete documents - Get IDs of documents to delete
#     delete_document_ids = request.data.get('delete_documents', [])
#     if delete_document_ids:
#         for doc_id in delete_document_ids:
#             try:
#                 document = MyLandDocument.objects.get(id=doc_id, myland=my_land)
#                 document.delete()  # Delete document from the database
#             except MyLandDocument.DoesNotExist:
#                 errors['document_deletion'] = f"Document with ID {doc_id} not found."
#                 return Response({'errors': errors}, status=status.HTTP_404_NOT_FOUND)

#     # Add new documents (Upload)
#     # Get documents from request
#     documents_data = request.data.get('documents', [])
#     for doc_data in documents_data:
#         document_id = doc_data.get('id')  # Get document ID if provided
#         file_type_id = doc_data.get('file_type')
#         documents = doc_data.get('documents', [])

#         for document_base64 in documents:
#             try:
#                 if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
#                     # Validate MIME type
#                     mime_type = validate_image_type(document_base64)
#                     if mime_type:
#                         document_data = document_base64.split(';base64,')[1]
#                         document_bytes = base64.b64decode(document_data)
#                         document_name = f"document_{timezone.now().strftime('%Y%m%d%H%M%S')}.{mime_type.split('/')[1]}"
#                         document_file = ContentFile(document_bytes, name=document_name)

#                         document_category = get_object_or_404(DocumentCategory, id=file_type_id)

                       
#                         if document_id:
#                             try:
#                                 document_instance = MyLandDocument.objects.get(id=document_id, myland=my_land)
#                                 document_instance.document_category = document_category  # Update file_type
#                                 document_instance.upload_document = document_file  # Update document
#                                 document_instance.save() 
#                             except MyLandDocument.DoesNotExist:
#                                 return Response({'errors': {'document': f"Document with ID {document_id} not found."}},
#                                                 status=status.HTTP_404_NOT_FOUND)
#                         else:
#                             # Create a new document if ID is not provided
#                             document_instance = MyLandDocument.objects.create(
#                                 farmer=farmer_obj,
#                                 myland=my_land,
#                                 document_category=document_category,
#                                 upload_document=document_file,
#                                 created_at=timezone.now(),
#                                 created_by=farmer_obj.farmer_user
#                             )

#                         # Collect document details for response
#                         document_details.append({
#                             'id': document_instance.id,
#                             'document_name': request.build_absolute_uri(f'/SuperAdmin{document_instance.upload_document.url}' if document_instance.upload_document else " "),
#                             'file_type': document_instance.document_category.name,
#                             'created_at': document_instance.created_at,
#                         })
#                     else:
#                         errors['documents'] = "Invalid MIME type for the document."
#                         return Response({'errors': errors}, status=status.HTTP_400_BAD_REQUEST)
#             except Exception as e:
#                 errors['document_processing'] = f"Error processing document: {str(e)}"
#                 return Response({'errors': errors}, status=status.HTTP_400_BAD_REQUEST)


#     # Return the updated land details
#     response_data = {
#         "land_details": {
#             "id": my_land.id,
#             "name": my_land.name,
#             "measurement_value": my_land.measurement_value,
#             "measurement_unit": my_land.measurement_unit.id,
#             "soil_type": my_land.soil_type.id,
#             "country": my_land.country.id,
#             "state": my_land.state.id,
#             "city": my_land.city.id,
#             "taluk": my_land.taluk.id,
#             "village": my_land.village.id,
#             "door_no": my_land.door_no,
#             "locations": my_land.locations,
#             "latitude": my_land.latitude,
#             "longitude": my_land.longitude,
#             "patta_number": my_land.patta_number,
#             "description": my_land.description,
#             "l_status": my_land.l_status,
#             "survey_details": [
#                 {
#                     "id": survey.id,
#                     "survey_no": survey.survey_no,
#                     "survey_measurement_value": survey.survey_measurement_value,
#                     "survey_measurement_unit": survey.survey_measurement_unit.id
#                 } for survey in my_land.survey_details.all()
#             ],
#             "documents": [
#                 {
#                     "id": doc.id,
#                     "document_category": doc.document_category.id,
#                     "upload_document": doc.upload_document.url if doc.upload_document else None,
#                     "status": doc.status
#                 } for doc in my_land.documents.all()
#             ]
#         }
#     }

#     return Response(response_data, status=status.HTTP_200_OK)
 

# @api_view(['PUT'])
# def update_my_land(request, farmer_id):
     
#     try:
#         farmer_obj = Farmer.objects.get(id=farmer_id)
#     except Farmer.DoesNotExist:
#         return Response({"error": f"Farmer with id {farmer_id} does not exist."}, status=status.HTTP_404_NOT_FOUND)
#     # Fetch the land object
#     land_id = request.data.get('id')
#     if not land_id:
#         return Response({"error": "Land id is required for update"}, status=status.HTTP_400_BAD_REQUEST)
    
#     try:
#         my_land = MyLand.objects.get(id=land_id, farmer_id=farmer_id)
#     except MyLand.DoesNotExist:
#         return Response({"detail": "MyLand not found."}, status=status.HTTP_404_NOT_FOUND)

#     # Handle the update for land fields like soil_type, measurement_unit, etc.
#     soil_type_id = request.data.get('soil_type')
#     if soil_type_id:
#         try:
#             soil_type = SoilType.objects.get(id=soil_type_id)
#             my_land.soil_type = soil_type
#         except SoilType.DoesNotExist:
#             return Response({"error": f"SoilType with id {soil_type_id} does not exist."}, status=status.HTTP_400_BAD_REQUEST)

#     measurement_unit_id = request.data.get('measurement_unit')
#     if measurement_unit_id:
#         try:
#             measurement_unit = LandUnit.objects.get(id=measurement_unit_id)
#             my_land.measurement_unit = measurement_unit
#         except LandUnit.DoesNotExist:
#             return Response({"error": f"LandUnit with id {measurement_unit_id} does not exist."}, status=status.HTTP_400_BAD_REQUEST)

#     country_id = request.data.get('country')
#     if country_id:
#         try:
#             country = Country.objects.get(id=country_id)
#             my_land.country = country
#         except Country.DoesNotExist:
#             return Response({"error": f"Country with id {country_id} does not exist."}, status=status.HTTP_400_BAD_REQUEST)

#     state_id = request.data.get('state')
#     if state_id:
#         try:
#             state = State.objects.get(id=state_id)
#             my_land.state = state
#         except State.DoesNotExist:
#             return Response({"error": f"State with id {state_id} does not exist."}, status=status.HTTP_400_BAD_REQUEST)

#     city_id = request.data.get('city')
#     if city_id:
#         try:
#             city = City.objects.get(id=city_id)
#             my_land.city = city
#         except City.DoesNotExist:
#             return Response({"error": f"City with id {city_id} does not exist."}, status=status.HTTP_400_BAD_REQUEST)

#     taluk_id = request.data.get('taluk')
#     if taluk_id:
#         try:
#             taluk = Taluk.objects.get(id=taluk_id)
#             my_land.taluk = taluk
#         except Taluk.DoesNotExist:
#             return Response({"error": f"Taluk with id {taluk_id} does not exist."}, status=status.HTTP_400_BAD_REQUEST)

#     village_id = request.data.get('village')
#     if village_id:
#         try:
#             village = Village.objects.get(id=village_id)
#             my_land.village = village
#         except Village.DoesNotExist:
#             return Response({"error": f"Village with id {village_id} does not exist."}, status=status.HTTP_400_BAD_REQUEST)
#     translated_json = my_land.translate_json or {
#         'name' : {},
#         "door_no": {},
#         "description": {}
#     }
#     name=request.data.get('name')
    
#     if name != my_land.name:
        
#         try:
#             for lang in target_language:
#                 translated_text = GoogleTranslator(source='auto', target=lang).translate( name)
                
#                 translated_json["name"][lang] = translated_text
#         except Exception as e:
#             print(e)
#             print("Error in translation")

#     door_no=request.data.get('door_no')
#     if door_no != my_land.door_no:
#         try:
#             for lang in target_language:
#                 translated_text = GoogleTranslator(source='auto', target=lang).translate(door_no)
#                 translated_json["door_no"][lang] = translated_text
#         except Exception as e:
#             print(e)
#             print("Error in translation")
#     description=request.data.get('description')
#     if description != my_land.description:
#         try:
#             for lang in target_language:
#                 translated_text = GoogleTranslator(source='auto', target=lang).translate(description)
#                 translated_json["description"][lang] = translated_text
#         except Exception as e:
#             print(e)
#             print("Error in translation")
    

#     # Other fields
#     my_land.id = request.data.get('id', my_land.id)
#     my_land.name = request.data.get('name', my_land.name)
#     my_land.measurement_value = request.data.get('measurement_value', my_land.measurement_value)
#     my_land.door_no = request.data.get('door_no', my_land.door_no)
#     my_land.locations = request.data.get('locations', my_land.locations)
#     my_land.latitude = request.data.get('latitude', my_land.latitude)
#     my_land.longitude = request.data.get('longitude', my_land.longitude)
#     my_land.patta_number = request.data.get('patta_number', my_land.patta_number)
#     my_land.description = request.data.get('description', my_land.description)
#     my_land.l_status = request.data.get('l_status', my_land.l_status)
    
 
#     my_land.updated_at = timezone.now()
#     my_land.updated_by = farmer_obj.farmer_user if farmer_obj.farmer_user else farmer_obj.sub_admin_user
#     my_land.save()

#     notification_message = f"Your land '{my_land.name}' has been successfully updated."
#     FarmerNotification.objects.create(
#         farmer=farmer_obj,
#         name=f"Land Update: {my_land.name}",
#         type="Land Update",
#         message=notification_message,
#         created_at=timezone.now(),
#         is_read=False
#     )

#     # Handle Survey Details (modify the survey data accordingly)
#     survey_details = request.data.get('survey_details', [])
#     for survey_data in survey_details:
#         survey_id = survey_data.get('id')

#         # Handle survey_measurement_unit field as a ForeignKey (LandUnit)
#         survey_measurement_unit_id = survey_data.get('survey_measurement_unit')
#         if survey_measurement_unit_id:
#             try:
#                 land_unit_instance = LandUnit.objects.get(id=survey_measurement_unit_id)
#                 survey_data['survey_measurement_unit'] = land_unit_instance
#             except LandUnit.DoesNotExist:
#                 return Response({"error": f"LandUnit with id {survey_measurement_unit_id} does not exist."}, status=status.HTTP_400_BAD_REQUEST)

#         if survey_id:  # If there's an ID, update the existing survey
#             try:
#                 survey = MyLandSurveyDetails.objects.get(id=survey_id, MyLand=my_land)
#                 # Update the survey fields
#                 survey.survey_no = survey_data.get('survey_no', survey.survey_no)
#                 survey.survey_measurement_value = survey_data.get('survey_measurement_value', survey.survey_measurement_value)
#                 survey.survey_measurement_unit = survey_data.get('survey_measurement_unit', survey.survey_measurement_unit)
#                 survey.save()
#             except MyLandSurveyDetails.DoesNotExist:
#                 return Response({"error": f"Survey with id {survey_id} not found."}, status=status.HTTP_404_NOT_FOUND)
#         else:  # If no ID exists, create a new survey
#             try:
#                 survey_measurement_unit = LandUnit.objects.get(id=survey_measurement_unit_id)
#                 new_survey = MyLandSurveyDetails(
#                     survey_no=survey_data.get('survey_no'),
#                     survey_measurement_value=survey_data.get('survey_measurement_value'),
#                     survey_measurement_unit=survey_measurement_unit,
#                     MyLand=my_land
#                 )
#                 new_survey.save()
#             except LandUnit.DoesNotExist:
#                 return Response({"error": f"LandUnit with id {survey_data['survey_measurement_unit']} does not exist."}, status=status.HTTP_400_BAD_REQUEST)

#     # Handle MyLand Documents (create or update documents)
#     document_details = []
#     errors = {}
#     # Delete documents - Get IDs of documents to delete
#     delete_document_ids = request.data.get('delete_documents', [])
#     if delete_document_ids:
#         for doc_id in delete_document_ids:
#             try:
#                 document = MyLandDocument.objects.get(id=doc_id, myland=my_land)
#                 document.delete()  # Delete document from the database
#             except MyLandDocument.DoesNotExist:
#                 errors['document_deletion'] = f"Document with ID {doc_id} not found."
#                 return Response({'errors': errors}, status=status.HTTP_404_NOT_FOUND)

#     # Add new documents (Upload)
#     # Get documents from request
#     documents_data = request.data.get('documents', [])
#     for doc_data in documents_data:
#         document_id = doc_data.get('id')  # Get document ID if provided
#         file_type_id = doc_data.get('file_type')
#         documents = doc_data.get('documents', [])

#         for document_base64 in documents:
#             try:
#                 if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
#                     # Validate MIME type
#                     mime_type = validate_image_type(document_base64)
#                     if mime_type:
#                         document_data = document_base64.split(';base64,')[1]
#                         document_bytes = base64.b64decode(document_data)
#                         document_name = f"document_{timezone.now().strftime('%Y%m%d%H%M%S')}.{mime_type.split('/')[1]}"
#                         document_file = ContentFile(document_bytes, name=document_name)

#                         document_category = get_object_or_404(DocumentCategory, id=file_type_id)

                       
#                         if document_id:
#                             try:
#                                 document_instance = MyLandDocument.objects.get(id=document_id, myland=my_land)
#                                 document_instance.document_category = document_category  # Update file_type
#                                 document_instance.upload_document = document_file  # Update document
#                                 document_instance.save() 
#                             except MyLandDocument.DoesNotExist:
#                                 return Response({'errors': {'document': f"Document with ID {document_id} not found."}},
#                                                 status=status.HTTP_404_NOT_FOUND)
#                         else:
#                             # Create a new document if ID is not provided
#                             document_instance = MyLandDocument.objects.create(
#                                 farmer=farmer_obj,
#                                 myland=my_land,
#                                 document_category=document_category,
#                                 upload_document=document_file,
#                                 created_at=timezone.now(),
#                                 created_by=farmer_obj.farmer_user
#                             )

#                         # Collect document details for response
#                         document_details.append({
#                             'id': document_instance.id,
#                             'document_name': request.build_absolute_uri(f'/SuperAdmin{document_instance.upload_document.url}' if document_instance.upload_document else " "),
#                             'file_type': document_instance.document_category.name,
#                             'created_at': document_instance.created_at,
#                         })
#                     else:
#                         errors['documents'] = "Invalid MIME type for the document."
#                         return Response({'errors': errors}, status=status.HTTP_400_BAD_REQUEST)
#             except Exception as e:
#                 errors['document_processing'] = f"Error processing document: {str(e)}"
#                 return Response({'errors': errors}, status=status.HTTP_400_BAD_REQUEST)


#     # Return the updated land details
#     response_data = {
#         "land_details": {
#             "id": my_land.id,
#             "name": my_land.name,
#             "measurement_value": my_land.measurement_value,
#             "measurement_unit": my_land.measurement_unit.id,
#             "soil_type": my_land.soil_type.id,
#             "country": my_land.country.id,
#             "state": my_land.state.id,
#             "city": my_land.city.id,
#             "taluk": my_land.taluk.id,
#             "village": my_land.village.id,
#             "door_no": my_land.door_no,
#             "locations": my_land.locations,
#             "latitude": my_land.latitude,
#             "longitude": my_land.longitude,
#             "patta_number": my_land.patta_number,
#             "description": my_land.description,
#             "l_status": my_land.l_status,
#             "survey_details": [
#                 {
#                     "id": survey.id,
#                     "survey_no": survey.survey_no,
#                     "survey_measurement_value": survey.survey_measurement_value,
#                     "survey_measurement_unit": survey.survey_measurement_unit.id
#                 } for survey in my_land.survey_details.all()
#             ],
#             "documents": [
#                 {
#                     "id": doc.id,
#                     "document_category": doc.document_category.id,
#                     "upload_document": doc.upload_document.url if doc.upload_document else None,
#                     "status": doc.status
#                 } for doc in my_land.documents.all()
#             ]
#         }
#     }

#     return Response(response_data, status=status.HTTP_200_OK)
 
# @api_view(['PUT'])
# def update_my_land(request, farmer_id):
#     try:
#         farmer_obj = Farmer.objects.get(id=farmer_id)
#     except Farmer.DoesNotExist:
#         return Response({"error": f"Farmer with id {farmer_id} does not exist."}, status=status.HTTP_404_NOT_FOUND)

#     # Fetch the land object
#     land_id = request.data.get('id')
#     if not land_id:
#         return Response({"error": "Land id is required for update"}, status=status.HTTP_400_BAD_REQUEST)

#     try:
#         my_land = MyLand.objects.get(id=land_id, farmer_id=farmer_id)
#     except MyLand.DoesNotExist:
#         return Response({"detail": "MyLand not found."}, status=status.HTTP_404_NOT_FOUND)

#     # Handle soil_type
#     soil_type_id = request.data.get('soil_type')
#     if soil_type_id:
#         try:
#             soil_type = SoilType.objects.get(id=soil_type_id)
#             my_land.soil_type = soil_type
#         except SoilType.DoesNotExist:
#             return Response({"error": f"SoilType with id {soil_type_id} does not exist."}, status=status.HTTP_400_BAD_REQUEST)

#     # Handle measurement_unit
#     measurement_unit_id = request.data.get('measurement_unit')
#     if measurement_unit_id:
#         try:
#             measurement_unit = LandUnit.objects.get(id=measurement_unit_id)
#             my_land.measurement_unit = measurement_unit
#         except LandUnit.DoesNotExist:
#             return Response({"error": f"LandUnit with id {measurement_unit_id} does not exist."}, status=status.HTTP_400_BAD_REQUEST)

#     # --- Handle country and location fields with name or id ---
#     # Initialize IDs from request data if provided
#     country = request.data.get('country')
#     state = request.data.get('state')
#     city = request.data.get('city')
#     taluk = request.data.get('taluk')
#     village = request.data.get('village')

#     # --- Handle country_name ---
#     country_name = request.data.get('country_name')
#     if country_name and country_name.strip():
#         country_obj, created = Country.objects.get_or_create(name=country_name.strip())
#         country = country_obj.id

#     # --- Handle state_name ---
#     state_name = request.data.get('state_name')
#     if state_name and state_name.strip():
#         country_id_for_state = country if country else None
#         state_obj, created = State.objects.get_or_create(name=state_name.strip(), country_id=country_id_for_state)
#         state = state_obj.id

#     # --- Handle city_name ---
#     city_name = request.data.get('city_name')
#     if city_name and city_name.strip():
#         state_id_for_city = state if state else None
#         country_id_for_city = country if country else None
#         city_obj, created = City.objects.get_or_create(name=city_name.strip(), state_id=state_id_for_city, country_id=country_id_for_city)
#         city = city_obj.id

#     # --- Handle taluk_name ---
#     taluk_name = request.data.get('taluk_name')
#     if taluk_name and taluk_name.strip():
#         city_id_for_taluk = city if city else None
#         state_id_for_taluk = state if state else None
#         country_id_for_taluk = country if country else None
#         taluk_obj, created = Taluk.objects.get_or_create(name=taluk_name.strip(), city_id=city_id_for_taluk, state_id=state_id_for_taluk, country_id=country_id_for_taluk)
#         taluk = taluk_obj.id

#     # --- Handle village_name ---
#     village_name = request.data.get('village_name')
#     if village_name and village_name.strip():
#         taluk_id_for_village = taluk if taluk else None
#         city_id_for_village = city if city else None
#         state_id_for_village = state if state else None
#         country_id_for_village = country if country else None

#         village_obj, created = Village.objects.get_or_create(
#             name=village_name.strip(),
#             taluk_id=taluk_id_for_village,
#             city_id=city_id_for_village,
#             state_id=state_id_for_village,
#             country_id=country_id_for_village,
#         )
#         village = village_obj.id

#     # Assign the location foreign keys to my_land
#     if country:
#         try:
#             my_land.country = Country.objects.get(id=country)
#         except Country.DoesNotExist:
#             return Response({"error": f"Country with id {country} does not exist."}, status=status.HTTP_400_BAD_REQUEST)

#     if state:
#         try:
#             my_land.state = State.objects.get(id=state)
#         except State.DoesNotExist:
#             return Response({"error": f"State with id {state} does not exist."}, status=status.HTTP_400_BAD_REQUEST)

#     if city:
#         try:
#             my_land.city = City.objects.get(id=city)
#         except City.DoesNotExist:
#             return Response({"error": f"City with id {city} does not exist."}, status=status.HTTP_400_BAD_REQUEST)

#     if taluk:
#         try:
#             my_land.taluk = Taluk.objects.get(id=taluk)
#         except Taluk.DoesNotExist:
#             return Response({"error": f"Taluk with id {taluk} does not exist."}, status=status.HTTP_400_BAD_REQUEST)

#     if village:
#         try:
#             my_land.village = Village.objects.get(id=village)
#         except Village.DoesNotExist:
#             return Response({"error": f"Village with id {village} does not exist."}, status=status.HTTP_400_BAD_REQUEST)

#     # Translation handling
#     translated_json = my_land.translate_json or {
#         'name': {},
#         "door_no": {},
#         "description": {}
#     }

#     target_language = ['hi', 'ta', 'te', 'kn', 'ml']  # Example target languages

#     # Translate name
#     name = request.data.get('name')
#     if name != my_land.name and name is not None:
#         try:
#             for lang in target_language:
#                 translated_text = GoogleTranslator(source='auto', target=lang).translate(name)
#                 translated_json["name"][lang] = translated_text
#         except Exception as e:
#             print(e)
#             print("Error in translation")

#     # Translate door_no
#     door_no = request.data.get('door_no')
#     if door_no != my_land.door_no and door_no is not None:
#         try:
#             for lang in target_language:
#                 translated_text = GoogleTranslator(source='auto', target=lang).translate(door_no)
#                 translated_json["door_no"][lang] = translated_text
#         except Exception as e:
#             print(e)
#             print("Error in translation")

#     # Translate description
#     description = request.data.get('description')
#     if description != my_land.description and description is not None:
#         try:
#             for lang in target_language:
#                 translated_text = GoogleTranslator(source='auto', target=lang).translate(description)
#                 translated_json["description"][lang] = translated_text
#         except Exception as e:
#             print(e)
#             print("Error in translation")

#     my_land.translate_json = translated_json

#     # Update other fields
#     my_land.id = request.data.get('id', my_land.id)
#     my_land.name = name if name is not None else my_land.name
#     my_land.measurement_value = request.data.get('measurement_value', my_land.measurement_value)
#     my_land.door_no = door_no if door_no is not None else my_land.door_no
#     my_land.locations = request.data.get('locations', my_land.locations)
#     my_land.geo_marks = request.data.get('geo_marks', my_land.geo_marks)
#     my_land.latitude = request.data.get('latitude', my_land.latitude)
#     my_land.longitude = request.data.get('longitude', my_land.longitude)
#     my_land.patta_number = request.data.get('patta_number', my_land.patta_number)
#     my_land.description = description if description is not None else my_land.description
#     my_land.l_status = request.data.get('l_status', my_land.l_status)

#     my_land.updated_at = timezone.now()
#     my_land.updated_by = farmer_obj.farmer_user if farmer_obj.farmer_user else farmer_obj.sub_admin_user
#     my_land.save()

#     notification_message = f"Your land '{my_land.name}' has been successfully updated."
#     FarmerNotification.objects.create(
#         farmer=farmer_obj,
#         name=f"Land Update: {my_land.name}",
#         type="Land Update",
#         message=notification_message,
#         created_at=timezone.now(),
#         is_read=False
#     )

#     # Handle Survey Details
#     survey_details = request.data.get('survey_details', [])
#     for survey_data in survey_details:
#         survey_id = survey_data.get('id')

#         survey_measurement_unit_id = survey_data.get('survey_measurement_unit')
#         if survey_measurement_unit_id:
#             try:
#                 land_unit_instance = LandUnit.objects.get(id=survey_measurement_unit_id)
#                 survey_data['survey_measurement_unit'] = land_unit_instance
#             except LandUnit.DoesNotExist:
#                 return Response({"error": f"LandUnit with id {survey_measurement_unit_id} does not exist."}, status=status.HTTP_400_BAD_REQUEST)

#         if survey_id:
#             try:
#                 survey = MyLandSurveyDetails.objects.get(id=survey_id, MyLand=my_land)
#                 survey.survey_no = survey_data.get('survey_no', survey.survey_no)
#                 survey.survey_measurement_value = survey_data.get('survey_measurement_value', survey.survey_measurement_value)
#                 survey.survey_measurement_unit = survey_data.get('survey_measurement_unit', survey.survey_measurement_unit)
#                 survey.save()
#             except MyLandSurveyDetails.DoesNotExist:
#                 return Response({"error": f"Survey with id {survey_id} not found."}, status=status.HTTP_404_NOT_FOUND)
#         else:
#             try:
#                 survey_measurement_unit = LandUnit.objects.get(id=survey_measurement_unit_id)
#                 new_survey = MyLandSurveyDetails(
#                     survey_no=survey_data.get('survey_no'),
#                     survey_measurement_value=survey_data.get('survey_measurement_value'),
#                     survey_measurement_unit=survey_measurement_unit,
#                     MyLand=my_land
#                 )
#                 new_survey.save()
#             except LandUnit.DoesNotExist:
#                 return Response({"error": f"LandUnit with id {survey_data['survey_measurement_unit']} does not exist."}, status=status.HTTP_400_BAD_REQUEST)

#     # Handle MyLand Documents
#     document_details = []
#     errors = {}

#     delete_document_ids = request.data.get('delete_documents', [])
#     if delete_document_ids:
#         for doc_id in delete_document_ids:
#             try:
#                 document = MyLandDocument.objects.get(id=doc_id, myland=my_land)
#                 document.delete()
#             except MyLandDocument.DoesNotExist:
#                 errors['document_deletion'] = f"Document with ID {doc_id} not found."
#                 return Response({'errors': errors}, status=status.HTTP_404_NOT_FOUND)

#     documents_data = request.data.get('documents', [])
#     for doc_data in documents_data:
#         document_id = doc_data.get('id')
#         file_type_id = doc_data.get('file_type')
#         documents = doc_data.get('documents', [])

#         for document_base64 in documents:
#             try:
#                 if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
#                     mime_type = validate_image_type(document_base64)
#                     if mime_type:
#                         document_data = document_base64.split(';base64,')[1]
#                         document_bytes = base64.b64decode(document_data)
#                         document_name = f"document_{timezone.now().strftime('%Y%m%d%H%M%S')}.{mime_type.split('/')[1]}"
#                         document_file = ContentFile(document_bytes, name=document_name)

#                         document_category = get_object_or_404(DocumentCategory, id=file_type_id)

#                         if document_id:
#                             try:
#                                 document_instance = MyLandDocument.objects.get(id=document_id, myland=my_land)
#                                 document_instance.document_category = document_category
#                                 document_instance.upload_document = document_file
#                                 document_instance.save()
#                             except MyLandDocument.DoesNotExist:
#                                 return Response({'errors': {'document': f"Document with ID {document_id} not found."}}, status=status.HTTP_404_NOT_FOUND)
#                         else:
#                             document_instance = MyLandDocument.objects.create(
#                                 farmer=farmer_obj,
#                                 myland=my_land,
#                                 document_category=document_category,
#                                 upload_document=document_file,
#                                 created_at=timezone.now(),
#                                 created_by=farmer_obj.farmer_user
#                             )

#                         document_details.append({
#                             'id': document_instance.id,
#                             'document_name': request.build_absolute_uri(f'/SuperAdmin{document_instance.upload_document.url}' if document_instance.upload_document else " "),
#                             'file_type': document_instance.document_category.name,
#                             'created_at': document_instance.created_at,
#                         })
#                     else:
#                         errors['documents'] = "Invalid MIME type for the document."
#                         return Response({'errors': errors}, status=status.HTTP_400_BAD_REQUEST)
#             except Exception as e:
#                 errors['document_processing'] = f"Error processing document: {str(e)}"
#                 return Response({'errors': errors}, status=status.HTTP_400_BAD_REQUEST)

#     # Return updated land details
#     response_data = {
#         "land_details": {
#             "id": my_land.id,
#             "name": my_land.name,
#             "measurement_value": my_land.measurement_value,
#             "measurement_unit": my_land.measurement_unit.id if my_land.measurement_unit else None,
#             "soil_type": my_land.soil_type.id if my_land.soil_type else None,
#             "country": my_land.country.id if my_land.country else None,
#             "state": my_land.state.id if my_land.state else None,
#             "city": my_land.city.id if my_land.city else None,
#             "taluk": my_land.taluk.id if my_land.taluk else None,
#             "village": my_land.village.id if my_land.village else None,
#             "door_no": my_land.door_no,
#             "locations": my_land.locations,
#             "latitude": my_land.latitude,
#             "longitude": my_land.longitude,
#             "geo_marks": my_land.geo_marks,
#             "patta_number": my_land.patta_number,
#             "description": my_land.description,
#             "l_status": my_land.l_status,
#             "survey_details": [
#                 {
#                     "id": survey.id,
#                     "survey_no": survey.survey_no,
#                     "survey_measurement_value": survey.survey_measurement_value,
#                     "survey_measurement_unit": survey.survey_measurement_unit.id if survey.survey_measurement_unit else None
#                 } for survey in my_land.survey_details.all()
#             ],
#             "documents": [
#                 {
#                     "id": doc.id,
#                     "document_category": doc.document_category.id,
#                     "upload_document": doc.upload_document.url if doc.upload_document else None,
#                     "status": doc.status
#                 } for doc in my_land.documents.all()
#             ]
#         }
#     }

#     return Response(response_data, status=status.HTTP_200_OK)

# @api_view(['PUT'])
# def update_my_land(request, farmer_id):
#     try:
#         farmer_obj = Farmer.objects.get(id=farmer_id)
#     except Farmer.DoesNotExist:
#         return Response({"error": f"Farmer with id {farmer_id} does not exist."}, status=status.HTTP_404_NOT_FOUND)

#     land_id = request.data.get('id')
#     if not land_id:
#         return Response({"error": "Land id is required for update"}, status=status.HTTP_400_BAD_REQUEST)

#     try:
#         my_land = MyLand.objects.get(id=land_id, farmer_id=farmer_id)
#     except MyLand.DoesNotExist:
#         return Response({"detail": "MyLand not found."}, status=status.HTTP_404_NOT_FOUND)

#     # Handle soil_type
#     soil_type_id = request.data.get('soil_type')
#     if soil_type_id:
#         try:
#             soil_type = SoilType.objects.get(id=soil_type_id)
#             my_land.soil_type = soil_type
#         except SoilType.DoesNotExist:
#             return Response({"error": f"SoilType with id {soil_type_id} does not exist."}, status=status.HTTP_400_BAD_REQUEST)

#     # Handle measurement_unit
#     measurement_unit_id = request.data.get('measurement_unit')
#     if measurement_unit_id:
#         try:
#             measurement_unit = LandUnit.objects.get(id=measurement_unit_id)
#             my_land.measurement_unit = measurement_unit
#         except LandUnit.DoesNotExist:
#             return Response({"error": f"LandUnit with id {measurement_unit_id} does not exist."}, status=status.HTTP_400_BAD_REQUEST)

#     # Location handling
#     country = request.data.get('country')
#     state = request.data.get('state')
#     city = request.data.get('city')
#     taluk = request.data.get('taluk')
#     village = request.data.get('village')

#     # Country by name
#     country_name = request.data.get('country_name')
#     if country_name and country_name.strip():
#         country_obj, _ = Country.objects.get_or_create(name=country_name.strip())
#         country = country_obj.id

#     # State by name
#     state_name = request.data.get('state_name')
#     if state_name and state_name.strip():
#         country_for_state = country if country else None
#         state_obj, _ = State.objects.get_or_create(name=state_name.strip(), country_id=country_for_state)
#         state = state_obj.id

#     # City by name
#     city_name = request.data.get('city_name')
#     if city_name and city_name.strip():
#         state_for_city = state if state else None
#         country_for_city = country if country else None
#         city_obj, _ = City.objects.get_or_create(name=city_name.strip(), state_id=state_for_city, country_id=country_for_city)
#         city = city_obj.id

#     # Taluk by name
#     taluk_name = request.data.get('taluk_name')
#     if taluk_name and taluk_name.strip():
#         city_for_taluk = city if city else None
#         state_for_taluk = state if state else None
#         country_for_taluk = country if country else None
#         taluk_obj, _ = Taluk.objects.get_or_create(name=taluk_name.strip(), city_id=city_for_taluk, state_id=state_for_taluk, country_id=country_for_taluk)
#         taluk = taluk_obj.id

#     # Village by name
#     village_name = request.data.get('village_name')
#     if village_name and village_name.strip():
#         taluk_for_village = taluk if taluk else None
#         city_for_village = city if city else None
#         state_for_village = state if state else None
#         country_for_village = country if country else None
#         village_obj, _ = Village.objects.get_or_create(
#             name=village_name.strip(),
#             taluk_id=taluk_for_village,
#             city_id=city_for_village,
#             state_id=state_for_village,
#             country_id=country_for_village,
#         )
#         village = village_obj.id

#     # Assign location foreign keys
#     if country:
#         try:
#             my_land.country = Country.objects.get(id=country)
#         except Country.DoesNotExist:
#             return Response({"error": f"Country with id {country} does not exist."}, status=status.HTTP_400_BAD_REQUEST)

#     if state:
#         try:
#             my_land.state = State.objects.get(id=state)
#         except State.DoesNotExist:
#             return Response({"error": f"State with id {state} does not exist."}, status=status.HTTP_400_BAD_REQUEST)

#     if city:
#         try:
#             my_land.city = City.objects.get(id=city)
#         except City.DoesNotExist:
#             return Response({"error": f"City with id {city} does not exist."}, status=status.HTTP_400_BAD_REQUEST)

#     if taluk:
#         try:
#             my_land.taluk = Taluk.objects.get(id=taluk)
#         except Taluk.DoesNotExist:
#             return Response({"error": f"Taluk with id {taluk} does not exist."}, status=status.HTTP_400_BAD_REQUEST)

#     if village:
#         try:
#             my_land.village = Village.objects.get(id=village)
#         except Village.DoesNotExist:
#             return Response({"error": f"Village with id {village} does not exist."}, status=status.HTTP_400_BAD_REQUEST)

#     # Translation handling
#     translated_json = my_land.translate_json or {
#         'name': {},
#         "door_no": {},
#         "description": {}
#     }
#     target_languages = ['hi', 'ta', 'te', 'kn', 'ml']

#     def translate_field(field_name, new_value, old_value):
#         if new_value is not None and new_value != old_value:
#             for lang in target_languages:
#                 try:
#                     translated_text = GoogleTranslator(source='auto', target=lang).translate(new_value)
#                     translated_json[field_name][lang] = translated_text
#                 except Exception as e:
#                     print(f"Translation error for {field_name} to {lang}: {e}")

#     name = request.data.get('name')
#     translate_field('name', name, my_land.name)

#     door_no = request.data.get('door_no')
#     translate_field('door_no', door_no, my_land.door_no)

#     description = request.data.get('description')
#     translate_field('description', description, my_land.description)

#     my_land.translate_json = translated_json

#     # Update other fields
#     my_land.name = name if name is not None else my_land.name
#     my_land.measurement_value = request.data.get('measurement_value', my_land.measurement_value)
#     my_land.door_no = door_no if door_no is not None else my_land.door_no
#     my_land.locations = request.data.get('locations', my_land.locations)

#     # Validate geo_marks format
#     geo_marks = request.data.get('geo_marks', None)
#     if geo_marks is not None:
#         if not isinstance(geo_marks, list):
#             return Response({"error": "geo_marks must be a list."}, status=status.HTTP_400_BAD_REQUEST)
#         for point in geo_marks:
#             if not isinstance(point, dict) or 'lat' not in point or 'lng' not in point:
#                 return Response({
#                     "error": "Each geo_mark must be a dict with 'lat' and 'lng' keys."
#                 }, status=status.HTTP_400_BAD_REQUEST)
#     my_land.geo_marks = geo_marks if geo_marks is not None else my_land.geo_marks

#     my_land.latitude = request.data.get('latitude', my_land.latitude)
#     my_land.longitude = request.data.get('longitude', my_land.longitude)
#     my_land.patta_number = request.data.get('patta_number', my_land.patta_number)
#     my_land.description = description if description is not None else my_land.description
#     my_land.l_status = request.data.get('l_status', my_land.l_status)

#     my_land.updated_at = timezone.now()
#     my_land.updated_by = farmer_obj.farmer_user if farmer_obj.farmer_user else farmer_obj.sub_admin_user
#     my_land.save()

#     # Create notification
#     notification_message = f"Your land '{my_land.name}' has been successfully updated."
#     FarmerNotification.objects.create(
#         farmer=farmer_obj,
#         name=f"Land Update: {my_land.name}",
#         type="Land Update",
#         message=notification_message,
#         created_at=timezone.now(),
#         is_read=False
#     )

#     # Handle Survey Details
#     survey_details = request.data.get('survey_details', [])
#     for survey_data in survey_details:
#         survey_id = survey_data.get('id')
#         survey_measurement_unit_id = survey_data.get('survey_measurement_unit')

#         if survey_measurement_unit_id:
#             try:
#                 land_unit_instance = LandUnit.objects.get(id=survey_measurement_unit_id)
#             except LandUnit.DoesNotExist:
#                 return Response({"error": f"LandUnit with id {survey_measurement_unit_id} does not exist."}, status=status.HTTP_400_BAD_REQUEST)
#         else:
#             land_unit_instance = None

#         if survey_id:
#             try:
#                 survey = MyLandSurveyDetails.objects.get(id=survey_id, my_land=my_land)
#                 survey.survey_no = survey_data.get('survey_no', survey.survey_no)
#                 survey.survey_measurement_value = survey_data.get('survey_measurement_value', survey.survey_measurement_value)
#                 if land_unit_instance:
#                     survey.survey_measurement_unit = land_unit_instance
#                 survey.save()
#             except MyLandSurveyDetails.DoesNotExist:
#                 return Response({"error": f"Survey with id {survey_id} not found."}, status=status.HTTP_404_NOT_FOUND)
#         else:
#             if not land_unit_instance:
#                 return Response({"error": "survey_measurement_unit is required for new survey details."}, status=status.HTTP_400_BAD_REQUEST)
#             new_survey = MyLandSurveyDetails(
#                 survey_no=survey_data.get('survey_no'),
#                 survey_measurement_value=survey_data.get('survey_measurement_value'),
#                 survey_measurement_unit=land_unit_instance,
#                 my_land=my_land
#             )
#             new_survey.save()

#     # Handle MyLand Documents
#     errors = {}

#     delete_document_ids = request.data.get('delete_documents', [])
#     for doc_id in delete_document_ids:
#         try:
#             document = MyLandDocument.objects.get(id=doc_id, myland=my_land)
#             document.delete()
#         except MyLandDocument.DoesNotExist:
#             errors['document_deletion'] = f"Document with ID {doc_id} not found."
#             return Response({'errors': errors}, status=status.HTTP_404_NOT_FOUND)

#     documents_data = request.data.get('documents', [])
#     for doc_data in documents_data:
#         document_id = doc_data.get('id')
#         file_type_id = doc_data.get('file_type')
#         documents = doc_data.get('documents', [])

#         for document_base64 in documents:
#             try:
#                 if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
#                     mime_type = validate_image_type(document_base64)
#                     if not mime_type:
#                         errors['documents'] = "Invalid MIME type for the document."
#                         return Response({'errors': errors}, status=status.HTTP_400_BAD_REQUEST)

#                     document_data = document_base64.split(';base64,')[1]
#                     document_bytes = base64.b64decode(document_data)
#                     ext = mime_type.split('/')[1]
#                     document_name = f"document_{timezone.now().strftime('%Y%m%d%H%M%S%f')}.{ext}"
#                     document_file = ContentFile(document_bytes, name=document_name)

#                     document_category = get_object_or_404(DocumentCategory, id=file_type_id)

#                     if document_id:
#                         try:
#                             document_instance = MyLandDocument.objects.get(id=document_id, myland=my_land)
#                             document_instance.document_category = document_category
#                             document_instance.upload_document = document_file
#                             document_instance.save()
#                         except MyLandDocument.DoesNotExist:
#                             return Response({'errors': {'document': f"Document with ID {document_id} not found."}}, status=status.HTTP_404_NOT_FOUND)
#                     else:
#                         document_instance = MyLandDocument.objects.create(
#                             farmer=farmer_obj,
#                             myland=my_land,
#                             document_category=document_category,
#                             upload_document=document_file,
#                             created_at=timezone.now(),
#                             created_by=farmer_obj.farmer_user
#                         )
#                 else:
#                     errors['documents'] = "Document must be an image or PDF encoded in base64."
#                     return Response({'errors': errors}, status=status.HTTP_400_BAD_REQUEST)
#             except Exception as e:
#                 errors['document_processing'] = f"Error processing document: {str(e)}"
#                 return Response({'errors': errors}, status=status.HTTP_400_BAD_REQUEST)

#     # Prepare response data
#     response_data = {
#         "land_details": {
#             "id": my_land.id,
#             "name": my_land.name,
#             "measurement_value": my_land.measurement_value,
#             "measurement_unit": my_land.measurement_unit.id if my_land.measurement_unit else None,
#             "soil_type": my_land.soil_type.id if my_land.soil_type else None,
#             "country": my_land.country.id if my_land.country else None,
#             "state": my_land.state.id if my_land.state else None,
#             "city": my_land.city.id if my_land.city else None,
#             "taluk": my_land.taluk.id if my_land.taluk else None,
#             "village": my_land.village.id if my_land.village else None,
#             "door_no": my_land.door_no,
#             "locations": my_land.locations,
#             "latitude": my_land.latitude,
#             "longitude": my_land.longitude,
#             "geo_marks": my_land.geo_marks,
#             "patta_number": my_land.patta_number,
#             "description": my_land.description,
#             "l_status": my_land.l_status,
#             "survey_details": [
#                 {
#                     "id": survey.id,
#                     "survey_no": survey.survey_no,
#                     "survey_measurement_value": survey.survey_measurement_value,
#                     "survey_measurement_unit": survey.survey_measurement_unit.id if survey.survey_measurement_unit else None
#                 } for survey in my_land.survey_details.all()
#             ],
#             "documents": [
#                 {
#                     "id": doc.id,
#                     "document_category": doc.document_category.id,
#                     "upload_document": request.build_absolute_uri(doc.upload_document.url) if doc.upload_document else None,
#                     "status": doc.status
#                 } for doc in my_land.documents.all()
#             ]
#         }
#     }

#     return Response(response_data, status=status.HTTP_200_OK)

import base64
import re
from django.core.files.base import ContentFile
from django.shortcuts import get_object_or_404
from rest_framework.decorators import api_view
from rest_framework.response import Response
from rest_framework import status
from django.utils import timezone
from deep_translator import GoogleTranslator


@api_view(['PUT'])
def update_my_land(request, farmer_id):
    try:
        farmer_obj = Farmer.objects.get(id=farmer_id)
    except Farmer.DoesNotExist:
        return Response({"error": f"Farmer with id {farmer_id} does not exist."}, status=status.HTTP_404_NOT_FOUND)

    land_id = request.data.get('id')
    if not land_id:
        return Response({"error": "Land id is required for update"}, status=status.HTTP_400_BAD_REQUEST)

    try:
        my_land = MyLand.objects.get(id=land_id, farmer_id=farmer_id)
    except MyLand.DoesNotExist:
        return Response({"detail": "MyLand not found."}, status=status.HTTP_404_NOT_FOUND)

    # Handle soil_type
    soil_type_id = request.data.get('soil_type')
    if soil_type_id:
        try:
            soil_type = SoilType.objects.get(id=soil_type_id)
            my_land.soil_type = soil_type
        except SoilType.DoesNotExist:
            return Response({"error": f"SoilType with id {soil_type_id} does not exist."}, status=status.HTTP_400_BAD_REQUEST)

    # Handle measurement_unit
    measurement_unit_id = request.data.get('measurement_unit')
    if measurement_unit_id:
        try:
            measurement_unit = LandUnit.objects.get(id=measurement_unit_id)
            my_land.measurement_unit = measurement_unit
        except LandUnit.DoesNotExist:
            return Response({"error": f"LandUnit with id {measurement_unit_id} does not exist."}, status=status.HTTP_400_BAD_REQUEST)

    # Remove all country/state/city/taluk/village fields from update

    # Parse latitude and longitude from locations URL if provided
    locations = request.data.get('locations', my_land.locations)
    latitude = request.data.get('latitude')
    longitude = request.data.get('longitude')

    if locations:
        try:
            match = re.search(r'@(-?\d+\.\d+),(-?\d+\.\d+)', locations)
            if match:
                latitude = float(match.group(1))
                longitude = float(match.group(2))
        except Exception:
            # Ignore extraction failure; fallback to given latitude/longitude if any
            pass

    if latitude is not None:
        my_land.latitude = latitude
    if longitude is not None:
        my_land.longitude = longitude

    # Translation handling
    translated_json = my_land.translate_json or {
        'name': {},
        "door_no": {},
        "description": {}
    }
    target_languages = ['hi', 'ta', 'te', 'kn', 'ml']

    def translate_field(field_name, new_value, old_value):
        if new_value is not None and new_value != old_value:
            for lang in target_languages:
                try:
                    translated_text = GoogleTranslator(source='auto', target=lang).translate(new_value)
                    translated_json[field_name][lang] = translated_text
                except Exception as e:
                    print(f"Translation error for {field_name} to {lang}: {e}")

    name = request.data.get('name')
    translate_field('name', name, my_land.name)

    door_no = request.data.get('door_no')
    translate_field('door_no', door_no, my_land.door_no)

    description = request.data.get('description')
    translate_field('description', description, my_land.description)

    my_land.translate_json = translated_json

    # Update other fields
    my_land.name = name if name is not None else my_land.name
    my_land.measurement_value = request.data.get('measurement_value', my_land.measurement_value)
    my_land.door_no = door_no if door_no is not None else my_land.door_no
    my_land.locations = locations if locations is not None else my_land.locations

    # Validate geo_marks format
    geo_marks = request.data.get('geo_marks', None)
    if geo_marks is not None:
        if not isinstance(geo_marks, list):
            return Response({"error": "geo_marks must be a list."}, status=status.HTTP_400_BAD_REQUEST)
        for point in geo_marks:
            if not isinstance(point, dict) or 'lat' not in point or 'lng' not in point:
                return Response({
                    "error": "Each geo_mark must be a dict with 'lat' and 'lng' keys."
                }, status=status.HTTP_400_BAD_REQUEST)
        my_land.geo_marks = geo_marks

    my_land.patta_number = request.data.get('patta_number', my_land.patta_number)
    my_land.description = description if description is not None else my_land.description
    my_land.l_status = request.data.get('l_status', my_land.l_status)

    my_land.updated_at = timezone.now()
    my_land.updated_by = farmer_obj.farmer_user if farmer_obj.farmer_user else farmer_obj.sub_admin_user
    my_land.save()

    # Create notification
    notification_message = f"Your land '{my_land.name}' has been successfully updated."
    FarmerNotification.objects.create(
        farmer=farmer_obj,
        name=f"Land Update: {my_land.name}",
        type="Land Update",
        message=notification_message,
        created_at=timezone.now(),
        is_read=False
    )

    # Handle Survey Details
    survey_details = request.data.get('survey_details', [])
    for survey_data in survey_details:
        survey_id = survey_data.get('id')
        survey_measurement_unit_id = survey_data.get('survey_measurement_unit')

        if survey_measurement_unit_id:
            try:
                land_unit_instance = LandUnit.objects.get(id=survey_measurement_unit_id)
            except LandUnit.DoesNotExist:
                return Response({"error": f"LandUnit with id {survey_measurement_unit_id} does not exist."}, status=status.HTTP_400_BAD_REQUEST)
        else:
            land_unit_instance = None

        if survey_id:
            try:
                survey = MyLandSurveyDetails.objects.get(id=survey_id, my_land=my_land)
                survey.survey_no = survey_data.get('survey_no', survey.survey_no)
                survey.survey_measurement_value = survey_data.get('survey_measurement_value', survey.survey_measurement_value)
                if land_unit_instance:
                    survey.survey_measurement_unit = land_unit_instance
                survey.save()
            except MyLandSurveyDetails.DoesNotExist:
                return Response({"error": f"Survey with id {survey_id} not found."}, status=status.HTTP_404_NOT_FOUND)
        else:
            if not land_unit_instance:
                return Response({"error": "survey_measurement_unit is required for new survey details."}, status=status.HTTP_400_BAD_REQUEST)
            new_survey = MyLandSurveyDetails(
                survey_no=survey_data.get('survey_no'),
                survey_measurement_value=survey_data.get('survey_measurement_value'),
                survey_measurement_unit=land_unit_instance,
                my_land=my_land
            )
            new_survey.save()

    # Handle MyLand Documents
    errors = {}

    delete_document_ids = request.data.get('delete_documents', [])
    for doc_id in delete_document_ids:
        try:
            document = MyLandDocument.objects.get(id=doc_id, myland=my_land)
            document.delete()
        except MyLandDocument.DoesNotExist:
            errors['document_deletion'] = f"Document with ID {doc_id} not found."
            return Response({'errors': errors}, status=status.HTTP_404_NOT_FOUND)

    documents_data = request.data.get('documents', [])
    for doc_data in documents_data:
        document_id = doc_data.get('id')
        file_type_id = doc_data.get('file_type')
        documents = doc_data.get('documents', [])

        for document_base64 in documents:
            try:
                if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
                    mime_type = validate_image_type(document_base64)
                    if not mime_type:
                        errors['documents'] = "Invalid MIME type for the document."
                        return Response({'errors': errors}, status=status.HTTP_400_BAD_REQUEST)

                    document_data = document_base64.split(';base64,')[1]
                    document_bytes = base64.b64decode(document_data)
                    ext = mime_type.split('/')[1]
                    document_name = f"document_{timezone.now().strftime('%Y%m%d%H%M%S%f')}.{ext}"
                    document_file = ContentFile(document_bytes, name=document_name)

                    document_category = get_object_or_404(DocumentCategory, id=file_type_id)

                    if document_id:
                        try:
                            document_instance = MyLandDocument.objects.get(id=document_id, myland=my_land)
                            document_instance.document_category = document_category
                            document_instance.upload_document = document_file
                            document_instance.save()
                        except MyLandDocument.DoesNotExist:
                            return Response({'errors': {'document': f"Document with ID {document_id} not found."}}, status=status.HTTP_404_NOT_FOUND)
                    else:
                        document_instance = MyLandDocument.objects.create(
                            farmer=farmer_obj,
                            myland=my_land,
                            document_category=document_category,
                            upload_document=document_file,
                            created_at=timezone.now(),
                            created_by=farmer_obj.farmer_user
                        )
                else:
                    errors['documents'] = "Document must be an image or PDF encoded in base64."
                    return Response({'errors': errors}, status=status.HTTP_400_BAD_REQUEST)
            except Exception as e:
                errors['document_processing'] = f"Error processing document: {str(e)}"
                return Response({'errors': errors}, status=status.HTTP_400_BAD_REQUEST)

    # Prepare response data WITHOUT country/state/city/taluk/village and without count
    response_data = {
        "land_details": {
            "id": my_land.id,
            "name": my_land.name,
            "measurement_value": my_land.measurement_value,
            "measurement_unit": my_land.measurement_unit.id if my_land.measurement_unit else None,
            "soil_type": my_land.soil_type.id if my_land.soil_type else None,
            "door_no": my_land.door_no,
            "locations": my_land.locations,
            "latitude": my_land.latitude,
            "longitude": my_land.longitude,
            "geo_marks": my_land.geo_marks,
            "patta_number": my_land.patta_number,
            "description": my_land.description,
            "l_status": my_land.l_status,
            "survey_details": [
                {
                    "id": survey.id,
                    "survey_no": survey.survey_no,
                    "survey_measurement_value": survey.survey_measurement_value,
                    "survey_measurement_unit": survey.survey_measurement_unit.id if survey.survey_measurement_unit else None
                } for survey in my_land.survey_details.all()
            ],
            "documents": [
                {
                    "id": doc.id,
                    "document_category": doc.document_category.id,
                    "upload_document": request.build_absolute_uri(doc.upload_document.url) if doc.upload_document else None,
                    "status": doc.status
                } for doc in my_land.documents.all()
            ]
        }
    }

    return Response(response_data, status=status.HTTP_200_OK)


@api_view(['POST'])
def get_schedules_by_month(request, farmer_id): 
    # Get year and month from the request body
    year = request.data.get('year')
    month = request.data.get('month')

    # If year or month is not provided, return an error message
    if not year or not month:
        return JsonResponse({
            "success": False,
            "message": "Please provide both year and month in the request body."
        }, status=400)

    try:
        year = int(year)  # Ensure year is an integer
        month = int(month)  # Ensure month is an integer
    except ValueError:
        return JsonResponse({
            "success": False,
            "message": "Invalid year or month value. Please provide valid integers."
        }, status=400)

    # Fetch schedules based on farmer_id, year, and month, and filter by status 0 (active status)
    schedules = MySchedule.objects.filter(
        farmer_id=farmer_id,
        start_date__year=year,
        start_date__month=month,
        status=0
    ).select_related('my_crop')  # Efficiently fetch related crop data

    # Group schedules by date
    grouped_schedules = {}

    for schedule in schedules:
        date_str = schedule.start_date.strftime('%b %d')  # Format the date as "Jan 20"
        day_str = schedule.start_date.strftime('%a')     # Format the day as "Mon"
        
        crop = schedule.my_crop
        crop_data = {
            "id": crop.id,
            "crop_type": crop.crop.name,  # Assuming crop has a name field
            "description": crop.description
        }

        # Ensure the date group exists before appending crop data
        if date_str not in grouped_schedules:
            grouped_schedules[date_str] = {
                "Date": date_str,
                "Day": day_str,
                "crop": []  # Initialize an empty list for crops
            }

        # Append the crop data to the date group
        grouped_schedules[date_str]["crop"].append(crop_data)

    # Convert grouped schedules into a list for the response
    result = list(grouped_schedules.values())

    return JsonResponse({"success": True, "data": result}, safe=False)

SUPPORTED_LANGUAGES = ['en', 'ta', 'hi']

# @api_view(['GET'])
# def helpdesk_list(request): 
#     try:
#         # Query all HelpDesk objects
#         helpdesks = HelpDesk.objects.all() 
#         helpdesk_data = []
#         for helpdesk in helpdesks:
#             helpdesk_data.append({
#                 'id': helpdesk.id, 
#                 'name': helpdesk.name,
#                 'number': helpdesk.number, 
#                 'language':{
#                     "default":"en"
#                 }
#             })

#         # Return the data in the response
#         return Response(helpdesk_data, status=status.HTTP_200_OK)
    
#     except HelpDesk.DoesNotExist:
#         return Response({"detail": "No helpdesk entries found."}, status=status.HTTP_404_NOT_FOUND)
 
# @api_view(['GET'])
# def helpdesk_list(request): 
#     # Default language
#     language_code = 'en'

#     # 1. Check for 'lang' in query params (e.g., ?lang=ta)
#     lang_param = request.GET.get('lang')
#     if lang_param in SUPPORTED_LANGUAGES:
#         language_code = lang_param

#     # 2. Else, try to get from user's language preference (if authenticated)
#     elif request.user.is_authenticated:
#         try:
#             user_language_pref = UserLanguagePreference.objects.get(user=request.user)
#             if user_language_pref.language_code in SUPPORTED_LANGUAGES:
#                 language_code = user_language_pref.language_code
#         except UserLanguagePreference.DoesNotExist:
#             pass  # keep default 'en'

#     try:
#         # Query all HelpDesk objects
#         helpdesks = HelpDesk.objects.all()
#         helpdesk_data = []

#         for helpdesk in helpdesks:
#             name = helpdesk.get_translated_value("name", language_code)
#             helpdesk_data.append({
#                 'id': helpdesk.id,
#                 'name': name,
#                 'number': helpdesk.number,
#                 'language': {
#                     'default': 'en'
#                 }
#             })

#         return Response(helpdesk_data, status=status.HTTP_200_OK)

#     except Exception as e:
#         return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
@api_view(['GET'])
def helpdesk_list(request): 
    try:
        language_code = request.GET.get("lang", "en")
        # Query all HelpDesk objects
        helpdesks = HelpDesk.objects.all() 
        helpdesk_data = []
        for helpdesk in helpdesks:
            translated_name = helpdesk.get_translated_value('name', language_code)
            helpdesk_data.append({
                'id': helpdesk.id, 
                'name': translated_name,
                'number': helpdesk.number, 
                'language':{
                    "default":"en"
                }
            })

        # Return the data in the response
        return Response(helpdesk_data, status=status.HTTP_200_OK)
    
    except HelpDesk.DoesNotExist:
        return Response({"detail": "No helpdesk entries found."}, status=status.HTTP_404_NOT_FOUND)



# @api_view(['POST'])
# def add_vehicle(request, farmer_id):
#     # Fetch the farmer instance based on the farmer_id
#     farmer = get_object_or_404(Farmer, id=farmer_id)

#     # Create a mutable copy of the data to ensure we can modify it
#     mutable_data = request.data.copy()

#     # Handle multiple vehicles data or a single vehicle entry
#     if isinstance(mutable_data, list):
#         for vehicle_data in mutable_data:
#             for field in vehicle_data:
#                 if vehicle_data[field] is None:
#                     vehicle_data[field] = ""  # Replace None with empty string
#             vehicle_data['farmer'] = farmer.id
#             vehicle_data['created_at'] = timezone.now()
#             vehicle_data['created_by'] = farmer.farmer_user.id
#     else:
#         for field in mutable_data:
#             if mutable_data[field] is None:
#                 mutable_data[field] = ""  # Replace None with empty string
#         mutable_data['farmer'] = farmer.id
#         mutable_data['created_at'] = timezone.now()
#         mutable_data['created_by'] = farmer.farmer_user.id

#     # Initialize the serializer with the mutable data
#     serializer = MyVehicleAddSerializer(data=mutable_data, many=isinstance(mutable_data, list))

#     # Validate the serializer
#     if serializer.is_valid():
#         # Save the vehicle record (the vehicle instance is created here)
#         vehicle_instance = serializer.save(farmer=farmer)

#         # Handle the inventory_type and related inventory_item
#         inventory_type_id = mutable_data.get('inventory_type')
#         new_inventory_item_id = request.data.get("inventory_items")

#         if inventory_type_id and new_inventory_item_id:
#             # Retrieve the new inventory item, which should have status=0 (active)
#             new_inventory_item = get_object_or_404(InventoryItems, id=new_inventory_item_id, status=0)

#             # Retrieve the last created MyVehicle entry with the same inventory_type and set previous inventory items to inactive
#             last_inventory_item = MyVehicle.objects.filter(
#                 inventory_type=vehicle_instance.inventory_type,
#                 inventory_items__status=0
#             ).latest('created_at')  # Assuming 'created_at' is the field indicating the creation time

#             if last_inventory_item:
#                 # Update the status of the previous inventory item to 1 (inactive)
#                 MyVehicle.objects.filter(
#                     inventory_type=vehicle_instance.inventory_type,
#                     inventory_items=last_inventory_item.inventory_items
#                 ).update(status=1)

#             # Set the new inventory item to the vehicle instance
#             vehicle_instance.inventory_items = new_inventory_item

#             # # Recalculate the available quantity for the inventory type
#             # total_quantity = MyVehicle.objects.filter(
#             #     inventory_type=inventory_type_id,
#             #     inventory_items=new_inventory_item
#             # ).aggregate(total_quantity=Sum('quantity'))['total_quantity'] or 0

#             # Update the vehicle instance with the recalculated available quantity
#             # vehicle_instance.available_quans = total_quantity
#             vehicle_instance.save()

#         # Handle the documents uploaded with vehicles (optional)
#         file_data = request.data.get('documents', None)  # Get the documents if provided
#         if file_data:
#             # Initialize grouped documents to handle file_type categorization
#             grouped_documents = {}

#             # Process each document and its corresponding file_type
#             for doc_data in file_data:
#                 file_type_id = doc_data.get('file_type')
#                 documents = doc_data.get('documents', [])

#                 if not documents:
#                     return Response(
#                         {"success": False, "message": f"No documents provided for file type {file_type_id}."},
#                         status=status.HTTP_400_BAD_REQUEST
#                     )

#                 # Check if file_type_id is None and create a new file type if necessary
#                 if file_type_id is None:
#                     new_file_type = doc_data.get('new_file_type')
#                     if not new_file_type:
#                         return Response({"error": f"New file type for document is required."}, status=status.HTTP_400_BAD_REQUEST)
                    
#                     # Create a new file type if not exists
#                     file_type, created = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=2)  # Assuming doctype=2 for vehicles
                    
#                 else:
#                     # Get the existing file type
#                     file_type = get_object_or_404(DocumentCategory, id=file_type_id)

#                 if file_type_id not in grouped_documents:
#                     grouped_documents[file_type_id] = []

#                 # Process the documents, creating VehicleDocument entries
#                 for i, document_base64 in enumerate(documents):
#                     try:
#                         # Validate MIME type (only image/jpeg, image/png, and application/pdf)
#                         if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
#                             mime_type = validate_image_type(document_base64)  # Validate the MIME type
#                             if mime_type:
#                                 # Extract the base64 data and decode it
#                                 document_data = document_base64.split(';base64,')[1]
#                                 document_bytes = base64.b64decode(document_data)

#                                 # Check file size (10MB max)
#                                 max_file_size = 10 * 1024 * 1024  # 10MB
#                                 if len(document_bytes) > max_file_size:
#                                     return Response({'error': f'File is too large. Max size is 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

#                                 # Create a document name and ContentFile
#                                 document_name = f"vehicle_{farmer_id}_{file_type_id}_{i}.{mime_type.split('/')[1]}"
#                                 document_file = ContentFile(document_bytes, name=document_name)

#                                 # Create VehicleDocument instance and save it
#                                 vehicle_document_instance = MyVehicleDocuments.objects.create(
#                                     farmer=farmer,
#                                     vehicle=vehicle_instance,  # Link to the vehicle instance
#                                     file_type=file_type,
#                                     document=document_file,
#                                     created_at=timezone.now(),
#                                     created_by=farmer.farmer_user
#                                 )

#                                 # Append the document info to the grouped_documents list
#                                 document_data = {
#                                     'document_id': vehicle_document_instance.id,
#                                     'document_category': {
#                                         'id': file_type.id,
#                                         'name': file_type.name
#                                     },
#                                     'upload_document': request.build_absolute_uri(f'/SuperAdmin{document_file.name}'),
#                                     'language': {
#                                         'default': 'en'
#                                     }
#                                 }

#                                 grouped_documents[file_type_id].append(document_data)
#                             else:
#                                 return Response({'error': 'Invalid MIME type for the document.'}, status=status.HTTP_400_BAD_REQUEST)
#                         else:
#                             return Response({'error': 'Invalid file format. Only image/jpeg, image/png, and application/pdf are allowed.'}, status=status.HTTP_400_BAD_REQUEST)

#                     except Exception as e:
#                         return Response({'error': f"Error processing document: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

#             # Prepare formatted document data for response
#             formatted_documents = []
#             for file_type_id, documents in grouped_documents.items():
#                 formatted_documents.append({
#                     'category_id': file_type_id,
#                     'documents': documents
#                 })
#         else:
#             formatted_documents = []  # If no documents are provided, return an empty list

#         # Save any additional fields from the request (e.g., quantity, purchase_amount, description)
#         vehicle_instance.running_kilometer = request.data.get("running_kilometer", vehicle_instance.running_kilometer)
#         vehicle_instance.service_frequency = request.data.get("service_frequency", vehicle_instance.service_frequency)
#         vehicle_instance.service_frequency_unit = request.data.get("service_frequency_unit", vehicle_instance.service_frequency_unit)
#         vehicle_instance.fuel_capacity = request.data.get("fuel_capacity", vehicle_instance.fuel_capacity)
#         vehicle_instance.average_mileage = request.data.get("average_mileage", vehicle_instance.average_mileage)
#         vehicle_instance.purchase_amount = request.data.get("purchase_amount", vehicle_instance.purchase_amount)
#         vehicle_instance.insurance = request.data.get("insurance", vehicle_instance.insurance)
#         vehicle_instance.company_name = request.data.get("company_name", vehicle_instance.company_name)
#         vehicle_instance.insurance_no = request.data.get("insurance_no", vehicle_instance.insurance_no)
#         vehicle_instance.insurance_amount = request.data.get("insurance_amount", vehicle_instance.insurance_amount)
#         vehicle_instance.insurance_start_date = request.data.get("insurance_start_date", vehicle_instance.insurance_start_date)
#         vehicle_instance.insurance_end_date = request.data.get("insurance_end_date", vehicle_instance.insurance_end_date)
#         vehicle_instance.insurance_renewal_date = request.data.get("insurance_renewal_date", vehicle_instance.insurance_renewal_date)
#         vehicle_instance.description = request.data.get("description", vehicle_instance.description)

#         # Save the updated vehicle record
#         vehicle_instance.save()

#         purchase_amount = float(mutable_data.get('purchase_amount', 0))
#         paid_amount = float(mutable_data.get('paid_amount', 0))

#         balance = 0
#         paid = 0
#         to_pay = 0
#         paid_date = None
#         total_paid = 0
#         received = 0
#         to_receive = 0
#         received_date = None
#         total_received = 0

#         if paid_amount < purchase_amount:
#             balance = purchase_amount - paid_amount
#             to_receive = balance
#             total_received = paid_amount
#             received_date = timezone.now() if paid_amount > 0 else None
#         elif paid_amount > purchase_amount:
#             balance = paid_amount - purchase_amount
#             to_pay = balance
#             received = paid_amount
#             total_received = paid_amount
#             received_date = timezone.now()
#         else:
#             total_received = paid_amount
#             received_date = timezone.now()

#         Outstanding.objects.create(
#             farmer=farmer,
#             vendor=vehicle_instance.vendor,
#             vehicle_purchase=vehicle_instance,
#             balance=balance,
#             paid=paid,
#             to_pay=to_pay,
#             paid_date=paid_date,
#             total_paid=total_paid,
#             received=received,
#             to_receive=to_receive,
#             received_date=received_date,
#             total_received=total_received,
#             payment_amount=paid_amount,
#             created_by=farmer.farmer_user,
#             created_at=timezone.now(),
#             status=0
#         )


#         # Return the response with the vehicle and document details
#         return Response(
#             {
#                 "success": True,
#                 "message": "Vehicle added successfully!",
#                 "data": serializer.data,
#                 "documents": formatted_documents,  # Include the grouped and formatted documents if provided
#                 "language": {
#                     "default": "en"
#                 }
#             },
#             status=status.HTTP_201_CREATED
#         )

#     # If serializer is invalid, return errors
#     return Response(
#         {
#             "success": False,
#             "message": "Failed to add vehicle. Please check the input data.",
#             "errors": serializer.errors
#         },
#         status=status.HTTP_400_BAD_REQUEST
#     )

# old 15-09-2025
# @api_view(['POST'])
# def add_vehicle(request, farmer_id):
#     # Fetch the farmer instance based on the farmer_id
#     farmer = get_object_or_404(Farmer, id=farmer_id)

#     # Create a mutable copy of the data to ensure we can modify it
#     mutable_data = request.data.copy()

#     # Required fields
#     required_fields = [
#         'date_of_consumption', 'inventory_type', 'inventory_category', 'inventory_items',
#         'vendor', 'register_number', 'owner_name', 'running_kilometer', 'purchase_amount', 'paid_amount'
#     ]

#     # Check for missing required fields
#     missing_fields = [field for field in required_fields if field not in mutable_data or mutable_data[field] is None]
#     if missing_fields:
#         return Response({
#             "success": False,
#             "message": f"Missing required fields: {', '.join(missing_fields)}"
#         }, status=status.HTTP_400_BAD_REQUEST)

#     # Check for missing insurance fields if insurance is enabled
#     if mutable_data.get('insurance', False):
#         insurance_required_fields = ['company_name', 'insurance_no', 'insurance_amount', 'insurance_start_date', 'insurance_end_date', 'insurance_renewal_date']
#         missing_insurance_fields = [field for field in insurance_required_fields if field not in mutable_data or mutable_data[field] is None]
#         if missing_insurance_fields:
#             return Response({
#                 "success": False,
#                 "message": f"Missing insurance fields: {', '.join(missing_insurance_fields)}"
#             }, status=status.HTTP_400_BAD_REQUEST)

#     # Handle the case where the fields are provided in the request data (whether required or optional)
#     for field in mutable_data:
#         if mutable_data[field] is None:
#             mutable_data[field] = ""  # Replace None with empty string

#     # Add the farmer, created_at, and created_by fields
#     mutable_data['farmer'] = farmer.id
#     mutable_data['created_at'] = timezone.now()
#     mutable_data['created_by'] = farmer.farmer_user.id

#     # Initialize the serializer with the mutable data
#     serializer = MyVehicleAddSerializer(data=mutable_data)

#     # Validate the serializer
#     if serializer.is_valid():
#         # Save the vehicle record (the vehicle instance is created here)
#         vehicle_instance = serializer.save(farmer=farmer)

#         # Handle the inventory_type and related inventory_item
#         inventory_type_id = mutable_data.get('inventory_type')
#         new_inventory_item_id = mutable_data.get("inventory_items")

#         if inventory_type_id and new_inventory_item_id:
#             # Retrieve the new inventory item, which should have status=0 (active)
#             new_inventory_item = get_object_or_404(InventoryItems, id=new_inventory_item_id, status=0)

#             # Retrieve the last created MyVehicle entry with the same inventory_type and set previous inventory items to inactive
#             last_inventory_item = MyVehicle.objects.filter(
#                 farmer = farmer,
#                 inventory_type=vehicle_instance.inventory_type,
#                 inventory_items__status=0
#             ).latest('created_at')  # Assuming 'created_at' is the field indicating the creation time

#             if last_inventory_item:
#                 # Update the status of the previous inventory item to 1 (inactive)
#                 MyVehicle.objects.filter(
#                     farmer = farmer,
#                     inventory_type=vehicle_instance.inventory_type,
#                     inventory_items=last_inventory_item.inventory_items
#                 ).update(status=1)

#             # Set the new inventory item to the vehicle instance
#             vehicle_instance.inventory_items = new_inventory_item

#             # Save the updated vehicle instance
#             vehicle_instance.save()

#         # Handle documents uploaded with vehicles (optional)
#         file_data = request.data.get('documents', None)  # Get the documents if provided
#         if file_data:
#             grouped_documents = {}

#             for doc_data in file_data:
#                 file_type_id = doc_data.get('file_type')
#                 documents = doc_data.get('documents', [])

#                 if not documents:
#                     return Response({
#                         "success": False,
#                         "message": f"No documents provided for file type {file_type_id}."
#                     }, status=status.HTTP_400_BAD_REQUEST)

#                 if file_type_id is None:
#                     new_file_type = doc_data.get('new_file_type')
#                     if not new_file_type:
#                         return Response({"error": "New file type for document is required."}, status=status.HTTP_400_BAD_REQUEST)
                    
#                     file_type, created = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=2)

#                 else:
#                     file_type = get_object_or_404(DocumentCategory, id=file_type_id)

#                 if file_type_id not in grouped_documents:
#                     grouped_documents[file_type_id] = []

#                 for i, document_base64 in enumerate(documents):
#                     try:
#                         if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
#                             mime_type = validate_image_type(document_base64)
#                             if mime_type:
#                                 document_data = document_base64.split(';base64,')[1]
#                                 document_bytes = base64.b64decode(document_data)

#                                 # Check file size (10MB max)
#                                 max_file_size = 10 * 1024 * 1024  # 10MB
#                                 if len(document_bytes) > max_file_size:
#                                     return Response({'error': f'File is too large. Max size is 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

#                                 document_name = f"vehicle_{farmer_id}_{file_type_id}_{i}.{mime_type.split('/')[1]}"
#                                 document_file = ContentFile(document_bytes, name=document_name)

#                                 vehicle_document_instance = MyVehicleDocuments.objects.create(
#                                     farmer=farmer,
#                                     vehicle=vehicle_instance,
#                                     file_type=file_type,
#                                     document=document_file,
#                                     created_at=timezone.now(),
#                                     created_by=farmer.farmer_user
#                                 )

#                                 document_data = {
#                                     'document_id': vehicle_document_instance.id,
#                                     'document_category': {'id': file_type.id, 'name': file_type.name},
#                                     'upload_document': request.build_absolute_uri(f'/SuperAdmin{document_file.name}'),
#                                     'language': {'default': 'en'}
#                                 }

#                                 grouped_documents[file_type_id].append(document_data)
#                             else:
#                                 return Response({'error': 'Invalid MIME type for the document.'}, status=status.HTTP_400_BAD_REQUEST)
#                         else:
#                             return Response({'error': 'Invalid file format. Only image/jpeg, image/png, and application/pdf are allowed.'}, status=status.HTTP_400_BAD_REQUEST)

#                     except Exception as e:
#                         return Response({'error': f"Error processing document: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

#             # Format and return documents data
#             formatted_documents = []
#             for file_type_id, documents in grouped_documents.items():
#                 formatted_documents.append({
#                     'category_id': file_type_id,
#                     'documents': documents
#                 })
#         else:
#             formatted_documents = []

#         # Handle optional fields if provided
#         vehicle_instance.running_kilometer = mutable_data.get("running_kilometer", vehicle_instance.running_kilometer)
#         vehicle_instance.service_frequency = mutable_data.get("service_frequency", vehicle_instance.service_frequency)
#         vehicle_instance.service_frequency_unit = mutable_data.get("service_frequency_unit", vehicle_instance.service_frequency_unit)
#         vehicle_instance.fuel_capacity = mutable_data.get("fuel_capacity", vehicle_instance.fuel_capacity)
#         vehicle_instance.average_mileage = mutable_data.get("average_mileage", vehicle_instance.average_mileage)
#         vehicle_instance.purchase_amount = mutable_data.get("purchase_amount", vehicle_instance.purchase_amount)
#         vehicle_instance.insurance = mutable_data.get("insurance", vehicle_instance.insurance)
#         vehicle_instance.company_name = mutable_data.get("company_name", vehicle_instance.company_name)
#         vehicle_instance.insurance_no = mutable_data.get("insurance_no", vehicle_instance.insurance_no)
#         vehicle_instance.insurance_amount = mutable_data.get("insurance_amount", vehicle_instance.insurance_amount)
#         vehicle_instance.insurance_start_date = mutable_data.get("insurance_start_date", vehicle_instance.insurance_start_date)
#         vehicle_instance.insurance_end_date = mutable_data.get("insurance_end_date", vehicle_instance.insurance_end_date)
#         vehicle_instance.insurance_renewal_date = mutable_data.get("insurance_renewal_date", vehicle_instance.insurance_renewal_date)
#         vehicle_instance.description = mutable_data.get("description", vehicle_instance.description)

#         # Save the updated vehicle instance
#         vehicle_instance.save()

#         # Create Outstanding record based on purchase and paid amount
#         purchase_amount = float(mutable_data.get('purchase_amount', 0))
#         paid_amount = float(mutable_data.get('paid_amount', 0))

#         balance = 0
#         to_pay = 0
#         to_receive = 0
#         total_received = 0
#         received_date = None
 
#         if paid_amount < purchase_amount:
#             balance = purchase_amount - paid_amount
#             to_receive = balance
#             total_received = paid_amount
#             received_date = timezone.now() if paid_amount > 0 else None
#         elif paid_amount > purchase_amount:
#             balance = paid_amount - purchase_amount
#             to_pay = balance
#             total_received = paid_amount
#             received_date = timezone.now()
#         else:
#             total_received = paid_amount
#             received_date = timezone.now()

#         # Create outstanding record
#         Outstanding.objects.create(
#             farmer=farmer,
#             vendor=vehicle_instance.vendor,
#             vehicle_purchase=vehicle_instance,
#             balance=balance,
#             to_pay=to_pay,
#             to_receive=to_receive,
#             paid_date=received_date,
#             total_paid=total_received,
#             received_date=received_date,
#             total_received=total_received,
#             payment_amount=paid_amount,
#             created_by=farmer.farmer_user,
#             created_at=timezone.now(),
#             status=0
#         )

#         # Return the response with the vehicle and document details
#         return Response({
#             "success": True,
#             "message": "Vehicle added successfully!",
#             "data": serializer.data,
#             "documents": formatted_documents,
#             "language": {"default": "en"}
#         }, status=status.HTTP_201_CREATED)

#     # If serializer is invalid, return errors
#     return Response({
#         "success": False,
#         "message": "Failed to add vehicle. Please check the input data.",
#         "errors": serializer.errors
#     }, status=status.HTTP_400_BAD_REQUEST)

@api_view(['POST'])
def add_vehicle(request, farmer_id):
    farmer = get_object_or_404(Farmer, id=farmer_id)
    data = request.data.copy()
    # user = farmer.farmer_user   # logged-in user

    # --- If vehicle_id provided, reset previous vehicle and update outstanding ---
    vehicle_id = data.get('vehicle_id')
    if vehicle_id:
        vehicle = get_object_or_404(MyVehicle, pk=vehicle_id)
        vehicle.status = 0
        vehicle.save()

        # If you have an inventory related to vehicle, reset its status as well
        try:
            inv = MyInventory.objects.get(vehicle_purchase=vehicle)
            inv.status = 0
            inv.save()
        except MyInventory.DoesNotExist:
            pass  # No inventory linked, skip

        # Optional: Create notification about vehicle reset/update
        FarmerNotification.objects.create(
            farmer=farmer,
            name='Vehicle Updated',
            message=f'Vehicle {vehicle.registration_number} reset and updated.',
            type='Vehicle'
        )

    # --- Validate required fields ---
    required_fields = [
      'vehicle_name', 'vendor', 'purchase_amount', 'paid_amount',
        'purchase_date', 'registration_number'
    ]
    missing_fields = [field for field in required_fields if not data.get(field)]
    if missing_fields:
        return Response({
            "success": False,
            "message": f"Missing required fields: {', '.join(missing_fields)}"
        }, status=status.HTTP_400_BAD_REQUEST)

    # --- Validate vendor exists ---
    vendor_id = data.get('vendor')
    vendor = get_object_or_404(MyVendor, id=vendor_id)

    # --- Prepare data for serializer ---
    data['farmer'] = farmer.id
    data['created_at'] = timezone.now()
    data['created_by'] = farmer.farmer_user.id  # Assuming farmer_user is User instance

    serializer = MyVehicleAddSerializer(data=data)
    if serializer.is_valid():
        vehicle_instance = serializer.save()

        # --- Documents handling (like add_fuel) ---
        file_data = request.data.get('documents', None)
        formatted_documents = []
        if file_data:
            grouped_documents = {}
            for doc_data in file_data:
                file_type_id = doc_data.get('file_type')
                documents = doc_data.get('documents', [])

                if not documents:
                    return Response({"success": False, "message": f"No documents for file type {file_type_id}"}, status=status.HTTP_400_BAD_REQUEST)

                if file_type_id is None:
                    new_file_type = doc_data.get('new_file_type')
                    if not new_file_type:
                        return Response({"error": "New file type required."}, status=status.HTTP_400_BAD_REQUEST)
                    file_type, _ = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=2)  # Assuming doctype 2 for vehicle docs
                    file_type_id = file_type.id
                else:
                    file_type = get_object_or_404(DocumentCategory, id=file_type_id)

                if file_type_id not in grouped_documents:
                    grouped_documents[file_type_id] = []

                for i, document_base64 in enumerate(documents):
                    try:
                        if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
                            mime_type = validate_image_type(document_base64)
                            if mime_type:
                                document_data = document_base64.split(';base64,')[1]
                                document_bytes = base64.b64decode(document_data)
                                if len(document_bytes) > 10 * 1024 * 1024:
                                    return Response({'error': 'File too large. Max 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

                                ext = mime_type.split('/')[1]
                                document_name = f"vehicle_{farmer_id}_{file_type_id}_{i}.{ext}"
                                document_file = ContentFile(document_bytes, name=document_name)

                                vehicle_doc = MyVehicleDocuments.objects.create(
                                    farmer=farmer,
                                    vehicle=vehicle_instance,
                                    file_type=file_type,
                                    document=document_file,
                                    created_at=timezone.now(),
                                    created_by=farmer.farmer_user
                                )

                                grouped_documents[file_type_id].append({
                                    'document_id': vehicle_doc.id,
                                    'document_category': {'id': file_type.id, 'name': file_type.name},
                                    'upload_document': request.build_absolute_uri(vehicle_doc.document.url),
                                    'language': {"default": "en"}
                                })
                            else:
                                return Response({'error': 'Invalid MIME type.'}, status=status.HTTP_400_BAD_REQUEST)
                        else:
                            return Response({'error': 'Unsupported file format.'}, status=status.HTTP_400_BAD_REQUEST)
                    except Exception as e:
                        return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)

            for file_type_id_key, docs in grouped_documents.items():
                formatted_documents.append({
                    'category_id': file_type_id_key,
                    'documents': docs
                })

        # --- Optional fields update ---
        optional_fields = [
            "running_kilometer", "service_frequency", "service_frequency_unit", "fuel_capacity",
            "average_mileage", "insurance", "company_name", "insurance_no", "insurance_amount",
            "insurance_start_date", "insurance_end_date", "insurance_renewal_date", "description"
        ]
        for field in optional_fields:
            if field in data:
                setattr(vehicle_instance, field, data[field])
        vehicle_instance.save()

    
        # Optional notification
        FarmerNotification.objects.create(
            farmer=farmer,
            name='New Vehicle Added',
            message=f'Vehicle {vehicle_instance.registration_number} added successfully.',
            type='Vehicle'
        )

        return Response({
            "success": True,
            "message": "Vehicle added successfully!",
            "data": serializer.data,
            "documents": formatted_documents,
            "language": {"default": "en"}
        }, status=status.HTTP_201_CREATED)

    return Response({
        "success": False,
        "message": "Validation failed.",
        "errors": serializer.errors
    }, status=status.HTTP_400_BAD_REQUEST)


# @api_view(['POST'])
# def add_machinery(request, farmer_id):
#     # Fetch the farmer instance based on the farmer_id
#     farmer = get_object_or_404(Farmer, id=farmer_id)

#     # Create a mutable copy of the data to ensure we can modify it
#     mutable_data = request.data.copy()

#     # Handle multiple machinery data or a single machinery entry
#     if isinstance(mutable_data, list):
#         for machinery_data in mutable_data:
#             for field in machinery_data:
#                 if machinery_data[field] is None:
#                     machinery_data[field] = ""  # Replace None with empty string
#             machinery_data['farmer'] = farmer.id
#             machinery_data['created_at'] = timezone.now()
#             machinery_data['created_by'] = farmer.farmer_user.id
#     else:
#         for field in mutable_data:
#             if mutable_data[field] is None:
#                 mutable_data[field] = ""  # Replace None with empty string
#         mutable_data['farmer'] = farmer.id
#         mutable_data['created_at'] = timezone.now()
#         mutable_data['created_by'] = farmer.farmer_user.id

#     # Initialize the serializer with the mutable data
#     serializer = MyMachineryAddSerializer(data=mutable_data, many=isinstance(mutable_data, list))

#     # Validate the serializer
#     if serializer.is_valid():
#         # Save the machinery record (the machinery instance is created here)
#         machinery_instance = serializer.save(farmer=farmer)

#         # Handle the documents uploaded with machinery (optional)
#         file_data = request.data.get('documents', None)  # Get the documents if provided
#         if file_data:
#             # Initialize grouped documents to handle file_type categorization
#             grouped_documents = {}

#             # Process each document and its corresponding file_type
#             for doc_data in file_data:
#                 file_type_id = doc_data.get('file_type')
#                 documents = doc_data.get('documents', [])

#                 if not documents:
#                     return Response(
#                         {"success": False, "message": f"No documents provided for file type {file_type_id}."},
#                         status=status.HTTP_400_BAD_REQUEST
#                     )

#                 # Check if file_type_id is None and create a new file type if necessary
#                 if file_type_id is None:
#                     new_file_type = doc_data.get('new_file_type')
#                     if not new_file_type:
#                         return Response({"error": f"New file type for document is required."}, status=status.HTTP_400_BAD_REQUEST)
                        
#                     # Create a new file type if not exists
#                     file_type, created = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=2)  # Assuming doctype=2 for machinery
#                 else:
#                     # Get the existing file type
#                     file_type = get_object_or_404(DocumentCategory, id=file_type_id)

#                 if file_type_id not in grouped_documents:
#                     grouped_documents[file_type_id] = []

#                 # Process the documents, creating MachineryDocument entries
#                 for i, document_base64 in enumerate(documents):
#                     try:
#                         # Validate MIME type (only image/jpeg, image/png, and application/pdf)
#                         if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
#                             mime_type = validate_image_type(document_base64)  # Validate the MIME type
#                             if mime_type:
#                                 # Extract the base64 data and decode it
#                                 document_data = document_base64.split(';base64,')[1]
#                                 document_bytes = base64.b64decode(document_data)

#                                 # Check file size (10MB max)
#                                 max_file_size = 10 * 1024 * 1024  # 10MB
#                                 if len(document_bytes) > max_file_size:
#                                     return Response({'error': f'File is too large. Max size is 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

#                                 # Create a document name and ContentFile
#                                 document_name = f"machinery_{farmer_id}_{file_type_id}_{i}.{mime_type.split('/')[1]}"
#                                 document_file = ContentFile(document_bytes, name=document_name)

#                                 # Create MyMachineryDocuments instance and save it
#                                 machinery_document_instance = MyMachineryDocuments.objects.create(
#                                     farmer=farmer,
#                                     document=document_file,
#                                     machinary=machinery_instance,  # Correct reference to 'machinary'
#                                     file_type=file_type,
#                                     created_at=timezone.now(),
#                                     created_by=farmer.farmer_user  # Assuming `farmer_user` is the field for the user who created it
#                                 )

#                                 # Append the document info to the grouped_documents list
#                                 document_data = {
#                                     'document_id': machinery_document_instance.id,
#                                     'document_category': {
#                                         'id': file_type.id,
#                                         'name': file_type.name
#                                     },
#                                     'upload_document': request.build_absolute_uri(f'/SuperAdmin{document_file.name}'),
#                                     'language': {
#                                         'default': 'en'
#                                     }
#                                 }

#                                 grouped_documents[file_type_id].append(document_data)
#                             else:
#                                 return Response({'error': 'Invalid MIME type for the document.'}, status=status.HTTP_400_BAD_REQUEST)
#                         else:
#                             return Response({'error': 'Invalid file format. Only image/jpeg, image/png, and application/pdf are allowed.'}, status=status.HTTP_400_BAD_REQUEST)

#                     except Exception as e:
#                         return Response({'error': f"Error processing document: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

#             # Prepare formatted document data for response
#             formatted_documents = []
#             for file_type_id, documents in grouped_documents.items():
#                 formatted_documents.append({
#                     'category_id': file_type_id,
#                     'documents': documents
#                 })
#         else:
#             formatted_documents = []  # If no documents are provided, return an empty list

#         # Handle the inventory_type and related inventory_item
#         inventory_type_id = mutable_data.get('inventory_type')
#         new_inventory_item_id = request.data.get("inventory_items")

#         if inventory_type_id and new_inventory_item_id:
#             # Retrieve the new inventory item, which should have status=0 (active)
#             new_inventory_item = get_object_or_404(InventoryItems, id=new_inventory_item_id, status=0)

#             # Retrieve the last created MyMachinery entry with the same inventory_type and set previous inventory items to inactive
#             last_inventory_item = MyMachinery.objects.filter(
#                 inventory_type=machinery_instance.inventory_type,
#                 inventory_items__status=0
#             ).latest('created_at')  # Assuming 'created_at' is the field indicating the creation time

#             if last_inventory_item:
#                 # Update the status of the previous inventory item to 1 (inactive)
#                 MyMachinery.objects.filter(
#                     inventory_type=machinery_instance.inventory_type,
#                     inventory_items=last_inventory_item.inventory_items
#                 ).update(status=1)

#             # Set the new inventory item to the machinery instance
#             machinery_instance.inventory_items = new_inventory_item

#             # Recalculate the available quantity for the inventory type
#             total_quantity = MyMachinery.objects.filter(
#                 inventory_type=inventory_type_id,
#                 inventory_items=new_inventory_item
#             ).aggregate(total_quantity=Sum('fuel_capacity'))['total_quantity'] or 0

#             # Update the machinery instance with the recalculated available quantity
#             machinery_instance.available_quans = total_quantity
#             machinery_instance.save()

#         machinery_instance.fuel_capacity = request.data.get("fuel_capacity", machinery_instance.fuel_capacity)
#         machinery_instance.purchase_amount = request.data.get("purchase_amount", machinery_instance.purchase_amount)
#         machinery_instance.description = request.data.get("description", machinery_instance.description)

#         # Save the updated machinery record
#         machinery_instance.save()

#         # Return the response with the machinery and document details
#         return Response(
#             {
#                 "success": True,
#                 "message": "Machinery added successfully!",
#                 "data": serializer.data,
#                 "documents": formatted_documents,  # Include the grouped and formatted documents if provided
#                 "language": {
#                     "default": "en"
#                 }
#             },
#             status=status.HTTP_201_CREATED
#         )

#     # If serializer is invalid, return errors
#     return Response(
#         {
#             "success": False,
#             "message": "Failed to add machinery. Please check the input data.",
#             "errors": serializer.errors
#         },
#         status=status.HTTP_400_BAD_REQUEST
#     )

#old 15-09-2025
# @api_view(['POST'])
# def add_machinery(request, farmer_id):
#     farmer = get_object_or_404(Farmer, id=farmer_id)
#     mutable_data = request.data.copy()

#     # ---------------- Required Fields Validation ---------------- #
#     required_fields = ['date_of_consumption', 'inventory_type', 'inventory_category',
#                        'inventory_items', 'vendor', 'purchase_amount', 'paid_amount']

#     missing_fields = [field for field in required_fields if not mutable_data.get(field)]
#     if missing_fields:
#         return Response({
#             "success": False,
#             "message": f"Missing required fields: {', '.join(missing_fields)}"
#         }, status=status.HTTP_400_BAD_REQUEST)

#     # Conditional requirement for fuel_capacity
#     machinery_type = int(mutable_data.get('machinery_type', -1))
#     if machinery_type == 0 and not mutable_data.get('fuel_capacity'):
#         return Response({
#             "success": False,
#             "message": "fuel_capacity is required for machinery_type = 0"
#         }, status=status.HTTP_400_BAD_REQUEST)

#     # ---------------- Prepare Data ---------------- #
#     if isinstance(mutable_data, list):
#         for machinery_data in mutable_data:
#             for field in machinery_data:
#                 if machinery_data[field] is None:
#                     machinery_data[field] = ""
#             machinery_data['farmer'] = farmer.id
#             machinery_data['created_at'] = timezone.now()
#             machinery_data['created_by'] = farmer.farmer_user.id
#     else:
#         for field in mutable_data:
#             if mutable_data[field] is None:
#                 mutable_data[field] = ""
#         mutable_data['farmer'] = farmer.id
#         mutable_data['created_at'] = timezone.now()
#         mutable_data['created_by'] = farmer.farmer_user.id

#     # ---------------- Serializer ---------------- #
#     serializer = MyMachineryAddSerializer(data=mutable_data, many=isinstance(mutable_data, list))
#     if serializer.is_valid():
#         machinery_instance = serializer.save(farmer=farmer)

#         # ---------------- Optional Document Uploads ---------------- #
#         file_data = request.data.get('documents', None)
#         if file_data:
#             grouped_documents = {}
#             for doc_data in file_data:
#                 file_type_id = doc_data.get('file_type')
#                 documents = doc_data.get('documents', [])

#                 if not documents:
#                     return Response({"success": False, "message": f"No documents provided for file type {file_type_id}."},
#                                     status=status.HTTP_400_BAD_REQUEST)

#                 if file_type_id is None:
#                     new_file_type = doc_data.get('new_file_type')
#                     if not new_file_type:
#                         return Response({"error": f"New file type for document is required."}, status=status.HTTP_400_BAD_REQUEST)
#                     file_type, _ = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=2)
#                 else:
#                     file_type = get_object_or_404(DocumentCategory, id=file_type_id)

#                 if file_type_id not in grouped_documents:
#                     grouped_documents[file_type_id] = []

#                 for i, document_base64 in enumerate(documents):
#                     try:
#                         if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
#                             mime_type = validate_image_type(document_base64)
#                             if mime_type:
#                                 document_data = document_base64.split(';base64,')[1]
#                                 document_bytes = base64.b64decode(document_data)

#                                 if len(document_bytes) > 10 * 1024 * 1024:
#                                     return Response({'error': 'File is too large. Max size is 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

#                                 document_name = f"machinery_{farmer_id}_{file_type_id}_{i}.{mime_type.split('/')[1]}"
#                                 document_file = ContentFile(document_bytes, name=document_name)

#                                 machinery_document_instance = MyMachineryDocuments.objects.create(
#                                     farmer=farmer,
#                                     document=document_file,
#                                     machinary=machinery_instance,
#                                     file_type=file_type,
#                                     created_at=timezone.now(),
#                                     created_by=farmer.farmer_user
#                                 )

#                                 document_info = {
#                                     'document_id': machinery_document_instance.id,
#                                     'document_category': {'id': file_type.id, 'name': file_type.name},
#                                     'upload_document': request.build_absolute_uri(f'/SuperAdmin{document_file.name}'),
#                                     'language': {'default': 'en'}
#                                 }

#                                 grouped_documents[file_type_id].append(document_info)
#                             else:
#                                 return Response({'error': 'Invalid MIME type for the document.'}, status=status.HTTP_400_BAD_REQUEST)
#                         else:
#                             return Response({'error': 'Invalid file format. Only image/jpeg, image/png, and application/pdf are allowed.'}, status=status.HTTP_400_BAD_REQUEST)

#                     except Exception as e:
#                         return Response({'error': f"Error processing document: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

#             formatted_documents = [{'category_id': file_type_id, 'documents': docs} for file_type_id, docs in grouped_documents.items()]
#         else:
#             formatted_documents = []

#         # ---------------- Inventory Item Management ---------------- #
#         inventory_type_id = mutable_data.get('inventory_type')
#         new_inventory_item_id = request.data.get("inventory_items")

#         if inventory_type_id and new_inventory_item_id:
#             new_inventory_item = get_object_or_404(InventoryItems, id=new_inventory_item_id, status=0)

#             last_inventory_item = MyMachinery.objects.filter(
#                 inventory_type=machinery_instance.inventory_type,
#                 inventory_items__status=0
#             ).latest('created_at')

#             if last_inventory_item:
#                 MyMachinery.objects.filter(
#                     farmer = farmer,
#                     inventory_type=machinery_instance.inventory_type,
#                     inventory_items=last_inventory_item.inventory_items
#                 ).update(status=1)

#             machinery_instance.inventory_items = new_inventory_item

#             # Recalculate available quantity
#             total_quantity = MyMachinery.objects.filter(
#                 farmer = farmer,
#                 inventory_type=inventory_type_id,
#                 inventory_items=new_inventory_item
#             ).aggregate(total_quantity=Sum('fuel_capacity'))['total_quantity'] or 0

#             machinery_instance.available_quans = total_quantity

#         # ---------------- Optional Fields ---------------- #
#         machinery_instance.fuel_capacity = request.data.get("fuel_capacity", machinery_instance.fuel_capacity)
#         machinery_instance.purchase_amount = request.data.get("purchase_amount", machinery_instance.purchase_amount)
#         machinery_instance.description = request.data.get("description", machinery_instance.description)
#         machinery_instance.warranty_start_date = request.data.get("warranty_start_date", None)
#         machinery_instance.warranty_end_date = request.data.get("warranty_end_date", None)

#         # Save final instance
#         machinery_instance.save()

#         return Response({
#             "success": True,
#             "message": "Machinery added successfully!",
#             "data": serializer.data,
#             "documents": formatted_documents,
#             "language": {"default": "en"}
#         }, status=status.HTTP_201_CREATED)

#     return Response({
#         "success": False,
#         "message": "Failed to add machinery. Please check the input data.",
#         "errors": serializer.errors
#     }, status=status.HTTP_400_BAD_REQUEST)

@api_view(['POST'])
def add_machinery(request, farmer_id):
    farmer = get_object_or_404(Farmer, id=farmer_id)
    data = request.data.copy()
    user = request.user  # logged-in user

    # --- If machinery_id provided, reset previous machinery and update outstanding ---
    machinery_id = data.get('machinery_id')
    if machinery_id:
        machinery = get_object_or_404(MyMachinery, pk=machinery_id)
        machinery.status = 0
        machinery.save()

        inv = get_object_or_404(MyInventory, machinery_purchase=machinery)
        inv.status = 0
        inv.save()
      
        FarmerNotification.objects.create(
            farmer=farmer,
            name='New Machinery Purchase Created',
            message=f'{machinery.inventory_items.name}',
            type='Machinery'
        )

    # --- Validate required fields ---
    required_fields = [
        'date_of_consumption', 'inventory_type', 'inventory_category',
        'inventory_items', 'vendor', 'purchase_amount', 'paid_amount'
    ]
    missing_fields = [field for field in required_fields if not data.get(field)]
    if missing_fields:
        return Response({
            "success": False,
            "message": f"Missing required fields: {', '.join(missing_fields)}"
        }, status=status.HTTP_400_BAD_REQUEST)

    # Conditional requirement for fuel_capacity if machinery_type == 0
    machinery_type = int(data.get('machinery_type', -1))
    if machinery_type == 0 and not data.get('fuel_capacity'):
        return Response({
            "success": False,
            "message": "fuel_capacity is required for machinery_type = 0"
        }, status=status.HTTP_400_BAD_REQUEST)

    # --- Validate vendor and inventory_type relationship ---
    vendor_id = data.get('vendor')
    inventory_type_id = data.get('inventory_type')
    vendor = get_object_or_404(MyVendor, id=vendor_id)

    if not vendor.inventory_type.filter(id=inventory_type_id).exists():
        return Response({
            "success": False,
            "message": "This vendor is not associated with the selected inventory type."
        }, status=status.HTTP_400_BAD_REQUEST)

    # --- Prepare metadata for serializer ---
    data['farmer'] = farmer.id
    data['created_at'] = timezone.now()
    data['created_by'] = farmer.farmer_user.id

    serializer = MyMachineryAddSerializer(data=data)
    if serializer.is_valid():
        machinery_instance = serializer.save()

        # --- Optional Documents Handling ---
        file_data = request.data.get('documents', None)
        formatted_documents = []
        if file_data:
            grouped_documents = {}
            for doc_data in file_data:
                file_type_id = doc_data.get('file_type')
                documents = doc_data.get('documents', [])

                if not documents:
                    return Response({"success": False, "message": f"No documents for file type {file_type_id}"}, status=status.HTTP_400_BAD_REQUEST)

                if file_type_id is None:
                    new_file_type = doc_data.get('new_file_type')
                    if not new_file_type:
                        return Response({"error": "New file type required."}, status=status.HTTP_400_BAD_REQUEST)
                    file_type, _ = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=2)
                    file_type_id = file_type.id
                else:
                    file_type = get_object_or_404(DocumentCategory, id=file_type_id)

                if file_type_id not in grouped_documents:
                    grouped_documents[file_type_id] = []

                for i, document_base64 in enumerate(documents):
                    try:
                        if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
                            mime_type = validate_image_type(document_base64)
                            if mime_type:
                                document_data = document_base64.split(';base64,')[1]
                                document_bytes = base64.b64decode(document_data)
                                if len(document_bytes) > 10 * 1024 * 1024:
                                    return Response({'error': 'File too large. Max 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

                                ext = mime_type.split('/')[1]
                                document_name = f"machinery_{farmer_id}_{file_type_id}_{i}.{ext}"
                                document_file = ContentFile(document_bytes, name=document_name)

                                machinery_doc = MyMachineryDocuments.objects.create(
                                    farmer=farmer,
                                    machinary=machinery_instance,
                                    file_type=file_type,
                                    document=document_file,
                                    created_at=timezone.now(),
                                    created_by=farmer.farmer_user
                                )

                                grouped_documents[file_type_id].append({
                                    'document_id': machinery_doc.id,
                                    'document_category': {'id': file_type.id, 'name': file_type.name},
                                    'upload_document': request.build_absolute_uri(machinery_doc.document.url),
                                    'language': {"default": "en"}
                                })
                            else:
                                return Response({'error': 'Invalid MIME type.'}, status=status.HTTP_400_BAD_REQUEST)
                        else:
                            return Response({'error': 'Unsupported file format.'}, status=status.HTTP_400_BAD_REQUEST)
                    except Exception as e:
                        return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)

            for file_type_id_key, docs in grouped_documents.items():
                formatted_documents.append({
                    'category_id': file_type_id_key,
                    'documents': docs
                })

        # --- Inventory logic ---
        new_inventory_item_id = data.get("inventory_items")
        if inventory_type_id and new_inventory_item_id:
            new_inventory_item = get_object_or_404(InventoryItems, id=new_inventory_item_id, status=0)

            try:
                last_item = MyMachinery.objects.filter(
                    farmer=farmer,
                    inventory_type=machinery_instance.inventory_type,
                    inventory_items__status=0
                ).latest('created_at')
                # Mark last machinery's inventory_items status to 1 (inactive)
                MyMachinery.objects.filter(
                    farmer=farmer,
                    inventory_type=machinery_instance.inventory_type,
                    inventory_items=last_item.inventory_items
                ).update(status=1)
            except MyMachinery.DoesNotExist:
                pass  # No previous machinery found

            machinery_instance.inventory_items = new_inventory_item

            # Calculate total fuel_capacity for this inventory item & type for this farmer
            total_fuel_capacity = MyMachinery.objects.filter(
                farmer=farmer,
                inventory_type=inventory_type_id,
                inventory_items=new_inventory_item
            ).aggregate(total=Sum('fuel_capacity'))['total'] or 0

            machinery_instance.available_quans = total_fuel_capacity
            machinery_instance.save()

        # --- Vendor Outstanding & Balance Update Logic ---
        purchase_amount = float(data.get('purchase_amount', 0))
        paid_amount = float(data.get('paid_amount', 0))

        net_change = paid_amount - purchase_amount  # Positive means vendor owes you; negative means you owe vendor
        current_balance = vendor.opening_balance or 0
        updated_balance = current_balance + net_change

        if updated_balance > 0:
            vendor.credit = True
            vendor.debit = False
            vendor.opening_balance = updated_balance
        elif updated_balance < 0:
            vendor.credit = False
            vendor.debit = True
            vendor.opening_balance = abs(updated_balance)
        else:
            vendor.credit = False
            vendor.debit = False
            vendor.opening_balance = 0

        if net_change < 0:
            vendor.payables = (vendor.payables or 0) + abs(net_change)
        elif net_change > 0:
            vendor.receivables = (vendor.receivables or 0) + net_change

        vendor.save()

        if vendor.is_customer_is_vendor and hasattr(vendor, 'customer'):
            customer = vendor.customer
            customer.opening_balance = vendor.opening_balance
            customer.payables = vendor.payables
            customer.receivables = vendor.receivables
            customer.is_credit = vendor.credit
            customer.save()

        # Create Outstanding record
        now = timezone.now()
        balance = abs(net_change)

        if net_change < 0:
            Outstanding.objects.create(
                farmer=farmer,
                vendor=vendor,
                machinery_purchase=machinery_instance,
                balance=purchase_amount,
                paid=paid_amount,
                to_pay=abs(net_change),
                paid_date=now,
                total_paid=paid_amount,
                identify=2,
                created_by=farmer.farmer_user,
                created_at=now
            )
        elif net_change > 0:
            Outstanding.objects.create(
                farmer=farmer,
                vendor=vendor,
                machinery_purchase=machinery_instance,
                balance=balance,
                paid=paid_amount,
                to_receive=net_change,
                received_date=now,
                total_received=paid_amount,
                identify=2,
                created_by=farmer.farmer_user,
                created_at=now
            )
        else:
            Outstanding.objects.create(
                farmer=farmer,
                vendor=vendor,
                machinery_purchase=machinery_instance,
                balance=0,
                paid=paid_amount,
                to_pay=0,
                paid_date=now,
                total_paid=paid_amount,
                received=paid_amount,
                to_receive=0,
                received_date=now,
                total_received=paid_amount,
                identify=2,
                created_by=farmer.farmer_user,
                created_at=now
            )

        # Notification
        FarmerNotification.objects.create(
            farmer=farmer,
            name='New Machinery Purchase Created',
            message=f'{machinery_instance.inventory_items.name}',
            type='Machinery'
        )

        return Response({
            "success": True,
            "message": "Machinery added successfully!",
            "data": serializer.data,
            "documents": formatted_documents,
            "language": {"default": "en"}
        }, status=status.HTTP_201_CREATED)

    return Response({
        "success": False,
        "message": "Validation failed.",
        "errors": serializer.errors
    }, status=status.HTTP_400_BAD_REQUEST)



# @api_view(['POST'])
# def add_tools(request, farmer_id):
#     # Fetch the farmer instance based on the farmer_id
#     farmer = get_object_or_404(Farmer, id=farmer_id)

#     # Create a mutable copy of the data to ensure we can modify it
#     mutable_data = request.data.copy()

#     # Handle multiple tools data or a single tool entry
#     if isinstance(mutable_data, list):
#         for tool_data in mutable_data:
#             for field in tool_data:
#                 if tool_data[field] is None:
#                     tool_data[field] = ""  # Replace None with empty string
#             tool_data['farmer'] = farmer.id
#             tool_data['created_at'] = timezone.now()
#             tool_data['created_by'] = farmer.farmer_user.id
#     else:
#         for field in mutable_data:
#             if mutable_data[field] is None:
#                 mutable_data[field] = ""  # Replace None with empty string
#         mutable_data['farmer'] = farmer.id
#         mutable_data['created_at'] = timezone.now()
#         mutable_data['created_by'] = farmer.farmer_user.id

#     # Initialize the serializer with the mutable data
#     serializer = MyToolsAddSerializer(data=mutable_data, many=isinstance(mutable_data, list))

#     # Validate the serializer
#     if serializer.is_valid():
#         # Save the tool record (the tool instance is created here)
#         tool_instance = serializer.save(farmer=farmer)

#         # Handle the inventory_type and related inventory_item
#         inventory_type_id = mutable_data.get('inventory_type')
#         new_inventory_item_id = request.data.get("inventory_items")

#         if inventory_type_id and new_inventory_item_id:
#             # Retrieve the new inventory item, which should have status=0 (active)
#             new_inventory_item = get_object_or_404(InventoryItems, id=new_inventory_item_id, status=0)

#             # Retrieve the last created MyTools entry with the same inventory_type and set previous inventory items to inactive
#             last_inventory_item = MyTools.objects.filter(
#                 inventory_type=tool_instance.inventory_type,
#                 inventory_items__status=0
#             ).latest('created_at')  # Assuming 'created_at' is the field indicating the creation time

#             if last_inventory_item:
#                 # Update the status of the previous inventory item to 1 (inactive)
#                 MyTools.objects.filter(
#                     inventory_type=tool_instance.inventory_type,
#                     inventory_items=last_inventory_item.inventory_items
#                 ).update(status=1)

#             # Set the new inventory item to the tool instance
#             tool_instance.inventory_items = new_inventory_item

#             # Recalculate the available quantity for the inventory type
#             total_quantity = MyTools.objects.filter(
#                 inventory_type=inventory_type_id,
#                 inventory_items=new_inventory_item
#             ).aggregate(total_quantity=Sum('quantity'))['total_quantity'] or 0

#             # Update the tool instance with the recalculated available quantity
#             tool_instance.available_quans = total_quantity
#             tool_instance.save()

#         # Handle the documents uploaded with tools (optional)
#         file_data = request.data.get('documents', None)  # Get the documents if provided
#         if file_data:
#             # Initialize grouped documents to handle file_type categorization
#             grouped_documents = {}

#             # Process each document and its corresponding file_type
#             for doc_data in file_data:
#                 file_type_id = doc_data.get('file_type')
#                 documents = doc_data.get('documents', [])

#                 if not documents:
#                     return Response(
#                         {"success": False, "message": f"No documents provided for file type {file_type_id}."},
#                         status=status.HTTP_400_BAD_REQUEST
#                     )

#                 # Check if file_type_id is None and create a new file type if necessary
#                 if file_type_id is None:
#                     new_file_type = doc_data.get('new_file_type')
#                     if not new_file_type:
#                         return Response({"error": f"New file type for document is required."}, status=status.HTTP_400_BAD_REQUEST)
                    
#                     # Create a new file type if not exists
#                     file_type, created = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=4)  # Assuming doctype=4 for tools
                    
#                 else:
#                     # Get the existing file type
#                     file_type = get_object_or_404(DocumentCategory, id=file_type_id)

#                 if file_type_id not in grouped_documents:
#                     grouped_documents[file_type_id] = []

#                 # Process the documents, creating ToolDocument entries
#                 for i, document_base64 in enumerate(documents):
#                     try:
#                         # Validate MIME type (only image/jpeg, image/png, and application/pdf)
#                         if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
#                             mime_type = validate_image_type(document_base64)  # Validate the MIME type
#                             if mime_type:
#                                 # Extract the base64 data and decode it
#                                 document_data = document_base64.split(';base64,')[1]
#                                 document_bytes = base64.b64decode(document_data)

#                                 # Check file size (10MB max)
#                                 max_file_size = 10 * 1024 * 1024  # 10MB
#                                 if len(document_bytes) > max_file_size:
#                                     return Response({'error': f'File is too large. Max size is 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

#                                 # Create a document name and ContentFile
#                                 document_name = f"tool_{farmer_id}_{file_type_id}_{i}.{mime_type.split('/')[1]}"
#                                 document_file = ContentFile(document_bytes, name=document_name)

#                                 # Create ToolDocument instance and save it
#                                 tool_document_instance = MyToolsDocuments.objects.create(
#                                     farmer=farmer,
#                                     tools=tool_instance,  # Link to the tool instance
#                                     file_type=file_type,
#                                     document=document_file,
#                                     created_at=timezone.now(),
#                                     created_by=farmer.farmer_user
#                                 )

#                                 # Append the document info to the grouped_documents list
#                                 document_data = {
#                                     'document_id': tool_document_instance.id,
#                                     'document_category': {
#                                         'id': file_type.id,
#                                         'name': file_type.name
#                                     },
#                                     'upload_document': request.build_absolute_uri(f'/SuperAdmin{document_file.name}'),
#                                     'language': {
#                                         'default': 'en'
#                                     }
#                                 }

#                                 grouped_documents[file_type_id].append(document_data)
#                             else:
#                                 return Response({'error': 'Invalid MIME type for the document.'}, status=status.HTTP_400_BAD_REQUEST)
#                         else:
#                             return Response({'error': 'Invalid file format. Only image/jpeg, image/png, and application/pdf are allowed.'}, status=status.HTTP_400_BAD_REQUEST)

#                     except Exception as e:
#                         return Response({'error': f"Error processing document: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

#             # Prepare formatted document data for response
#             formatted_documents = []
#             for file_type_id, documents in grouped_documents.items():
#                 formatted_documents.append({
#                     'category_id': file_type_id,
#                     'documents': documents
#                 })
#         else:
#             formatted_documents = []  # If no documents are provided, return an empty list

#         # Save any additional fields from the request (e.g., quantity, purchase_amount, description)
#         tool_instance.quantity = request.data.get("quantity", tool_instance.quantity)
#         tool_instance.purchase_amount = request.data.get("purchase_amount", tool_instance.purchase_amount)
#         tool_instance.description = request.data.get("description", tool_instance.description)
#         tool_instance.reusable = request.data.get("reusable", tool_instance.reusable)

#         # Save the updated tool record
#         tool_instance.save()

#         # Return the response with the tool and document details
#         return Response(
#             {
#                 "success": True,
#                 "message": "Tool added successfully!",
#                 "data": serializer.data,
#                 "documents": formatted_documents,  # Include the grouped and formatted documents if provided
#                 "language": {
#                     "default": "en"
#                 }
#             },
#             status=status.HTTP_201_CREATED
#         )

#     # If serializer is invalid, return errors
#     return Response(
#         {
#             "success": False,
#             "message": "Failed to add tool. Please check the input data.",
#             "errors": serializer.errors
#         },
#         status=status.HTTP_400_BAD_REQUEST
#     )

# old 15-09-2025
# @api_view(['POST'])
# def add_tools(request, farmer_id):
#     # Fetch the farmer instance based on the farmer_id
#     farmer = get_object_or_404(Farmer, id=farmer_id)

#     # Create a mutable copy of the data to ensure we can modify it
#     mutable_data = request.data.copy()

#     # Ensure required fields are present
#     required_fields = ['date_of_consumption', 'inventory_type', 'inventory_category', 'inventory_items', 'vendor', 'quantity', 'purchase_amount', 'paid_amount']
#     missing_fields = [field for field in required_fields if not mutable_data.get(field)]
#     if missing_fields:
#         return Response(
#             {"success": False, "message": f"Missing required fields: {', '.join(missing_fields)}."},
#             status=status.HTTP_400_BAD_REQUEST
#         )

#     # Handle multiple tools data or a single tool entry
#     if isinstance(mutable_data, list):
#         for tool_data in mutable_data:
#             for field in tool_data:
#                 if tool_data[field] is None:
#                     tool_data[field] = ""  # Replace None with empty string
#             tool_data['farmer'] = farmer.id
#             tool_data['created_at'] = timezone.now()
#             tool_data['created_by'] = farmer.farmer_user.id
#     else:
#         for field in mutable_data:
#             if mutable_data[field] is None:
#                 mutable_data[field] = ""  # Replace None with empty string
#         mutable_data['farmer'] = farmer.id
#         mutable_data['created_at'] = timezone.now()
#         mutable_data['created_by'] = farmer.farmer_user.id

#     # Initialize the serializer with the mutable data
#     serializer = MyToolsAddSerializer(data=mutable_data, many=isinstance(mutable_data, list))

#     # Validate the serializer
#     if serializer.is_valid():
#         # Save the tool record (the tool instance is created here)
#         tool_instance = serializer.save(farmer=farmer)

#         # Handle the inventory_type and related inventory_item
#         inventory_type_id = mutable_data.get('inventory_type')
#         new_inventory_item_id = request.data.get("inventory_items")

#         if inventory_type_id and new_inventory_item_id:
#             # Retrieve the new inventory item, which should have status=0 (active)
#             new_inventory_item = get_object_or_404(InventoryItems, id=new_inventory_item_id, status=0)

#             # Retrieve the last created MyTools entry with the same inventory_type and set previous inventory items to inactive
#             last_inventory_item = MyTools.objects.filter(
#                 farmer = farmer,
#                 inventory_type=tool_instance.inventory_type,
#                 inventory_items__status=0
#             ).latest('created_at')  # Assuming 'created_at' is the field indicating the creation time

#             if last_inventory_item:
#                 # Update the status of the previous inventory item to 1 (inactive)
#                 MyTools.objects.filter(
#                     farmer = farmer,
#                     inventory_type=tool_instance.inventory_type,
#                     inventory_items=last_inventory_item.inventory_items
#                 ).update(status=1)

#             # Set the new inventory item to the tool instance
#             tool_instance.inventory_items = new_inventory_item

#             # Recalculate the available quantity for the inventory type
#             total_quantity = MyTools.objects.filter(
#                 farmer = farmer,
#                 inventory_type=inventory_type_id,
#                 inventory_items=new_inventory_item
#             ).aggregate(total_quantity=Sum('quantity'))['total_quantity'] or 0

#             # Update the tool instance with the recalculated available quantity
#             tool_instance.available_quans = total_quantity
#             tool_instance.save()

#         # Handle the documents uploaded with tools (optional)
#         file_data = request.data.get('documents', None)  # Get the documents if provided
#         if file_data:
#             # Initialize grouped documents to handle file_type categorization
#             grouped_documents = {}

#             # Process each document and its corresponding file_type
#             for doc_data in file_data:
#                 file_type_id = doc_data.get('file_type')
#                 documents = doc_data.get('documents', [])

#                 if not documents:
#                     return Response(
#                         {"success": False, "message": f"No documents provided for file type {file_type_id}."},
#                         status=status.HTTP_400_BAD_REQUEST
#                     )

#                 # Check if file_type_id is None and create a new file type if necessary
#                 if file_type_id is None:
#                     new_file_type = doc_data.get('new_file_type')
#                     if not new_file_type:
#                         return Response({"error": f"New file type for document is required."}, status=status.HTTP_400_BAD_REQUEST)
                    
#                     # Create a new file type if not exists
#                     file_type, created = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=4)  # Assuming doctype=4 for tools
                    
#                 else:
#                     # Get the existing file type
#                     file_type = get_object_or_404(DocumentCategory, id=file_type_id)

#                 if file_type_id not in grouped_documents:
#                     grouped_documents[file_type_id] = []

#                 # Process the documents, creating ToolDocument entries
#                 for i, document_base64 in enumerate(documents):
#                     try:
#                         # Validate MIME type (only image/jpeg, image/png, and application/pdf)
#                         if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
#                             mime_type = validate_image_type(document_base64)  # Validate the MIME type
#                             if mime_type:
#                                 # Extract the base64 data and decode it
#                                 document_data = document_base64.split(';base64,')[1]
#                                 document_bytes = base64.b64decode(document_data)

#                                 # Check file size (10MB max)
#                                 max_file_size = 10 * 1024 * 1024  # 10MB
#                                 if len(document_bytes) > max_file_size:
#                                     return Response({'error': f'File is too large. Max size is 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

#                                 # Create a document name and ContentFile
#                                 document_name = f"tool_{farmer_id}_{file_type_id}_{i}.{mime_type.split('/')[1]}"
#                                 document_file = ContentFile(document_bytes, name=document_name)

#                                 # Create ToolDocument instance and save it
#                                 tool_document_instance = MyToolsDocuments.objects.create(
#                                     farmer=farmer,
#                                     tools=tool_instance,  # Link to the tool instance
#                                     file_type=file_type,
#                                     document=document_file,
#                                     created_at=timezone.now(),
#                                     created_by=farmer.farmer_user
#                                 )

#                                 # Append the document info to the grouped_documents list
#                                 document_data = {
#                                     'document_id': tool_document_instance.id,
#                                     'document_category': {
#                                         'id': file_type.id,
#                                         'name': file_type.name
#                                     },
#                                     'upload_document': request.build_absolute_uri(f'/SuperAdmin{document_file.name}'),
#                                     'language': {
#                                         'default': 'en'
#                                     }
#                                 }

#                                 grouped_documents[file_type_id].append(document_data)
#                             else:
#                                 return Response({'error': 'Invalid MIME type for the document.'}, status=status.HTTP_400_BAD_REQUEST)
#                         else:
#                             return Response({'error': 'Invalid file format. Only image/jpeg, image/png, and application/pdf are allowed.'}, status=status.HTTP_400_BAD_REQUEST)

#                     except Exception as e:
#                         return Response({'error': f"Error processing document: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

#             # Prepare formatted document data for response
#             formatted_documents = []
#             for file_type_id, documents in grouped_documents.items():
#                 formatted_documents.append({
#                     'category_id': file_type_id,
#                     'documents': documents
#                 })
#         else:
#             formatted_documents = []  # If no documents are provided, return an empty list

#         # Handle Outstanding record creation (like in the pesticide example)
#         purchase_amount = float(mutable_data.get('purchase_amount', 0))
#         paid_amount = float(mutable_data.get('paid_amount', 0))

#         balance = 0
#         paid = 0
#         to_pay = 0
#         paid_date = None
#         total_paid = 0
#         received = 0
#         to_receive = 0
#         received_date = None
#         total_received = 0

#         if paid_amount < purchase_amount:
#             balance = purchase_amount - paid_amount
#             to_receive = balance
#             total_received = paid_amount
#             received_date = timezone.now() if paid_amount > 0 else None
#         elif paid_amount > purchase_amount:
#             balance = paid_amount - purchase_amount
#             to_pay = balance
#             received = paid_amount
#             total_received = paid_amount
#             received_date = timezone.now()
#         else:
#             total_received = paid_amount
#             received_date = timezone.now()

#         Outstanding.objects.create(
#             farmer=farmer,
#             vendor=tool_instance.vendor,
#             tool_purchase=tool_instance,
#             balance=balance,
#             paid=paid,
#             to_pay=to_pay,
#             paid_date=paid_date,
#             total_paid=total_paid,
#             received=received,
#             to_receive=to_receive,
#             received_date=received_date,
#             total_received=total_received,
#             payment_amount=paid_amount,
#             created_by=farmer.farmer_user,
#             created_at=timezone.now(),
#             status=0
#         )

#         return Response(
#             {
#                 "success": True,
#                 "message": "Tool added successfully!",
#                 "data": serializer.data,
#                 "documents": formatted_documents,  # Include the grouped and formatted documents if provided
#                 "language": {
#                     "default": "en"
#                 }
#             },
#             status=status.HTTP_201_CREATED
#         )

#     # If serializer is invalid, return errors
#     return Response(
#         {
#             "success": False,
#             "message": "Failed to add tool. Please check the provided data.",
#             "errors": serializer.errors
#         },
#         status=status.HTTP_400_BAD_REQUEST
#     )

@api_view(['POST'])
def add_tools(request, farmer_id):
    farmer = get_object_or_404(Farmer, id=farmer_id)
    data = request.data.copy()
    user = request.user  # logged-in user

    # Validate required fields
    required_fields = [
        'date_of_consumption', 'inventory_type',
        'inventory_items', 'vendor', 'quantity', 'purchase_amount', 'paid_amount'
    ]
    missing_fields = [field for field in required_fields if not data.get(field)]
    if missing_fields:
        return Response({
            "success": False,
            "message": f"Missing required fields: {', '.join(missing_fields)}"
        }, status=status.HTTP_400_BAD_REQUEST)

    # Validate vendor and inventory_type relationship
    vendor_id = data.get('vendor')
    inventory_type_id = data.get('inventory_type')
    vendor = get_object_or_404(MyVendor, id=vendor_id)

    if not vendor.inventory_type.filter(id=inventory_type_id).exists():
        return Response({
            "success": False,
            "message": "This vendor is not associated with the selected inventory type."
        }, status=status.HTTP_400_BAD_REQUEST)

    # Add farmer and metadata
    data['farmer'] = farmer.id
    data['created_at'] = timezone.now()
    data['created_by'] = farmer.farmer_user.id

    serializer = MyToolsAddSerializer(data=data)
    if serializer.is_valid():
        tool_instance = serializer.save()

        # Handle inventory_items and update previous inventory status to inactive
        new_inventory_item_id = data.get("inventory_items")
        if inventory_type_id and new_inventory_item_id:
            new_inventory_item = get_object_or_404(InventoryItems, id=new_inventory_item_id, status=0)

            try:
                last_tool = MyTools.objects.filter(
                    farmer=farmer,
                    inventory_type=tool_instance.inventory_type,
                    inventory_items__status=0
                ).latest('created_at')

                # Mark last tool's inventory_items status to inactive
                MyTools.objects.filter(
                    farmer=farmer,
                    inventory_type=tool_instance.inventory_type,
                    inventory_items=last_tool.inventory_items
                ).update(status=1)
            except MyTools.DoesNotExist:
                pass

            tool_instance.inventory_items = new_inventory_item

            # Calculate total quantity for this inventory item & type for this farmer
            total_quantity = MyTools.objects.filter(
                farmer=farmer,
                inventory_type=inventory_type_id,
                inventory_items=new_inventory_item
            ).aggregate(total=Sum('quantity'))['total'] or 0

            tool_instance.available_quans = total_quantity
            tool_instance.save()

        # --- Handle optional documents ---
        file_data = request.data.get('documents', None)
        formatted_documents = []
        if file_data:
            grouped_documents = {}

            for doc_data in file_data:
                file_type_id = doc_data.get('file_type')
                documents = doc_data.get('documents', [])

                if not documents:
                    return Response({"success": False, "message": f"No documents for file type {file_type_id}"}, status=status.HTTP_400_BAD_REQUEST)

                if file_type_id is None:
                    new_file_type = doc_data.get('new_file_type')
                    if not new_file_type:
                        return Response({"error": "New file type required."}, status=status.HTTP_400_BAD_REQUEST)
                    file_type, _ = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=4)  # Assuming doctype=4 for tools
                    file_type_id = file_type.id
                else:
                    file_type = get_object_or_404(DocumentCategory, id=file_type_id)

                if file_type_id not in grouped_documents:
                    grouped_documents[file_type_id] = []

                for i, document_base64 in enumerate(documents):
                    try:
                        if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
                            mime_type = validate_image_type(document_base64)
                            if mime_type:
                                document_data = document_base64.split(';base64,')[1]
                                document_bytes = base64.b64decode(document_data)

                                if len(document_bytes) > 10 * 1024 * 1024:
                                    return Response({'error': 'File too large. Max 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

                                ext = mime_type.split('/')[1]
                                document_name = f"tool_{farmer_id}_{file_type_id}_{i}.{ext}"
                                document_file = ContentFile(document_bytes, name=document_name)

                                tool_doc = MyToolsDocuments.objects.create(
                                    farmer=farmer,
                                    tools=tool_instance,
                                    file_type=file_type,
                                    document=document_file,
                                    created_at=timezone.now(),
                                    created_by=farmer.farmer_user
                                )

                                grouped_documents[file_type_id].append({
                                    'document_id': tool_doc.id,
                                    'document_category': {'id': file_type.id, 'name': file_type.name},
                                    'upload_document': request.build_absolute_uri(tool_doc.document.url),
                                    'language': {"default": "en"}
                                })
                            else:
                                return Response({'error': 'Invalid MIME type.'}, status=status.HTTP_400_BAD_REQUEST)
                        else:
                            return Response({'error': 'Unsupported file format.'}, status=status.HTTP_400_BAD_REQUEST)
                    except Exception as e:
                        return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)

            for file_type_id_key, docs in grouped_documents.items():
                formatted_documents.append({
                    'category_id': file_type_id_key,
                    'documents': docs
                })

        # Create Farmer notification
        FarmerNotification.objects.create(
            farmer=farmer,
            name='New Tool Purchase Created',
            message=f'{tool_instance.inventory_items.name}',
            type='Tool'
        )

        return Response({
            "success": True,
            "message": "Tool added successfully!",
            "data": serializer.data,
            "documents": formatted_documents,
            "language": {"default": "en"}
        }, status=status.HTTP_201_CREATED)

    return Response({
        "success": False,
        "message": "Validation failed.",
        "errors": serializer.errors
    }, status=status.HTTP_400_BAD_REQUEST)


# old 15-09-2025 
# @api_view(['POST'])
# def add_pesticides(request, farmer_id):
#     # Fetch the farmer instance based on the farmer_id
#     farmer = get_object_or_404(Farmer, id=farmer_id)

#     # Create a mutable copy of the data to ensure we can modify it
#     mutable_data = request.data.copy()

#     # Ensure required fields are present
#     required_fields = ['date_of_consumption', 'inventory_type', 'inventory_category', 'inventory_items', 'vendor', 'quantity', 'quantity_unit', 'purchase_amount', 'paid_amount']
#     missing_fields = [field for field in required_fields if not mutable_data.get(field)]
#     if missing_fields:
#         return Response(
#             {"success": False, "message": f"Missing required fields: {', '.join(missing_fields)}."},
#             status=status.HTTP_400_BAD_REQUEST
#         )

#     # Handle multiple pesticides data or a single pesticide entry
#     if isinstance(mutable_data, list):
#         for pesticide_data in mutable_data:
#             for field in pesticide_data:
#                 if pesticide_data[field] is None:
#                     pesticide_data[field] = ""  # Replace None with empty string
#             pesticide_data['farmer'] = farmer.id
#             pesticide_data['created_at'] = timezone.now()
#             pesticide_data['created_by'] = farmer.farmer_user.id
#     else:
#         for field in mutable_data:
#             if mutable_data[field] is None:
#                 mutable_data[field] = ""  # Replace None with empty string
#         mutable_data['farmer'] = farmer.id
#         mutable_data['created_at'] = timezone.now()
#         mutable_data['created_by'] = farmer.farmer_user.id

#     # Initialize the serializer with the mutable data
#     serializer = MyPesticidesAddSerializer(data=mutable_data, many=isinstance(mutable_data, list))

#     # Validate the serializer
#     if serializer.is_valid():
#         # Save the pesticide record (the pesticide instance is created here)
#         pesticide_instance = serializer.save(farmer=farmer)

#         # Handle the inventory_type and related inventory_item
#         inventory_type_id = mutable_data.get('inventory_type')
#         new_inventory_item_id = request.data.get("inventory_items")

#         if inventory_type_id and new_inventory_item_id:
#             # Retrieve the new inventory item, which should have status=0 (active)
#             new_inventory_item = get_object_or_404(InventoryItems, id=new_inventory_item_id, status=0)

#             # Retrieve the last created MyPesticides entry with the same inventory_type and set previous inventory items to inactive
#             last_inventory_item = MyPesticides.objects.filter(
#                 farmer=farmer,
#                 inventory_type=pesticide_instance.inventory_type,
#                 inventory_items__status=0
#             ).latest('created_at')  # Assuming 'created_at' is the field indicating the creation time

#             if last_inventory_item:
#                 # Update the status of the previous inventory item to 1 (inactive)
#                 MyPesticides.objects.filter(
#                     farmer =farmer,
#                     inventory_type=pesticide_instance.inventory_type,
#                     inventory_items=last_inventory_item.inventory_items
#                 ).update(status=1)

#             # Set the new inventory item to the pesticide instance
#             pesticide_instance.inventory_items = new_inventory_item

#             # Recalculate the available quantity for the inventory type
#             total_quantity = MyPesticides.objects.filter(
#                 farmer =farmer ,
#                 inventory_type=inventory_type_id,
#                 inventory_items=new_inventory_item
#             ).aggregate(total_quantity=Sum('quantity'))['total_quantity'] or 0

#             # Update the pesticide instance with the recalculated available quantity
#             pesticide_instance.available_quans = total_quantity
#             pesticide_instance.save()

#         # Handle the documents uploaded with pesticides (optional)
#         file_data = request.data.get('documents', None)  # Get the documents if provided
#         if file_data:
#             # Initialize grouped documents to handle file_type categorization
#             grouped_documents = {}

#             # Process each document and its corresponding file_type
#             for doc_data in file_data:
#                 file_type_id = doc_data.get('file_type')
#                 documents = doc_data.get('documents', [])

#                 if not documents:
#                     return Response(
#                         {"success": False, "message": f"No documents provided for file type {file_type_id}."},
#                         status=status.HTTP_400_BAD_REQUEST
#                     )

#                 # Check if file_type_id is None and create a new file type if necessary
#                 if file_type_id is None:
#                     new_file_type = doc_data.get('new_file_type')
#                     if not new_file_type:
#                         return Response({"error": f"New file type for document is required."}, status=status.HTTP_400_BAD_REQUEST)
                    
#                     # Create a new file type if not exists
#                     file_type, created = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=1)
                    
#                 else:
#                     # Get the existing file type
#                     file_type = get_object_or_404(DocumentCategory, id=file_type_id)

#                 if file_type_id not in grouped_documents:
#                     grouped_documents[file_type_id] = []

#                 # Process the documents, creating PesticideDocument entries
#                 for i, document_base64 in enumerate(documents):
#                     try:
#                         # Validate MIME type (only image/jpeg, image/png, and application/pdf)
#                         if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
#                             mime_type = validate_image_type(document_base64)  # Validate the MIME type
#                             if mime_type:
#                                 # Extract the base64 data and decode it
#                                 document_data = document_base64.split(';base64,')[1]
#                                 document_bytes = base64.b64decode(document_data)

#                                 # Check file size (10MB max)
#                                 max_file_size = 10 * 1024 * 1024  # 10MB
#                                 if len(document_bytes) > max_file_size:
#                                     return Response({'error': f'File is too large. Max size is 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

#                                 # Create a document name and ContentFile
#                                 document_name = f"pesticide_{farmer_id}_{file_type_id}_{i}.{mime_type.split('/')[1]}"
#                                 document_file = ContentFile(document_bytes, name=document_name)

#                                 # Create PesticideDocument instance and save it
#                                 pesticide_document_instance = MyPesticidesDocuments.objects.create(
#                                     farmer=farmer,
#                                     pest=pesticide_instance,  # Link to the pesticide instance
#                                     file_type=file_type,
#                                     document=document_file,
#                                     created_at=timezone.now(),
#                                     created_by=farmer.farmer_user
#                                 )

#                                 # Append the document info to the grouped_documents list
#                                 document_data = {
#                                     'document_id': pesticide_document_instance.id,
#                                     'document_category': {
#                                         'id': file_type.id,
#                                         'name': file_type.name
#                                     },
#                                     'upload_document': request.build_absolute_uri(f'/SuperAdmin{document_file.name}'),
#                                     'language': {
#                                         'default': 'en'
#                                     }
#                                 }

#                                 grouped_documents[file_type_id].append(document_data)
#                             else:
#                                 return Response({'error': 'Invalid MIME type for the document.'}, status=status.HTTP_400_BAD_REQUEST)
#                         else:
#                             return Response({'error': 'Invalid file format. Only image/jpeg, image/png, and application/pdf are allowed.'}, status=status.HTTP_400_BAD_REQUEST)

#                     except Exception as e:
#                         return Response({'error': f"Error processing document: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

#             # Prepare formatted document data for response
#             formatted_documents = []
#             for file_type_id, documents in grouped_documents.items():
#                 formatted_documents.append({
#                     'category_id': file_type_id,
#                     'documents': documents
#                 })
#         else:
#             formatted_documents = []  # If no documents are provided, return an empty list

#         # Handle the inventory_type and related inventory_item
#         inventory_type_id = mutable_data.get('inventory_type')
#         new_inventory_item_id = request.data.get("inventory_items")

#         if inventory_type_id and new_inventory_item_id:
#             # Retrieve the new inventory item, which should have status=0 (active)
#             new_inventory_item = get_object_or_404(InventoryItems, id=new_inventory_item_id, status=0)

#             # Retrieve the last created MyPesticides entry with the same inventory_type and set previous inventory items to inactive
#             last_inventory_item = MyPesticides.objects.filter(
#                 inventory_type=pesticide_instance.inventory_type,
#                 inventory_items__status=0
#             ).latest('created_at')  # Assuming 'created_at' is the field indicating the creation time

#             if last_inventory_item:
#                 # Update the status of the previous inventory item to 1 (inactive)
#                 MyPesticides.objects.filter(
#                     farmer=farmer,
#                     inventory_type=pesticide_instance.inventory_type,
#                     inventory_items=last_inventory_item.inventory_items
#                 ).update(status=1)

#             # Set the new inventory item to the pesticide instance
#             pesticide_instance.inventory_items = new_inventory_item

#             # Recalculate the available quantity for the inventory type
#             total_quantity = MyPesticides.objects.filter(
#                 farmer=farmer,
#                 inventory_type=inventory_type_id,
#                 inventory_items=new_inventory_item
#             ).aggregate(total_quantity=Sum('quantity'))['total_quantity'] or 0

#             # Update the pesticide instance with the recalculated available quantity
#             pesticide_instance.available_quans = total_quantity
#             pesticide_instance.save()

#         pesticide_instance.quantity = request.data.get("quantity", pesticide_instance.quantity)
#         pesticide_instance.purchase_amount = request.data.get("purchase_amount", pesticide_instance.purchase_amount)
#         pesticide_instance.description = request.data.get("description", pesticide_instance.description)

#         # Save the updated pesticide record
#         pesticide_instance.save()

#         # Create Outstanding record
#         purchase_amount = float(mutable_data.get('purchase_amount', 0))
#         paid_amount = float(mutable_data.get('paid_amount', 0))

#         balance = 0
#         paid = 0
#         to_pay = 0
#         paid_date = None
#         total_paid = 0
#         received = 0
#         to_receive = 0
#         received_date = None
#         total_received = 0

#         if paid_amount < purchase_amount:
#             balance = purchase_amount - paid_amount
#             to_receive = balance
#             total_received = paid_amount
#             received_date = timezone.now() if paid_amount > 0 else None
#         elif paid_amount > purchase_amount:
#             balance = paid_amount - purchase_amount
#             to_pay = balance
#             received = paid_amount
#             total_received = paid_amount
#             received_date = timezone.now()
#         else:
#             total_received = paid_amount
#             received_date = timezone.now()

#         Outstanding.objects.create(
#             farmer=farmer,
#             vendor=pesticide_instance.vendor,
#             fuel_purchase=None,
#             pesticide_purchase=pesticide_instance,
#             balance=balance,
#             paid=paid,
#             to_pay=to_pay,
#             paid_date=paid_date,
#             total_paid=total_paid,
#             received=received,
#             to_receive=to_receive,
#             received_date=received_date,
#             total_received=total_received,
#             payment_amount=paid_amount,
#             created_by=farmer.farmer_user,
#             created_at=timezone.now(),
#             status=0
#         )

#         return Response(
#             {
#                 "success": True,
#                 "message": "Pesticide added successfully!",
#                 "data": serializer.data,
#                 "documents": formatted_documents,  # Include the grouped and formatted documents if provided
#                 "language": {
#                     "default": "en"
#                 }
#             },
#             status=status.HTTP_201_CREATED
#         )

#     # If serializer is invalid, return errors
#     return Response(
#         {
#             "success": False,
#             "message": "Failed to add pesticide. Please check the provided data.",
#             "errors": serializer.errors
#         },
#         status=status.HTTP_400_BAD_REQUEST
#     )
 
# @api_view(['POST'])
# def add_pesticides(request, farmer_id):
#     farmer = get_object_or_404(Farmer, id=farmer_id)
#     data = request.data.copy()
#     user = request.user  # logged-in user

#     # --- If pesticide_id provided, reset previous pesticide and update outstanding ---
#     pesticide_id = data.get('pesticide_id')
#     if pesticide_id:
#         pesticide = get_object_or_404(MyPesticides, pk=pesticide_id)
#         pesticide.status = 0
#         pesticide.save()

#         inv = get_object_or_404(MyInventory, pesticide_purchase=pesticide)
#         inv.status = 0
#         inv.save()

#         if pesticide.purchase_amount != pesticide.paid_amount:
#             if pesticide.purchase_amount > pesticide.paid_amount:  # Payables
#                 outstanding = Outstanding.objects.create(
#                     farmer=pesticide.farmer,
#                     vendor=pesticide.vendor,
#                     pesticide_purchase=pesticide,
#                     balance=pesticide.purchase_amount,
#                     paid=pesticide.paid_amount,
#                     to_pay=float(pesticide.purchase_amount) - float(pesticide.paid_amount),
#                     paid_date=pesticide.date_of_purchase,
#                     total_paid=pesticide.paid_amount,
#                     identify=1,
#                     created_by=user,
#                     created_at=timezone.now()
#                 )
#                 if float(outstanding.to_pay) > 0:
#                     vendor = get_object_or_404(MyVendor, pk=outstanding.vendor.id)
#                     vendor.payables = (float(vendor.payables or 0)) + float(outstanding.to_pay)
#                     if vendor.opening_balance and vendor.opening_balance != 0 and vendor.credit:
#                         if float(vendor.opening_balance) > float(outstanding.to_pay):
#                             vendor.credit = True
#                             vendor.debit = False
#                             vendor.opening_balance = float(vendor.opening_balance) - float(outstanding.to_pay)
#                         else:
#                             vendor.credit = False
#                             vendor.debit = True
#                             vendor.opening_balance = float(outstanding.to_pay) - float(vendor.opening_balance)
#                     elif vendor.opening_balance and vendor.opening_balance != 0 and vendor.credit == False and vendor.debit:
#                         vendor.opening_balance = float(vendor.opening_balance) + float(outstanding.to_pay)
#                         vendor.credit = False
#                         vendor.debit = True
#                     else:
#                         vendor.opening_balance = float(outstanding.to_pay)
#                         vendor.credit = False
#                         vendor.debit = True
#                     vendor.save()

#                     if vendor.is_customer_is_vendor:
#                         customer = vendor.customer
#                         customer.opening_balance = vendor.opening_balance
#                         customer.payables = vendor.payables
#                         customer.is_credit = vendor.credit
#                         customer.save()

#             elif pesticide.purchase_amount < pesticide.paid_amount:  # Receivables
#                 outstanding = Outstanding.objects.create(
#                     farmer=pesticide.farmer,
#                     vendor=pesticide.vendor,
#                     pesticide_purchase=pesticide,
#                     balance=float(pesticide.paid_amount) - float(pesticide.purchase_amount),
#                     paid=pesticide.paid_amount,
#                     to_receive=float(pesticide.paid_amount) - float(pesticide.purchase_amount),
#                     paid_date=pesticide.date_of_purchase,
#                     received_date=pesticide.date_of_purchase,
#                     total_received=pesticide.paid_amount,
#                     identify=1,
#                     created_by=user,
#                     created_at=timezone.now()
#                 )
#                 if float(outstanding.to_receive) > 0:
#                     vendor = get_object_or_404(MyVendor, pk=outstanding.vendor.id)
#                     vendor.receivables = (float(vendor.receivables or 0)) + float(outstanding.to_receive)
#                     if vendor.opening_balance and vendor.opening_balance != 0 and vendor.credit:
#                         vendor.opening_balance = float(vendor.opening_balance) + float(outstanding.to_receive)
#                         vendor.credit = True
#                         vendor.debit = False
#                     elif vendor.opening_balance and vendor.opening_balance != 0 and vendor.credit == False and vendor.debit:
#                         if float(vendor.opening_balance) > float(outstanding.to_receive):
#                             vendor.credit = False
#                             vendor.debit = True
#                             vendor.opening_balance = float(vendor.opening_balance) - float(outstanding.to_receive)
#                         else:
#                             vendor.credit = True
#                             vendor.debit = False
#                             vendor.opening_balance = float(outstanding.to_receive) - float(vendor.opening_balance)
#                     else:
#                         vendor.opening_balance = float(outstanding.to_receive)
#                         vendor.credit = True
#                         vendor.debit = False
#                     vendor.save()

#                     if vendor.is_customer_is_vendor:
#                         customer = vendor.customer
#                         customer.opening_balance = vendor.opening_balance
#                         customer.receivables = vendor.receivables
#                         customer.is_credit = vendor.credit
#                         customer.save()

#         FarmerNotification.objects.create(
#             farmer=farmer,
#             name='New Purchase Created',
#             message=f'{pesticide.inventory_items.name}',
#             type='Pesticide'
#         )

#     # --- Validate required fields ---
#     required_fields = [
#         'date_of_purchase', 'inventory_type', 'inventory_category',
#         'inventory_items', 'vendor', 'quantity', 'purchase_amount', 'paid_amount'
#     ]
#     missing_fields = [field for field in required_fields if not data.get(field)]
#     if missing_fields:
#         return Response({
#             "success": False,
#             "message": f"Missing required fields: {', '.join(missing_fields)}"
#         }, status=status.HTTP_400_BAD_REQUEST)

#     # --- Validate vendor and inventory_type relationship ---
#     vendor_id = data.get('vendor')
#     inventory_type_id = data.get('inventory_type')
#     vendor = get_object_or_404(MyVendor, id=vendor_id)

#     if not vendor.inventory_type.filter(id=inventory_type_id).exists():
#         return Response({
#             "success": False,
#             "message": "This vendor is not associated with the selected inventory type."
#         }, status=status.HTTP_400_BAD_REQUEST)

#     # --- Prepare metadata for serializer ---
#     data['farmer'] = farmer.id
#     data['created_at'] = timezone.now()
#     data['created_by'] = farmer.farmer_user.id  # Assuming farmer_user is the User instance

#     serializer = MyPesticidesAddSerializer(data=data)
#     if serializer.is_valid():
#         pesticide_instance = serializer.save()

#         # --- Optional Documents Handling ---
#         file_data = request.data.get('documents', None)
#         formatted_documents = []
#         if file_data:
#             grouped_documents = {}
#             for doc_data in file_data:
#                 file_type_id = doc_data.get('file_type')
#                 documents = doc_data.get('documents', [])

#                 if not documents:
#                     return Response({"success": False, "message": f"No documents for file type {file_type_id}"}, status=status.HTTP_400_BAD_REQUEST)

#                 if file_type_id is None:
#                     new_file_type = doc_data.get('new_file_type')
#                     if not new_file_type:
#                         return Response({"error": "New file type required."}, status=status.HTTP_400_BAD_REQUEST)
#                     file_type, _ = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=1)
#                     file_type_id = file_type.id
#                 else:
#                     file_type = get_object_or_404(DocumentCategory, id=file_type_id)

#                 if file_type_id not in grouped_documents:
#                     grouped_documents[file_type_id] = []

#                 for i, document_base64 in enumerate(documents):
#                     try:
#                         if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
#                             mime_type = validate_image_type(document_base64)
#                             if mime_type:
#                                 document_data = document_base64.split(';base64,')[1]
#                                 document_bytes = base64.b64decode(document_data)
#                                 if len(document_bytes) > 10 * 1024 * 1024:
#                                     return Response({'error': 'File too large. Max 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

#                                 ext = mime_type.split('/')[1]
#                                 document_name = f"pesticide_{farmer_id}_{file_type_id}_{i}.{ext}"
#                                 document_file = ContentFile(document_bytes, name=document_name)

#                                 pesticide_doc = MyPesticidesDocuments.objects.create(
#                                     farmer=farmer,
#                                     pesticide=pesticide_instance,
#                                     file_type=file_type,
#                                     document=document_file,
#                                     created_at=timezone.now(),
#                                     created_by=farmer.farmer_user
#                                 )

#                                 grouped_documents[file_type_id].append({
#                                     'document_id': pesticide_doc.id,
#                                     'document_category': {'id': file_type.id, 'name': file_type.name},
#                                     'upload_document': request.build_absolute_uri(pesticide_doc.document.url),
#                                     'language': {"default": "en"}
#                                 })
#                             else:
#                                 return Response({'error': 'Invalid MIME type.'}, status=status.HTTP_400_BAD_REQUEST)
#                         else:
#                             return Response({'error': 'Unsupported file format.'}, status=status.HTTP_400_BAD_REQUEST)
#                     except Exception as e:
#                         return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)

#             for file_type_id_key, docs in grouped_documents.items():
#                 formatted_documents.append({
#                     'category_id': file_type_id_key,
#                     'documents': docs
#                 })

#         # --- Inventory logic ---
#         new_inventory_item_id = data.get("inventory_items")
#         if inventory_type_id and new_inventory_item_id:
#             new_inventory_item = get_object_or_404(InventoryItems, id=new_inventory_item_id, status=0)

#             try:
#                 last_item = MyPesticides.objects.filter(
#                     farmer=farmer,
#                     inventory_type=pesticide_instance.inventory_type,
#                     inventory_items__status=0
#                 ).latest('created_at')
#                 # Mark last pesticide's inventory_items status to 1 (inactive)
#                 MyPesticidesSerializer.objects.filter(
#                     farmer=farmer,
#                     inventory_type=pesticide_instance.inventory_type,
#                     inventory_items=last_item.inventory_items
#                 ).update(status=1)
#             except MyPesticides.DoesNotExist:
#                 # No previous pesticide found, skip update
#                 pass

#             pesticide_instance.inventory_items = new_inventory_item

#             # Calculate total quantity for this inventory item & type for this farmer
#             total_quantity = MyPesticides.objects.filter(
#                 farmer=farmer,
#                 inventory_type=inventory_type_id,
#                 inventory_items=new_inventory_item
#             ).aggregate(total=Sum('quantity'))['total'] or 0

#             pesticide_instance.available_quans = total_quantity
#             pesticide_instance.save()

#         # --- Vendor Outstanding & Balance Update Logic ---
#         purchase_amount = float(data.get('purchase_amount', 0))
#         paid_amount = float(data.get('paid_amount', 0))

#         net_change = paid_amount - purchase_amount  # Positive means vendor owes you; negative means you owe vendor
#         current_balance = vendor.opening_balance or 0
#         updated_balance = current_balance + net_change

#         # Set credit/debit flags and opening_balance accordingly
#         if updated_balance > 0:
#             # Vendor owes you money (receivables)
#             vendor.credit = True
#             vendor.debit = False
#             vendor.opening_balance = updated_balance
#         elif updated_balance < 0:
#             # You owe vendor money (payables)
#             vendor.credit = False
#             vendor.debit = True
#             vendor.opening_balance = abs(updated_balance)
#         else:
#             # No outstanding balance
#             vendor.credit = False
#             vendor.debit = False
#             vendor.opening_balance = 0

#         # Update payables or receivables amounts on vendor accordingly
#         if net_change < 0:
#             # You owe vendor money â†’ payables increase
#             vendor.payables = (vendor.payables or 0) + abs(net_change)
#         elif net_change > 0:
#             # Vendor owes you money â†’ receivables increase
#             vendor.receivables = (vendor.receivables or 0) + net_change

#         vendor.save()

#         # Sync balances to customer if vendor is also a customer
#         if vendor.is_customer_is_vendor and hasattr(vendor, 'customer'):
#             customer = vendor.customer
#             customer.opening_balance = vendor.opening_balance
#             customer.payables = vendor.payables
#             customer.receivables = vendor.receivables
#             customer.is_credit = vendor.credit
#             customer.save()

#         # Prepare Outstanding record fields
#         balance = abs(net_change)
#         now = timezone.now()

#         # Depending on net_change, set appropriate Outstanding fields
#         if net_change < 0:
#             # Payables case (you owe vendor)
#             to_pay = abs(net_change)
#             Outstanding.objects.create(
#                 farmer=farmer,
#                 vendor=vendor,
#                 pesticide_purchase=pesticide_instance,
#                 balance=purchase_amount,
#                 paid=paid_amount,
#                 to_pay=to_pay,
#                 paid_date=now,
#                 total_paid=paid_amount,
#                 identify=1,
#                 created_by=farmer.farmer_user,
#                 created_at=now
#             )
#         elif net_change > 0:
#             # Receivables case (vendor owes you)
#             to_receive = net_change
#             Outstanding.objects.create(
#                 farmer=farmer,
#                 vendor=vendor,
#                 pesticide_purchase=pesticide_instance,
#                 balance=balance,
#                 paid=paid_amount,
#                 to_receive=to_receive,
#                 received_date=now,
#                 total_received=paid_amount,
#                 identify=1,
#                 created_by=farmer.farmer_user,
#                 created_at=now
#             )
#         else:
#             # Exact payment, no outstanding balance
#             Outstanding.objects.create(
#                 farmer=farmer,
#                 vendor=vendor,
#                 pesticide_purchase=pesticide_instance,
#                 balance=0,
#                 paid=paid_amount,
#                 to_pay=0,
#                 paid_date=now,
#                 total_paid=paid_amount,
#                 received=paid_amount,
#                 to_receive=0,
#                 received_date=now,
#                 total_received=paid_amount,
#                 identify=1,
#                 created_by=farmer.farmer_user,
#                 created_at=now
#             )

#         # Optional: Create Farmer Notification
#         FarmerNotification.objects.create(
#             farmer=farmer,
#             name='New Purchase Created',
#             message=f'{pesticide_instance.inventory_items.name}',
#             type='Pesticide'
#         )

#         return Response({
#             "success": True,
#             "message": "Pesticide added successfully!",
#             "data": serializer.data,
#             "documents": formatted_documents,
#             "language": {"default": "en"}
#         }, status=status.HTTP_201_CREATED)

#     return Response({
#         "success": False,
#         "message": "Validation failed.",
#         "errors": serializer.errors
#     }, status=status.HTTP_400_BAD_REQUEST)

@api_view(['POST'])
def add_pesticides(request, farmer_id):
    farmer = get_object_or_404(Farmer, id=farmer_id)
    data = request.data.copy()
    user = request.user  # logged-in user

    # --- If pesticide_id provided, reset previous pesticide and update outstanding ---
    pesticide_id = data.get('pesticide_id')
    if pesticide_id:
        pesticide = get_object_or_404(MyPesticides, pk=pesticide_id)
        pesticide.status = 0
        pesticide.save()

        inv = get_object_or_404(MyInventory, pesticide_purchase=pesticide)
        inv.status = 0
        inv.save()

        FarmerNotification.objects.create(
            farmer=farmer,
            name='Previous Purchase Reset',
            message=f'{pesticide.inventory_items.name}',
            type='Pesticide'
        )

    # --- Validate required fields ---
    required_fields = [
        'date_of_purchase', 'inventory_type', 'inventory_category',
        'inventory_items', 'vendor', 'quantity', 'purchase_amount', 'paid_amount'
    ]
    missing_fields = [field for field in required_fields if not data.get(field)]
    if missing_fields:
        return Response({
            "success": False,
            "message": f"Missing required fields: {', '.join(missing_fields)}"
        }, status=status.HTTP_400_BAD_REQUEST)

    # --- Validate vendor and inventory_type relationship ---
    vendor_id = data.get('vendor')
    inventory_type_id = data.get('inventory_type')
    vendor = get_object_or_404(MyVendor, id=vendor_id)

    if not vendor.inventory_type.filter(id=inventory_type_id).exists():
        return Response({
            "success": False,
            "message": "This vendor is not associated with the selected inventory type."
        }, status=status.HTTP_400_BAD_REQUEST)

    # --- Prepare metadata for serializer ---
    data['farmer'] = farmer.id
    data['created_at'] = timezone.now()
    data['created_by'] = user.id  # Use logged-in user id, not farmer_user for consistency

    serializer = MyPesticidesAddSerializer(data=data)
    if serializer.is_valid():
        pesticide_instance = serializer.save()

        # --- Optional Documents Handling ---
        file_data = request.data.get('documents', None)
        formatted_documents = []
        if file_data:
            grouped_documents = {}
            for doc_data in file_data:
                file_type_id = doc_data.get('file_type')
                documents = doc_data.get('documents', [])

                if not documents:
                    return Response({"success": False, "message": f"No documents for file type {file_type_id}"}, status=status.HTTP_400_BAD_REQUEST)

                if file_type_id is None:
                    new_file_type = doc_data.get('new_file_type')
                    if not new_file_type:
                        return Response({"error": "New file type required."}, status=status.HTTP_400_BAD_REQUEST)
                    file_type, _ = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=1)
                    file_type_id = file_type.id
                else:
                    file_type = get_object_or_404(DocumentCategory, id=file_type_id)

                if file_type_id not in grouped_documents:
                    grouped_documents[file_type_id] = []

                for i, document_base64 in enumerate(documents):
                    try:
                        if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
                            mime_type = validate_image_type(document_base64)
                            if mime_type:
                                document_data = document_base64.split(';base64,')[1]
                                document_bytes = base64.b64decode(document_data)
                                if len(document_bytes) > 10 * 1024 * 1024:
                                    return Response({'error': 'File too large. Max 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

                                ext = mime_type.split('/')[1]
                                document_name = f"pesticide_{farmer_id}_{file_type_id}_{i}.{ext}"
                                document_file = ContentFile(document_bytes, name=document_name)

                                pesticide_doc = MyPesticidesDocuments.objects.create(
                                    farmer=farmer,
                                    pesticide=pesticide_instance,
                                    file_type=file_type,
                                    document=document_file,
                                    created_at=timezone.now(),
                                    created_by=user
                                )

                                grouped_documents[file_type_id].append({
                                    'document_id': pesticide_doc.id,
                                    'document_category': {'id': file_type.id, 'name': file_type.name},
                                    'upload_document': request.build_absolute_uri(pesticide_doc.document.url),
                                    'language': {"default": "en"}
                                })
                            else:
                                return Response({'error': 'Invalid MIME type.'}, status=status.HTTP_400_BAD_REQUEST)
                        else:
                            return Response({'error': 'Unsupported file format.'}, status=status.HTTP_400_BAD_REQUEST)
                    except Exception as e:
                        return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)

            for file_type_id_key, docs in grouped_documents.items():
                formatted_documents.append({
                    'category_id': file_type_id_key,
                    'documents': docs
                })

        # --- Inventory logic ---
        new_inventory_item_id = data.get("inventory_items")
        if inventory_type_id and new_inventory_item_id:
            new_inventory_item = get_object_or_404(InventoryItems, id=new_inventory_item_id, status=0)

            try:
                last_item = MyPesticides.objects.filter(
                    farmer=farmer,
                    inventory_type=pesticide_instance.inventory_type,
                    inventory_items__status=0
                ).exclude(id=pesticide_instance.id).latest('created_at')
                # Mark last pesticide's inventory_items status to 1 (inactive)
                MyPesticides.objects.filter(
                    farmer=farmer,
                    inventory_type=pesticide_instance.inventory_type,
                    inventory_items=last_item.inventory_items
                ).update(status=1)
            except MyPesticides.DoesNotExist:
                # No previous pesticide found, skip update
                pass

            pesticide_instance.inventory_items = new_inventory_item

            # Calculate total quantity for this inventory item & type for this farmer
            total_quantity = MyPesticides.objects.filter(
                farmer=farmer,
                inventory_type=inventory_type_id,
                inventory_items=new_inventory_item
            ).aggregate(total=Sum('quantity'))['total'] or 0

            pesticide_instance.available_quans = total_quantity
            pesticide_instance.save()

        # --- Vendor Outstanding & Balance Update Logic ---
        purchase_amount = float(data.get('purchase_amount', 0))
        paid_amount = float(data.get('paid_amount', 0))

        net_change = paid_amount - purchase_amount  # Positive means vendor owes you; negative means you owe vendor
        current_balance = vendor.opening_balance or 0
        updated_balance = current_balance + net_change

        # Set credit/debit flags and opening_balance accordingly
        if updated_balance > 0:
            # Vendor owes you money (receivables)
            vendor.credit = True
            vendor.debit = False
            vendor.opening_balance = updated_balance
        elif updated_balance < 0:
            # You owe vendor money (payables)
            vendor.credit = False
            vendor.debit = True
            vendor.opening_balance = abs(updated_balance)
        else:
            # No outstanding balance
            vendor.credit = False
            vendor.debit = False
            vendor.opening_balance = 0

        # Update payables or receivables amounts on vendor accordingly
        if net_change < 0:
            # You owe vendor money â†’ payables increase
            vendor.payables = (vendor.payables or 0) + abs(net_change)
        elif net_change > 0:
            # Vendor owes you money â†’ receivables increase
            vendor.receivables = (vendor.receivables or 0) + net_change

        vendor.save()

        # Sync balances to customer if vendor is also a customer
        if vendor.is_customer_is_vendor and hasattr(vendor, 'customer'):
            customer = vendor.customer
            customer.opening_balance = vendor.opening_balance
            customer.payables = vendor.payables
            customer.receivables = vendor.receivables
            customer.is_credit = vendor.credit
            customer.save()

        # Prepare Outstanding record fields
        balance = abs(net_change)
        now = timezone.now()

        # Depending on net_change, set appropriate Outstanding fields
        if net_change < 0:
            # Payables case (you owe vendor)
            to_pay = abs(net_change)
            Outstanding.objects.create(
                farmer=farmer,
                vendor=vendor,
                pesticide_purchase=pesticide_instance,
                balance=purchase_amount,
                paid=paid_amount,
                to_pay=to_pay,
                paid_date=now,
                total_paid=paid_amount,
                identify=1,
                created_by=user,
                created_at=now
            )
        elif net_change > 0:
            # Receivables case (vendor owes you)
            to_receive = net_change
            Outstanding.objects.create(
                farmer=farmer,
                vendor=vendor,
                pesticide_purchase=pesticide_instance,
                balance=balance,
                paid=paid_amount,
                to_receive=to_receive,
                received_date=now,
                total_received=paid_amount,
                identify=1,
                created_by=user,
                created_at=now
            )
        else:
            # Exact payment, no outstanding balance
            Outstanding.objects.create(
                farmer=farmer,
                vendor=vendor,
                pesticide_purchase=pesticide_instance,
                balance=0,
                paid=paid_amount,
                to_pay=0,
                paid_date=now,
                total_paid=paid_amount,
                received=paid_amount,
                to_receive=0,
                received_date=now,
                total_received=paid_amount,
                identify=1,
                created_by=user,
                created_at=now
            )

        # Create Farmer Notification for new pesticide purchase
        FarmerNotification.objects.create(
            farmer=farmer,
            name='New Purchase Created',
            message=f'{pesticide_instance.inventory_items.name}',
            type='Pesticide'
        )

        return Response({
            "success": True,
            "message": "Pesticide added successfully!",
            "data": serializer.data,
            "documents": formatted_documents,
            "language": {"default": "en"}
        }, status=status.HTTP_201_CREATED)

    # If serializer not valid
    return Response({
        "success": False,
        "message": "Validation failed.",
        "errors": serializer.errors
    }, status=status.HTTP_400_BAD_REQUEST)

# @api_view(['POST'])
# def add_fertilizer(request, farmer_id):
#     # Fetch the farmer instance based on the farmer_id
#     farmer = get_object_or_404(Farmer, id=farmer_id)

#     # Create a mutable copy of the data to ensure we can modify it
#     mutable_data = request.data.copy()

#     # Handle multiple fertilizers data or a single fertilizer entry
#     if isinstance(mutable_data, list):
#         for fertilizer_data in mutable_data:
#             for field in fertilizer_data:
#                 if fertilizer_data[field] is None:
#                     fertilizer_data[field] = ""  # Replace None with empty string
#             fertilizer_data['farmer'] = farmer.id
#             fertilizer_data['created_at'] = timezone.now()
#             fertilizer_data['created_by'] = farmer.farmer_user.id
#     else:
#         for field in mutable_data:
#             if mutable_data[field] is None:
#                 mutable_data[field] = ""  # Replace None with empty string
#         mutable_data['farmer'] = farmer.id
#         mutable_data['created_at'] = timezone.now()
#         mutable_data['created_by'] = farmer.farmer_user.id

#     # Initialize the serializer with the mutable data
#     serializer = MyFertilizersAddSerializer(data=mutable_data, many=isinstance(mutable_data, list))

#     # Validate the serializer
#     if serializer.is_valid():
#         # Save the fertilizer record (the fertilizer instance is created here)
#         fertilizer_instance = serializer.save(farmer=farmer)

#         # Handle the inventory_type and related inventory_item
#         inventory_type_id = mutable_data.get('inventory_type')
#         new_inventory_item_id = request.data.get("inventory_items")

#         if inventory_type_id and new_inventory_item_id:
#             # Retrieve the new inventory item, which should have status=0 (active)
#             new_inventory_item = get_object_or_404(InventoryItems, id=new_inventory_item_id, status=0)

#             # Retrieve the last created MyFertilizers entry with the same inventory_type and set previous inventory items to inactive
#             last_inventory_item = MyFertilizers.objects.filter(
#                 inventory_type=fertilizer_instance.inventory_type,
#                 inventory_items__status=0
#             ).latest('created_at')  # Assuming 'created_at' is the field indicating the creation time

#             if last_inventory_item:
#                 # Update the status of the previous inventory item to 1 (inactive)
#                 MyFertilizers.objects.filter(
#                     inventory_type=fertilizer_instance.inventory_type,
#                     inventory_items=last_inventory_item.inventory_items
#                 ).update(status=1)

#             # Set the new inventory item to the fertilizer instance
#             fertilizer_instance.inventory_items = new_inventory_item

#             # Recalculate the available quantity for the inventory type
#             total_quantity = MyFertilizers.objects.filter(
#                 inventory_type=inventory_type_id,
#                 inventory_items=new_inventory_item
#             ).aggregate(total_quantity=Sum('quantity'))['total_quantity'] or 0

#             # Update the fertilizer instance with the recalculated available quantity
#             fertilizer_instance.available_quans = total_quantity
#             fertilizer_instance.save()

#         # Handle the documents uploaded with fertilizers (optional)
#         file_data = request.data.get('documents', None)  # Get the documents if provided
#         if file_data:
#             # Initialize grouped documents to handle file_type categorization
#             grouped_documents = {}

#             # Process each document and its corresponding file_type
#             for doc_data in file_data:
#                 file_type_id = doc_data.get('file_type')
#                 documents = doc_data.get('documents', [])

#                 if not documents:
#                     return Response(
#                         {"success": False, "message": f"No documents provided for file type {file_type_id}."},
#                         status=status.HTTP_400_BAD_REQUEST
#                     )

#                 # Check if file_type_id is None and create a new file type if necessary
#                 if file_type_id is None:
#                     new_file_type = doc_data.get('new_file_type')
#                     if not new_file_type:
#                         return Response({"error": f"New file type for document is required."}, status=status.HTTP_400_BAD_REQUEST)
                    
#                     # Create a new file type if not exists
#                     file_type, created = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=2)  # Assuming doctype=2 for fertilizers
                    
#                 else:
#                     # Get the existing file type
#                     file_type = get_object_or_404(DocumentCategory, id=file_type_id)

#                 if file_type_id not in grouped_documents:
#                     grouped_documents[file_type_id] = []

#                 # Process the documents, creating FertilizerDocument entries
#                 for i, document_base64 in enumerate(documents):
#                     try:
#                         # Validate MIME type (only image/jpeg, image/png, and application/pdf)
#                         if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
#                             mime_type = validate_image_type(document_base64)  # Validate the MIME type
#                             if mime_type:
#                                 # Extract the base64 data and decode it
#                                 document_data = document_base64.split(';base64,')[1]
#                                 document_bytes = base64.b64decode(document_data)

#                                 # Check file size (10MB max)
#                                 max_file_size = 10 * 1024 * 1024  # 10MB
#                                 if len(document_bytes) > max_file_size:
#                                     return Response({'error': f'File is too large. Max size is 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

#                                 # Create a document name and ContentFile
#                                 document_name = f"fertilizer_{farmer_id}_{file_type_id}_{i}.{mime_type.split('/')[1]}"
#                                 document_file = ContentFile(document_bytes, name=document_name)

#                                 # Create FertilizerDocument instance and save it
#                                 fertilizer_document_instance = MyFertilizersDocuments.objects.create(
#                                     farmer=farmer,
#                                     fertilizers=fertilizer_instance,  # Link to the fertilizer instance
#                                     file_type=file_type,
#                                     document=document_file,
#                                     created_at=timezone.now(),
#                                     created_by=farmer.farmer_user
#                                 )

#                                 # Append the document info to the grouped_documents list
#                                 document_data = {
#                                     'document_id': fertilizer_document_instance.id,
#                                     'document_category': {
#                                         'id': file_type.id,
#                                         'name': file_type.name
#                                     },
#                                     'upload_document': request.build_absolute_uri(f'/SuperAdmin{document_file.name}'),
#                                     'language': {
#                                         'default': 'en'
#                                     }
#                                 }

#                                 grouped_documents[file_type_id].append(document_data)
#                             else:
#                                 return Response({'error': 'Invalid MIME type for the document.'}, status=status.HTTP_400_BAD_REQUEST)
#                         else:
#                             return Response({'error': 'Invalid file format. Only image/jpeg, image/png, and application/pdf are allowed.'}, status=status.HTTP_400_BAD_REQUEST)

#                     except Exception as e:
#                         return Response({'error': f"Error processing document: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

#             # Prepare formatted document data for response
#             formatted_documents = []
#             for file_type_id, documents in grouped_documents.items():
#                 formatted_documents.append({
#                     'category_id': file_type_id,
#                     'documents': documents
#                 })
#         else:
#             formatted_documents = []  # If no documents are provided, return an empty list

#         # Save any additional fields from the request (e.g., quantity, purchase_amount, description)
#         fertilizer_instance.quantity = request.data.get("quantity", fertilizer_instance.quantity)
#         fertilizer_instance.purchase_amount = request.data.get("purchase_amount", fertilizer_instance.purchase_amount)
#         fertilizer_instance.description = request.data.get("description", fertilizer_instance.description)

#         # Save the updated fertilizer record
#         fertilizer_instance.save()

#            # Create Outstanding record
#         purchase_amount = float(mutable_data.get('purchase_amount', 0))
#         paid_amount = float(mutable_data.get('paid_amount', 0))

#         balance = 0
#         paid = 0
#         to_pay = 0
#         paid_date = None
#         total_paid = 0
#         received = 0
#         to_receive = 0
#         received_date = None
#         total_received = 0

#         if paid_amount < purchase_amount:
#             balance = purchase_amount - paid_amount
#             to_receive = balance
#             total_received = paid_amount
#             received_date = timezone.now() if paid_amount > 0 else None
#         elif paid_amount > purchase_amount:
#             balance = paid_amount - purchase_amount
#             to_pay = balance
#             received = paid_amount
#             total_received = paid_amount
#             received_date = timezone.now()
#         else:
#             total_received = paid_amount
#             received_date = timezone.now()

#         Outstanding.objects.create(
#             farmer=farmer,
#             vendor=fertilizer_instance.vendor,
#             fuel_purchase=None,
#             fertilizer_purchase=fertilizer_instance,
#             balance=balance,
#             paid=paid,
#             to_pay=to_pay,
#             paid_date=paid_date,
#             total_paid=total_paid,
#             received=received,
#             to_receive=to_receive,
#             received_date=received_date,
#             total_received=total_received,
#             payment_amount=paid_amount,
#             created_by=farmer.farmer_user,
#             created_at=timezone.now(),
#             status=0
#         )

#         # Return the response with the fertilizer and document details
#         return Response(
#             {
#                 "success": True,
#                 "message": "Fertilizer added successfully!",
#                 "data": serializer.data,
#                 "documents": formatted_documents,  # Include the grouped and formatted documents if provided
#                 "language": {
#                     "default": "en"
#                 }
#             },
#             status=status.HTTP_201_CREATED
#         )

#     # If serializer is invalid, return errors
#     return Response(
#         {
#             "success": False,
#             "message": "Failed to add fertilizer. Please check the input data.",
#             "errors": serializer.errors
#         },
#         status=status.HTTP_400_BAD_REQUEST
#     )

# @api_view(['POST'])
# def add_fertilizer(request, farmer_id):
#     # Fetch the farmer instance based on the farmer_id
#     farmer = get_object_or_404(Farmer, id=farmer_id)

#     # Create a mutable copy of the data to ensure we can modify it
#     mutable_data = request.data.copy()

#     # Check for required fields
#     required_fields = [
#         'date_of_consumption', 'inventory_type', 'inventory_category', 
#         'inventory_items', 'vendor', 'quantity', 'quantity_unit', 
#         'purchase_amount', 'paid_amount'
#     ]

#     missing_fields = [field for field in required_fields if field not in mutable_data or not mutable_data[field]]
#     if missing_fields:
#         return Response(
#             {"success": False, "message": f"Missing required fields: {', '.join(missing_fields)}"},
#             status=status.HTTP_400_BAD_REQUEST
#         )

#     # Handle optional fields: description and documents
#     description = mutable_data.get("description", "")
#     documents = mutable_data.get("documents", [])

#     # Set default values for optional fields if not provided
#     mutable_data['farmer'] = farmer.id
#     mutable_data['created_at'] = timezone.now()
#     mutable_data['created_by'] = farmer.farmer_user.id

#     # Initialize the serializer with the mutable data
#     serializer = MyFertilizersAddSerializer(data=mutable_data)

#     # Validate the serializer
#     if serializer.is_valid():
#         # Save the fertilizer record (the fertilizer instance is created here)
#         fertilizer_instance = serializer.save(farmer=farmer)

#         # Handle the inventory_type and related inventory_item
#         inventory_type_id = mutable_data.get('inventory_type')
#         new_inventory_item_id = mutable_data.get('inventory_items')

#         if inventory_type_id and new_inventory_item_id:
#             # Retrieve the new inventory item, which should have status=0 (active)
#             new_inventory_item = get_object_or_404(InventoryItems, id=new_inventory_item_id, status=0)

#             # Retrieve the last created MyFertilizers entry with the same inventory_type and set previous inventory items to inactive
#             last_inventory_item = MyFertilizers.objects.filter(
#                 inventory_type=fertilizer_instance.inventory_type,
#                 inventory_items__status=0
#             ).latest('created_at')  # Assuming 'created_at' is the field indicating the creation time

#             if last_inventory_item:
#                 # Update the status of the previous inventory item to 1 (inactive)
#                 MyFertilizers.objects.filter(
#                     inventory_type=fertilizer_instance.inventory_type,
#                     inventory_items=last_inventory_item.inventory_items
#                 ).update(status=1)

#             # Set the new inventory item to the fertilizer instance
#             fertilizer_instance.inventory_items = new_inventory_item

#             # Recalculate the available quantity for the inventory type
#             total_quantity = MyFertilizers.objects.filter(
#                 inventory_type=inventory_type_id,
#                 inventory_items=new_inventory_item
#             ).aggregate(total_quantity=Sum('quantity'))['total_quantity'] or 0

#             # Update the fertilizer instance with the recalculated available quantity
#             fertilizer_instance.available_quans = total_quantity
#             fertilizer_instance.save()

#         # Handle the documents uploaded with fertilizers (optional)
#         if documents:
#             # Initialize grouped documents to handle file_type categorization
#             grouped_documents = {}

#             # Process each document and its corresponding file_type
#             for doc_data in documents:
#                 file_type_id = doc_data.get('file_type')
#                 document_files = doc_data.get('documents', [])

#                 if not document_files:
#                     return Response(
#                         {"success": False, "message": f"No documents provided for file type {file_type_id}."},
#                         status=status.HTTP_400_BAD_REQUEST
#                     )

#                 # Check if file_type_id is None and create a new file type if necessary
#                 if file_type_id is None:
#                     new_file_type = doc_data.get('new_file_type')
#                     if not new_file_type:
#                         return Response({"error": f"New file type for document is required."}, status=status.HTTP_400_BAD_REQUEST)
                    
#                     # Create a new file type if not exists
#                     file_type, created = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=2)  # Assuming doctype=2 for fertilizers
                    
#                 else:
#                     # Get the existing file type
#                     file_type = get_object_or_404(DocumentCategory, id=file_type_id)

#                 if file_type_id not in grouped_documents:
#                     grouped_documents[file_type_id] = []

#                 # Process the documents, creating FertilizerDocument entries
#                 for i, document_base64 in enumerate(document_files):
#                     try:
#                         # Validate MIME type (only image/jpeg, image/png, and application/pdf)
#                         if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
#                             mime_type = validate_image_type(document_base64)  # Validate the MIME type
#                             if mime_type:
#                                 # Extract the base64 data and decode it
#                                 document_data = document_base64.split(';base64,')[1]
#                                 document_bytes = base64.b64decode(document_data)

#                                 # Check file size (10MB max)
#                                 max_file_size = 10 * 1024 * 1024  # 10MB
#                                 if len(document_bytes) > max_file_size:
#                                     return Response({'error': f'File is too large. Max size is 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

#                                 # Create a document name and ContentFile
#                                 document_name = f"fertilizer_{farmer_id}_{file_type_id}_{i}.{mime_type.split('/')[1]}"
#                                 document_file = ContentFile(document_bytes, name=document_name)

#                                 # Create FertilizerDocument instance and save it
#                                 fertilizer_document_instance = MyFertilizersDocuments.objects.create(
#                                     farmer=farmer,
#                                     fertilizers=fertilizer_instance,  # Link to the fertilizer instance
#                                     file_type=file_type,
#                                     document=document_file,
#                                     created_at=timezone.now(),
#                                     created_by=farmer.farmer_user
#                                 )

#                                 # Append the document info to the grouped_documents list
#                                 document_data = {
#                                     'document_id': fertilizer_document_instance.id,
#                                     'document_category': {
#                                         'id': file_type.id,
#                                         'name': file_type.name
#                                     },
#                                     'upload_document': request.build_absolute_uri(f'/SuperAdmin{document_file.name}'),
#                                     'language': {
#                                         'default': 'en'
#                                     }
#                                 }

#                                 grouped_documents[file_type_id].append(document_data)
#                             else:
#                                 return Response({'error': 'Invalid MIME type for the document.'}, status=status.HTTP_400_BAD_REQUEST)
#                         else:
#                             return Response({'error': 'Invalid file format. Only image/jpeg, image/png, and application/pdf are allowed.'}, status=status.HTTP_400_BAD_REQUEST)

#                     except Exception as e:
#                         return Response({'error': f"Error processing document: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

#             # Prepare formatted document data for response
#             formatted_documents = []
#             for file_type_id, documents in grouped_documents.items():
#                 formatted_documents.append({
#                     'category_id': file_type_id,
#                     'documents': documents
#                 })
#         else:
#             formatted_documents = []  # If no documents are provided, return an empty list

#         # Save any additional fields from the request (e.g., quantity, purchase_amount, description)
#         fertilizer_instance.quantity = mutable_data.get("quantity", fertilizer_instance.quantity)
#         fertilizer_instance.purchase_amount = mutable_data.get("purchase_amount", fertilizer_instance.purchase_amount)
#         fertilizer_instance.paid_amount = mutable_data.get("paid_amount", fertilizer_instance.paid_amount)
#         fertilizer_instance.outstanding = fertilizer_instance.purchase_amount - fertilizer_instance.paid_amount
#         fertilizer_instance.description = description  # Handle description

#         # Save the updated fertilizer record
#         fertilizer_instance.save()


#         purchase_amount = float(mutable_data.get('purchase_amount', 0))
#         paid_amount = float(mutable_data.get('paid_amount', 0))

#         balance = 0
#         paid = 0
#         to_pay = 0
#         paid_date = None
#         total_paid = 0
#         received = 0
#         to_receive = 0
#         received_date = None
#         total_received = 0

#         if paid_amount < purchase_amount:
#             balance = purchase_amount - paid_amount
#             to_receive = balance
#             total_received = paid_amount
#             received_date = timezone.now() if paid_amount > 0 else None
#         elif paid_amount > purchase_amount:
#             balance = paid_amount - purchase_amount
#             to_pay = balance
#             received = paid_amount
#             total_received = paid_amount
#             received_date = timezone.now()
#         else:
#             total_received = paid_amount
#             received_date = timezone.now()

#         Outstanding.objects.create(
#             farmer=farmer,
#             vendor=fertilizer_instance.vendor,
#             fuel_purchase=None,
#             fertilizer_purchase=fertilizer_instance,
#             balance=balance,
#             paid=paid,
#             to_pay=to_pay,
#             paid_date=paid_date,
#             total_paid=total_paid,
#             received=received,
#             to_receive=to_receive,
#             received_date=received_date,
#             total_received=total_received,
#             payment_amount=paid_amount,
#             created_by=farmer.farmer_user,
#             created_at=timezone.now(),
#             status=0
#         )


#         # Return the response with the fertilizer and document details
#         return Response(
#             {
#                 "success": True,
#                 "message": "Fertilizer added successfully!",
#                 "data": serializer.data,
#                 "documents": formatted_documents,  # Include the grouped and formatted documents if provided
#                 "language": {
#                     "default": "en"
#                 }
#             },
#             status=status.HTTP_201_CREATED
#         )

#     # If serializer is invalid, return errors
#     return Response(
#         {
#             "success": False,
#             "message": "Failed to add fertilizer. Please check the input data.",
#             "errors": serializer.errors
#         },
#         status=status.HTTP_400_BAD_REQUEST
#     )

 
# old 15-09-2025
# @api_view(['POST'])
# def add_fertilizer(request, farmer_id):
#     farmer = get_object_or_404(Farmer, id=farmer_id)
#     mutable_data = request.data.copy()

#     required_fields = [
#         'date_of_consumption', 'inventory_type', 'inventory_category',
#         'inventory_items', 'vendor', 'quantity', 'quantity_unit',
#         'purchase_amount', 'paid_amount'
#     ]

#     missing_fields = [field for field in required_fields if field not in mutable_data or not mutable_data[field]]
#     if missing_fields:
#         return Response(
#             {"success": False, "message": f"Missing required fields: {', '.join(missing_fields)}"},
#             status=status.HTTP_400_BAD_REQUEST
#         )

#     description = mutable_data.get("description", "")
#     documents = mutable_data.get("documents", [])

#     mutable_data['farmer'] = farmer.id
#     mutable_data['created_at'] = timezone.now()
#     mutable_data['created_by'] = farmer.farmer_user.id

#     serializer = MyFertilizersAddSerializer(data=mutable_data)

#     if serializer.is_valid():
#         fertilizer_instance = serializer.save(farmer=farmer)

#         inventory_type_id = mutable_data.get('inventory_type')
#         new_inventory_item_id = mutable_data.get('inventory_items')

#         if inventory_type_id and new_inventory_item_id:
#             new_inventory_item = get_object_or_404(InventoryItems, id=new_inventory_item_id, status=0)

#             last_inventory_item = MyFertilizers.objects.filter(
#                 farmer = farmer,
#                 inventory_type=fertilizer_instance.inventory_type,
#                 inventory_items__status=0
#             ).order_by('-created_at').first()

#             if last_inventory_item:
#                 MyFertilizers.objects.filter(
#                     farmer = farmer,
#                     inventory_type=fertilizer_instance.inventory_type,
#                     inventory_items=last_inventory_item.inventory_items
#                 ).update(status=1)

#             fertilizer_instance.inventory_items = new_inventory_item

#             total_quantity = MyFertilizers.objects.filter(
#                 farmer = farmer,
#                 inventory_type=inventory_type_id,
#                 inventory_items=new_inventory_item
#             ).aggregate(total_quantity=Sum('quantity'))['total_quantity'] or 0

#             fertilizer_instance.available_quans = total_quantity
#             fertilizer_instance.save()

#         formatted_documents = []
#         if documents:
#             grouped_documents = {}

#             for doc_data in documents:
#                 file_type_id = doc_data.get('file_type')
#                 document_files = doc_data.get('documents', [])

#                 if not document_files:
#                     return Response(
#                         {"success": False, "message": f"No documents provided for file type {file_type_id}."},
#                         status=status.HTTP_400_BAD_REQUEST
#                     )

#                 if file_type_id is None:
#                     new_file_type = doc_data.get('new_file_type')
#                     if not new_file_type:
#                         return Response({"error": f"New file type for document is required."}, status=status.HTTP_400_BAD_REQUEST)
                    
#                     file_type, _ = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=2)
#                 else:
#                     file_type = get_object_or_404(DocumentCategory, id=file_type_id)

#                 if file_type.id not in grouped_documents:
#                     grouped_documents[file_type.id] = []

#                 for i, document_base64 in enumerate(document_files):
#                     try:
#                         if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
#                             mime_type = validate_image_type(document_base64)
#                             if mime_type:
#                                 document_data = document_base64.split(';base64,')[1]
#                                 document_bytes = base64.b64decode(document_data)

#                                 max_file_size = 10 * 1024 * 1024
#                                 if len(document_bytes) > max_file_size:
#                                     return Response({'error': f'File is too large. Max size is 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

#                                 document_name = f"fertilizer_{farmer_id}_{file_type.id}_{i}.{mime_type.split('/')[1]}"
#                                 document_file = ContentFile(document_bytes, name=document_name)

#                                 fert_doc = MyFertilizersDocuments.objects.create(
#                                     farmer=farmer,
#                                     fertilizers=fertilizer_instance,
#                                     file_type=file_type,
#                                     document=document_file,
#                                     created_at=timezone.now(),
#                                     created_by=farmer.farmer_user
#                                 )

#                                 document_info = {
#                                     'document_id': fert_doc.id,
#                                     'document_category': {
#                                         'id': file_type.id,
#                                         'name': file_type.name
#                                     },
#                                     'upload_document': request.build_absolute_uri(f'/SuperAdmin{document_file.name}'),
#                                     'language': {
#                                         'default': 'en'
#                                     }
#                                 }

#                                 grouped_documents[file_type.id].append(document_info)
#                             else:
#                                 return Response({'error': 'Invalid MIME type for the document.'}, status=status.HTTP_400_BAD_REQUEST)
#                         else:
#                             return Response({'error': 'Invalid file format. Only image/jpeg, image/png, and application/pdf are allowed.'}, status=status.HTTP_400_BAD_REQUEST)

#                     except Exception as e:
#                         return Response({'error': f"Error processing document: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

#             for file_type_id, documents in grouped_documents.items():
#                 formatted_documents.append({
#                     'category_id': file_type_id,
#                     'documents': documents
#                 })

#         # âœ… Safely cast amounts and quantities to float
#         try:
#             quantity = float(mutable_data.get("quantity", 0))
#             purchase_amount = float(mutable_data.get("purchase_amount", 0))
#             paid_amount = float(mutable_data.get("paid_amount", 0))
#         except ValueError:
#             return Response({'error': 'Quantity, purchase_amount, and paid_amount must be numbers.'}, status=status.HTTP_400_BAD_REQUEST)

#         fertilizer_instance.quantity = quantity
#         fertilizer_instance.purchase_amount = purchase_amount
#         fertilizer_instance.paid_amount = paid_amount
#         fertilizer_instance.outstanding = purchase_amount - paid_amount
#         fertilizer_instance.description = description
#         fertilizer_instance.save()

#         # âœ… Handle outstanding calculations
#         balance = 0
#         paid = 0
#         to_pay = 0
#         paid_date = None
#         total_paid = 0
#         received = 0
#         to_receive = 0
#         received_date = None
#         total_received = 0

#         if paid_amount < purchase_amount:
#             balance = purchase_amount - paid_amount
#             to_receive = balance
#             total_received = paid_amount
#             received_date = timezone.now() if paid_amount > 0 else None
#         elif paid_amount > purchase_amount:
#             balance = paid_amount - purchase_amount
#             to_pay = balance
#             received = paid_amount
#             total_received = paid_amount
#             received_date = timezone.now()
#         else:
#             total_received = paid_amount
#             received_date = timezone.now()

#         Outstanding.objects.create(
#             farmer=farmer,
#             vendor=fertilizer_instance.vendor,
#             fuel_purchase=None,
#             fertilizer_purchase=fertilizer_instance,
#             balance=balance,
#             paid=paid,
#             to_pay=to_pay,
#             paid_date=paid_date,
#             total_paid=total_paid,
#             received=received,
#             to_receive=to_receive,
#             received_date=received_date,
#             total_received=total_received,
#             payment_amount=paid_amount,
#             created_by=farmer.farmer_user,
#             created_at=timezone.now(),
#             status=0
#         )

#         return Response(
#             {
#                 "success": True,
#                 "message": "Fertilizer added successfully!",
#                 "data": serializer.data,
#                 "documents": formatted_documents,
#                 "language": {
#                     "default": "en"
#                 }
#             },
#             status=status.HTTP_201_CREATED
#         )

#     return Response(
#         {
#             "success": False,
#             "message": "Failed to add fertilizer. Please check the input data.",
#             "errors": serializer.errors
#         },
#         status=status.HTTP_400_BAD_REQUEST
#     )

@api_view(['POST'])
def add_fertilizer(request, farmer_id):
    farmer = get_object_or_404(Farmer, id=farmer_id)
    data = request.data.copy()
    user = request.user  # logged-in user

    # --- If fertilizer_id provided, reset previous fertilizer and update outstanding ---
    fertilizer_id = data.get('fertilizer_id')
    if fertilizer_id:
        fertilizer = get_object_or_404(MyFertilizers, pk=fertilizer_id)
        fertilizer.status = 0
        fertilizer.save()

        # Assuming similar inventory model for fertilizers
        inv = get_object_or_404(MyInventory, fertilizer_purchase=fertilizer)
        inv.status = 0
        inv.save()

        if fertilizer.purchase_amount != fertilizer.paid_amount:
            if fertilizer.purchase_amount > fertilizer.paid_amount:  # Payables
                outstanding = Outstanding.objects.create(
                    farmer=fertilizer.farmer,
                    vendor=fertilizer.vendor,
                    fertilizer_purchase=fertilizer,
                    balance=fertilizer.purchase_amount,
                    paid=fertilizer.paid_amount,
                    to_pay=float(fertilizer.purchase_amount) - float(fertilizer.paid_amount),
                    paid_date=fertilizer.date_of_consumption,
                    total_paid=fertilizer.paid_amount,
                    identify=2,  # Assuming 2 = fertilizer type
                    created_by=user,
                    created_at=timezone.now()
                )
                if float(outstanding.to_pay) > 0:
                    vendor = get_object_or_404(MyVendor, pk=outstanding.vendor.id)
                    vendor.payables = (float(vendor.payables or 0)) + float(outstanding.to_pay)
                    if vendor.opening_balance and vendor.opening_balance != 0 and vendor.credit:
                        if float(vendor.opening_balance) > float(outstanding.to_pay):
                            vendor.credit = True
                            vendor.debit = False
                            vendor.opening_balance = float(vendor.opening_balance) - float(outstanding.to_pay)
                        else:
                            vendor.credit = False
                            vendor.debit = True
                            vendor.opening_balance = float(outstanding.to_pay) - float(vendor.opening_balance)
                    elif vendor.opening_balance and vendor.opening_balance != 0 and vendor.credit == False and vendor.debit:
                        vendor.opening_balance = float(vendor.opening_balance) + float(outstanding.to_pay)
                        vendor.credit = False
                        vendor.debit = True
                    else:
                        vendor.opening_balance = float(outstanding.to_pay)
                        vendor.credit = False
                        vendor.debit = True
                    vendor.save()

                    if vendor.is_customer_is_vendor:
                        customer = vendor.customer
                        customer.opening_balance = vendor.opening_balance
                        customer.payables = vendor.payables
                        customer.is_credit = vendor.credit
                        customer.save()

            elif fertilizer.purchase_amount < fertilizer.paid_amount:  # Receivables
                outstanding = Outstanding.objects.create(
                    farmer=fertilizer.farmer,
                    vendor=fertilizer.vendor,
                    fertilizer_purchase=fertilizer,
                    balance=float(fertilizer.paid_amount) - float(fertilizer.purchase_amount),
                    paid=fertilizer.paid_amount,
                    to_receive=float(fertilizer.paid_amount) - float(fertilizer.purchase_amount),
                    paid_date=fertilizer.date_of_consumption,
                    received_date=fertilizer.date_of_consumption,
                    total_received=fertilizer.paid_amount,
                    identify=2,
                    created_by=user,
                    created_at=timezone.now()
                )
                if float(outstanding.to_receive) > 0:
                    vendor = get_object_or_404(MyVendor, pk=outstanding.vendor.id)
                    vendor.receivables = (float(vendor.receivables or 0)) + float(outstanding.to_receive)
                    if vendor.opening_balance and vendor.opening_balance != 0 and vendor.credit:
                        vendor.opening_balance = float(vendor.opening_balance) + float(outstanding.to_receive)
                        vendor.credit = True
                        vendor.debit = False
                    elif vendor.opening_balance and vendor.opening_balance != 0 and vendor.credit == False and vendor.debit:
                        if float(vendor.opening_balance) > float(outstanding.to_receive):
                            vendor.credit = False
                            vendor.debit = True
                            vendor.opening_balance = float(vendor.opening_balance) - float(outstanding.to_receive)
                        else:
                            vendor.credit = True
                            vendor.debit = False
                            vendor.opening_balance = float(outstanding.to_receive) - float(vendor.opening_balance)
                    else:
                        vendor.opening_balance = float(outstanding.to_receive)
                        vendor.credit = True
                        vendor.debit = False
                    vendor.save()

                    if vendor.is_customer_is_vendor:
                        customer = vendor.customer
                        customer.opening_balance = vendor.opening_balance
                        customer.receivables = vendor.receivables
                        customer.is_credit = vendor.credit
                        customer.save()

        FarmerNotification.objects.create(
            farmer=farmer,
            name='New Purchase Created',
            message=f'{fertilizer_instance.inventory_items.name}',
            type='Fertilizer'
        )

    # --- Validate required fields ---
    required_fields = [
        'date_of_consumption', 'inventory_type', 'inventory_category',
        'inventory_items', 'vendor', 'quantity', 'quantity_unit',
        'purchase_amount', 'paid_amount'
    ]
    missing_fields = [field for field in required_fields if not data.get(field)]
    if missing_fields:
        return Response({
            "success": False,
            "message": f"Missing required fields: {', '.join(missing_fields)}"
        }, status=status.HTTP_400_BAD_REQUEST)

    # --- Validate vendor and inventory_type relationship ---
    vendor_id = data.get('vendor')
    inventory_type_id = data.get('inventory_type')
    vendor = get_object_or_404(MyVendor, id=vendor_id)

    if not vendor.inventory_type.filter(id=inventory_type_id).exists():
        return Response({
            "success": False,
            "message": "This vendor is not associated with the selected inventory type."
        }, status=status.HTTP_400_BAD_REQUEST)

    # --- Prepare metadata for serializer ---
    data['farmer'] = farmer.id
    data['created_at'] = timezone.now()
    data['created_by'] = farmer.farmer_user.id

    serializer = MyFertilizersAddSerializer(data=data)
    if serializer.is_valid():
        fertilizer_instance = serializer.save()

        # --- Optional Documents Handling ---
        file_data = data.get('documents', None)
        formatted_documents = []
        if file_data:
            grouped_documents = {}
            for doc_data in file_data:
                file_type_id = doc_data.get('file_type')
                documents = doc_data.get('documents', [])

                if not documents:
                    return Response({"success": False, "message": f"No documents for file type {file_type_id}"}, status=status.HTTP_400_BAD_REQUEST)

                if file_type_id is None:
                    new_file_type = doc_data.get('new_file_type')
                    if not new_file_type:
                        return Response({"error": "New file type required."}, status=status.HTTP_400_BAD_REQUEST)
                    file_type, _ = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=2)
                    file_type_id = file_type.id
                else:
                    file_type = get_object_or_404(DocumentCategory, id=file_type_id)

                if file_type_id not in grouped_documents:
                    grouped_documents[file_type_id] = []

                for i, document_base64 in enumerate(documents):
                    try:
                        if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
                            mime_type = validate_image_type(document_base64)
                            if mime_type:
                                document_data = document_base64.split(';base64,')[1]
                                document_bytes = base64.b64decode(document_data)
                                if len(document_bytes) > 10 * 1024 * 1024:
                                    return Response({'error': 'File too large. Max 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

                                ext = mime_type.split('/')[1]
                                document_name = f"fertilizer_{farmer_id}_{file_type_id}_{i}.{ext}"
                                document_file = ContentFile(document_bytes, name=document_name)

                                fert_doc = MyFertilizersDocuments.objects.create(
                                    farmer=farmer,
                                    fertilizers=fertilizer_instance,
                                    file_type=file_type,
                                    document=document_file,
                                    created_at=timezone.now(),
                                    created_by=farmer.farmer_user
                                )

                                grouped_documents[file_type_id].append({
                                    'document_id': fert_doc.id,
                                    'document_category': {'id': file_type.id, 'name': file_type.name},
                                    'upload_document': request.build_absolute_uri(fert_doc.document.url),
                                    'language': {"default": "en"}
                                })
                            else:
                                return Response({'error': 'Invalid MIME type.'}, status=status.HTTP_400_BAD_REQUEST)
                        else:
                            return Response({'error': 'Unsupported file format.'}, status=status.HTTP_400_BAD_REQUEST)
                    except Exception as e:
                        return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)

            for file_type_id_key, docs in grouped_documents.items():
                formatted_documents.append({
                    'category_id': file_type_id_key,
                    'documents': docs
                })

        # --- Inventory logic ---
        new_inventory_item_id = data.get("inventory_items")
        if inventory_type_id and new_inventory_item_id:
            new_inventory_item = get_object_or_404(InventoryItems, id=new_inventory_item_id, status=0)

            try:
                last_item = MyFertilizers.objects.filter(
                    farmer=farmer,
                    inventory_type=fertilizer_instance.inventory_type,
                    inventory_items__status=0
                ).latest('created_at')

                MyFertilizers.objects.filter(
                    farmer=farmer,
                    inventory_type=fertilizer_instance.inventory_type,
                    inventory_items=last_item.inventory_items
                ).update(status=1)
            except MyFertilizers.DoesNotExist:
                pass

            fertilizer_instance.inventory_items = new_inventory_item

            total_quantity = MyFertilizers.objects.filter(
                farmer=farmer,
                inventory_type=inventory_type_id,
                inventory_items=new_inventory_item
            ).aggregate(total=Sum('quantity'))['total'] or 0

            fertilizer_instance.available_quans = total_quantity
            fertilizer_instance.save()

        # --- Vendor Outstanding & Balance Update Logic ---
        purchase_amount = float(data.get('purchase_amount', 0))
        paid_amount = float(data.get('paid_amount', 0))

        net_change = paid_amount - purchase_amount
        current_balance = vendor.opening_balance or 0
        updated_balance = current_balance + net_change

        if updated_balance > 0:
            vendor.credit = True
            vendor.debit = False
            vendor.opening_balance = updated_balance
        elif updated_balance < 0:
            vendor.credit = False
            vendor.debit = True
            vendor.opening_balance = abs(updated_balance)
        else:
            vendor.credit = False
            vendor.debit = False
            vendor.opening_balance = 0

        if net_change < 0:
            vendor.payables = (vendor.payables or 0) + abs(net_change)
        elif net_change > 0:
            vendor.receivables = (vendor.receivables or 0) + net_change

        vendor.save()

        if vendor.is_customer_is_vendor and hasattr(vendor, 'customer'):
            customer = vendor.customer
            customer.opening_balance = vendor.opening_balance
            customer.payables = vendor.payables
            customer.receivables = vendor.receivables
            customer.is_credit = vendor.credit
            customer.save()

        balance = abs(net_change)
        now = timezone.now()

        if net_change < 0:
            Outstanding.objects.create(
                farmer=farmer,
                vendor=vendor,
                fertilizer_purchase=fertilizer_instance,
                balance=purchase_amount,
                paid=paid_amount,
                to_pay=abs(net_change),
                paid_date=now,
                total_paid=paid_amount,
                identify=2,
                created_by=farmer.farmer_user,
                created_at=now
            )
        elif net_change > 0:
            Outstanding.objects.create(
                farmer=farmer,
                vendor=vendor,
                fertilizer_purchase=fertilizer_instance,
                balance=balance,
                paid=paid_amount,
                to_receive=net_change,
                received_date=now,
                total_received=paid_amount,
                identify=2,
                created_by=farmer.farmer_user,
                created_at=now
            )
        else:
            Outstanding.objects.create(
                farmer=farmer,
                vendor=vendor,
                fertilizer_purchase=fertilizer_instance,
                balance=0,
                paid=paid_amount,
                to_pay=0,
                paid_date=now,
                total_paid=paid_amount,
                received=paid_amount,
                to_receive=0,
                received_date=now,
                total_received=paid_amount,
                identify=2,
                created_by=farmer.farmer_user,
                created_at=now
            )

        # Create Farmer Notification
        FarmerNotification.objects.create(
            farmer=farmer,
            name='New Purchase Created',
            message=f'{fertilizer_instance.inventory_items.name}',
            type='Fertilizer'
        )

        return Response({
            "success": True,
            "message": "Fertilizer added successfully!",
            "data": serializer.data,
            "documents": formatted_documents,
            "language": {"default": "en"}
        }, status=status.HTTP_201_CREATED)

    return Response({
        "success": False,
        "message": "Failed to add fertilizer. Please check the input data.",
        "errors": serializer.errors
    }, status=status.HTTP_400_BAD_REQUEST)


@api_view(['POST'])
def get_guidelines_list(request):
    crop_id = request.data.get('crop_id')
    guidelinestype_id = request.data.get('guidelinestype_id')
 
    if not crop_id and not guidelinestype_id:
        return Response({"detail": "At least one of crop_id or guidelinestype_id is required."}, status=status.HTTP_400_BAD_REQUEST)
 
    filter_conditions = {}
     
    if crop_id:
        filter_conditions['crop_id'] = crop_id
     
    if guidelinestype_id:
        filter_conditions['guidelinestype_id'] = guidelinestype_id
     
    guidelines = Guidelines.objects.filter(**filter_conditions,status=0)
 
    if not guidelines.exists():
        return Response({"detail": "No guidelines found matching the criteria."}, status=status.HTTP_404_NOT_FOUND)
 
    result = []
    for guideline in guidelines:
        guideline_data = {
            'id': guideline.id,
            'name': guideline.name,
            'guidelinestype': guideline.guidelinestype.name if guideline.guidelinestype else None,
            'guidelinescategory': {
                'id': guideline.guidelinescategory.id if guideline.guidelinescategory else None,
                'name': guideline.guidelinescategory.name if guideline.guidelinescategory else None
            },
            'crop': {
                'id': guideline.crop.id if guideline.crop else None,
                'name': guideline.crop.name if guideline.crop else None
            },
            'description': guideline.description,
            'status': guideline.status,
            'created_at': guideline.created_at.isoformat() if guideline.created_at else None,
            'updated_at': guideline.updated_at.isoformat() if guideline.updated_at else None,
            'video_url': guideline.video_url,
            'document': guideline.document.url if guideline.document else None,
            'media_type': guideline.media_type
        }
        result.append(guideline_data)

    return Response(result, status=status.HTTP_200_OK)

@api_view(['POST'])
def filter_guidelines_by_keyword(request): 
    filter_keyword = request.data.get('filter')
 
    if not filter_keyword:
        return Response({"detail": "'filter' parameter is required."}, status=status.HTTP_400_BAD_REQUEST)

     
    guidelines = Guidelines.objects.filter(
        Q(name__icontains=filter_keyword) |   
        Q(guidelinestype__name__icontains=filter_keyword) |  
        Q(guidelinescategory__name__icontains=filter_keyword) |  
        Q(crop__name__icontains=filter_keyword) |  
        Q(description__icontains=filter_keyword) |  
        Q(video_url__icontains=filter_keyword) |   
        Q(media_type__icontains=filter_keyword) |  
        Q(document__icontains=filter_keyword)  
    )
 
    if not guidelines.exists():
        return Response({"detail": "No guidelines found matching the filter."}, status=status.HTTP_404_NOT_FOUND)
 
    result = []
    for guideline in guidelines:
        guideline_data = {
            'id': guideline.id,
            'name': guideline.name,
            'guidelinestype': guideline.guidelinestype.name if guideline.guidelinestype else None,
            'guidelinescategory': {
                'id': guideline.guidelinescategory.id if guideline.guidelinescategory else None,
                'name': guideline.guidelinescategory.name if guideline.guidelinescategory else None
            },
            'crop': {
                'id': guideline.crop.id if guideline.crop else None,
                'name': guideline.crop.name if guideline.crop else None
            },
            'description': guideline.description,
            'status': guideline.status,
            'created_at': guideline.created_at.isoformat() if guideline.created_at else None,
            'updated_at': guideline.updated_at.isoformat() if guideline.updated_at else None,
            'video_url': guideline.video_url,
            # 'document': guideline.document.url if guideline.document else None,
            'document': request.build_absolute_uri(f'/SuperAdmin{guideline.document.url}' if guideline.document else guideline.document.url) if guideline.document else "",
            'media_type': guideline.media_type,
            'language':{
                'default':'en'
            }
        }
        result.append(guideline_data)

    return Response(result, status=status.HTTP_200_OK)
 
@api_view(['POST'])
def deactivate_my_land(request, id):
    try:
        # Get the farmer
        farmer = Farmer.objects.get(id=id)
    except Farmer.DoesNotExist:
        return Response({"error": "Farmer not found"}, status=status.HTTP_400_BAD_REQUEST)

    try:
        # Get the land by id
        land = MyLand.objects.get(id=request.data.get('id'), farmer=farmer)
    except MyLand.DoesNotExist:
        return Response({"error": "Land not found or not associated with the specified farmer"}, status=status.HTTP_400_BAD_REQUEST)
    
    # Update the status to 2 (indicating it is deactivated)
    land.status = 2
    land.save()
    notification_message = f"Your land '{land.name}' has been deleted."
    FarmerNotification.objects.create(
        farmer=farmer,
        name=f"Land Deleted: {land.name}",
        type="Land Deleted",
        message=notification_message,
        created_at=timezone.now(),
        is_read=False
    )

    return Response({"message": "Land Deleted Successfully"}, status=status.HTTP_200_OK)
 
@api_view(['POST'])
def deactivate_my_crop(request, id):
    try:
        # Get the farmer using the provided farmer id
        farmer = Farmer.objects.get(id=id)
    except Farmer.DoesNotExist:
        return Response({"error": "Farmer not found"}, status=status.HTTP_400_BAD_REQUEST)

    try:
        # Get the crop by id and ensure it is associated with the correct farmer
        crop = MyCrop.objects.get(id=request.data.get('crop_id'), farmer=farmer)
    except MyCrop.DoesNotExist:
        return Response({"error": "Crop not found or not associated with the specified farmer"}, status=status.HTTP_400_BAD_REQUEST)
    
    # Update the status to 2 (indicating it is deactivated)
    crop.status = 2
    crop.save()

    notification_message = f"Your Crop '{crop.crop.name}' has been deleted."
    FarmerNotification.objects.create(
        farmer=farmer,
        name=f"Crop Deleted: {crop.crop.name}",
        type="Crop Deleted",
        message=notification_message,
        created_at=timezone.now(),
        is_read=False
    )

    return Response({"message": "Crop deactivated successfully"}, status=status.HTTP_200_OK)
 
 
# @api_view(['GET'])
# def farmer_land_and_crop_details(request, farmer_id):

#     try:
#         user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
#         language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
#     except UserLanguagePreference.DoesNotExist:
#         language_code = 'en'  # Fallback to 'en' if no preference is found

#     try:
#         # Retrieve all lands associated with the farmer
#         lands = MyLand.objects.filter(farmer_id=farmer_id,status=0)
        
#         # Manually structure the response data
#         land_data = []
#         for land in lands:
#             # Fetch surveys and documents for each land
#             survey_details = []
#             for survey in land.survey_details.all():
#                 survey_details.append({
#                     "id": survey.id,
#                     "survey_no": survey.survey_no,
#                     "survey_measurement_value": str(survey.survey_measurement_value),  # Convert Decimal to string
#                     "survey_measurement_unit": survey.survey_measurement_unit.id  # Assuming you're only sending the id
#                 })

#             documents = []
#             for document in land.documents.all():
#                 documents.append({
#                     "id": document.id,
#                     "document_category": document.document_category.id,  # Sending document category id
#                     "upload_document": document.upload_document.url if document.upload_document else None,
#                     "status": document.status
#                 })

#             # Fetch the count of crops related to the land
#             crop_count = MyCrop.objects.filter(land=land,status=0).count()

#             # Initialize dictionaries for various calculations for crops
#             crop_schedule_counts = {}
#             crop_schedule_total_counts = {}
#             crop_sales_amount = {}  
#             crop_expenses_amount = {}  
#             completed_counts = 0
#             in_progress_count = 0

#             crop_data = []
            
#             # Fetch crops related to this land
#             crops = MyCrop.objects.filter(land=land,status=0)
#             for crop_instance in crops:
#                 # Fetch schedule counts for each crop
#                 completed_count = MySchedule.objects.filter(
#                     status=0,
#                     my_crop=crop_instance,
#                     schedule_status__code=0,
#                     farmer=farmer_id
#                 ).count()
                
#                 total_count = MySchedule.objects.filter(
#                     status=0,
#                     my_crop=crop_instance,
#                     farmer=farmer_id 
#                 ).count()

#                 # Calculate the total sales amount for the crop
#                 total_sales = MySales.objects.filter(
#                     my_crop=crop_instance,
#                     farmer=farmer_id,status=0
#                 ).aggregate(total_sales_amount=Sum('total_sales_amount'))['total_sales_amount'] or 0

#                 # Calculate the total expenses amount for the crop
#                 total_expenses = MyExpense.objects.filter(
#                     my_crop=crop_instance,
#                     farmer=farmer_id,status=0
#                 ).aggregate(total_expenses_amount=Sum('amount'))['total_expenses_amount'] or 0

#                 # Store the results in dictionaries
#                 crop_schedule_counts[crop_instance.id] = completed_count
#                 crop_schedule_total_counts[crop_instance.id] = total_count
#                 crop_sales_amount[crop_instance.id] = total_sales
#                 crop_expenses_amount[crop_instance.id] = total_expenses

#                 # Calculate the in-progress and completed crop counts
#                 if completed_count == total_count and total_count > 0:
#                     completed_counts += 1
#                 elif total_count > completed_count:
#                     in_progress_count += 1

#                 # Prepare the crop data to return
#                 crop_data.append({
#                     "id": crop_instance.id,
#                     # "name": crop_instance.crop.name if crop_instance.crop else None,
#                     "name": crop_instance.crop.get_translated_value("name", language_code) if crop_instance.crop and language_code == 'ta' else (crop_instance.crop.name if crop_instance.crop else None),
#                     # "img": crop_instance.crop.img.url if crop_instance.crop.img else None,
#                     "img": request.build_absolute_uri(f'/SuperAdmin{crop_instance.crop.img.url }' if crop_instance.crop.img else crop_instance.crop.img.url) if crop_instance.crop.img else "", 
#                     "expense": total_expenses,
#                     "sales": total_sales,
#                     "total_schedule_count": total_count,
#                     "completed_schedule_count": completed_count,
#                 })

#             # Prepare the land data to return
#             land_data.append({
#                 "id": land.id,
#                 # "name": land.name,
#                 "name": land.get_translated_value("name", language_code) if language_code == 'ta' else land.name,
#                 # "village": {
#                 #     "id": land.village.id if land.village else None,
#                 #     "name": land.village.name if land.village else None
#                 # },
#                 "village": {
#                     "id": land.village.id if land.village else None,
#                     "name": land.village.get_translated_value("name", language_code) if land.village and language_code == 'ta' else (land.village.name if land.village else None),
#                 },
#                 "measurement_value": land.measurement_value,
#                 # "measurement_unit": {
#                 #     "id": land.measurement_unit.id if land.measurement_unit else None,
#                 #     "name": land.measurement_unit.name if land.measurement_unit else None
#                 # },
#                 "measurement_unit": {
#                     "id": land.measurement_unit.id if land.measurement_unit else None,
#                     "name": land.measurement_unit.get_translated_value("name", language_code) if land.measurement_unit and language_code == 'ta' else (land.measurement_unit.name if land.measurement_unit else None),
#                 },
#                 "land_crop_count": crop_count,   
#                 "crops": crop_data,
#                 "language":{
#                     "default":"en"
#                 }
#             })

#         # Return the merged data
#         return Response({
#             "lands": land_data, 
#         }, status=status.HTTP_200_OK)

#     except MyLand.DoesNotExist:
#         return Response({"error": "No land found for this farmer."}, status=status.HTTP_404_NOT_FOUND)
 
@api_view(['GET'])
def farmer_land_and_crop_details(request, farmer_id):

    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'  # Fallback to 'en' if no preference is found

    try:
        # Retrieve all lands associated with the farmer
        lands = MyLand.objects.filter(farmer_id=farmer_id, status=0)
        
        # Manually structure the response data
        land_data = []
        for land in lands:
            # Fetch surveys and documents for each land
            survey_details = []
            for survey in land.survey_details.all():
                survey_details.append({
                    "id": survey.id,
                    "survey_no": survey.survey_no,
                    "survey_measurement_value": str(survey.survey_measurement_value),  # Convert Decimal to string
                    "survey_measurement_unit": survey.survey_measurement_unit.id  # Assuming you're only sending the id
                })

            documents = []
            for document in land.documents.all():
                documents.append({
                    "id": document.id,
                    "document_category": document.document_category.id,  # Sending document category id
                    "upload_document": document.upload_document.url if document.upload_document else None,
                    "status": document.status
                })

            # Fetch the count of crops related to the land
            crop_count = MyCrop.objects.filter(land=land, status=0).count()

            # Initialize dictionaries for various calculations for crops
            crop_schedule_counts = {}
            crop_schedule_total_counts = {}
            crop_sales_amount = {}  
            crop_expenses_amount = {}  
            completed_counts = 0
            in_progress_count = 0

            crop_data = []
            
            # Fetch crops related to this land
            crops = MyCrop.objects.filter(land=land, status=0)
            for crop_instance in crops:
                # Fetch schedule counts for each crop
                completed_count = MySchedule.objects.filter(
                    status=0,
                    my_crop=crop_instance,
                    schedule_status__code=0,
                    farmer=farmer_id
                ).count()
                
                total_count = MySchedule.objects.filter(
                    status=0,
                    my_crop=crop_instance,
                    farmer=farmer_id 
                ).count()

                # Calculate the total sales amount for the crop
                total_sales = MySales.objects.filter(
                    my_crop=crop_instance,
                    farmer=farmer_id, status=0
                ).aggregate(total_sales_amount=Sum('total_sales_amount'))['total_sales_amount'] or 0

                # Calculate the total expenses amount for the crop
                total_expenses = MyExpense.objects.filter(
                    my_crop=crop_instance,
                    farmer=farmer_id, status=0
                ).aggregate(total_expenses_amount=Sum('amount'))['total_expenses_amount'] or 0

                # Store the results in dictionaries
                crop_schedule_counts[crop_instance.id] = completed_count
                crop_schedule_total_counts[crop_instance.id] = total_count
                crop_sales_amount[crop_instance.id] = total_sales
                crop_expenses_amount[crop_instance.id] = total_expenses

                # Calculate the in-progress and completed crop counts
                if completed_count == total_count and total_count > 0:
                    completed_counts += 1
                elif total_count > completed_count:
                    in_progress_count += 1

                # Prepare the crop data to return
                crop_data.append({
                    "id": crop_instance.id,
                    "name": crop_instance.crop.get_translated_value("name", language_code) if crop_instance.crop and language_code == 'ta' else (crop_instance.crop.name if crop_instance.crop else None),
                    "img": request.build_absolute_uri(f'/SuperAdmin{crop_instance.crop.img.url}' if crop_instance.crop.img else crop_instance.crop.img.url) if crop_instance.crop.img else "", 
                    "expense": total_expenses,
                    "sales": total_sales,
                    "total_schedule_count": total_count,
                    "completed_schedule_count": completed_count,
                })

            # Prepare the land data to return (removed country, state, city, taluk, village)
            land_data.append({
                "id": land.id,
                "name": land.get_translated_value("name", language_code) if language_code == 'ta' else land.name,
                "measurement_value": land.measurement_value,
                "measurement_unit": {
                    "id": land.measurement_unit.id if land.measurement_unit else None,
                    "name": land.measurement_unit.get_translated_value("name", language_code) if land.measurement_unit and language_code == 'ta' else (land.measurement_unit.name if land.measurement_unit else None),
                },
                "land_crop_count": crop_count,   
                "crops": crop_data,
                "language": {
                    "default": "en"
                }
            })

        # Return the merged data
        return Response({
            "lands": land_data, 
        }, status=status.HTTP_200_OK)

    except MyLand.DoesNotExist:
        return Response({"error": "No land found for this farmer."}, status=status.HTTP_404_NOT_FOUND) 
    
# @api_view(['GET'])
# def full_land_details(request, farmer_id):
#     try:
#         user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
#         language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
#     except UserLanguagePreference.DoesNotExist:
#         language_code = 'en'  # Fallback to 'en' if no preference is found

#     try: 
#         land_id = request.query_params.get('land_id', None)

#         if not land_id:
#             return Response({"error": "Land ID is required in the query parameters."}, status=status.HTTP_400_BAD_REQUEST)
 
#         land = MyLand.objects.get(id=land_id, farmer_id=farmer_id, status=0)

#         # Prepare the full land details data
#         land_data = {
#             "id": land.id,
#             "name": land.get_translated_value("name", language_code) if language_code == 'ta' else land.name,
#             "measurement_value": land.measurement_value,
#             "measurement_unit": {
#                 "id": land.measurement_unit.id if land.measurement_unit else None,
#                 "name": land.measurement_unit.get_translated_value("name", language_code) if land.measurement_unit and language_code == 'ta' else (land.measurement_unit.name if land.measurement_unit else None),
#             },
#             "soil_type": {
#                 "id": land.soil_type.id if land.soil_type else None,
#                 "name": land.soil_type.get_translated_value("name", language_code) if land.soil_type and language_code == 'ta' else (land.soil_type.name if land.soil_type else None),
#             },
#             "country": {
#                 "id": land.country.id if land.country else None,
#                 "name": land.country.get_translated_value("name", language_code) if land.country and language_code == 'ta' else (land.country.name if land.country else None),
#             },
#             "state": {
#                 "id": land.state.id if land.state else None,
#                 "name": land.state.get_translated_value("name", language_code) if land.state and language_code == 'ta' else (land.state.name if land.state else None),
#             },
#             "city": {
#                 "id": land.city.id if land.city else None,
#                 "name": land.city.get_translated_value("name", language_code) if land.city and language_code == 'ta' else (land.city.name if land.city else None),
#             },
#             "taluk": {
#                 "id": land.taluk.id if land.taluk else None,
#                 "name": land.taluk.get_translated_value("name", language_code) if land.taluk and language_code == 'ta' else (land.taluk.name if land.taluk else None),
#             },
#             "village": {
#                 "id": land.village.id if land.village else None,
#                 "name": land.village.get_translated_value("name", language_code) if land.village and language_code == 'ta' else (land.village.name if land.village else None),
#             },
#             "door_no": land.get_translated_value("door_no", language_code) if land.door_no and language_code == 'ta' else land.door_no,
#             "locations": land.locations,
#             "latitude": land.latitude,
#             "longitude": land.longitude,
#             "patta_number": land.patta_number,
#             "description": land.get_translated_value("description", language_code) if land.description and language_code == 'ta' else land.description,
#             "l_status": land.l_status,
#         }

#         # Fetch survey details where status=0 or status=1
#         survey_details = []
#         for survey in land.survey_details.filter(status__in=[0, 1]):  # Filter survey details by status
#             survey_details.append({
#                 "id": survey.id,
#                 "survey_no": survey.survey_no,
#                 "survey_measurement_value": str(survey.survey_measurement_value),
#                 "survey_measurement_unit": survey.survey_measurement_unit.id if survey.survey_measurement_unit else None,
#                 "survey_measurement_unit_name": survey.survey_measurement_unit.get_translated_value("name", language_code) if survey.survey_measurement_unit and language_code == 'ta' else (survey.survey_measurement_unit.name if survey.survey_measurement_unit else None),
#             })
#         land_data["survey_details"] = survey_details
#         land_data["survey_count"] = len(survey_details)  # Add the survey count

#         # Fetch document details where status=0 or status=1, and group by document category id
#         documents = {}
#         for document in land.documents.filter(status__in=[0, 1]):  # Filter document details by status
#             category_id = document.document_category.id if document.document_category else None

#             if category_id not in documents:
#                 documents[category_id] = []

#             documents[category_id].append({
#                 "id": document.id,
#                 "document_category": {
#                     "id": document.document_category.id if document.document_category else None,
#                     "name": document.document_category.get_translated_value("name", language_code) if document.document_category and language_code == 'ta' else (document.document_category.name if document.document_category else None),
#                     # "name": document.document_category.name if document.document_category else None
#                 },
#                 "upload_document": request.build_absolute_uri(f'/SuperAdmin{document.upload_document.url}' if document.upload_document else document.upload_document.url) if document.upload_document else "",
#                 "language": {"default": "en"}
#             })

#         # Convert documents dictionary to list for the response
#         land_data["documents"] = [{"category_id": category_id, "documents": docs} for category_id, docs in documents.items()]

#         # Fetch crop details where status=0 or status=1
#         crop_details = []
#         for crop in land.mycrop_set.filter(status__in=[0, 1]):  # Filter crops by status
#             # Count the schedules associated with each crop
#             crop_schedule_count = MySchedule.objects.filter(my_crop=crop, status=0).count()
#             crop_schedule_completed_count = MySchedule.objects.filter(my_crop=crop, schedule_status__code=0).count()  # '0' represents completed status

#             # Fetch schedules for each crop
#             schedules = []
#             for schedule in MySchedule.objects.filter(my_crop=crop, status=0):  # Filter schedules by status
#                 schedules.append({
#                     "id": schedule.id,
#                     "schedule_activity_type": {
#                         "id": schedule.schedule_activity_type.id if schedule.schedule_activity_type else None,
#                         "name": schedule.schedule_activity_type.get_translated_value("name", language_code) if schedule.schedule_activity_type and language_code == 'ta' else (schedule.schedule_activity_type.name if schedule.schedule_activity_type else None),
#                     },
#                     "start_date": schedule.start_date,
#                     "end_date": schedule.end_date,
#                     "schedule_status": {
#                         "id": schedule.schedule_status.id if schedule.schedule_status else None,
#                         "name": schedule.schedule_status.get_translated_value("name", language_code) if schedule.schedule_status and language_code == 'ta' else (schedule.schedule_status.name if schedule.schedule_status else None),
#                     },
#                     "schedule": schedule.get_translated_value("schedule", language_code) if schedule.schedule and language_code == 'ta' else schedule.schedule,
#                     "comment": schedule.get_translated_value("comment", language_code) if schedule.comment and language_code == 'ta' else schedule.comment,
#                     "schedule_choice": schedule.schedule_choice,
#                     "schedule_weekly": [weekly.id for weekly in schedule.schedule_weekly.all()],
#                     "schedule_monthly": [monthly.id for monthly in schedule.schedule_monthly.all()],
#                     "schedule_year": [year.id for year in schedule.schedule_year.all()],
#                 })

#             crop_details.append({
#                 "id": crop.id,
#                 "crop_type": {
#                     "id": crop.crop_type.id if crop.crop_type else None,
#                     "name": crop.crop_type.get_translated_value("name", language_code) if crop.crop_type and language_code == 'ta' else (crop.crop_type.name if crop.crop_type else None),
#                 },
#                 "crop": {
#                     "id": crop.crop.id if crop.crop else None,
#                     "name": crop.crop.get_translated_value("name", language_code) if crop.crop and language_code == 'ta' else (crop.crop.name if crop.crop else None),
#                 },
#                 "harvesting_type": {
#                     "id": crop.harvesting_type.id if crop.harvesting_type else None,
#                     "name": crop.harvesting_type.get_translated_value("name", language_code) if crop.harvesting_type and language_code == 'ta' else (crop.harvesting_type.name if crop.harvesting_type else None),
#                 },
#                 "plantation_date": crop.plantation_date,
#                 "measurement_value": crop.measurement_value,
#                 "measurement_unit": {
#                     "id": crop.measurement_unit.id if crop.measurement_unit else None,
#                     "name": crop.measurement_unit.get_translated_value("name", language_code) if crop.measurement_unit and language_code == 'ta' else (crop.measurement_unit.name if crop.measurement_unit else None),
#                 },
#                 "img": request.build_absolute_uri(f'/SuperAdmin{crop.crop.img.url}' if crop.crop.img else crop.crop.img.url) if crop.crop.img else "",
#                 "description": crop.get_translated_value("description", language_code) if crop.description and language_code == 'ta' else crop.description,
#                 "status": crop.status,
#                 "geo_marks": crop.geo_marks,
#                 "c_status": crop.c_status,
#                 "expense": crop.expense,
#                 "sales": crop.sales,
#                 "crop_schedule_count": crop_schedule_count,  # Add crop schedule count here
#                 "crop_schedule_completed_count": crop_schedule_completed_count,
#                 "schedules": schedules,  # Add schedules for the crop here
#                 "language": {"default": "en"}
#             })
#         land_data["crop_details"] = crop_details
#         land_data["crop_count"] = len(crop_details)  # Add the crop count

#         return Response(land_data, status=status.HTTP_200_OK)

#     except MyLand.DoesNotExist:
#         return Response({"error": "Land not found for this farmer.", "language": {"default": "en"}}, status=status.HTTP_404_NOT_FOUND)
 

@api_view(['GET'])
def full_land_details(request, farmer_id):
    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'  # Fallback to 'en' if no preference is found

    try: 
        land_id = request.query_params.get('land_id', None)

        if not land_id:
            return Response({"error": "Land ID is required in the query parameters."}, status=status.HTTP_400_BAD_REQUEST)
 
        land = MyLand.objects.get(id=land_id, farmer_id=farmer_id, status=0)

        # Prepare the full land details data without location hierarchy fields
        land_data = {
            "id": land.id,
            "name": land.get_translated_value("name", language_code) if language_code == 'ta' else land.name,
            "measurement_value": land.measurement_value,
            "measurement_unit": {
                "id": land.measurement_unit.id if land.measurement_unit else None,
                "name": land.measurement_unit.get_translated_value("name", language_code) if land.measurement_unit and language_code == 'ta' else (land.measurement_unit.name if land.measurement_unit else None),
            },
            "soil_type": {
                "id": land.soil_type.id if land.soil_type else None,
                "name": land.soil_type.get_translated_value("name", language_code) if land.soil_type and language_code == 'ta' else (land.soil_type.name if land.soil_type else None),
            },
            # Removed country, state, city, taluk, village
            "door_no": land.get_translated_value("door_no", language_code) if land.door_no and language_code == 'ta' else land.door_no,
            "locations": land.locations,
            "latitude": land.latitude,
            "longitude": land.longitude,
            "patta_number": land.patta_number,
            "description": land.get_translated_value("description", language_code) if land.description and language_code == 'ta' else land.description,
            "l_status": land.l_status,
        }

        # Fetch survey details where status=0 or status=1
        survey_details = []
        for survey in land.survey_details.filter(status__in=[0, 1]):  # Filter survey details by status
            survey_details.append({
                "id": survey.id,
                "survey_no": survey.survey_no,
                "survey_measurement_value": str(survey.survey_measurement_value),
                "survey_measurement_unit": survey.survey_measurement_unit.id if survey.survey_measurement_unit else None,
                "survey_measurement_unit_name": survey.survey_measurement_unit.get_translated_value("name", language_code) if survey.survey_measurement_unit and language_code == 'ta' else (survey.survey_measurement_unit.name if survey.survey_measurement_unit else None),
            })
        land_data["survey_details"] = survey_details
        land_data["survey_count"] = len(survey_details)  # Add the survey count

        # Fetch document details where status=0 or status=1, and group by document category id
        documents = {}
        for document in land.documents.filter(status__in=[0, 1]):  # Filter document details by status
            category_id = document.document_category.id if document.document_category else None

            if category_id not in documents:
                documents[category_id] = []

            documents[category_id].append({
                "id": document.id,
                "document_category": {
                    "id": document.document_category.id if document.document_category else None,
                    "name": document.document_category.get_translated_value("name", language_code) if document.document_category and language_code == 'ta' else (document.document_category.name if document.document_category else None),
                },
                "upload_document": request.build_absolute_uri(f'/SuperAdmin{document.upload_document.url}' if document.upload_document else document.upload_document.url) if document.upload_document else "",
                "language": {"default": "en"}
            })

        # Convert documents dictionary to list for the response
        land_data["documents"] = [{"category_id": category_id, "documents": docs} for category_id, docs in documents.items()]

        # Fetch crop details where status=0 or status=1
        crop_details = []
        for crop in land.mycrop_set.filter(status__in=[0, 1]):  # Filter crops by status
            # Count the schedules associated with each crop
            crop_schedule_count = MySchedule.objects.filter(my_crop=crop, status=0).count()
            crop_schedule_completed_count = MySchedule.objects.filter(my_crop=crop, schedule_status__code=0).count()  # '0' represents completed status

            # Fetch schedules for each crop
            schedules = []
            for schedule in MySchedule.objects.filter(my_crop=crop, status=0):  # Filter schedules by status
                schedules.append({
                    "id": schedule.id,
                    "schedule_activity_type": {
                        "id": schedule.schedule_activity_type.id if schedule.schedule_activity_type else None,
                        "name": schedule.schedule_activity_type.get_translated_value("name", language_code) if schedule.schedule_activity_type and language_code == 'ta' else (schedule.schedule_activity_type.name if schedule.schedule_activity_type else None),
                    },
                    "start_date": schedule.start_date,
                    "end_date": schedule.end_date,
                    "schedule_status": {
                        "id": schedule.schedule_status.id if schedule.schedule_status else None,
                        "name": schedule.schedule_status.get_translated_value("name", language_code) if schedule.schedule_status and language_code == 'ta' else (schedule.schedule_status.name if schedule.schedule_status else None),
                    },
                    "schedule": schedule.get_translated_value("schedule", language_code) if schedule.schedule and language_code == 'ta' else schedule.schedule,
                    "comment": schedule.get_translated_value("comment", language_code) if schedule.comment and language_code == 'ta' else schedule.comment,
                    "schedule_choice": schedule.schedule_choice,
                    "schedule_weekly": [weekly.id for weekly in schedule.schedule_weekly.all()],
                    "schedule_monthly": [monthly.id for monthly in schedule.schedule_monthly.all()],
                    "schedule_year": [year.id for year in schedule.schedule_year.all()],
                })

            crop_details.append({
                "id": crop.id,
                "crop_type": {
                    "id": crop.crop_type.id if crop.crop_type else None,
                    "name": crop.crop_type.get_translated_value("name", language_code) if crop.crop_type and language_code == 'ta' else (crop.crop_type.name if crop.crop_type else None),
                },
                "crop": {
                    "id": crop.crop.id if crop.crop else None,
                    "name": crop.crop.get_translated_value("name", language_code) if crop.crop and language_code == 'ta' else (crop.crop.name if crop.crop else None),
                },
                "harvesting_type": {
                    "id": crop.harvesting_type.id if crop.harvesting_type else None,
                    "name": crop.harvesting_type.get_translated_value("name", language_code) if crop.harvesting_type and language_code == 'ta' else (crop.harvesting_type.name if crop.harvesting_type else None),
                },
                "plantation_date": crop.plantation_date,
                "measurement_value": crop.measurement_value,
                "measurement_unit": {
                    "id": crop.measurement_unit.id if crop.measurement_unit else None,
                    "name": crop.measurement_unit.get_translated_value("name", language_code) if crop.measurement_unit and language_code == 'ta' else (crop.measurement_unit.name if crop.measurement_unit else None),
                },
                "img": request.build_absolute_uri(f'/SuperAdmin{crop.crop.img.url}' if crop.crop.img else crop.crop.img.url) if crop.crop.img else "",
                "description": crop.get_translated_value("description", language_code) if crop.description and language_code == 'ta' else crop.description,
                "status": crop.status,
                "geo_marks": crop.geo_marks,
                "c_status": crop.c_status,
                "expense": crop.expense,
                "sales": crop.sales,
                "crop_schedule_count": crop_schedule_count,  # Add crop schedule count here
                "crop_schedule_completed_count": crop_schedule_completed_count,
                "schedules": schedules,  # Add schedules for the crop here
                "language": {"default": "en"}
            })
        land_data["crop_details"] = crop_details
        land_data["crop_count"] = len(crop_details)  # Add the crop count

        return Response(land_data, status=status.HTTP_200_OK)

    except MyLand.DoesNotExist:
        return Response({"error": "Land not found for this farmer.", "language": {"default": "en"}}, status=status.HTTP_404_NOT_FOUND)


@api_view(['GET'])
def land_with_survey_details(request, farmer_id):
    try:
        # Get language preference
        try:
            user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
            language_code = user_language_pref.language_code or 'en'
        except UserLanguagePreference.DoesNotExist:
            language_code = 'en'

        # Validate and get land_id from query
        land_id = request.query_params.get('land_id', None)
        if not land_id:
            return Response({"error": "Land ID is required in the query parameters."}, status=status.HTTP_400_BAD_REQUEST)

        # Get land object
        land = MyLand.objects.get(id=land_id, farmer_id=farmer_id, status=0)

        # Prepare response
        response_data = {
            "id": land.id,
            "name": land.get_translated_value("name", language_code) if language_code == 'ta' else land.name,
            "survey_details": []
        }

        # Append survey details (status 0 or 1 only)
        for survey in land.survey_details.filter(status__in=[0, 1]):
            response_data["survey_details"].append({
                "id": survey.id,
                "survey_no": survey.survey_no,
                "survey_measurement_value": str(survey.survey_measurement_value),
                "survey_measurement_unit": survey.survey_measurement_unit.id if survey.survey_measurement_unit else None,
                "survey_measurement_unit_name": (
                    survey.survey_measurement_unit.get_translated_value("name", language_code)
                    if survey.survey_measurement_unit and language_code == 'ta'
                    else (survey.survey_measurement_unit.name if survey.survey_measurement_unit else None)
                ),
            })

        return Response(response_data, status=status.HTTP_200_OK)

    except MyLand.DoesNotExist:
        return Response({"error": "Land not found for this farmer."}, status=status.HTTP_404_NOT_FOUND)

 
 
@api_view(['POST'])
def get_land_crop_details(request, farmer_id):
    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'  # Fallback to 'en' if no preference is found

    try: 
        land_id = request.data.get('land_id', None)
        crop_id = request.data.get('crop_id', None)
 
        if not land_id or not crop_id:
            return Response({"error": "Both land_id and crop_id are required."}, status=status.HTTP_400_BAD_REQUEST)
 
        land = MyLand.objects.get(id=land_id, farmer_id=farmer_id,status=0)
        mycrop = MyCrop.objects.get(id=crop_id, land=land,status=0)
        crop = mycrop.crop
 
        land_data = {
            "id": land.id,
            "name": land.get_translated_value("name", language_code) if land else "",
            "measurement_value": land.measurement_value,
            "measurement_unit": land.measurement_unit.get_translated_value("name", language_code) if land.measurement_unit else None,
        }
 
        total_sales = MySales.objects.filter(
            my_crop=mycrop,
            farmer=farmer_id,status=0
        ).aggregate(total_sales_amount=Sum('total_sales_amount'))['total_sales_amount'] or 0

        total_expenses = MyExpense.objects.filter(
            my_crop=mycrop,
            farmer=farmer_id,status=0
        ).aggregate(total_expenses_amount=Sum('amount'))['total_expenses_amount'] or 0
 
        crop_data = {
            "id": crop.id,
            "crop_type": crop.croptype.get_translated_value("name", language_code) if crop.croptype else None,
            "crop": crop.get_translated_value("name", language_code) if crop else None,
            # "img": crop.img.url if crop.img else None,
            "img": request.build_absolute_uri(f'/SuperAdmin{crop.img.url}' if crop.img else crop.img.url) if crop.img else "", 
            "description": crop.get_translated_value("description", language_code) if crop else "",
            "total_sales_amount": total_sales,
            "total_expenses_amount": total_expenses,
        }

        # Fetch guidelines for the given crop
        guidelines = Guidelines.objects.filter(crop=crop, status=0)

        # Prepare guidelines data
        guidelines_data = []
        for guideline in guidelines:
            guidelines_data.append({
                "id": guideline.id,
                "name": guideline.get_translated_value("name", language_code) if guideline else "",
                "description": guideline.get_translated_value("description", language_code) if guideline else "",
                "video_url": guideline.video_url,
                "document": guideline.document.url if guideline.document else None,
                "media_type": guideline.media_type,
                "status": guideline.status
            })

        # Fetch schedule details for the given farmer, land, and crop
        schedule_details = []
        schedules = MySchedule.objects.filter(farmer_id=farmer_id, my_land=land, my_crop=mycrop, status=0)

        for schedule in schedules:
            schedule_data = {
                "schedule_id": schedule.id,
                "schedule_activity_type": schedule.schedule_activity_type.get_translated_value("name", language_code) if schedule.schedule_activity_type else None,
                "start_date": schedule.start_date,
                "end_date": schedule.end_date,
                "schedule_status": schedule.schedule_status.get_translated_value("name", language_code) if schedule.schedule_status else None,
                "schedule": schedule.get_translated_value("schedule", language_code) if schedule else "",
                "comment": schedule.get_translated_value("comment", language_code) if schedule else "",
                "schedule_choice": schedule.schedule_choice,
                "schedule_weekly": [weekly.name for weekly in schedule.schedule_weekly.all()],
                "schedule_monthly": [monthly.name for monthly in schedule.schedule_monthly.all()],
                "schedule_year": [year.name for year in schedule.schedule_year.all()],
            }
            schedule_details.append(schedule_data)

        # Construct the final response data
        response_data = {
            "farmer_id": farmer_id,
            "land": land_data,
            "crop": crop_data,
            "guidelines": guidelines_data,
            "schedules": schedule_details,
            "language": {"default": "en"}
        }

        return Response(response_data, status=status.HTTP_200_OK)

    except MyLand.DoesNotExist:
        return Response({"error": "Land not found for this farmer."}, status=status.HTTP_404_NOT_FOUND)

    except MyCrop.DoesNotExist:
        return Response({"error": "Crop not found for this land."}, status=status.HTTP_404_NOT_FOUND)

    except MySchedule.DoesNotExist:
        return Response({"error": "No schedule found for this farmer, land, and crop."}, status=status.HTTP_404_NOT_FOUND)
 




@api_view(['POST'])
def deactivate_my_sale(request, id):
    try:
        # Get the farmer
        farmer = Farmer.objects.get(id=id)
    except Farmer.DoesNotExist:
        return Response({"error": "Farmer not found"}, status=status.HTTP_400_BAD_REQUEST)

    try:
        # Get the sale by id and check if it's associated with the farmer
        sale = MySales.objects.get(id=request.data.get('id'), farmer=farmer)
    except MySales.DoesNotExist:
        return Response({"error": "Sale not found or not associated with the specified farmer"}, status=status.HTTP_400_BAD_REQUEST)
    
    # Update the status to 2 (indicating it is deactivated, this may vary based on your use case)
    sale.status = 2  # Adjust this status code to match the "deactivated" status in your application
    sale.save()

    notification_message = f"Your Sale '{sale.my_crop.crop.name}' has been deleted."
    FarmerNotification.objects.create(
        farmer=farmer,
        name=f"Sale Deleted: {sale.my_crop.crop.name}", 
        type="Sale Deleted",
        message=notification_message,
        created_at=timezone.now(),
        is_read=False
    )

    return Response({"message": "Sale deactivated successfully",
                     "language":{"default":"en"
                     }}, status=status.HTTP_200_OK) 

from django.utils import timezone
from datetime import timedelta

# @api_view(['POST'])
# def get_sales_details(request, farmer_id):
#     try:
#         user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
#         language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
#     except UserLanguagePreference.DoesNotExist:
#         language_code = 'en' 

#     try:
#         # Parse the request body to get sales_id
#         sales_id = request.data.get('sales_id')  # Get sales_id from the JSON body of the request
        
#         if not sales_id:
#             return Response({"error": "sales_id is required in the payload"}, status=status.HTTP_400_BAD_REQUEST)
        
#         # Retrieve the MySales object, ensuring the farmer_id is associated with the sale
#         sale = get_object_or_404(MySales, id=sales_id, farmer_id=farmer_id, status=0)
        
#         # Retrieve all DeductionReasons related to this sale
#         deductions = DeductionReasons.objects.filter(my_sales=sale)
        
#         # Retrieve all SalesDocuments related to this sale
#         sales_documents = SalesDocument.objects.filter(my_sales=sale)
        
#         # Retrieve date format from settings or use a default format
#         try:
#             settings = GeneralSetting.objects.first()
#             date_format = convert_to_strftime_format(settings.date_format) if settings else '%d-%m-%Y'  # Fallback to default format
#         except Exception as e:
#             date_format = '%d-%m-%Y'  # Fallback to default format in case of any error with GeneralSetting

#         # Format the dates_of_sales using the retrieved or default date format
#         formatted_sales_date = sale.dates_of_sales.strftime(date_format) if sale.dates_of_sales else ""

#         # Calculate the day count from MyCrop's created_at to current date
#         if sale.my_crop and sale.my_crop.created_at:
#             day_count = (timezone.now().date() - sale.my_crop.created_at.date()).days
#         else:
#             day_count = 0  # If no crop is associated or created_at is not available

#         # Prepare the response data
#         response_data = {
#             'sales_id': sale.id,
#             'farmer': {
#                 'id': sale.farmer.id if sale.farmer else "",
#                 # 'name': sale.farmer.name if sale.farmer else "",
#                 'name': sale.farmer.get_translated_value("name", language_code) if sale.farmer else "",
#             },
#             'land': {
#                 'id': sale.my_crop.land.id if sale.my_crop.land else "",
#                 # 'name': sale.my_crop.land.name if sale.my_crop.land else "",
#                 'name': sale.my_crop.land.get_translated_value("name", language_code) if sale.my_crop.land else "",
#             },
#             'dates_of_sales': formatted_sales_date,  # Use the formatted date
#             'my_crop': {
#                 'id': sale.my_crop.id if sale.my_crop else "",
#                 # 'name': sale.my_crop.crop.name if sale.my_crop and sale.my_crop.crop else "",
#                 'name': sale.my_crop.crop.get_translated_value("name", language_code) if sale.my_crop and sale.my_crop.crop else "",
#                 'img': request.build_absolute_uri(f'/SuperAdmin{sale.my_crop.crop.img.url}' if sale.my_crop.crop.img else sale.my_crop.crop.img.url) if sale.my_crop.crop.img else "",
#             },
#             'my_customer': {
#                 'id': sale.my_customer.id if sale.my_customer else "",
#                 'name': sale.my_customer.get_translated_value("customer_name", language_code) if sale.my_customer else "",
#                 # 'name': sale.my_customer.customer_name if sale.my_customer else "",
#             },
#             'sales_quantity': sale.sales_quantity,
#             'sales_unit': {
#                 'id': sale.sales_unit.id if sale.sales_unit else "",
#                 # 'name': sale.sales_unit.name if sale.sales_unit else "",
#                 'name': sale.sales_unit.get_translated_value("name", language_code) if sale.sales_unit else "",
#             },
#             'quantity_amount': sale.quantity_amount,
#             'total_amount': sale.total_amount,
#             'sales_amount': sale.sales_amount,
#             'deduction_amount': sale.deduction_amount,
#             'total_sales_amount': sale.total_sales_amount, 
#             'amount_paid': sale.amount_paid,
#             # 'description': sale.description,
#             'description': sale.get_translated_value("description", language_code) if sale else "",
#             'status': sale.status,
#             'created_at': sale.created_at,
#             'updated_at': sale.updated_at,
#             'deductions': [],
#             'documents': [],
#             "language": {"default": "en"},
#             'day_count': day_count  # Add the day count to the response
#         }
        
#         # Add deductions to the response data
#         for deduction in deductions:
#             deduction_data = {
#                 'deduction_id': deduction.id,
#                 'reason': {
#                     'id': deduction.reason.id if deduction.reason else "",
#                     # 'name': deduction.reason.name if deduction.reason else "",
#                     'name': deduction.reason.get_translated_value("name", language_code) if deduction.reason else "",
#                 },
#                 'charges': deduction.charges,
#                 'rupee': {
#                     'id': deduction.rupee.id if deduction.rupee else "N/A",  # Fallback value if `rupee` is None
#                     'name': deduction.rupee.name if deduction.rupee else "Not Available",  # Fallback value if `rupee` is None
#                 }
#             }
#             response_data['deductions'].append(deduction_data)
        
#         # Group sales documents by document_category.id
#         grouped_documents = {}
#         for document in sales_documents:
#             document_data = {
#                 'id': document.id,
#                 'document_category': {
#                     'id': document.document_category.id if document.document_category else "",
#                     'name': document.document_category.name if document.document_category else "Unknown Category",  # Handle missing category
#                 },
#                 'file_upload': request.build_absolute_uri(f'/SuperAdmin{document.file_upload.url}' if document.file_upload else document.file_upload.url) if document.file_upload else "",
#                 'language': {'default': 'en'}
#             }
            
#             # Group the document by document_category.id, if no category set to "unknown_category"
#             category_id = str(document.document_category.id) if document.document_category else "unknown_category"
            
#             if category_id not in grouped_documents:
#                 grouped_documents[category_id] = []  # Initialize the category array
            
#             grouped_documents[category_id].append(document_data)

#         # Format the grouped documents into the response structure
#         formatted_documents = []
#         for category_id, documents in grouped_documents.items():
#             formatted_documents.append({
#                 'category_id': category_id,
#                 'documents': documents
#             })

#         # Add grouped documents to the response data
#         response_data['documents'] = formatted_documents
        
#         # Return the response as JSON
#         return Response(response_data, status=status.HTTP_200_OK)

#     except json.JSONDecodeError:
#         return Response({"error": "Invalid JSON in the request body"}, status=status.HTTP_400_BAD_REQUEST)

@api_view(['POST'])
def get_sales_details(request, farmer_id):
    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'

    try:
        sales_id = request.data.get('sales_id')
        if not sales_id:
            return Response({"error": "sales_id is required in the payload"}, status=status.HTTP_400_BAD_REQUEST)

        sale = get_object_or_404(MySales, id=sales_id, farmer_id=farmer_id, status=0)

        deductions = DeductionReasons.objects.filter(my_sales=sale)
        sales_documents = SalesDocument.objects.filter(my_sales=sale)

        try:
            settings = GeneralSetting.objects.first()
            date_format = convert_to_strftime_format(settings.date_format) if settings else '%d-%m-%Y'
        except Exception:
            date_format = '%d-%m-%Y'

        formatted_sales_date = sale.dates_of_sales.strftime(date_format) if sale.dates_of_sales else ""

        if sale.my_crop and sale.my_crop.created_at:
            day_count = (timezone.now().date() - sale.my_crop.created_at.date()).days
        else:
            day_count = 0

        response_data = {
            'sales_id': sale.id,
            'farmer': {
                'id': sale.farmer.id if sale.farmer else "",
                'name': safe_get_translated_value(sale.farmer, "name", language_code),
            },
            'land': {
                'id': sale.my_crop.land.id if sale.my_crop and sale.my_crop.land else "",
                'name': safe_get_translated_value(sale.my_crop.land, "name", language_code) if sale.my_crop else "",
            },
            'dates_of_sales': formatted_sales_date,
            'my_crop': {
                'id': sale.my_crop.id if sale.my_crop else "",
                'name': safe_get_translated_value(sale.my_crop.crop, "name", language_code) if sale.my_crop and sale.my_crop.crop else "",
                'img': request.build_absolute_uri(
                    f'/SuperAdmin{sale.my_crop.crop.img.url}' if sale.my_crop and sale.my_crop.crop and sale.my_crop.crop.img else ""
                ),
            },
            'my_customer': {
                'id': sale.my_customer.id if sale.my_customer else "",
                'name': safe_get_translated_value(sale.my_customer, "customer_name", language_code),
            },
            'sales_quantity': sale.sales_quantity,
            'sales_unit': {
                'id': sale.sales_unit.id if sale.sales_unit else "",
                'name': safe_get_translated_value(sale.sales_unit, "name", language_code),
            },
            'quantity_amount': sale.quantity_amount,
            'total_amount': sale.total_amount,
            'sales_amount': sale.sales_amount,
            'deduction_amount': sale.deduction_amount,
            'total_sales_amount': sale.total_sales_amount,
            'amount_paid': sale.amount_paid,
            'description': safe_get_translated_value(sale, "description", language_code),
            'status': sale.status,
            'created_at': sale.created_at,
            'updated_at': sale.updated_at,
            'deductions': [],
            'documents': [],
            "language": {"default": "en"},
            'day_count': day_count
        }

        for deduction in deductions:
            deduction_data = {
                'deduction_id': deduction.id,
                'reason': {
                    'id': deduction.reason.id if deduction.reason else "",
                    'name': safe_get_translated_value(deduction.reason, "name", language_code) if deduction.reason else "",
                },
                'charges': deduction.charges,
                'rupee': {
                    'id': deduction.rupee.id if deduction.rupee else "N/A",
                    'name': deduction.rupee.name if deduction.rupee else "Not Available",
                }
            }
            response_data['deductions'].append(deduction_data)

        grouped_documents = {}
        for document in sales_documents:
            document_data = {
                'id': document.id,
                'document_category': {
                    'id': document.document_category.id if document.document_category else "",
                    'name': document.document_category.name if document.document_category else "Unknown Category",
                },
                'file_upload': request.build_absolute_uri(
                    f'/SuperAdmin{document.file_upload.url}' if document.file_upload else ""
                ),
                'language': {'default': 'en'}
            }

            category_id = str(document.document_category.id) if document.document_category else "unknown_category"
            if category_id not in grouped_documents:
                grouped_documents[category_id] = []
            grouped_documents[category_id].append(document_data)

        formatted_documents = []
        for category_id, documents in grouped_documents.items():
            formatted_documents.append({
                'category_id': category_id,
                'documents': documents
            })

        response_data['documents'] = formatted_documents

        return Response(response_data, status=status.HTTP_200_OK)

    except json.JSONDecodeError:
        return Response({"error": "Invalid JSON in the request body"}, status=status.HTTP_400_BAD_REQUEST)


def safe_get_translated_value(obj, field, lang_code):
    """
    Safely get translated value from an object.
    Returns empty string on error or if obj is None.
    """
    if not obj:
        return ""
    try:
        return obj.get_translated_value(field, lang_code)
    except Exception:
        # Log error if needed here
        return ""
 

# def safe_get_translated_value(obj, field, lang):
#     try:
#         if obj:
#             return obj.get_translated_value(field, lang)
#     except Exception:
#         pass
#     return ""

# @api_view(['POST'])

# def get_sales_by_crop(request, farmer_id):
#     try:
#         if not request.data or not isinstance(request.data, dict):
#             return Response({"error": "Missing or invalid request data."}, status=400)

#         crop_id = request.data.get('crop_id')
#         filter_type = request.data.get('type')
#         valid_filter_types = ['week', 'month', 'year']

#         if crop_id is None:
#             return Response({"error": "crop_id is required in the payload"}, status=400)

#         if not isinstance(filter_type, str) or filter_type not in valid_filter_types:
#             return Response({"error": "Valid filter_type (week, month, or year) is required in the payload"}, status=400)

#         try:
#             user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
#             language_code = user_language_pref.language_code or 'en'
#         except UserLanguagePreference.DoesNotExist:
#             language_code = 'en'

#         crop = get_object_or_404(MyCrop, id=crop_id, status=0)

#         try:
#             settings = GeneralSetting.objects.first()
#             date_format = convert_to_strftime_format(settings.date_format) if settings else '%d-%m-%Y'
#         except Exception:
#             date_format = '%d-%m-%Y'

#         current_time = timezone.now()

#         if filter_type == 'week':
#             start_date = current_time - timedelta(days=7)
#         elif filter_type == 'month':
#             start_date = current_time - timedelta(days=30)
#         elif filter_type == 'year':
#             start_date = current_time - timedelta(days=365)
#         else:
#             return Response({"error": "Invalid filter_type."}, status=400)

#         sales = MySales.objects.filter(
#             farmer_id=farmer_id,
#             my_crop=crop,
#             dates_of_sales__gte=start_date,
#             status=0
#         )

#         total_sales_amount = 0

#         # Use defaultdict only if grouping is needed
#         sales_grouped_by_month = defaultdict(list) if filter_type == 'year' else None
#         flat_sales_data = []

#         for sale in sales:
#             formatted_sales_date = sale.dates_of_sales.strftime(date_format) if sale.dates_of_sales else ""

#             sale_dict = {
#                 'sales_id': sale.id,
#                 'dates_of_sales': formatted_sales_date,
#                 'sales_quantity': sale.sales_quantity,
#                 'sales_unit': {
#                     'id': sale.sales_unit.id if sale.sales_unit else "",
#                     'name': safe_get_translated_value(sale.sales_unit, "name", language_code),
#                 },
#                 'quantity_amount': sale.quantity_amount,
#                 'total_amount': sale.total_amount,
#                 'sales_amount': sale.sales_amount,
#                 'deduction_amount': sale.deduction_amount,
#                 'total_sales_amount': sale.total_sales_amount,
#                 'description': safe_get_translated_value(sale, "description", language_code),
#                 'status': sale.status,
#                 'farmer': {
#                     'id': sale.farmer.id if sale.farmer else "",
#                     'name': safe_get_translated_value(sale.farmer, "name", language_code),
#                 },
#                 'my_customer': {
#                     'id': sale.my_customer.id if sale.my_customer else "",
#                     'name': safe_get_translated_value(sale.my_customer, "customer_name", language_code),
#                     'village': safe_get_translated_value(
#                         sale.my_customer.village if sale.my_customer and sale.my_customer.village else None,
#                         "name",
#                         language_code
#                     ),
#                 },
#                 'created_at': sale.created_at,
#                 'updated_at': sale.updated_at,
#             }

#             total_sales_amount += sale.sales_amount or 0

#             if filter_type == 'year' and sale.dates_of_sales:
#                 month_name = calendar.month_name[sale.dates_of_sales.month]
#                 sales_grouped_by_month[month_name].append(sale_dict)
#             else:
#                 flat_sales_data.append(sale_dict)

#         crop_img_url = ""
#         if crop.crop and crop.crop.img and getattr(crop.crop.img, 'url', None):
#             crop_img_url = request.build_absolute_uri(f'/SuperAdmin{crop.crop.img.url}')

#         return Response({
#             'crop_id': crop.id,
#             'crop_name': safe_get_translated_value(crop.crop, "name", language_code),
#             'crop_land_id': crop.land.id if crop.land else "",
#             'crop_land': safe_get_translated_value(crop.land, "name", language_code),
#             "crop_img": crop_img_url,
#             'total_sales_amount': total_sales_amount,
#             'sales': sales_grouped_by_month if filter_type == 'year' else flat_sales_data,
#             "language": {"default": "en"}
#         })

#     except Exception as e:
#         return Response({
#             "error": str(e),
#             "traceback": traceback.format_exc()
#         }, status=500)

@api_view(['POST'])
def get_sales_by_crop(request, farmer_id):
    try:
        if not request.data or not isinstance(request.data, dict):
            return Response({"error": "Missing or invalid request data."}, status=400)

        crop_id = request.data.get('crop_id')
        filter_type = request.data.get('type')
        valid_filter_types = ['week', 'month', 'year']

        if crop_id is None:
            return Response({"error": "crop_id is required in the payload"}, status=400)

        if not isinstance(filter_type, str) or filter_type not in valid_filter_types:
            return Response({"error": "Valid filter_type (week, month, or year) is required in the payload"}, status=400)

        try:
            user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
            language_code = user_language_pref.language_code or 'en'
        except UserLanguagePreference.DoesNotExist:
            language_code = 'en'

        crop = get_object_or_404(MyCrop, id=crop_id, status=0)

        try:
            settings = GeneralSetting.objects.first()
            date_format = convert_to_strftime_format(settings.date_format) if settings else '%d-%m-%Y'
        except Exception:
            date_format = '%d-%m-%Y'

        current_time = timezone.now()

        if filter_type == 'week':
            start_date = current_time - timedelta(days=7)
        elif filter_type == 'month':
            start_date = current_time - timedelta(days=30)
        elif filter_type == 'year':
            start_date = current_time - timedelta(days=365)
        else:
            return Response({"error": "Invalid filter_type."}, status=400)

        sales = MySales.objects.filter(
            farmer_id=farmer_id,
            my_crop=crop,
            dates_of_sales__gte=start_date,
            status=0
        )

        total_sales_amount = 0

        sales_grouped_by_month = defaultdict(list) if filter_type == 'year' else None
        sales_grouped_by_date = defaultdict(list) if filter_type != 'year' else None

        for sale in sales:
            formatted_sales_date = sale.dates_of_sales.strftime(date_format) if sale.dates_of_sales else ""

            sale_dict = {
                'sales_id': sale.id,
                'dates_of_sales': formatted_sales_date,
                'sales_quantity': sale.sales_quantity,
                'sales_unit': {
                    'id': sale.sales_unit.id if sale.sales_unit else "",
                    'name': safe_get_translated_value(sale.sales_unit, "name", language_code),
                },
                'quantity_amount': sale.quantity_amount,
                'total_amount': sale.total_amount,
                'sales_amount': sale.sales_amount,
                'deduction_amount': sale.deduction_amount,
                'total_sales_amount': sale.total_sales_amount,
                'description': safe_get_translated_value(sale, "description", language_code),
                'status': sale.status,
                'farmer': {
                    'id': sale.farmer.id if sale.farmer else "",
                    'name': safe_get_translated_value(sale.farmer, "name", language_code),
                },
                'my_customer': {
                    'id': sale.my_customer.id if sale.my_customer else "",
                    'name': safe_get_translated_value(sale.my_customer, "customer_name", language_code),
                    'village': safe_get_translated_value(
                        sale.my_customer.village if sale.my_customer and sale.my_customer.village else None,
                        "name",
                        language_code
                    ),
                },
                'created_at': sale.created_at,
                'updated_at': sale.updated_at,
            }

            total_sales_amount += sale.sales_amount or 0

            if filter_type == 'year' and sale.dates_of_sales:
                month_name = calendar.month_name[sale.dates_of_sales.month]
                sales_grouped_by_month[month_name].append(sale_dict)
            else:
                sales_grouped_by_date[formatted_sales_date].append(sale_dict)

        crop_img_url = ""
        if crop.crop and crop.crop.img and getattr(crop.crop.img, 'url', None):
            crop_img_url = request.build_absolute_uri(f'/SuperAdmin{crop.crop.img.url}')

        return Response({
            'crop_id': crop.id,
            'crop_name': safe_get_translated_value(crop.crop, "name", language_code),
            'crop_land_id': crop.land.id if crop.land else "",
            'crop_land': safe_get_translated_value(crop.land, "name", language_code),
            "crop_img": crop_img_url,
            'total_sales_amount': total_sales_amount,
            'sales': sales_grouped_by_month if filter_type == 'year' else sales_grouped_by_date,
            "language": {"default": "en"}
        })

    except Exception as e:
        return Response({
            "error": str(e),
            "traceback": traceback.format_exc()
        }, status=500)


@api_view(['POST'])
def deactivate_my_schedule(request, id):
    # Step 1: Get the farmer instance
    try:
        farmer = Farmer.objects.get(id=id)
    except Farmer.DoesNotExist:
        return Response({"error": "Farmer not found"}, status=status.HTTP_400_BAD_REQUEST)

    # Step 2: Get the schedule by ID
    schedule_id = request.data.get('id')
    if not schedule_id:
        return Response({"error": "Schedule ID is required"}, status=status.HTTP_400_BAD_REQUEST)

    try:
        schedule = MySchedule.objects.get(id=schedule_id, farmer=farmer,status=0)
    except MySchedule.DoesNotExist:
        return Response({"error": "Schedule not found or not associated with the specified farmer"}, status=status.HTTP_400_BAD_REQUEST)

    # Step 3: Update the schedule status to 2 (deactivated)
    schedule.status = 2  # Assuming '2' indicates deactivated status
    schedule.updated_at = timezone.now()
    schedule.updated_by = farmer.farmer_user  # Assuming the farmer is associated with a user in your system
    schedule.save()

    # Step 4: Create a notification for the farmer
    notification_message = f"Your schedule for crop {schedule.my_crop.crop.name} on {schedule.start_date} has been deleted."
    FarmerNotification.objects.create(
        farmer=farmer,
        name="Schedule Deleted",
        type="Task Management",
        message=notification_message,
        is_read=False  # Notification is unread by default
    )

    # Step 5: Return success response
    return Response({
        "message": "Schedule Deleted Successfully",
        "language": {"default": "en"}
    }, status=status.HTTP_200_OK)

@api_view(['GET'])
def get_schedule_details(request, farmer_id):

    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'

    try:
        # Get schedule_id from the query parameters
        schedule_id = request.query_params.get('id')

        if not schedule_id:
            return Response({'error': 'schedule_id is required in the query parameters'}, status=status.HTTP_400_BAD_REQUEST)

        # Retrieve the schedule instance using farmer_id and schedule_id
        my_schedule = MySchedule.objects.get(farmer_id=farmer_id, id=schedule_id, status=0)

        # Get the schedule date format from the settings or default
        try:
            settings = GeneralSetting.objects.first()
            date_format = convert_to_strftime_format(settings.date_format)
        except Exception as e:
            date_format = '%d-%m-%Y'  # Fallback to default format

        # Format the start_date and end_date
        start_date = my_schedule.start_date.strftime(date_format) if my_schedule.start_date else ""
        end_date = my_schedule.end_date.strftime(date_format) if my_schedule.end_date else ""

        # Prepare schedule data
        schedule_table_id = my_schedule.manage_schedule.id if my_schedule.manage_schedule else None
        my_crop = my_schedule.my_crop

        # Fetch expenses for the crop
        crop_expenses = MyExpense.objects.filter(my_crop=my_crop, status=0)

        expense_data = []
        total_expense_amount = 0  # Initialize the total expense amount

        for expense in crop_expenses:
            expense_files = ExpenseFile.objects.filter(my_expense=expense)

            files_data = []
            for file in expense_files:
                files_data.append({
                    'file_url': request.build_absolute_uri(f'/assets{file.file.url}' if file.file.url else file.file.url) if file.file else "",
                    # 'file_type': file.file_type.name if file.file_type else None,
                    'file_type': file.file_type.get_translated_value("name", language_code) if file.file_type else None,
                    'uploaded_at': file.uploaded_at
                })

            # Format the created_day of the expense (if applicable)
            created_day = expense.created_day.strftime(date_format) if expense.created_day else ""

            expense_data.append({
                'expense_id': expense.id,
                'type_expenses': expense.type_expenses.get_translated_value("name", language_code) if expense.type_expenses else None,
                # 'type_expenses': expense.type_expenses.name if expense.type_expenses else None,
                'amount': expense.amount,
                # 'description': expense.description,
                'description': expense.get_translated_value("description", language_code) if expense else " ",
                'created_day': created_day,  # Add formatted created_day
                'status': expense.status,
                'documents': files_data
            })

            total_expense_amount += expense.amount  # Add the expense amount to the total

        # Prepare the schedule data with id and name for relevant fields
        schedule_data = {
            'farmer_id': my_schedule.farmer.id,
            'schedule_id': my_schedule.id,
            'my_land': {
                'id': my_schedule.my_land.id if my_schedule.my_land else None,
                # 'name': my_schedule.my_land.name if my_schedule.my_land else None
                'name': my_schedule.my_land.get_translated_value("name", language_code) if my_schedule.my_land and language_code == 'ta' else my_schedule.my_land.name if my_schedule.my_land else None
            },
            'my_crop': {
                'id': my_schedule.my_crop.id if my_schedule.my_crop else None,
                # 'name': my_schedule.my_crop.crop.name if my_schedule.my_crop else None,
                'name': my_schedule.my_crop.crop.get_translated_value("name", language_code) if my_schedule.my_crop and my_schedule.my_crop.crop and language_code == 'ta' else my_schedule.my_crop.crop.name if my_schedule.my_crop and my_schedule.my_crop.crop else None,
                "crop_img": request.build_absolute_uri(f'/SuperAdmin{my_schedule.my_crop.crop.img.url}' if my_schedule.my_crop.crop.img else my_schedule.my_crop.crop.img.url) if my_schedule.my_crop.crop.img else "",
            },
            'schedule_activity_type': {
                'id': my_schedule.schedule_activity_type.id if my_schedule.schedule_activity_type else None,
                # 'name': my_schedule.schedule_activity_type.name if my_schedule.schedule_activity_type else None
                'name': my_schedule.schedule_activity_type.get_translated_value("name", language_code) if my_schedule.schedule_activity_type and language_code == 'ta' else my_schedule.schedule_activity_type.name if my_schedule.schedule_activity_type else None,
            },
            'start_date': start_date,  # Formatted date
            'end_date': end_date,  # Formatted date
            'schedule_status': {
                'id': my_schedule.schedule_status.id if my_schedule.schedule_status else None,
                # 'name': my_schedule.schedule_status.name if my_schedule.schedule_status else None
                'name': my_schedule.schedule_status.get_translated_value("name", language_code) if my_schedule.schedule_status and language_code == 'ta' else my_schedule.schedule_status.name if my_schedule.schedule_status else None,
            },
            'status': my_schedule.status,
            # 'description': my_schedule.schedule,
            # 'comment': my_schedule.comment,
            'description': my_schedule.get_translated_value("schedule", language_code) if my_schedule.schedule and language_code == 'ta' else my_schedule.schedule if my_schedule.schedule else None,
            'comment': my_schedule.get_translated_value("comment", language_code) if my_schedule.comment and language_code == 'ta' else my_schedule.comment if my_schedule.comment else None,
            'crop_expenses': expense_data,
            'total_expense_amount': total_expense_amount,  # Add total expense amount to response
            'language': {
                'default': "en"
            }
        }

        return Response(schedule_data, status=status.HTTP_200_OK)

    except MySchedule.DoesNotExist:
        return Response({'error': 'Schedule not found'}, status=status.HTTP_404_NOT_FOUND)
    except json.JSONDecodeError:
        return Response({'error': 'Invalid JSON payload'}, status=status.HTTP_400_BAD_REQUEST)
    except Exception as e:
        return Response({'error': f'An unexpected error occurred: {str(e)}'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@api_view(['GET'])
def get_crop_expenses(request, farmer_id):
    try:
        # Get crop_id from the query parameters
        crop_id = request.query_params.get('crop_id')

        if not crop_id:
            return Response({'error': 'crop_id is required in the query parameters'}, status=status.HTTP_400_BAD_REQUEST)

        # Retrieve the crop instance using the farmer_id and crop_id
        my_crop = MyCrop.objects.get(farmer_id=farmer_id, id=crop_id,status=0)

        # Fetch expenses for the crop
        crop_expenses = MyExpense.objects.filter(my_crop=my_crop, status=0)

        expense_data = []
        total_expense_amount = 0  # Initialize the total expense amount

        for expense in crop_expenses:
            expense_files = ExpenseFile.objects.filter(my_expense=expense)

            files_data = []
            for file in expense_files:
                files_data.append({
                    'file_url': request.build_absolute_uri(f'/assets{file.file.url}' if file.file.url else file.file.url) if file.file else "",
                    'file_type': file.file_type.name if file.file_type else None,
                    'uploaded_at': file.uploaded_at
                })

            expense_data.append({
                'expense_id': expense.id,
                'type_expenses': expense.type_expenses.name if expense.type_expenses else None,
                'amount': expense.amount,
                'description': expense.description,
                'created_day': expense.created_day,
                'status': expense.status,
                'documents': files_data
            })

            total_expense_amount += expense.amount  # Add the expense amount to the total

        # Prepare the crop expense data
        crop_expense_data = {
            'farmer_id': my_crop.farmer.id,
            'crop_id': my_crop.id,
            'crop_name': my_crop.crop.name if my_crop.crop else None,
            'total_expense_amount': total_expense_amount,  # Add total expense amount to response
            'crop_expenses': expense_data,
            'language': {
                'default': "en"
            }
        }

        return Response(crop_expense_data, status=status.HTTP_200_OK)

    except MyCrop.DoesNotExist:
        return Response({'error': 'Crop not found'}, status=status.HTTP_404_NOT_FOUND)
    except json.JSONDecodeError:
        return Response({'error': 'Invalid JSON payload'}, status=status.HTTP_400_BAD_REQUEST)

@api_view(['POST'])
def deactivate_my_vendor(request, id):
    try:
        # Get the farmer
        farmer = Farmer.objects.get(id=id)
    except Farmer.DoesNotExist:
        return Response({"error": "Farmer not found"}, status=status.HTTP_400_BAD_REQUEST)

    try: 
        vendor = MyVendor.objects.get(id=request.data.get('vendor_id'), farmer=farmer)
    except MyVendor.DoesNotExist:
        return Response({"error": "Vendor not found or not associated with the specified farmer"}, status=status.HTTP_400_BAD_REQUEST)
     
    vendor.status = 2
    vendor.save()

    return Response({
        "message": "Vendor deactivated successfully",
        "language": {"default": "en"}
    }, status=status.HTTP_200_OK)

@api_view(['POST']) 
def deactivate_my_customer(request, id):
    try: 
        farmer = Farmer.objects.get(id=id)
    except Farmer.DoesNotExist:
        return Response({"error": "Farmer not found"}, status=status.HTTP_400_BAD_REQUEST)

    try: 
        customer = MyCustomer.objects.get(id=request.data.get('customer_id'), farmer=farmer)
    except MyCustomer.DoesNotExist:
        return Response({"error": "Customer not found or not associated with the specified farmer"}, status=status.HTTP_400_BAD_REQUEST)
     
    customer.status = 2
    customer.save()

    return Response({"message": "Customer deleted successfully",
                     "language": {"default": "en"}
                     }, status=status.HTTP_200_OK)

@api_view(['POST']) 
def deactivate_my_customer_vendor(request, id):
    # Try to fetch the farmer by ID
    try: 
        farmer = Farmer.objects.get(id=id)
    except Farmer.DoesNotExist:
        return Response({"error": "Farmer not found"}, status=status.HTTP_400_BAD_REQUEST)

    # Get customer_id from request data
    customer_id = request.data.get('customer_id')
    
    # Ensure customer_id is provided
    if not customer_id:
        return Response({"error": "customer_id is required"}, status=status.HTTP_400_BAD_REQUEST)

    # Try to fetch the customer by ID and ensure they are associated with the farmer and marked as a vendor
    try: 
        customer = MyCustomer.objects.get(id=customer_id, farmer=farmer, is_customer_is_vendor=True)
    except MyCustomer.DoesNotExist:
        return Response({"error": "Customer not found or not associated with the specified farmer, or not marked as vendor"}, status=status.HTTP_400_BAD_REQUEST)

    # Update the customer's status to 2 (deactivated)
    customer.status = 2
    customer.save()

    return Response({"message": "Customer status updated to deactivated", "language": {"default": "en"}}, status=status.HTTP_200_OK)

@api_view(['POST'])
def customer_sales_details(request, id):
    try:
        user_language_pref = UserLanguagePreference.objects.get(user=id)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'

    customer_id = request.data.get('customer_id')  # Get customer ID from request
    customers = MyCustomer.objects.filter(id=customer_id, farmer=id, status=0,is_customer_is_vendor=False)  # Filter customers by ID and farmer

    customer_sales_list = []  # List to store customer sales details


    try:
        settings = GeneralSetting.objects.first()
        date_format = convert_to_strftime_format(settings.date_format) if settings else '%d-%m-%Y'  # Fallback to default format
    except Exception as e:
        date_format = '%d-%m-%Y'

    def format_date(date):
        return date.strftime(date_format) if date else ""    
    
    for customer in customers:
        # Get the markets associated with this customer
        # market_list = [market.name for market in customer.market.all()]
        market_list = [ market.get_translated_value("name", language_code) for market in customer.market.all()] if customer else []
        
        # Get the sales related to this customer
        sales_details = MySales.objects.filter(my_customer=customer,status=0)  # Filter sales by customer
        
        for sale in sales_details:
            # For each sale, collect relevant information
            sales_data = {
                "customer_id":customer.id,
                "customer_name": customer.get_translated_value("customer_name", language_code) if customer.customer_name else "", 
                # "customer_name": customer.customer_name, 
                "market_list": market_list,  # List of markets associated with the customer
                "crop_id":sale.my_crop.id,
                # "crop_name": sale.my_crop.crop.name if sale.my_crop else "",  # Crop name from the sale
                "crop_name": sale.my_crop.crop.get_translated_value("name", language_code) if sale.my_crop.crop else "", 
                "sales_date": format_date(sale.dates_of_sales),
                "total_sales_amount": sale.total_sales_amount,
                "language":{
                    "default":"en"
                }
            }
            customer_sales_list.append(sales_data)  # Add sales data to the list
    
    return Response(customer_sales_list, status=status.HTTP_200_OK)

@api_view(['GET'])
def get_farmer_profile(request, farmer_id):
    try:
        # Fetch the farmer by ID
        farmer = Farmer.objects.get(id=farmer_id)
        
        # Manually constructing the response data
        farmer_data = {
            "id": farmer.id, 
            "name": farmer.name,
            "phone": farmer.phone,
            "email": farmer.email,
            "country": {
                "id": farmer.country.id if farmer.country else "",
                "name": farmer.country.name if farmer.country else ""
            },
            "state": {
                "id": farmer.state.id if farmer.state else "",
                "name": farmer.state.name if farmer.state else ""
            },
            "city": {
                "id": farmer.city.id if farmer.city else "",
                "name": farmer.city.name if farmer.city else ""
            },
            "taluk": {
                "id": farmer.taluk.id if farmer.taluk else "",
                "name": farmer.taluk.name if farmer.taluk else ""
            },
            "village": {
                "id": farmer.village.id if farmer.village else  "",
                "name": farmer.village.name if farmer.village else ""
            },
            "door_no": farmer.door_no,
            "pincode": farmer.pincode,
            "description": farmer.description,
            "img": request.build_absolute_uri(f'/SuperAdmin{farmer.img.url}' if farmer.img else farmer.img.url) if farmer.img else "", 
            "company_name": farmer.company_name,
            "tax_no": farmer.tax_no, 
            "language": {
                "default": "en"
            }
        }

        # Return the manually constructed data as the response
        return Response(farmer_data, status=status.HTTP_200_OK)

    except Farmer.DoesNotExist:
        return Response({"detail": "Farmer not found"}, status=status.HTTP_404_NOT_FOUND)

@api_view(['POST'])
def delete_expense_file(request, id):
    try: 
        # Find the ExpenseFile based on the provided ID
        expense_file = ExpenseFile.objects.get(id=id)
    except ExpenseFile.DoesNotExist:
        return Response({"error": "Expense file not found"}, status=status.HTTP_400_BAD_REQUEST)
    
    # Delete the ExpenseFile object from the database
    expense_file.delete()

    return Response({
        "message": "Expense file deleted successfully",
        "language": {"default": "en"}
    }, status=status.HTTP_200_OK)

# @api_view(['GET'])
# def purchase_list(request, farmer_id):
#     try:
#         # Fetch all objects with status = 0 for the given farmer
#         my_fuels = MyFuel.objects.filter(farmer_id=farmer_id, status__in=[0, 1])
#         my_vehicles = MyVehicle.objects.filter(farmer_id=farmer_id,status__in=[0, 1])
#         my_machinery = MyMachinery.objects.filter(farmer_id=farmer_id,status__in=[0, 1])
#         my_tools = MyTools.objects.filter(farmer_id=farmer_id,status__in=[0, 1])
#         my_seeds = MySeeds.objects.filter(farmer_id=farmer_id, status__in=[0, 1])
#         my_fertilizers = MyFertilizers.objects.filter(farmer_id=farmer_id, status__in=[0, 1])
#         my_pesticides = MyPesticides.objects.filter(farmer_id=farmer_id,status__in=[0, 1])

#         # Sum quantities safely, treating None as 0
#         total_fuel_liters = sum([float(fuel.quantity) if fuel.quantity is not None else 0 for fuel in my_fuels])
#         total_vehicle_liters = sum([float(vehicle.fuel_capacity) if vehicle.fuel_capacity is not None else 0 for vehicle in my_vehicles])
#         total_machinery_fuel = sum([float(machinery.fuel_capacity) if machinery.fuel_capacity is not None else 0 for machinery in my_machinery])
#         total_tool_quantity = sum([float(tool.quantity) if tool.quantity is not None else 0 for tool in my_tools])
#         total_seeds_quantity = sum([float(seeds.quantity) if seeds.quantity is not None else 0 for seeds in my_seeds])
#         total_fertilizers_quantity = sum([float(fertilizers.quantity) if fertilizers.quantity is not None else 0 for fertilizers in my_fertilizers])
#         total_pesticides_quantity = sum([float(pesticides.quantity) if pesticides.quantity is not None else 0 for pesticides in my_pesticides])

#         # Construct the response data
#         response_data = {
#             'fuel': {
#                 'total_quantity': str(total_fuel_liters)
#             },
#             'vehicle': {
#                 'total_fuel_capacity': str(total_vehicle_liters)
#             },
#             'machinery': {
#                 'total_fuel_capacity': str(total_machinery_fuel)
#             },
#             'tools': {
#                 'total_quantity': str(total_tool_quantity)
#             },
#             'Pesticides': {
#                 'total_quantity': str(total_pesticides_quantity)
#             },
#             'fertilizers': {
#                 'total_quantity': str(total_fertilizers_quantity)
#             },
#             'seeds': {
#                 'total_quantity': str(total_seeds_quantity)
#             },
#             'language': {
#                 'default': 'en'
#             }
#         }

#         return Response(response_data)

#     except Exception as e:
#         return Response({'error': str(e)}, status=400)

@api_view(['GET'])
def purchase_list(request, farmer_id):
    try:
        # Fetch all objects with status = 0 or 1 for the given farmer
        my_fuels = MyFuel.objects.filter(farmer_id=farmer_id, status__in=[0, 1])
        my_vehicles = MyVehicle.objects.filter(farmer_id=farmer_id, status__in=[0, 1])
        my_machinery = MyMachinery.objects.filter(farmer_id=farmer_id, status__in=[0, 1])
        my_tools = MyTools.objects.filter(farmer_id=farmer_id, status__in=[0, 1])
        my_seeds = MySeeds.objects.filter(farmer_id=farmer_id, status__in=[0, 1])
        my_fertilizers = MyFertilizers.objects.filter(farmer_id=farmer_id, status__in=[0, 1])
        my_pesticides = MyPesticides.objects.filter(farmer_id=farmer_id, status__in=[0, 1])

        # Sum quantities safely, treating None as 0
        total_fuel_liters = sum([float(fuel.quantity) if fuel.quantity is not None else 0 for fuel in my_fuels])
        total_vehicle_liters = sum([float(vehicle.fuel_capacity) if vehicle.fuel_capacity is not None else 0 for vehicle in my_vehicles])
        total_machinery_fuel = sum([float(machinery.fuel_capacity) if machinery.fuel_capacity is not None else 0 for machinery in my_machinery])
        total_tool_quantity = sum([float(tool.quantity) if tool.quantity is not None else 0 for tool in my_tools])
        total_seeds_quantity = sum([float(seeds.quantity) if seeds.quantity is not None else 0 for seeds in my_seeds])
        total_fertilizers_quantity = sum([float(fertilizers.quantity) if fertilizers.quantity is not None else 0 for fertilizers in my_fertilizers])
        total_pesticides_quantity = sum([float(pesticides.quantity) if pesticides.quantity is not None else 0 for pesticides in my_pesticides])

        # Construct the response data with IDs
        response_data = {
            'fuel': {
                'id': 6,
                'total_quantity': str(total_fuel_liters)
            },
            'vehicle': {
                'id': 1,
                'total_fuel_capacity': str(total_vehicle_liters)
            },
            'machinery': {
                'id': 2,
                'total_fuel_capacity': str(total_machinery_fuel)
            },
            'tools': {
                'id': 3,
                'total_quantity': str(total_tool_quantity)
            },
            'pesticides': {
                'id': 4,
                'total_quantity': str(total_pesticides_quantity)
            },
            'fertilizers': {
                'id': 5,
                'total_quantity': str(total_fertilizers_quantity)
            },
            'seeds': {
                'id': 7,
                'total_quantity': str(total_seeds_quantity)
            },
            'language': {
                'default': 'en'
            }
        }

        return Response(response_data)

    except Exception as e:
        return Response({'error': str(e)}, status=400)


@api_view(['POST'])
def deactivate_my_fuel(request, id):
    try:  
        farmer = Farmer.objects.get(id=id)
    except Farmer.DoesNotExist:
        return Response({"error": "Farmer not found"}, status=status.HTTP_400_BAD_REQUEST)

    try:  
        my_fuel_id = request.data.get('my_fuel_id')
        if not my_fuel_id:
            return Response({"error": "MyFuel ID is required in the payload."}, status=status.HTTP_400_BAD_REQUEST)

        my_fuel = MyFuel.objects.get(id=my_fuel_id, farmer=farmer)
    except MyFuel.DoesNotExist:
        return Response({"error": "MyFuel record not found or not associated with the specified farmer"}, status=status.HTTP_400_BAD_REQUEST)
      
    my_fuel.status = 2
    my_fuel.save()

    return Response({"message": "MyFuel Deleted successfully", "language": {"default": "en"}}, status=status.HTTP_200_OK)

@api_view(['POST'])
def deactivate_my_vehicle(request, id):
    try:  
        # Get the farmer object by farmer id (from URL)
        farmer = Farmer.objects.get(id=id)
    except Farmer.DoesNotExist:
        return Response({"error": "Farmer not found"}, status=status.HTTP_400_BAD_REQUEST)

    try:  
        # Get the MyVehicle object associated with the farmer and the provided 'my_vehicle_id' from the payload
        my_vehicle_id = request.data.get('my_vehicle_id')
        if not my_vehicle_id:
            return Response({"error": "MyVehicle ID is required in the payload."}, status=status.HTTP_400_BAD_REQUEST)

        my_vehicle = MyVehicle.objects.get(id=my_vehicle_id, farmer=farmer)
    except MyVehicle.DoesNotExist:
        return Response({"error": "MyVehicle record not found or not associated with the specified farmer"}, status=status.HTTP_400_BAD_REQUEST)
      
    # Set status to 2 (deactivated) and save
    my_vehicle.status = 2
    my_vehicle.save()

    return Response({"message": "MyVehicle deactivated successfully", "language": {"default": "en"}}, status=status.HTTP_200_OK)
 
@api_view(['POST'])
def deactivate_my_tools(request, id):
    try:  
        # Get the farmer object by farmer id (from URL)
        farmer = Farmer.objects.get(id=id)
    except Farmer.DoesNotExist:
        return Response({"error": "Farmer not found"}, status=status.HTTP_400_BAD_REQUEST)

    try:  
        # Get the MyTools object associated with the farmer and the provided 'my_tools_id' from the payload
        my_tools_id = request.data.get('my_tools_id')
        if not my_tools_id:
            return Response({"error": "MyTools ID is required in the payload."}, status=status.HTTP_400_BAD_REQUEST)

        my_tools = MyTools.objects.get(id=my_tools_id, farmer=farmer)
    except MyTools.DoesNotExist:
        return Response({"error": "MyTools record not found or not associated with the specified farmer"}, status=status.HTTP_400_BAD_REQUEST)
      
    # Set status to 2 (deactivated) and save
    my_tools.status = 2
    my_tools.save()

    return Response({"message": "MyTools deactivated successfully", "language": {"default": "en"}}, status=status.HTTP_200_OK)
 
@api_view(['POST'])
def deactivate_my_machinery(request, id):
    try:  
        # Get the farmer object by farmer id (from URL)
        farmer = Farmer.objects.get(id=id)
    except Farmer.DoesNotExist:
        return Response({"error": "Farmer not found"}, status=status.HTTP_400_BAD_REQUEST)

    try:  
        # Get the MyMachinery object associated with the farmer and the provided 'my_machinery_id' from the payload
        my_machinery_id = request.data.get('my_machinery_id')
        if not my_machinery_id:
            return Response({"error": "MyMachinery ID is required in the payload."}, status=status.HTTP_400_BAD_REQUEST)

        my_machinery = MyMachinery.objects.get(id=my_machinery_id, farmer=farmer)
    except MyMachinery.DoesNotExist:
        return Response({"error": "MyMachinery record not found or not associated with the specified farmer"}, status=status.HTTP_400_BAD_REQUEST)
      
    # Set status to 2 (deactivated) and save
    my_machinery.status = 2
    my_machinery.save()

    return Response({"message": "MyMachinery deactivated successfully", "language": {"default": "en"}}, status=status.HTTP_200_OK)
 
@api_view(['POST'])
def deactivate_my_seeds(request, id):
    try:  
        # Get the farmer object by farmer id (from URL)
        farmer = Farmer.objects.get(id=id)
    except Farmer.DoesNotExist:
        return Response({"error": "Farmer not found"}, status=status.HTTP_400_BAD_REQUEST)

    try:  
        # Get the MySeeds object associated with the farmer and the provided 'my_seeds_id' from the payload
        my_seeds_id = request.data.get('my_seeds_id')
        if not my_seeds_id:
            return Response({"error": "MySeeds ID is required in the payload."}, status=status.HTTP_400_BAD_REQUEST)

        my_seeds = MySeeds.objects.get(id=my_seeds_id, farmer=farmer)
    except MySeeds.DoesNotExist:
        return Response({"error": "MySeeds record not found or not associated with the specified farmer"}, status=status.HTTP_400_BAD_REQUEST)
      
    # Set status to 2 (deactivated) and save
    my_seeds.status = 2
    my_seeds.save()

    return Response({"message": "MySeeds deactivated successfully", "language": {"default": "en"}}, status=status.HTTP_200_OK)
 
@api_view(['POST'])
def deactivate_my_fertilizers(request, id):
    try:  
        # Get the farmer object by farmer id (from URL)
        farmer = Farmer.objects.get(id=id)
    except Farmer.DoesNotExist:
        return Response({"error": "Farmer not found"}, status=status.HTTP_400_BAD_REQUEST)

    try:  
        # Get the MyFertilizers object associated with the farmer and the provided 'my_fertilizers_id' from the payload
        my_fertilizers_id = request.data.get('my_fertilizers_id')
        if not my_fertilizers_id:
            return Response({"error": "MyFertilizers ID is required in the payload."}, status=status.HTTP_400_BAD_REQUEST)

        my_fertilizers = MyFertilizers.objects.get(id=my_fertilizers_id, farmer=farmer)
    except MyFertilizers.DoesNotExist:
        return Response({"error": "MyFertilizers record not found or not associated with the specified farmer"}, status=status.HTTP_400_BAD_REQUEST)
      
    # Set status to 2 (deactivated) and save
    my_fertilizers.status = 2
    my_fertilizers.save()

    return Response({"message": "MyFertilizers deactivated successfully", "language": {"default": "en"}}, status=status.HTTP_200_OK)
  
@api_view(['POST'])
def deactivate_pesticides(request, id):
    try:   
        farmer = Farmer.objects.get(id=id)
    except Farmer.DoesNotExist:
        return Response({"error": "Farmer not found"}, status=status.HTTP_400_BAD_REQUEST)

    try:  
        pesticides_id = request.data.get('pesticides_id')
        if not pesticides_id:
            return Response({"error": "Pesticides ID is required in the payload."}, status=status.HTTP_400_BAD_REQUEST)

        pesticides = MyPesticides.objects.get(id=pesticides_id, farmer=farmer)
    except MyPesticides.DoesNotExist:
        return Response({"error": "Pesticides record not found or not associated with the specified farmer"}, status=status.HTTP_400_BAD_REQUEST)
       
    pesticides.status = 2
    pesticides.save()

    return Response({"message": "Pesticides deactivated successfully", "language": {"default": "en"}}, status=status.HTTP_200_OK)

@api_view(['PUT'])
def update_fuel(request, farmer_id):
    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'

    # Retrieve the farmer
    farmer = get_object_or_404(Farmer, id=farmer_id, status=0)

    fuel_id = request.data.get('fuel_id')
    if not fuel_id:
        return Response(
            {
                "success": False,
                "message": "fuel_id is required in the request data.",
            },
            status=status.HTTP_400_BAD_REQUEST
        )

    # Get the fuel instance or return 404 if not found
    fuel_instance = get_object_or_404(MyFuel, id=fuel_id, farmer=farmer, status=0)

    # Handle fields passed as 'None' and replace them with empty strings
    for field in request.data:
        if request.data[field] is None:
            request.data[field] = ""

    translated_json = fuel_instance.translate_json or {
        "description": {}
    }

    description=request.data.get('description')
    if description != fuel_instance.description:
        try:
            for lang in target_language:
                translated_text = GoogleTranslator(source='auto', target=lang).translate(description)
                translated_json["description"][lang] = translated_text
        except Exception as e:
            print(e)
            print("Error in translation")


    # Assign updated fields from the request to the fuel_instance
    fuel_instance.date_of_consumption = request.data.get("date_of_consumption", fuel_instance.date_of_consumption)
    fuel_instance.vendor = get_object_or_404(MyVendor, id=request.data.get("vendor", fuel_instance.vendor.id), status=0)
    fuel_instance.inventory_type = get_object_or_404(InventoryType, id=request.data.get("inventory_type", fuel_instance.inventory_type.id), status=0)
    fuel_instance.translate_json = translated_json

    # Check if the inventory items are being updated
    new_inventory_item_id = request.data.get("inventory_items")
    if new_inventory_item_id:
        # Get the new inventory item
        new_inventory_item = get_object_or_404(InventoryItems, id=new_inventory_item_id, status=0)

        # Get the last created inventory item with the same inventory type and set previous inventory items to inactive
        last_inventory_item = MyFuel.objects.filter(
            inventory_type=fuel_instance.inventory_type,
            inventory_items__status=0
        ).latest('created_at')  # Assuming 'created_at' is the field indicating the creation time

        # Update the status of the previous inventory item to 1 (inactive)
        MyFuel.objects.filter(
            inventory_type=fuel_instance.inventory_type,
            inventory_items=last_inventory_item.inventory_items
        ).update(inventory_items=last_inventory_item.inventory_items, status=1)

        # Set the inventory_items to the new item
        fuel_instance.inventory_items = new_inventory_item

    fuel_instance.quantity = request.data.get("quantity", fuel_instance.quantity)
    fuel_instance.purchase_amount = request.data.get("purchase_amount", fuel_instance.purchase_amount)
    fuel_instance.description = request.data.get("description", fuel_instance.description)

    # Save the updated fuel record
    fuel_instance.save()

    # Recalculate the available quantity for the inventory items and type
    total_quantity = MyFuel.objects.filter(
        inventory_type=fuel_instance.inventory_type,
        inventory_items=fuel_instance.inventory_items
    ).aggregate(total_quantity=Sum('quantity'))['total_quantity'] or 0

    fuel_instance.available_quans = total_quantity
    fuel_instance.save()

    # Handle file uploads (fuel documents) only if provided
    file_data = request.data.get('documents', [])
    sales_details = []  # To hold the details of the documents being uploaded/updated

    if file_data:
        # Process each document data provided
        for doc_data in file_data:
            # Get the file type
            file_type_id = doc_data.get('file_type')

            if file_type_id is None:
                new_file_type = doc_data.get('new_file_type')
                if not new_file_type:
                    return Response({"error": "New file type for document is required."}, status=status.HTTP_400_BAD_REQUEST)

                # Get or create the document category
                file_type, created = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=2)
            else:
                file_type = get_object_or_404(DocumentCategory, id=file_type_id)

            documents = doc_data.get('documents', [])
            if not documents:
                return Response({"success": False, "message": f"No documents provided for file type {file_type_id}."}, status=status.HTTP_400_BAD_REQUEST)

            # Process each document provided
            for i, document_base64 in enumerate(documents):
                try:
                    if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
                        mime_type = validate_image_type(document_base64)  # Validate MIME type
                        if mime_type:
                            # Decode the base64-encoded document
                            document_data = document_base64.split(';base64,')[1]
                            document_bytes = base64.b64decode(document_data)

                            # Validate file size (10MB max)
                            max_file_size = 10 * 1024 * 1024
                            if len(document_bytes) > max_file_size:
                                return Response({'error': 'File is too large. Max size is 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

                            # Create a file name based on farmer ID, file type, and document index
                            document_name = f"fuel_{farmer_id}_{file_type.id}_{i}.{mime_type.split('/')[1]}"
                            document_file = ContentFile(document_bytes, name=document_name)

                            document_id = doc_data.get("document_id")  # Get the document ID from the request if present

                            if document_id:
                                # Try to update an existing document if the document_id exists
                                fuel_document = MyFuelDocuments.objects.filter(id=document_id, fuel=fuel_instance, file_type=file_type).first()
                                if fuel_document:
                                    # Update the document with the new file
                                    fuel_document.document = document_file
                                    fuel_document.save()
                                    sales_details.append({
                                        'id': fuel_document.id,
                                        'file_name': fuel_document.document.name,
                                        'file_type': fuel_document.file_type.name,
                                    })
                                else:
                                    # If the document doesn't exist, return an error
                                    return Response({'error': f"Document with ID {document_id} not found."}, status=status.HTTP_404_NOT_FOUND)
                            else:
                                # If no document_id exists, we create a new document
                                fuel_document = MyFuelDocuments(
                                    farmer=farmer,
                                    fuel=fuel_instance,
                                    file_type=file_type,
                                    document=document_file
                                )
                                fuel_document.save()

                                # Add the newly created document to the response
                                sales_details.append({
                                    'id': fuel_document.id,
                                    'file_name': fuel_document.document.name,
                                    # 'file_type': fuel_document.file_type.name,
                                    'file_type': fuel_document.file_type.get_translated_value("name", language_code) if fuel_document else "",
                                })
                        else:
                            return Response({'error': 'Invalid MIME type for the document.'}, status=status.HTTP_400_BAD_REQUEST)
                    else:
                        return Response({'error': 'Invalid file format. Only image/jpeg, image/png, and application/pdf are allowed.'}, status=status.HTTP_400_BAD_REQUEST)

                except Exception as e:
                    return Response({'error': f"Error processing document: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

    # Prepare document details for response
    documents_details = []
    for doc in sales_details:
        documents_details.append({
            "id": doc['id'],
            "document": request.build_absolute_uri(f'/SuperAdmin{doc["file_name"]}'),
            "file_type": doc['file_type'],
        })

    # Return the updated fuel instance and documents details with id and name for the relevant fields
    return Response(
        {
            "success": True,
            "message": "Fuel updated successfully!",
            "data": {
                "id": fuel_instance.id,
                "farmer": farmer.id,
                "farmer_name": farmer.name,
                "vendor": {
                    "id": fuel_instance.vendor.id if fuel_instance.vendor else "",
                    "name": fuel_instance.vendor.name if fuel_instance.vendor else ""
                },
                "inventory_item": {
                    "id": fuel_instance.inventory_items.id if fuel_instance.inventory_items else "",
                    "name": fuel_instance.inventory_items.name if fuel_instance.inventory_items else ""
                },
                "inventory_type": {
                    "id": fuel_instance.inventory_type.id if fuel_instance.inventory_type else "",
                    "name": fuel_instance.inventory_type.name if fuel_instance.inventory_type else ""
                },
                "inventory_category": {
                    "id": fuel_instance.inventory_category.id if fuel_instance.inventory_category else "",
                    "name": fuel_instance.inventory_category.name if fuel_instance.inventory_category else ""
                },
                "quantity": fuel_instance.quantity,
                "purchase_amount": fuel_instance.purchase_amount,
                "description": fuel_instance.description,
                "status": fuel_instance.status,
                "available_quantity": fuel_instance.available_quans,
                "documents": documents_details  # Including document details in the response
            },
            "language": {
                "default": "en"
            }
        },
        status=status.HTTP_200_OK
    )

@api_view(['PUT'])
def update_vehicle(request, farmer_id):
    # Retrieve the farmer
    farmer = get_object_or_404(Farmer, id=farmer_id, status=0)

    vehicle_id = request.data.get('vehicle_id')
    if not vehicle_id:
        return Response(
            {
                "success": False,
                "message": "vehicle_id is required in the request data.",
            },
            status=status.HTTP_400_BAD_REQUEST
        )

    # Get the vehicle instance or return 404 if not found
    vehicle_instance = get_object_or_404(MyVehicle, id=vehicle_id, farmer=farmer, status=0)

    # Handle fields passed as 'None' and replace them with empty strings
    for field in request.data:
        if request.data[field] is None:
            request.data[field] = ""

    # Assign updated fields from the request to the vehicle_instance
    vehicle_instance.date_of_registration = request.data.get("date_of_registration", vehicle_instance.date_of_registration)
    vehicle_instance.vendor = get_object_or_404(MyVendor, id=request.data.get("vendor", vehicle_instance.vendor.id), status=0)
    vehicle_instance.inventory_type = get_object_or_404(InventoryType, id=request.data.get("inventory_type", vehicle_instance.inventory_type.id), status=0)

    # Check if the inventory items are being updated
    new_inventory_item_id = request.data.get("inventory_items")
    if new_inventory_item_id:
        # Get the new inventory item
        new_inventory_item = get_object_or_404(InventoryItems, id=new_inventory_item_id, status=0)

        # Get the last created inventory item with the same inventory type and set previous inventory items to inactive
        last_inventory_item = MyVehicle.objects.filter(
            inventory_type=vehicle_instance.inventory_type,
            inventory_items__status=0
        ).latest('created_at')  # Assuming 'created_at' is the field indicating the creation time

        # Update the status of the previous inventory item to 1 (inactive)
        MyVehicle.objects.filter(
            inventory_type=vehicle_instance.inventory_type,
            inventory_items=last_inventory_item.inventory_items
        ).update(inventory_items=last_inventory_item.inventory_items, status=1)

        # Set the inventory_items to the new item
        vehicle_instance.inventory_items = new_inventory_item

    # Update the rest of the fields from the request data
    vehicle_instance.register_number = request.data.get("register_number", vehicle_instance.register_number)
    vehicle_instance.owner_name = request.data.get("owner_name", vehicle_instance.owner_name)
    vehicle_instance.registration_valid_till = request.data.get("registration_valid_till", vehicle_instance.registration_valid_till)
    vehicle_instance.engine_number = request.data.get("engine_number", vehicle_instance.engine_number)
    vehicle_instance.chasis_number = request.data.get("chasis_number", vehicle_instance.chasis_number)
    vehicle_instance.running_kilometer = request.data.get("running_kilometer", vehicle_instance.running_kilometer)
    vehicle_instance.service_frequency = request.data.get("service_frequency", vehicle_instance.service_frequency)
    vehicle_instance.service_frequency_unit = request.data.get("service_frequency_unit", vehicle_instance.service_frequency_unit)
    vehicle_instance.fuel_capacity = request.data.get("fuel_capacity", vehicle_instance.fuel_capacity)
    vehicle_instance.average_mileage = request.data.get("average_mileage", vehicle_instance.average_mileage)
    vehicle_instance.purchase_amount = request.data.get("purchase_amount", vehicle_instance.purchase_amount)
    vehicle_instance.insurance = request.data.get("insurance", vehicle_instance.insurance)
    vehicle_instance.company_name = request.data.get("company_name", vehicle_instance.company_name)
    vehicle_instance.insurance_no = request.data.get("insurance_no", vehicle_instance.insurance_no)
    vehicle_instance.insurance_amount = request.data.get("insurance_amount", vehicle_instance.insurance_amount)
    vehicle_instance.insurance_start_date = request.data.get("insurance_start_date", vehicle_instance.insurance_start_date)
    vehicle_instance.insurance_end_date = request.data.get("insurance_end_date", vehicle_instance.insurance_end_date)
    vehicle_instance.insurance_renewal_date = request.data.get("insurance_renewal_date", vehicle_instance.insurance_renewal_date)
    vehicle_instance.description = request.data.get("description", vehicle_instance.description)

    # Save the updated vehicle record
    vehicle_instance.save()

    # # Recalculate the available quantity for the inventory items and type
    # total_quantity = MyVehicle.objects.filter(
    #     inventory_type=vehicle_instance.inventory_type,
    #     inventory_items=vehicle_instance.inventory_items
    # ).aggregate(total_quantity=Sum('quantity'))['total_quantity'] or 0

    # vehicle_instance.available_quans = total_quantity
    vehicle_instance.save()

    # Handle file uploads (vehicle documents) only if provided
    file_data = request.data.get('documents', [])
    sales_details = []  # To hold the details of the documents being uploaded/updated

    if file_data:
        # Process each document data provided
        for doc_data in file_data:
            # Get the file type
            file_type_id = doc_data.get('file_type')

            if file_type_id is None:
                new_file_type = doc_data.get('new_file_type')
                if not new_file_type:
                    return Response({"error": "New file type for document is required."}, status=status.HTTP_400_BAD_REQUEST)

                # Get or create the document category
                file_type, created = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=2)
            else:
                file_type = get_object_or_404(DocumentCategory, id=file_type_id)

            documents = doc_data.get('documents', [])
            if not documents:
                return Response({"success": False, "message": f"No documents provided for file type {file_type_id}."}, status=status.HTTP_400_BAD_REQUEST)

            # Process each document provided
            for i, document_base64 in enumerate(documents):
                try:
                    if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
                        mime_type = validate_image_type(document_base64)  # Validate MIME type
                        if mime_type:
                            # Decode the base64-encoded document
                            document_data = document_base64.split(';base64,')[1]
                            document_bytes = base64.b64decode(document_data)

                            # Validate file size (10MB max)
                            max_file_size = 10 * 1024 * 1024
                            if len(document_bytes) > max_file_size:
                                return Response({'error': 'File is too large. Max size is 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

                            # Create a file name based on farmer ID, file type, and document index
                            document_name = f"vehicle_{farmer_id}_{file_type.id}_{i}.{mime_type.split('/')[1]}"
                            document_file = ContentFile(document_bytes, name=document_name)

                            document_id = doc_data.get("document_id")  # Get the document ID from the request if present

                            if document_id:
                                # Try to update an existing document if the document_id exists
                                vehicle_document = MyVehicleDocuments.objects.filter(id=document_id, vehicle=vehicle_instance, file_type=file_type).first()
                                if vehicle_document:
                                    # Update the document with the new file
                                    vehicle_document.document = document_file
                                    vehicle_document.save()
                                    sales_details.append({
                                        'id': vehicle_document.id,
                                        'file_name': vehicle_document.document.name,
                                        'file_type': vehicle_document.file_type.name,
                                    })
                                else:
                                    # If the document doesn't exist, return an error
                                    return Response({'error': f"Document with ID {document_id} not found."}, status=status.HTTP_404_NOT_FOUND)
                            else:
                                # If no document_id exists, we create a new document
                                vehicle_document = MyVehicleDocuments(
                                    farmer=farmer,
                                    vehicle=vehicle_instance,
                                    file_type=file_type,
                                    document=document_file
                                )
                                vehicle_document.save()

                                # Add the newly created document to the response
                                sales_details.append({
                                    'id': vehicle_document.id,
                                    'file_name': vehicle_document.document.name,
                                    'file_type': vehicle_document.file_type.name,
                                })
                        else:
                            return Response({'error': 'Invalid MIME type for the document.'}, status=status.HTTP_400_BAD_REQUEST)
                    else:
                        return Response({'error': 'Invalid file format. Only image/jpeg, image/png, and application/pdf are allowed.'}, status=status.HTTP_400_BAD_REQUEST)

                except Exception as e:
                    return Response({'error': f"Error processing document: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

    # Prepare document details for response
    documents_details = []
    for doc in sales_details:
        documents_details.append({
            "id": doc['id'],
            "document": request.build_absolute_uri(f'/SuperAdmin{doc["file_name"]}'),
            "file_type": doc['file_type'],
        })

    # Return the updated vehicle instance and documents details with id and name for the relevant fields
    return Response(
        {
            "success": True,
            "message": "Vehicle updated successfully!",
            "data": {
                "id": vehicle_instance.id,
                "farmer": farmer.id,
                "farmer_name": farmer.name,
                "vendor": {
                    "id": vehicle_instance.vendor.id if vehicle_instance.vendor else "",
                    "name": vehicle_instance.vendor.name if vehicle_instance.vendor else ""
                },
                "inventory_item": {
                    "id": vehicle_instance.inventory_items.id if vehicle_instance.inventory_items else "",
                    "name": vehicle_instance.inventory_items.name if vehicle_instance.inventory_items else ""
                },
                "inventory_type": {
                    "id": vehicle_instance.inventory_type.id if vehicle_instance.inventory_type else "",
                    "name": vehicle_instance.inventory_type.name if vehicle_instance.inventory_type else ""
                },
                "inventory_category": {
                    "id": vehicle_instance.inventory_category.id if vehicle_instance.inventory_category else "",
                    "name": vehicle_instance.inventory_category.name if vehicle_instance.inventory_category else ""
                },
                "register_number": vehicle_instance.register_number,
                "owner_name": vehicle_instance.owner_name,
                "date_of_registration": vehicle_instance.date_of_registration,
                "registration_valid_till": vehicle_instance.registration_valid_till,
                "engine_number": vehicle_instance.engine_number,
                "chasis_number": vehicle_instance.chasis_number,
                "running_kilometer": vehicle_instance.running_kilometer,
                "service_frequency": vehicle_instance.service_frequency,
                "service_frequency_unit": vehicle_instance.service_frequency_unit,
                "fuel_capacity": vehicle_instance.fuel_capacity,
                "average_mileage": vehicle_instance.average_mileage,
                "purchase_amount": vehicle_instance.purchase_amount,
                "insurance": vehicle_instance.insurance,
                "company_name": vehicle_instance.company_name,
                "insurance_no": vehicle_instance.insurance_no,
                "insurance_amount": vehicle_instance.insurance_amount,
                "insurance_start_date": vehicle_instance.insurance_start_date,
                "insurance_end_date": vehicle_instance.insurance_end_date,
                "insurance_renewal_date": vehicle_instance.insurance_renewal_date,
                "description": vehicle_instance.description,
                "status": vehicle_instance.status,
                "available_quantity": vehicle_instance.available_quans,
                "documents": documents_details
            },
            "language": {
                "default": "en"
            }
        },
        status=status.HTTP_200_OK
    )

@api_view(['PUT'])
def update_machinery(request, farmer_id):
    # Retrieve the Farmer object based on the farmer_id from the URL
    farmer = get_object_or_404(Farmer, id=farmer_id)

    # Get the machinery_id from the request data
    machinery_id = request.data.get('machinery_id')
    if not machinery_id:
        return Response(
            {
                "success": False,
                "message": "machinery_id is required in the request data.",
            },
            status=status.HTTP_400_BAD_REQUEST
        )

    # Retrieve the MyMachinery instance based on machinery_id and farmer_id
    machinery_instance = get_object_or_404(MyMachinery, id=machinery_id, farmer=farmer)

    # Handle fields passed as 'None' and replace them with empty strings
    for field in request.data:
        if request.data[field] is None:
            request.data[field] = ""

    # Assign updated fields from the request to the machinery_instance
    machinery_instance.machinery_type = request.data.get('machinery_type', machinery_instance.machinery_type)
    machinery_instance.fuel_capacity = request.data.get('fuel_capacity', machinery_instance.fuel_capacity)
    machinery_instance.purchase_amount = request.data.get('purchase_amount', machinery_instance.purchase_amount)
    machinery_instance.warranty_start_date = request.data.get('warranty_start_date', machinery_instance.warranty_start_date)
    machinery_instance.warranty_end_date = request.data.get('warranty_end_date', machinery_instance.warranty_end_date)
    machinery_instance.description = request.data.get('description', machinery_instance.description)
    machinery_instance.status = request.data.get('status', machinery_instance.status)
    machinery_instance.available_quans = request.data.get('available_quans', machinery_instance.available_quans)

    # Handle ForeignKey fields (vendor, inventory_type, etc.)
    vendor_id = request.data.get('vendor')
    if vendor_id:
        vendor_instance = get_object_or_404(MyVendor, id=vendor_id)
        machinery_instance.vendor = vendor_instance

    inventory_type_id = request.data.get('inventory_type')
    if inventory_type_id:
        inventory_type_instance = get_object_or_404(InventoryType, id=inventory_type_id)
        machinery_instance.inventory_type = inventory_type_instance

    inventory_items_id = request.data.get('inventory_items')
    if inventory_items_id:
        inventory_items_instance = get_object_or_404(InventoryItems, id=inventory_items_id)
        machinery_instance.inventory_items = inventory_items_instance

    inventory_category_id = request.data.get('inventory_category')
    if inventory_category_id:
        inventory_category_instance = get_object_or_404(InventoryCategory, id=inventory_category_id)
        machinery_instance.inventory_category = inventory_category_instance

    # Save the updated machinery record
    machinery_instance.save()

    # Handle file uploads (machinery documents)
    file_data = request.data.get('documents', [])
    sales_details = []

    # Process each document data provided
    if file_data:
        for doc_data in file_data:
            # Get the file type
            file_type_id = doc_data.get('file_type')

            if file_type_id is None:
                new_file_type = doc_data.get('new_file_type')
                if not new_file_type:
                    return Response({"error": "New file type for document is required."}, status=status.HTTP_400_BAD_REQUEST)

                # Get or create the document category
                file_type, created = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=2)
            else:
                file_type = get_object_or_404(DocumentCategory, id=file_type_id)

            documents = doc_data.get('documents', [])
            if not documents:
                return Response({"success": False, "message": f"No documents provided for file type {file_type_id}."}, status=status.HTTP_400_BAD_REQUEST)

            # Process each document provided
            for i, document_base64 in enumerate(documents):
                try:
                    if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
                        mime_type = validate_image_type(document_base64)  # Validate MIME type
                        if mime_type:
                            # Decode the base64-encoded document
                            document_data = document_base64.split(';base64,')[1]
                            document_bytes = base64.b64decode(document_data)

                            # Validate file size (10MB max)
                            max_file_size = 10 * 1024 * 1024
                            if len(document_bytes) > max_file_size:
                                return Response({'error': 'File is too large. Max size is 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

                            # Create a file name based on machinery ID, file type, and document index
                            document_name = f"machinery_{farmer_id}_{file_type.id}_{i}.{mime_type.split('/')[1]}"
                            document_file = ContentFile(document_bytes, name=document_name)

                            document_id = doc_data.get("document_id")  # Get the document ID from the request if present

                            if document_id:
                                # Try to update an existing document if the document_id exists
                                machinery_document = MyMachineryDocuments.objects.filter(id=document_id, machinary=machinery_instance, file_type=file_type).first()
                                if machinery_document:
                                    # Update the document with the new file
                                    machinery_document.document = document_file
                                    machinery_document.save()
                                    sales_details.append({
                                        'id': machinery_document.id,
                                        'file_name': machinery_document.document.name,
                                        'file_type': machinery_document.file_type.name,
                                    })
                                else:
                                    # If the document doesn't exist, return an error
                                    return Response({'error': f"Document with ID {document_id} not found."}, status=status.HTTP_404_NOT_FOUND)
                            else:
                                # If no document_id exists, we create a new document
                                machinery_document = MyMachineryDocuments(
                                    farmer=farmer,
                                    machinary=machinery_instance,
                                    file_type=file_type,
                                    document=document_file
                                )
                                machinery_document.save()

                                # Add the newly created document to the response
                                sales_details.append({
                                    'id': machinery_document.id,
                                    'file_name': machinery_document.document.name,
                                    'file_type': machinery_document.file_type.name,
                                })
                        else:
                            return Response({'error': 'Invalid MIME type for the document.'}, status=status.HTTP_400_BAD_REQUEST)
                    else:
                        return Response({'error': 'Invalid file format. Only image/jpeg, image/png, and application/pdf are allowed.'}, status=status.HTTP_400_BAD_REQUEST)

                except Exception as e:
                    return Response({'error': f"Error processing document: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

    # Prepare document details for response
    documents_details = []
    for doc in sales_details:
        documents_details.append({
            "id": doc['id'],
            "document": request.build_absolute_uri(f'/SuperAdmin{doc["file_name"]}'),
            "file_type": doc['file_type'],
        })

    # Return the updated machinery instance and documents details with id and name for the relevant fields
    return Response(
        {
            "success": True,
            "message": "Machinery updated successfully!",
            "data": {
                "id": machinery_instance.id,
                "farmer": farmer.id,
                "vendor": machinery_instance.vendor.id if machinery_instance.vendor else "",
                "inventory_item": machinery_instance.inventory_items.name if machinery_instance.inventory_items else "",
                "inventory_type": machinery_instance.inventory_type.name if machinery_instance.inventory_type else "",
                "inventory_category": machinery_instance.inventory_category.name if machinery_instance.inventory_category else "",
                "machinery_type": machinery_instance.machinery_type,
                "fuel_capacity": machinery_instance.fuel_capacity,
                "purchase_amount": machinery_instance.purchase_amount,
                "warranty_start_date": machinery_instance.warranty_start_date,
                "warranty_end_date": machinery_instance.warranty_end_date,
                "description": machinery_instance.description,
                "status": machinery_instance.status,
                "available_quantity": machinery_instance.available_quans,
                "documents": documents_details
            },
            "language": {
                "default": "en"
            }
        },
        status=status.HTTP_200_OK
    )

@api_view(['PUT'])
def update_tools(request, tool_id, farmer_id):
    # Retrieve the tool instance
    tool_instance = get_object_or_404(MyTools, id=tool_id, status=0)

    # Retrieve the farmer instance using the farmer_id passed in the URL
    farmer_instance = get_object_or_404(Farmer, id=farmer_id)

    # Update the tool's farmer field
    tool_instance.farmer = farmer_instance

    # Handle missing tool_id in the request
    if not tool_id:
        return Response(
            {
                "success": False,
                "message": "tool_id is required in the request data.",
            },
            status=status.HTTP_400_BAD_REQUEST
        )

    # Handle fields passed as 'None' and replace them with empty strings
    for field in request.data:
        if request.data[field] is None:
            request.data[field] = ""

    # Update the tool fields
    tool_instance.date_of_consumption = request.data.get("date_of_consumption", tool_instance.date_of_consumption)
    tool_instance.vendor = get_object_or_404(MyVendor, id=request.data.get("vendor", tool_instance.vendor.id), status=0)
    tool_instance.inventory_type = get_object_or_404(InventoryType, id=request.data.get("inventory_type", tool_instance.inventory_type.id), status=0)
    tool_instance.inventory_category = get_object_or_404(InventoryCategory, id=request.data.get("inventory_category", tool_instance.inventory_category.id), status=0)
    tool_instance.inventory_items = get_object_or_404(InventoryItems, id=request.data.get("inventory_items", tool_instance.inventory_items.id), status=0)

    tool_instance.quantity = request.data.get("quantity", tool_instance.quantity)
    tool_instance.purchase_amount = request.data.get("purchase_amount", tool_instance.purchase_amount)
    tool_instance.description = request.data.get("description", tool_instance.description)
    tool_instance.reusable = request.data.get("reusable", tool_instance.reusable)

    # Save the updated tool instance
    tool_instance.save()

    # Handle file uploads (tool documents) if provided
    file_data = request.data.get('documents', [])
    tool_documents_details = []  # List to hold document details

    if isinstance(file_data, list):  # Ensure 'documents' is a list
        for doc_data in file_data:
            # Get the file type
            file_type_id = doc_data.get('file_type')

            if file_type_id is None:
                new_file_type = doc_data.get('new_file_type')
                if not new_file_type:
                    return Response({"error": "New file type for document is required."}, status=status.HTTP_400_BAD_REQUEST)

                # Get or create the document category
                file_type, created = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=3)
            else:
                file_type = get_object_or_404(DocumentCategory, id=file_type_id)

            documents = doc_data.get('documents', [])
            if not documents:
                return Response({"success": False, "message": f"No documents provided for file type {file_type_id}."}, status=status.HTTP_400_BAD_REQUEST)

            # Process each document provided
            for i, document_base64 in enumerate(documents):
                try:
                    if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
                        mime_type = validate_image_type(document_base64)  # Validate MIME type
                        if mime_type:
                            # Decode the base64-encoded document
                            document_data = document_base64.split(';base64,')[1]
                            document_bytes = base64.b64decode(document_data)

                            # Validate file size (10MB max)
                            max_file_size = 10 * 1024 * 1024
                            if len(document_bytes) > max_file_size:
                                return Response({'error': 'File is too large. Max size is 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

                            # Create a file name based on tool ID, file type, and document index
                            document_name = f"tool_{tool_id}_{file_type.id}_{i}.{mime_type.split('/')[1]}"
                            document_file = ContentFile(document_bytes, name=document_name)

                            document_id = doc_data.get("document_id")  # Get the document ID from the request if present

                            if document_id:
                                # Try to update an existing document if the document_id exists
                                tool_document = MyToolsDocuments.objects.filter(id=document_id, tools=tool_instance, file_type=file_type).first()
                                if tool_document:
                                    # Update the document with the new file
                                    tool_document.document = document_file
                                    tool_document.save()
                                    tool_documents_details.append({
                                        'id': tool_document.id,
                                        'file_name': tool_document.document.name,
                                        'file_type': tool_document.file_type.name,
                                    })
                                else:
                                    # If the document doesn't exist, return an error
                                    return Response({'error': f"Document with ID {document_id} not found."}, status=status.HTTP_404_NOT_FOUND)
                            else:
                                # If no document_id exists, we create a new document
                                tool_document = MyToolsDocuments(
                                    farmer=tool_instance.farmer,
                                    tools=tool_instance,
                                    file_type=file_type,
                                    document=document_file
                                )
                                tool_document.save()

                                # Add the newly created document to the response
                                tool_documents_details.append({
                                    'id': tool_document.id,
                                    'file_name': tool_document.document.name,
                                    'file_type': tool_document.file_type.name,
                                })
                        else:
                            return Response({'error': 'Invalid MIME type for the document.'}, status=status.HTTP_400_BAD_REQUEST)
                    else:
                        return Response({'error': 'Invalid file format. Only image/jpeg, image/png, and application/pdf are allowed.'}, status=status.HTTP_400_BAD_REQUEST)

                except Exception as e:
                    return Response({'error': f"Error processing document: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

    else:
        return Response({'error': "'documents' field should be a list."}, status=status.HTTP_400_BAD_REQUEST)

    # Prepare document details for response
    documents_details = []
    for doc in tool_documents_details:
        documents_details.append({
            "id": doc['id'],
            "document": request.build_absolute_uri(f'/SuperAdmin{doc["file_name"]}'),
            "file_type": doc['file_type'],
        })

    # Return the updated tool instance and documents details
    return Response(
        {
            "success": True,
            "message": "Tool updated successfully!",
            "data": {
                "id": tool_instance.id,
                "tool_name": tool_instance.inventory_items.name if tool_instance.inventory_items else "",
                "tool_type": {
                    "id": tool_instance.inventory_type.id if tool_instance.inventory_type else "",
                    "name": tool_instance.inventory_type.name if tool_instance.inventory_type else ""
                },
                "quantity": tool_instance.quantity,
                "purchase_amount": tool_instance.purchase_amount,
                "description": tool_instance.description,
                "reusable": tool_instance.reusable,
                "status": tool_instance.status,
                "available_quantity": tool_instance.available_quans,
                "documents": documents_details  # Including document details in the response
            },
            "language": {
                "default": "en"
            }
        },
        status=status.HTTP_200_OK
    )

@api_view(['PUT'])
def update_pesticides(request, farmer_id, pesticide_id):
    # Retrieve the farmer
    farmer = get_object_or_404(Farmer, id=farmer_id, status=0)

    # Retrieve the pesticide instance
    pesticide_instance = get_object_or_404(MyPesticides, id=pesticide_id, farmer=farmer, status=0)

    # Handle missing pesticide_id in the request
    if not pesticide_id:
        return Response(
            {
                "success": False,
                "message": "pesticide_id is required in the request data.",
            },
            status=status.HTTP_400_BAD_REQUEST
        )

    # Handle fields passed as 'None' and replace them with empty strings
    for field in request.data:
        if request.data[field] is None:
            request.data[field] = ""

    # Assign updated fields from the request to the pesticide_instance
    pesticide_instance.date_of_consumption = request.data.get("date_of_consumption", pesticide_instance.date_of_consumption)
    pesticide_instance.vendor = get_object_or_404(MyVendor, id=request.data.get("vendor", pesticide_instance.vendor.id), status=0)
    pesticide_instance.inventory_type = get_object_or_404(InventoryType, id=request.data.get("inventory_type", pesticide_instance.inventory_type.id), status=0)
    pesticide_instance.inventory_category = get_object_or_404(InventoryCategory, id=request.data.get("inventory_category", pesticide_instance.inventory_category.id), status=0)
    pesticide_instance.inventory_items = get_object_or_404(InventoryItems, id=request.data.get("inventory_items", pesticide_instance.inventory_items.id), status=0)

    pesticide_instance.quantity = request.data.get("quantity", pesticide_instance.quantity)
    pesticide_instance.purchase_amount = request.data.get("purchase_amount", pesticide_instance.purchase_amount)
    pesticide_instance.description = request.data.get("description", pesticide_instance.description)

    # Save the updated pesticide instance
    pesticide_instance.save()

    # Handle file uploads (pesticide documents) only if provided
    file_data = request.data.get('documents', [])
    sales_details = []  # To hold the details of the documents being uploaded/updated

    if file_data:
        # Process each document data provided
        for doc_data in file_data:
            # Get the file type
            file_type_id = doc_data.get('file_type')

            if file_type_id is None:
                new_file_type = doc_data.get('new_file_type')
                if not new_file_type:
                    return Response({"error": "New file type for document is required."}, status=status.HTTP_400_BAD_REQUEST)

                # Get or create the document category
                file_type, created = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=2)
            else:
                file_type = get_object_or_404(DocumentCategory, id=file_type_id)

            documents = doc_data.get('documents', [])
            if not documents:
                return Response({"success": False, "message": f"No documents provided for file type {file_type_id}."}, status=status.HTTP_400_BAD_REQUEST)

            # Process each document provided
            for i, document_base64 in enumerate(documents):
                try:
                    if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
                        mime_type = validate_image_type(document_base64)  # Validate MIME type
                        if mime_type:
                            # Decode the base64-encoded document
                            document_data = document_base64.split(';base64,')[1]
                            document_bytes = base64.b64decode(document_data)

                            # Validate file size (10MB max)
                            max_file_size = 10 * 1024 * 1024
                            if len(document_bytes) > max_file_size:
                                return Response({'error': 'File is too large. Max size is 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

                            # Create a file name based on farmer ID, file type, and document index
                            document_name = f"pesticide_{farmer_id}_{file_type.id}_{i}.{mime_type.split('/')[1]}"
                            document_file = ContentFile(document_bytes, name=document_name)

                            document_id = doc_data.get("document_id")  # Get the document ID from the request if present

                            if document_id:
                                # Try to update an existing document if the document_id exists
                                pesticide_document = MyPesticidesDocuments.objects.filter(id=document_id, pest=pesticide_instance, file_type=file_type).first()
                                if pesticide_document:
                                    # Update the document with the new file
                                    pesticide_document.document = document_file
                                    pesticide_document.save()
                                    sales_details.append({
                                        'id': pesticide_document.id,
                                        'file_name': pesticide_document.document.name,
                                        'file_type': pesticide_document.file_type.name,
                                    })
                                else:
                                    # If the document doesn't exist, return an error
                                    return Response({'error': f"Document with ID {document_id} not found."}, status=status.HTTP_404_NOT_FOUND)
                            else:
                                # If no document_id exists, create a new document
                                pesticide_document = MyPesticidesDocuments(
                                    farmer=farmer,
                                    pest=pesticide_instance,  # Correct field name to 'pest'
                                    file_type=file_type,
                                    document=document_file
                                )
                                pesticide_document.save()

                                # Add the newly created document to the response
                                sales_details.append({
                                    'id': pesticide_document.id,
                                    'file_name': pesticide_document.document.name,
                                    'file_type': pesticide_document.file_type.name,
                                })
                        else:
                            return Response({'error': 'Invalid MIME type for the document.'}, status=status.HTTP_400_BAD_REQUEST)
                    else:
                        return Response({'error': 'Invalid file format. Only image/jpeg, image/png, and application/pdf are allowed.'}, status=status.HTTP_400_BAD_REQUEST)

                except Exception as e:
                    return Response({'error': f"Error processing document: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

    # Prepare document details for response
    documents_details = []
    for doc in sales_details:
        documents_details.append({
            "id": doc['id'],
            "document": request.build_absolute_uri(f'/SuperAdmin{doc["file_name"]}'),
            "file_type": doc['file_type'],
        })

    # Return the updated pesticide instance and documents details with id and name for the relevant fields
    return Response(
        {
            "success": True,
            "message": "Pesticide updated successfully!",
            "data": {
                "id": pesticide_instance.id,
                "farmer": farmer.id,
                "farmer_name": farmer.name,
                "vendor": {
                    "id": pesticide_instance.vendor.id if pesticide_instance.vendor else "",
                    "name": pesticide_instance.vendor.name if pesticide_instance.vendor else ""
                },
                "inventory_item": {
                    "id": pesticide_instance.inventory_items.id if pesticide_instance.inventory_items else "",
                    "name": pesticide_instance.inventory_items.name if pesticide_instance.inventory_items else ""
                },
                "inventory_type": {
                    "id": pesticide_instance.inventory_type.id if pesticide_instance.inventory_type else "",
                    "name": pesticide_instance.inventory_type.name if pesticide_instance.inventory_type else ""
                },
                "inventory_category": {
                    "id": pesticide_instance.inventory_category.id if pesticide_instance.inventory_category else "",
                    "name": pesticide_instance.inventory_category.name if pesticide_instance.inventory_category else ""
                },
                "quantity": pesticide_instance.quantity,
                "purchase_amount": pesticide_instance.purchase_amount,
                "description": pesticide_instance.description,
                "status": pesticide_instance.status,
                "available_quantity": pesticide_instance.available_quans,
                "documents": documents_details  # Including document details in the response
            },
            "language": {
                "default": "en"
            }
        },
        status=status.HTTP_200_OK
    )

@api_view(['PUT'])
def update_fertilizers(request, farmer_id, fertilizer_id):
    # Retrieve the farmer
    farmer = get_object_or_404(Farmer, id=farmer_id, status=0)

    # Retrieve the fertilizer instance
    fertilizer_instance = get_object_or_404(MyFertilizers, id=fertilizer_id, farmer=farmer, status=0)

    # Handle missing fertilizer_id in the request
    if not fertilizer_id:
        return Response(
            {
                "success": False,
                "message": "fertilizer_id is required in the request data.",
            },
            status=status.HTTP_400_BAD_REQUEST
        )

    # Handle fields passed as 'None' and replace them with empty strings
    for field in request.data:
        if request.data[field] is None:
            request.data[field] = ""

    # Assign updated fields from the request to the fertilizer_instance
    fertilizer_instance.date_of_consumption = request.data.get("date_of_consumption", fertilizer_instance.date_of_consumption)
    fertilizer_instance.vendor = get_object_or_404(MyVendor, id=request.data.get("vendor", fertilizer_instance.vendor.id), status=0)
    fertilizer_instance.inventory_type = get_object_or_404(InventoryType, id=request.data.get("inventory_type", fertilizer_instance.inventory_type.id), status=0)
    fertilizer_instance.inventory_category = get_object_or_404(InventoryCategory, id=request.data.get("inventory_category", fertilizer_instance.inventory_category.id), status=0)
    fertilizer_instance.inventory_items = get_object_or_404(InventoryItems, id=request.data.get("inventory_items", fertilizer_instance.inventory_items.id), status=0)

    fertilizer_instance.quantity = request.data.get("quantity", fertilizer_instance.quantity)
    fertilizer_instance.purchase_amount = request.data.get("purchase_amount", fertilizer_instance.purchase_amount)
    fertilizer_instance.description = request.data.get("description", fertilizer_instance.description)

    # Save the updated fertilizer instance
    fertilizer_instance.save()

    # Handle file uploads (fertilizer documents) only if provided
    file_data = request.data.get('documents', [])
    sales_details = []  # To hold the details of the documents being uploaded/updated

    if file_data:
        # Process each document data provided
        for doc_data in file_data:
            # Get the file type
            file_type_id = doc_data.get('file_type')

            if file_type_id is None:
                new_file_type = doc_data.get('new_file_type')
                if not new_file_type:
                    return Response({"error": "New file type for document is required."}, status=status.HTTP_400_BAD_REQUEST)

                # Get or create the document category
                file_type, created = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=2)
            else:
                file_type = get_object_or_404(DocumentCategory, id=file_type_id)

            documents = doc_data.get('documents', [])
            if not documents:
                return Response({"success": False, "message": f"No documents provided for file type {file_type_id}."}, status=status.HTTP_400_BAD_REQUEST)

            # Process each document provided
            for i, document_base64 in enumerate(documents):
                try:
                    if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
                        mime_type = validate_image_type(document_base64)  # Validate MIME type
                        if mime_type:
                            # Decode the base64-encoded document
                            document_data = document_base64.split(';base64,')[1]
                            document_bytes = base64.b64decode(document_data)

                            # Validate file size (10MB max)
                            max_file_size = 10 * 1024 * 1024
                            if len(document_bytes) > max_file_size:
                                return Response({'error': 'File is too large. Max size is 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

                            # Create a file name based on farmer ID, file type, and document index
                            document_name = f"fertilizer_{farmer_id}_{file_type.id}_{i}.{mime_type.split('/')[1]}"
                            document_file = ContentFile(document_bytes, name=document_name)

                            document_id = doc_data.get("document_id")  # Get the document ID from the request if present

                            if document_id:
                                # Try to update an existing document if the document_id exists
                                fertilizer_document = MyFertilizersDocuments.objects.filter(id=document_id, fertilizers=fertilizer_instance, file_type=file_type).first()
                                if fertilizer_document:
                                    # Update the document with the new file
                                    fertilizer_document.document = document_file
                                    fertilizer_document.save()
                                    sales_details.append({
                                        'id': fertilizer_document.id,
                                        'file_name': fertilizer_document.document.name,
                                        'file_type': fertilizer_document.file_type.name,
                                    })
                                else:
                                    # If the document doesn't exist, return an error
                                    return Response({'error': f"Document with ID {document_id} not found."}, status=status.HTTP_404_NOT_FOUND)
                            else:
                                # If no document_id exists, create a new document
                                fertilizer_document = MyFertilizersDocuments(
                                    farmer=farmer,
                                    fertilizers=fertilizer_instance,  # Correct field name to 'fertilizer'
                                    file_type=file_type,
                                    document=document_file
                                )
                                fertilizer_document.save()

                                # Add the newly created document to the response
                                sales_details.append({
                                    'id': fertilizer_document.id,
                                    'file_name': fertilizer_document.document.name,
                                    'file_type': fertilizer_document.file_type.name,
                                })
                        else:
                            return Response({'error': 'Invalid MIME type for the document.'}, status=status.HTTP_400_BAD_REQUEST)
                    else:
                        return Response({'error': 'Invalid file format. Only image/jpeg, image/png, and application/pdf are allowed.'}, status=status.HTTP_400_BAD_REQUEST)

                except Exception as e:
                    return Response({'error': f"Error processing document: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

    # Prepare document details for response
    documents_details = []
    for doc in sales_details:
        documents_details.append({
            "id": doc['id'],
            "document": request.build_absolute_uri(f'/SuperAdmin{doc["file_name"]}'),
            "file_type": doc['file_type'],
        })

    # Return the updated fertilizer instance and documents details with id and name for the relevant fields
    return Response(
        {
            "success": True,
            "message": "Fertilizer updated successfully!",
            "data": {
                "id": fertilizer_instance.id,
                "farmer": farmer.id,
                "farmer_name": farmer.name,
                "vendor": {
                    "id": fertilizer_instance.vendor.id if fertilizer_instance.vendor else "",
                    "name": fertilizer_instance.vendor.name if fertilizer_instance.vendor else ""
                },
                "inventory_item": {
                    "id": fertilizer_instance.inventory_items.id if fertilizer_instance.inventory_items else "",
                    "name": fertilizer_instance.inventory_items.name if fertilizer_instance.inventory_items else ""
                },
                "inventory_type": {
                    "id": fertilizer_instance.inventory_type.id if fertilizer_instance.inventory_type else "",
                    "name": fertilizer_instance.inventory_type.name if fertilizer_instance.inventory_type else ""
                },
                "inventory_category": {
                    "id": fertilizer_instance.inventory_category.id if fertilizer_instance.inventory_category else "",
                    "name": fertilizer_instance.inventory_category.name if fertilizer_instance.inventory_category else ""
                },
                "quantity": fertilizer_instance.quantity,
                "purchase_amount": fertilizer_instance.purchase_amount,
                "description": fertilizer_instance.description,
                "status": fertilizer_instance.status,
                "available_quantity": fertilizer_instance.available_quans,
                "documents": documents_details  # Including document details in the response
            },
            "language": {
                "default": "en"
            }
        },
        status=status.HTTP_200_OK
    )

@api_view(['PUT'])
def update_seeds(request, farmer_id, seed_id):
    # Retrieve the farmer
    farmer = get_object_or_404(Farmer, id=farmer_id, status=0)

    # Retrieve the seed instance
    seed_instance = get_object_or_404(MySeeds, id=seed_id, farmer=farmer, status=0)

    # Handle missing seed_id in the request
    if not seed_id:
        return Response(
            {
                "success": False,
                "message": "seed_id is required in the request data.",
            },
            status=status.HTTP_400_BAD_REQUEST
        )

    # Handle fields passed as 'None' and replace them with empty strings
    for field in request.data:
        if request.data[field] is None:
            request.data[field] = ""

    # Assign updated fields from the request to the seed_instance
    seed_instance.date_of_consumption = request.data.get("date_of_consumption", seed_instance.date_of_consumption)
    seed_instance.vendor = get_object_or_404(MyVendor, id=request.data.get("vendor", seed_instance.vendor.id), status=0)
    seed_instance.inventory_type = get_object_or_404(InventoryType, id=request.data.get("inventory_type", seed_instance.inventory_type.id), status=0)
    seed_instance.inventory_category = get_object_or_404(InventoryCategory, id=request.data.get("inventory_category", seed_instance.inventory_category.id), status=0)
    seed_instance.inventory_items = get_object_or_404(InventoryItems, id=request.data.get("inventory_items", seed_instance.inventory_items.id), status=0)

    seed_instance.quantity = request.data.get("quantity", seed_instance.quantity)
    seed_instance.purchase_amount = request.data.get("purchase_amount", seed_instance.purchase_amount)
    seed_instance.description = request.data.get("description", seed_instance.description)

    # Save the updated seed instance
    seed_instance.save()

    # Handle file uploads (seed documents) only if provided
    file_data = request.data.get('documents', [])
    sales_details = []  # To hold the details of the documents being uploaded/updated

    if file_data:
        # Process each document data provided
        for doc_data in file_data:
            # Get the file type
            file_type_id = doc_data.get('file_type')

            if file_type_id is None:
                new_file_type = doc_data.get('new_file_type')
                if not new_file_type:
                    return Response({"error": "New file type for document is required."}, status=status.HTTP_400_BAD_REQUEST)

                # Get or create the document category
                file_type, created = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=2)
            else:
                file_type = get_object_or_404(DocumentCategory, id=file_type_id)

            documents = doc_data.get('documents', [])
            if not documents:
                return Response({"success": False, "message": f"No documents provided for file type {file_type_id}."}, status=status.HTTP_400_BAD_REQUEST)

            # Process each document provided
            for i, document_base64 in enumerate(documents):
                try:
                    if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
                        mime_type = validate_image_type(document_base64)  # Validate MIME type
                        if mime_type:
                            # Decode the base64-encoded document
                            document_data = document_base64.split(';base64,')[1]
                            document_bytes = base64.b64decode(document_data)

                            # Validate file size (10MB max)
                            max_file_size = 10 * 1024 * 1024
                            if len(document_bytes) > max_file_size:
                                return Response({'error': 'File is too large. Max size is 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

                            # Create a file name based on farmer ID, file type, and document index
                            document_name = f"seed_{farmer_id}_{file_type.id}_{i}.{mime_type.split('/')[1]}"
                            document_file = ContentFile(document_bytes, name=document_name)

                            document_id = doc_data.get("document_id")  # Get the document ID from the request if present

                            if document_id:
                                # Try to update an existing document if the document_id exists
                                seed_document = MyseedsDocuments.objects.filter(id=document_id, seed=seed_instance, file_type=file_type).first()
                                if seed_document:
                                    # Update the document with the new file
                                    seed_document.document = document_file
                                    seed_document.save()
                                    sales_details.append({
                                        'id': seed_document.id,
                                        'file_name': seed_document.document.name,
                                        'file_type': seed_document.file_type.name,
                                    })
                                else:
                                    # If the document doesn't exist, return an error
                                    return Response({'error': f"Document with ID {document_id} not found."}, status=status.HTTP_404_NOT_FOUND)
                            else:
                                # If no document_id exists, create a new document
                                seed_document = MyseedsDocuments(
                                    farmer=farmer,
                                    seeds=seed_instance,  # Correct field name to 'seed'
                                    file_type=file_type,
                                    document=document_file
                                )
                                seed_document.save()

                                # Add the newly created document to the response
                                sales_details.append({
                                    'id': seed_document.id,
                                    'file_name': seed_document.document.name,
                                    'file_type': seed_document.file_type.name,
                                })
                        else:
                            return Response({'error': 'Invalid MIME type for the document.'}, status=status.HTTP_400_BAD_REQUEST)
                    else:
                        return Response({'error': 'Invalid file format. Only image/jpeg, image/png, and application/pdf are allowed.'}, status=status.HTTP_400_BAD_REQUEST)

                except Exception as e:
                    return Response({'error': f"Error processing document: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

    # Prepare document details for response
    documents_details = []
    for doc in sales_details:
        documents_details.append({
            "id": doc['id'],
            "document": request.build_absolute_uri(f'/SuperAdmin{doc["file_name"]}'),
            "file_type": doc['file_type'],
        })

    # Return the updated seed instance and documents details with id and name for the relevant fields
    return Response(
        {
            "success": True,
            "message": "Seed updated successfully!",
            "data": {
                "id": seed_instance.id,
                "farmer": farmer.id,
                "farmer_name": farmer.name,
                "vendor": {
                    "id": seed_instance.vendor.id if seed_instance.vendor else "",
                    "name": seed_instance.vendor.name if seed_instance.vendor else ""
                },
                "inventory_item": {
                    "id": seed_instance.inventory_items.id if seed_instance.inventory_items else "",
                    "name": seed_instance.inventory_items.name if seed_instance.inventory_items else ""
                },
                "inventory_type": {
                    "id": seed_instance.inventory_type.id if seed_instance.inventory_type else "",
                    "name": seed_instance.inventory_type.name if seed_instance.inventory_type else ""
                },
                "inventory_category": {
                    "id": seed_instance.inventory_category.id if seed_instance.inventory_category else "",
                    "name": seed_instance.inventory_category.name if seed_instance.inventory_category else ""
                },
                "quantity": seed_instance.quantity,
                "purchase_amount": seed_instance.purchase_amount,
                "description": seed_instance.description,
                "status": seed_instance.status,
                "available_quantity": seed_instance.available_quans,
                "documents": documents_details  # Including document details in the response
            },
            "language": {
                "default": "en"
            }
        },
        status=status.HTTP_200_OK
    )

#expense dashboard(expenselist)
@api_view(['POST'])
def list_farmer_expenses(request, farmer_id): 

    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'

    time_period = request.data.get('time_period', None)

    if not time_period:
        return Response({"detail": "Time period is required."}, status=status.HTTP_400_BAD_REQUEST)
 
    if time_period not in ['week', '30days', 'year']:
        return Response({"detail": "Invalid time period. Use 'week', '30days', or 'year'."}, status=status.HTTP_400_BAD_REQUEST)

    farmer = get_object_or_404(Farmer, id=farmer_id)
 
    current_date = timezone.now()
 
    if time_period == 'week':
        date_from = current_date - timedelta(weeks=1)
    elif time_period == '30days':
        date_from = current_date - timedelta(days=30)
    elif time_period == 'year':
        date_from = current_date - timedelta(days=365)
 
    expenses = MyExpense.objects.filter(farmer=farmer, status=0, created_day__gte=date_from)

    expenses_data = []

    # Retrieve date format from settings or use a default format
    try:
        settings = GeneralSetting.objects.first()
        date_format = convert_to_strftime_format(settings.date_format) if settings else '%d-%m-%Y'  # Fallback to default format
    except Exception as e:
        date_format = '%d-%m-%Y'  # Fallback to default format in case of any error with GeneralSetting

    for expense in expenses:
        # Format the created_day using the retrieved or default date format
        formatted_created_day = expense.created_day.strftime(date_format) if expense.created_day else ""

        expense_data = {
            "id": expense.id,
            "farmer": {
                "id": expense.farmer.id if expense.farmer else "",
                # "name": expense.farmer.name if expense.farmer else ""   
                "name": expense.farmer.get_translated_value("name", language_code) if expense.farmer else "" 
                
            },
            "my_crop": {
                "id": expense.my_crop.id if expense.my_crop else "",
                # "name": expense.my_crop.crop.name if expense.my_crop else ""  
                "name": expense.my_crop.crop.get_translated_value("name", language_code) if expense.my_crop else "" 
            },
            "type_expenses": {
                "id": expense.type_expenses.id if expense.type_expenses else "",
                # "name": expense.type_expenses.name if expense.type_expenses else ""  
                "name": expense.type_expenses.get_translated_value("name", language_code) if expense.type_expenses else ""  
            },
            "amount": expense.amount,
            # "description": expense.description,
            "description": expense.get_translated_value("description", language_code) if expense.description else "",
            "created_day": formatted_created_day,  # Use the formatted created_day
            "language": {
                "default": "en"
            }
        }
         
        expenses_data.append(expense_data)

    return Response(
        {"success": True, "data": expenses_data},
        status=status.HTTP_200_OK
    )
  
@api_view(['POST'])
def list_farmer_purchase(request, farmer_id):

    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'

    try:
        time_period = request.data.get('time_period', None)

        if not time_period:
            return Response({"detail": "Time period is required."}, status=status.HTTP_400_BAD_REQUEST)

        # Validate time_period and calculate date_from
        current_date = timezone.now()

        if time_period == 'week':
            date_from = current_date - timedelta(weeks=1)
        elif time_period == '30days':
            date_from = current_date - timedelta(days=30)
        elif time_period == 'year':
            date_from = current_date - timedelta(days=365)
        else:
            return Response({"detail": "Invalid time period."}, status=status.HTTP_400_BAD_REQUEST)

        # Retrieve date format from settings or use a default format
        try:
            settings = GeneralSetting.objects.first()
            date_format = convert_to_strftime_format(settings.date_format) if settings else '%d-%m-%Y'  # Fallback to default format
        except Exception as e:
            date_format = '%d-%m-%Y'  # Fallback to default format in case of any error with GeneralSetting

        # Fetch records based on the farmer_id and date range
        myfuel_records = MyFuel.objects.filter(farmer_id=farmer_id, status=0, date_of_consumption__gte=date_from)
        myvehicle_records = MyVehicle.objects.filter(farmer_id=farmer_id, status=0, date_of_consumption__gte=date_from)
        mymachinery_records = MyMachinery.objects.filter(farmer_id=farmer_id, status=0, date_of_consumption__gte=date_from)
        mytools_records = MyTools.objects.filter(farmer_id=farmer_id, status=0, date_of_consumption__gte=date_from)
        mypesticides_records = MyPesticides.objects.filter(farmer_id=farmer_id, status=0, date_of_consumption__gte=date_from)
        myfertilizers_records = MyFertilizers.objects.filter(farmer_id=farmer_id, status=0, date_of_consumption__gte=date_from)
        myseeds_records = MySeeds.objects.filter(farmer_id=farmer_id, status=0, date_of_consumption__gte=date_from)

        if not (myfuel_records or myvehicle_records or mymachinery_records or mytools_records or mypesticides_records or myfertilizers_records or myseeds_records):
            return Response({"detail": "No records found for this farmer within the specified time period."}, status=status.HTTP_404_NOT_FOUND)

        result = []

        # Function to format the date_of_consumption
        def format_date(date):
            return date.strftime(date_format) if date else ""

        # Append MyFuel records
        for record in myfuel_records:
            result.append({
                "id": record.id,
                "farmer": {"id": record.farmer.id if record.farmer else "", "name": record.farmer.get_translated_value("name", language_code) if record.farmer else ""},
                # "farmer": {"id": record.farmer.id if record.farmer else "", "name": record.farmer.name if record.farmer else ""},
                "date_of_consumption": format_date(record.date_of_consumption),  # Format date_of_consumption
                "vendor": {"id": record.vendor.id if record.vendor else "", "name": record.vendor.get_translated_value("name", language_code) if record.vendor else ""},
                "inventory_type": {"id": record.inventory_type.id if record.inventory_type else "", "name": record.inventory_type.get_translated_value("name", language_code) if record.inventory_type else ""},
                "inventory_category": {"id": record.inventory_category.id if record.inventory_category else "", "name": record.inventory_category.get_translated_value("name", language_code) if record.inventory_category else ""},
                "inventory_items": {"id": record.inventory_items.id if record.inventory_items else "", "name": record.inventory_items.get_translated_value("name", language_code) if record.inventory_items else ""},
                # "vendor": {"id": record.vendor.id if record.vendor else "", "name": record.vendor.name if record.vendor else ""},
                # "inventory_type": {"id": record.inventory_type.id if record.inventory_type else "", "name": record.inventory_type.name if record.inventory_type else ""},
                # "inventory_category": {"id": record.inventory_category.id if record.inventory_category else "", "name": record.inventory_category.name if record.inventory_category else ""},
                # "inventory_items": {"id": record.inventory_items.id if record.inventory_items else "", "name": record.inventory_items.name if record.inventory_items else ""},
                "quantity": str(record.quantity) if record.quantity else "",
                "purchase_amount": str(record.purchase_amount) if record.purchase_amount else "",
                "available_quans": record.available_quans,
                "language": {"default": "en"},
                # "type": "fuel"
                "type": { "en": "fuel","ta": "à®Žà®°à®¿à®ªà¯Šà®°à¯à®³à¯" }.get(language_code, "fuel")
            })

        # Append MyVehicle records
        for record in myvehicle_records:
            result.append({
                "id": record.id,
                "farmer": {"id": record.farmer.id if record.farmer else "", "name": record.farmer.get_translated_value("name", language_code) if record.farmer else ""},
                # "farmer": {"id": record.farmer.id if record.farmer else "", "name": record.farmer.name if record.farmer else ""},
                "date_of_consumption": format_date(record.date_of_consumption),  # Format date_of_consumption
                "vendor": {"id": record.vendor.id if record.vendor else "", "name": record.vendor.get_translated_value("name", language_code) if record.vendor else ""},
                "inventory_type": {"id": record.inventory_type.id if record.inventory_type else "", "name": record.inventory_type.get_translated_value("name", language_code) if record.inventory_type else ""},
                "inventory_category": {"id": record.inventory_category.id if record.inventory_category else "", "name": record.inventory_category.get_translated_value("name", language_code) if record.inventory_category else ""},
                "inventory_items": {"id": record.inventory_items.id if record.inventory_items else "", "name": record.inventory_items.get_translated_value("name", language_code) if record.inventory_items else ""},
                # "vendor": {"id": record.vendor.id if record.vendor else "", "name": record.vendor.name if record.vendor else ""},
                # "inventory_type": {"id": record.inventory_type.id if record.inventory_type else "", "name": record.inventory_type.name if record.inventory_type else ""},
                # "inventory_category": {"id": record.inventory_category.id if record.inventory_category else "", "name": record.inventory_category.name if record.inventory_category else ""},
                # "inventory_items": {"id": record.inventory_items.id if record.inventory_items else "", "name": record.inventory_items.name if record.inventory_items else ""},
                "register_number": record.register_number,
                # "owner_name": record.owner_name,
                "owner_name": record.get_translated_value("owner_name", language_code) if record.owner_name else "",
                "date_of_registration": format_date(record.date_of_registration),
                "registration_valid_till": format_date(record.registration_valid_till),
                "engine_number": record.engine_number,
                "chasis_number": record.chasis_number,
                "running_kilometer": str(record.running_kilometer) if record.running_kilometer else "",
                "service_frequency": str(record.service_frequency) if record.service_frequency else "",
                "fuel_capacity": str(record.fuel_capacity) if record.fuel_capacity else "",
                "average_mileage": str(record.average_mileage) if record.average_mileage else "",
                "purchase_amount": str(record.purchase_amount) if record.purchase_amount else "",
                "insurance": record.insurance,
                # "company_name": record.company_name,
                "company_name": record.get_translated_value("company_name", language_code) if record.company_name else "",
                "insurance_no": record.insurance_no,
                "insurance_amount": str(record.insurance_amount) if record.insurance_amount else "",
                "insurance_start_date": format_date(record.insurance_start_date),
                "insurance_end_date": format_date(record.insurance_end_date),
                "insurance_renewal_date": format_date(record.insurance_renewal_date),
                "available_quans": record.available_quans,
                "type": "vehicle",
                "language": {"default": "en"},
            })

                # Append MyMachinery records
 
 
        for record in mymachinery_records:
            result.append({
                "id": record.id,
                "farmer": {"id": record.farmer.id if record.farmer else "", "name": record.farmer.get_translated_value("name", language_code) if record.farmer else ""},
                # "farmer": {"id": record.farmer.id if record.farmer else "", "name": record.farmer.name if record.farmer else ""},
                "date_of_consumption": format_date(record.date_of_consumption),
                "vendor": {"id": record.vendor.id if record.vendor else "", "name": record.vendor.get_translated_value("name", language_code) if record.vendor else ""},
                "inventory_type": {"id": record.inventory_type.id if record.inventory_type else "", "name": record.inventory_type.get_translated_value("name", language_code) if record.inventory_type else ""},
                "inventory_category": {"id": record.inventory_category.id if record.inventory_category else "", "name": record.inventory_category.get_translated_value("name", language_code) if record.inventory_category else ""},
                "inventory_items": {"id": record.inventory_items.id if record.inventory_items else "", "name": record.inventory_items.get_translated_value("name", language_code) if record.inventory_items else ""},
                # "vendor": {"id": record.vendor.id if record.vendor else "", "name": record.vendor.name if record.vendor else ""},
                # "inventory_type": {"id": record.inventory_type.id if record.inventory_type else "", "name": record.inventory_type.name if record.inventory_type else ""},
                # "inventory_category": {"id": record.inventory_category.id if record.inventory_category else "", "name": record.inventory_category.name if record.inventory_category else ""},
                # "inventory_items": {"id": record.inventory_items.id if record.inventory_items else "", "name": record.inventory_items.name if record.inventory_items else ""},
                "machinery_type": record.machinery_type,
                "fuel_capacity": str(record.fuel_capacity) if record.fuel_capacity else "",
                "purchase_amount": str(record.purchase_amount) if record.purchase_amount else "",
                "warranty_start_date": format_date(record.warranty_start_date),
                "warranty_end_date": format_date(record.warranty_end_date),
                "available_quans": record.available_quans,
                # "type": "machinery",
                "type": { "en": "machinery","ta": "à®‡à®¯à®¨à¯à®¤à®¿à®°à®™à¯à®•à®³à¯" }.get(language_code, "machinery"),
                "language": {"default": "en"},
            })

        # Append MyTools records
        for record in mytools_records:
            result.append({
                "id": record.id,
                "farmer": {"id": record.farmer.id if record.farmer else "", "name": record.farmer.get_translated_value("name", language_code) if record.farmer else ""},
                # "farmer": {"id": record.farmer.id if record.farmer else "", "name": record.farmer.name if record.farmer else ""},
                "date_of_consumption": format_date(record.date_of_consumption), 
                # "vendor": {"id": record.vendor.id if record.vendor else "", "name": record.vendor.name if record.vendor else ""},
                # "inventory_type": {"id": record.inventory_type.id if record.inventory_type else "", "name": record.inventory_type.name if record.inventory_type else ""},
                # "inventory_category": {"id": record.inventory_category.id if record.inventory_category else "", "name": record.inventory_category.name if record.inventory_category else ""},
                # "inventory_items": {"id": record.inventory_items.id if record.inventory_items else "", "name": record.inventory_items.name if record.inventory_items else ""},
                "vendor": {"id": record.vendor.id if record.vendor else "", "name": record.vendor.get_translated_value("name", language_code) if record.vendor else ""},
                "inventory_type": {"id": record.inventory_type.id if record.inventory_type else "", "name": record.inventory_type.get_translated_value("name", language_code) if record.inventory_type else ""},
                "inventory_category": {"id": record.inventory_category.id if record.inventory_category else "", "name": record.inventory_category.name if record.inventory_category else ""},
                "inventory_items": {"id": record.inventory_items.id if record.inventory_items else "","name": record.inventory_items.get_translated_value("name", language_code) if record.inventory_items else ""},
                "quantity": str(record.quantity) if record.quantity else "",
                "purchase_amount": str(record.purchase_amount) if record.purchase_amount else "",
                "available_quans": record.available_quans,
                # "type": "tools",
                "type": { "en": "tools","ta": "à®•à®°à¯à®µà®¿à®•à®³à¯" }.get(language_code, "tools"),
                "language": {"default": "en"},
            })

        # Append MyPesticides records
        for record in mypesticides_records:
            result.append({
                "id": record.id,
                "farmer": {"id": record.farmer.id if record.farmer else "", "name": record.farmer.get_translated_value("name", language_code) if record.farmer else ""},
                # "farmer": {"id": record.farmer.id if record.farmer else "", "name": record.farmer.name if record.farmer else ""},
                "date_of_consumption": format_date(record.date_of_consumption), 
                "vendor": {"id": record.vendor.id if record.vendor else "", "name": record.vendor.get_translated_value("name", language_code) if record.vendor else ""},
                "inventory_type": {"id": record.inventory_type.id if record.inventory_type else "", "name": record.inventory_type.get_translated_value("name", language_code) if record.inventory_type else ""},
                "inventory_category": {"id": record.inventory_category.id if record.inventory_category else "", "name": record.inventory_category.get_translated_value("name", language_code) if record.inventory_category else ""},
                "inventory_items": {"id": record.inventory_items.id if record.inventory_items else "", "name": record.inventory_items.get_translated_value("name", language_code) if record.inventory_items else ""},
                # "vendor": {"id": record.vendor.id if record.vendor else "", "name": record.vendor.name if record.vendor else ""},
                # "inventory_type": {"id": record.inventory_type.id if record.inventory_type else "", "name": record.inventory_type.name if record.inventory_type else ""},
                # "inventory_category": {"id": record.inventory_category.id if record.inventory_category else "", "name": record.inventory_category.name if record.inventory_category else ""},
                # "inventory_items": {"id": record.inventory_items.id if record.inventory_items else "", "name": record.inventory_items.name if record.inventory_items else ""},
                "quantity": str(record.quantity) if record.quantity else "",
                "quantity_unit": record.quantity_unit.id if record.quantity_unit else "",
                "purchase_amount": str(record.purchase_amount) if record.purchase_amount else "",
                "available_quans": record.available_quans,
                # "type": "pesticides",
                "type": { "en": "pesticides","ta": "à®ªà¯‚à®šà¯à®šà®¿à®•à¯à®•à¯Šà®²à¯à®²à®¿à®•à®³à¯" }.get(language_code, "pesticides"),
                "language": {"default": "en"},
            })

        # Append MyFertilizers records
        for record in myfertilizers_records:
            result.append({
                "id": record.id,
                "farmer": {"id": record.farmer.id if record.farmer else "", "name": record.farmer.get_translated_value("name", language_code) if record.farmer else ""},
                # "farmer": {"id": record.farmer.id if record.farmer else "", "name": record.farmer.name if record.farmer else ""},
                "date_of_consumption": format_date(record.date_of_consumption), 
                "vendor": {"id": record.vendor.id if record.vendor else "", "name": record.vendor.get_translated_value("name", language_code) if record.vendor else ""},
                "inventory_type": {"id": record.inventory_type.id if record.inventory_type else "", "name": record.inventory_type.get_translated_value("name", language_code) if record.inventory_type else ""},
                "inventory_category": {"id": record.inventory_category.id if record.inventory_category else "", "name": record.inventory_category.get_translated_value("name", language_code) if record.inventory_category else ""},
                "inventory_items": {"id": record.inventory_items.id if record.inventory_items else "", "name": record.inventory_items.get_translated_value("name", language_code) if record.inventory_items else ""},
                # "vendor": {"id": record.vendor.id if record.vendor else "", "name": record.vendor.name if record.vendor else ""},
                # "inventory_type": {"id": record.inventory_type.id if record.inventory_type else "", "name": record.inventory_type.name if record.inventory_type else ""},
                # "inventory_category": {"id": record.inventory_category.id if record.inventory_category else "", "name": record.inventory_category.name if record.inventory_category else ""},
                # "inventory_items": {"id": record.inventory_items.id if record.inventory_items else "", "name": record.inventory_items.name if record.inventory_items else ""},
                "quantity": str(record.quantity) if record.quantity else "",
                "quantity_unit": record.quantity_unit.id if record.quantity_unit else "",
                "purchase_amount": str(record.purchase_amount) if record.purchase_amount else "",
                "available_quans": record.available_quans,
                # "type": "fertilizers",
                "type": { "en": "fertilizers","ta": "à®‰à®°à®™à¯à®•à®³à¯" }.get(language_code, "fertilizers"),
                "language": {"default": "en"},
            })

        # Append MySeeds records
        for record in myseeds_records:
            result.append({
                "id": record.id,
                "farmer": {"id": record.farmer.id if record.farmer else "", "name": record.farmer.get_translated_value("name", language_code) if record.farmer else ""},
                # "farmer": {"id": record.farmer.id if record.farmer else "", "name": record.farmer.name if record.farmer else ""},
                "date_of_consumption": format_date(record.date_of_consumption), 
                "vendor": {"id": record.vendor.id if record.vendor else "", "name": record.vendor.get_translated_value("name", language_code) if record.vendor else ""},
                "inventory_type": {"id": record.inventory_type.id if record.inventory_type else "", "name": record.inventory_type.get_translated_value("name", language_code) if record.inventory_type else ""},
                "inventory_category": {"id": record.inventory_category.id if record.inventory_category else "", "name": record.inventory_category.get_translated_value("name", language_code) if record.inventory_category else ""},
                "inventory_items": {"id": record.inventory_items.id if record.inventory_items else "", "name": record.inventory_items.get_translated_value("name", language_code) if record.inventory_items else ""},
                # "vendor": {"id": record.vendor.id if record.vendor else "", "name": record.vendor.name if record.vendor else ""},
                # "inventory_type": {"id": record.inventory_type.id if record.inventory_type else "", "name": record.inventory_type.name if record.inventory_type else ""},
                # "inventory_category": {"id": record.inventory_category.id if record.inventory_category else "", "name": record.inventory_category.name if record.inventory_category else ""},
                # "inventory_items": {"id": record.inventory_items.id if record.inventory_items else "", "name": record.inventory_items.name if record.inventory_items else ""},
                "quantity": str(record.quantity) if record.quantity else "",
                "quantity_unit": record.quantity_unit.id if record.quantity_unit else "",
                "purchase_amount": str(record.purchase_amount) if record.purchase_amount else "",
                "available_quans": record.available_quans,
                # "type": "seeds",
                "type": { "en": "seeds","ta": "à®µà®¿à®¤à¯ˆà®•à®³à¯" }.get(language_code, "seeds"),
                "language": {"default": "en"},
            })

        return Response(result, status=status.HTTP_200_OK)

    except Exception as e:
        return Response({"detail": str(e)}, status=status.HTTP_400_BAD_REQUEST)

@api_view(['POST'])
def both_farmer_expense_purchase_list(request, farmer_id): 

    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en' 

    time_period = request.data.get('time_period', None)

    if not time_period:
        return Response({"detail": "Time period is required."}, status=status.HTTP_400_BAD_REQUEST)

    if time_period not in ['week', '30days', 'year']:
        return Response({"detail": "Invalid time period. Use 'week', '30days', or 'year'."}, status=status.HTTP_400_BAD_REQUEST)

    farmer = get_object_or_404(Farmer, id=farmer_id)

    current_date = timezone.now()

    # Calculate date_from based on the time_period
    if time_period == 'week':
        date_from = current_date - timedelta(weeks=1)
    elif time_period == '30days':
        date_from = current_date - timedelta(days=30)
    elif time_period == 'year':
        date_from = current_date - timedelta(days=365)

    try:
        settings = GeneralSetting.objects.first()
        date_format = convert_to_strftime_format(settings.date_format) if settings else '%d-%m-%Y'  # Fallback to default format
    except Exception as e:
        date_format = '%d-%m-%Y'

    def format_date(date):
        return date.strftime(date_format) if date else ""         

    # Get Expenses Data
    expenses = MyExpense.objects.filter(farmer=farmer, status=0, created_day__gte=date_from)

    expenses_data = []
    for expense in expenses:
        expense_data = {
            "id": expense.id,
            "farmer": {
                "id": expense.farmer.id if expense.farmer else "",
                # "name": expense.farmer.name if expense.farmer else ""   
                "name": expense.farmer.get_translated_value("name", language_code) if expense.farmer else "" 
            },
            "my_crop": {
                "id": expense.my_crop.id if expense.my_crop else "",
                # "name": expense.my_crop.crop.name if expense.my_crop else ""  
                "name": expense.my_crop.crop.get_translated_value("name", language_code) if expense.my_crop else ""  
            },
            "type_expenses": {
                "id": expense.type_expenses.id if expense.type_expenses else "",
                # "name": expense.type_expenses.name if expense.type_expenses else ""  
                "name": expense.type_expenses.get_translated_value("name", language_code) if expense.type_expenses else ""  
            },
            "amount": expense.amount,
            "description": expense.get_translated_value("description", language_code) if expense else "",
            # "description": expense.description,
            "created_day": format_date(expense.created_day),
            "language": {"default": "en"}
        }
        expenses_data.append(expense_data)

    # Get Purchases Data (Fuel, Vehicle, Machinery, Tools, Pesticides, Fertilizers, Seeds)
    purchase_data = []

    # Fuel
    myfuel_records = MyFuel.objects.filter(farmer_id=farmer_id, status=0, date_of_consumption__gte=date_from)
    for record in myfuel_records:
        purchase_data.append({
            "id": record.id,
            "farmer": {"id": record.farmer.id if record.farmer else "", "name": record.farmer.get_translated_value("name", language_code) if record.farmer else ""},
            # "farmer": {"id": record.farmer.id if record.farmer else "", "name": record.farmer.name if record.farmer else ""},
            "date_of_consumption": format_date(record.date_of_consumption),
            "vendor": {"id": record.vendor.id if record.vendor else "", "name": record.vendor.get_translated_value("name", language_code) if record.vendor else ""},
            "inventory_type": {"id": record.inventory_type.id if record.inventory_type else "",  "name": record.inventory_type.get_translated_value("name", language_code) if record.inventory_type else ""},
            "inventory_category": {"id": record.inventory_category.id if record.inventory_category else "", "name": record.inventory_category.get_translated_value("name", language_code) if record.inventory_category else ""},
            "inventory_items": {"id": record.inventory_items.id if record.inventory_items else "", "name": record.inventory_items.get_translated_value("name", language_code) if record.inventory_items else ""},
            # "vendor": {"id": record.vendor.id if record.vendor else "", "name": record.vendor.name if record.vendor else ""},
            # "inventory_type": {"id": record.inventory_type.id if record.inventory_type else "", "name": record.inventory_type.name if record.inventory_type else ""},
            # "inventory_category": {"id": record.inventory_category.id if record.inventory_category else "", "name": record.inventory_category.name if record.inventory_category else ""},
            # "inventory_items": {"id": record.inventory_items.id if record.inventory_items else "", "name": record.inventory_items.name if record.inventory_items else ""},
            "quantity": str(record.quantity) if record.quantity else "",
            "purchase_amount": str(record.purchase_amount) if record.purchase_amount else "",
            "available_quans": record.available_quans,
            # "type": "fuel",
            "type": { "en": "fuel","ta": "à®Žà®°à®¿à®ªà¯Šà®°à¯à®³à¯" }.get(language_code, "fuel"),
            "language": {"default": "en"}
        })

    # Vehicle
    myvehicle_records = MyVehicle.objects.filter(farmer_id=farmer_id, status=0, date_of_consumption__gte=date_from)
    for record in myvehicle_records:
        purchase_data.append({
            "id": record.id,
            "farmer": {"id": record.farmer.id if record.farmer else "", "name": record.farmer.get_translated_value("name", language_code) if record.farmer else ""},
            # "farmer": {"id": record.farmer.id if record.farmer else "", "name": record.farmer.name if record.farmer else ""},
            "date_of_consumption": format_date(record.date_of_consumption),
            "vendor": {"id": record.vendor.id if record.vendor else "", "name": record.vendor.get_translated_value("name", language_code) if record.vendor else ""},
            "inventory_type": {"id": record.inventory_type.id if record.inventory_type else "",  "name": record.inventory_type.get_translated_value("name", language_code) if record.inventory_type else ""},
            "inventory_category": {"id": record.inventory_category.id if record.inventory_category else "", "name": record.inventory_category.get_translated_value("name", language_code) if record.inventory_category else ""},
            "inventory_items": {"id": record.inventory_items.id if record.inventory_items else "", "name": record.inventory_items.get_translated_value("name", language_code) if record.inventory_items else ""},
            # "vendor": {"id": record.vendor.id if record.vendor else "", "name": record.vendor.name if record.vendor else ""},
            # "inventory_type": {"id": record.inventory_type.id if record.inventory_type else "", "name": record.inventory_type.name if record.inventory_type else ""},
            # "inventory_category": {"id": record.inventory_category.id if record.inventory_category else "", "name": record.inventory_category.name if record.inventory_category else ""},
            # "inventory_items": {"id": record.inventory_items.id if record.inventory_items else "", "name": record.inventory_items.name if record.inventory_items else ""},
            "register_number": record.register_number,
            # "owner_name": record.owner_name,
            "owner_name": record.get_translated_value("owner_name", language_code) if record.owner_name else "",
            "date_of_registration": format_date(record.date_of_registration),
            "registration_valid_till": format_date(record.registration_valid_till),
            "engine_number": record.engine_number,
            "chasis_number": record.chasis_number,
            "running_kilometer": str(record.running_kilometer) if record.running_kilometer else "",
            "service_frequency": str(record.service_frequency) if record.service_frequency else "",
            "fuel_capacity": str(record.fuel_capacity) if record.fuel_capacity else "",
            "average_mileage": str(record.average_mileage) if record.average_mileage else "",
            "purchase_amount": str(record.purchase_amount) if record.purchase_amount else "",
            "insurance": record.insurance,
            # "company_name": record.company_name,
            "company_name": record.get_translated_value("company_name", language_code) if record.company_name else "",
            "insurance_no": record.insurance_no,
            "insurance_amount": str(record.insurance_amount) if record.insurance_amount else "",
            "insurance_start_date": format_date(record.insurance_start_date),
            "insurance_end_date": format_date(record.insurance_end_date),
            "insurance_renewal_date": format_date(record.insurance_renewal_date),
            "available_quans": record.available_quans,
            # "type": "vehicle",
            "type": { "en": "vehicle","ta": "à®µà®¾à®•à®©à®®à¯" }.get(language_code, "vehicle"),
            "language": {"default": "en"}
        })

    # Machinery
    mymachinery_records = MyMachinery.objects.filter(farmer_id=farmer_id, status=0, date_of_consumption__gte=date_from)
    for record in mymachinery_records:
        purchase_data.append({
            "id": record.id,
             "farmer": {"id": record.farmer.id if record.farmer else "", "name": record.farmer.get_translated_value("name", language_code) if record.farmer else ""},
            # "farmer": {"id": record.farmer.id if record.farmer else "", "name": record.farmer.name if record.farmer else ""},
            "date_of_consumption": format_date(record.date_of_consumption),
            "vendor": {"id": record.vendor.id if record.vendor else "", "name": record.vendor.get_translated_value("name", language_code) if record.vendor else ""},
            "inventory_type": {"id": record.inventory_type.id if record.inventory_type else "",  "name": record.inventory_type.get_translated_value("name", language_code) if record.inventory_type else ""},
            "inventory_category": {"id": record.inventory_category.id if record.inventory_category else "", "name": record.inventory_category.get_translated_value("name", language_code) if record.inventory_category else ""},
            "inventory_items": {"id": record.inventory_items.id if record.inventory_items else "", "name": record.inventory_items.get_translated_value("name", language_code) if record.inventory_items else ""},
            # "vendor": {"id": record.vendor.id if record.vendor else "", "name": record.vendor.name if record.vendor else ""},
            # "inventory_type": {"id": record.inventory_type.id if record.inventory_type else "", "name": record.inventory_type.name if record.inventory_type else ""},
            # "inventory_category": {"id": record.inventory_category.id if record.inventory_category else "", "name": record.inventory_category.name if record.inventory_category else ""},
            # "inventory_items": {"id": record.inventory_items.id if record.inventory_items else "", "name": record.inventory_items.name if record.inventory_items else ""},
            "quantity": str(record.fuel_capacity) if record.fuel_capacity else "",
            "purchase_amount": str(record.purchase_amount) if record.purchase_amount else "",
            "available_quans": record.available_quans,
            # "type": "machinery",
            "type": { "en": "machinery","ta": "à®‡à®¯à®¨à¯à®¤à®¿à®°à®™à¯à®•à®³à¯" }.get(language_code, "machinery"),
            "language": {"default": "en"}
        })

    # Tools
    mytools_records = MyTools.objects.filter(farmer_id=farmer_id, status=0, date_of_consumption__gte=date_from)
    for record in mytools_records:
        purchase_data.append({
            "id": record.id,
            "farmer": {"id": record.farmer.id if record.farmer else "", "name": record.farmer.get_translated_value("name", language_code) if record.farmer else ""},
            # "farmer": {"id": record.farmer.id if record.farmer else "", "name": record.farmer.name if record.farmer else ""},
            "date_of_consumption": format_date(record.date_of_consumption),
            "vendor": {"id": record.vendor.id if record.vendor else "", "name": record.vendor.get_translated_value("name", language_code) if record.vendor else ""},
            "inventory_type": {"id": record.inventory_type.id if record.inventory_type else "",  "name": record.inventory_type.get_translated_value("name", language_code) if record.inventory_type else ""},
            "inventory_category": {"id": record.inventory_category.id if record.inventory_category else "", "name": record.inventory_category.get_translated_value("name", language_code) if record.inventory_category else ""},
            "inventory_items": {"id": record.inventory_items.id if record.inventory_items else "", "name": record.inventory_items.get_translated_value("name", language_code) if record.inventory_items else ""},
            # "vendor": {"id": record.vendor.id if record.vendor else "", "name": record.vendor.name if record.vendor else ""},
            # "inventory_type": {"id": record.inventory_type.id if record.inventory_type else "", "name": record.inventory_type.name if record.inventory_type else ""},
            # "inventory_category": {"id": record.inventory_category.id if record.inventory_category else "", "name": record.inventory_category.name if record.inventory_category else ""},
            # "inventory_items": {"id": record.inventory_items.id if record.inventory_items else "", "name": record.inventory_items.name if record.inventory_items else ""},
            "quantity": str(record.quantity) if record.quantity else "",
            "purchase_amount": str(record.purchase_amount) if record.purchase_amount else "",
            "available_quans": record.available_quans,
            "type": "tools",
            "type": { "en": "tools","ta": "à®•à®°à¯à®µà®¿à®•à®³à¯" }.get(language_code, "tools"),
            "language": {"default": "en"}
        })

    # Pesticides
    mypesticides_records = MyPesticides.objects.filter(farmer_id=farmer_id, status=0, date_of_consumption__gte=date_from)
    for record in mypesticides_records:
        purchase_data.append({
            "id": record.id,
            "farmer": {"id": record.farmer.id if record.farmer else "", "name": record.farmer.get_translated_value("name", language_code) if record.farmer else ""},
            # "farmer": {"id": record.farmer.id if record.farmer else "", "name": record.farmer.name if record.farmer else ""},
            "date_of_consumption": format_date(record.date_of_consumption),
            "vendor": {"id": record.vendor.id if record.vendor else "", "name": record.vendor.get_translated_value("name", language_code) if record.vendor else ""},
            "inventory_type": {"id": record.inventory_type.id if record.inventory_type else "",  "name": record.inventory_type.get_translated_value("name", language_code) if record.inventory_type else ""},
            "inventory_category": {"id": record.inventory_category.id if record.inventory_category else "", "name": record.inventory_category.get_translated_value("name", language_code) if record.inventory_category else ""},
            "inventory_items": {"id": record.inventory_items.id if record.inventory_items else "", "name": record.inventory_items.get_translated_value("name", language_code) if record.inventory_items else ""},
            # "vendor": {"id": record.vendor.id if record.vendor else "", "name": record.vendor.name if record.vendor else ""},
            # "inventory_type": {"id": record.inventory_type.id if record.inventory_type else "", "name": record.inventory_type.name if record.inventory_type else ""},
            # "inventory_category": {"id": record.inventory_category.id if record.inventory_category else "", "name": record.inventory_category.name if record.inventory_category else ""},
            # "inventory_items": {"id": record.inventory_items.id if record.inventory_items else "", "name": record.inventory_items.name if record.inventory_items else ""},
            "quantity": str(record.quantity) if record.quantity else "",
            "purchase_amount": str(record.purchase_amount) if record.purchase_amount else "",
            "available_quans": record.available_quans,
            # "type": "pesticides",
            "type": { "en": "pesticides","ta": "à®ªà¯‚à®šà¯à®šà®¿à®•à¯à®•à¯Šà®²à¯à®²à®¿à®•à®³à¯" }.get(language_code, "pesticides"),
            "language": {"default": "en"}
        })

    # Fertilizers
    myfertilizers_records = MyFertilizers.objects.filter(farmer_id=farmer_id, status=0, date_of_consumption__gte=date_from)
    for record in myfertilizers_records:
        purchase_data.append({
            "id": record.id,
            "farmer": {"id": record.farmer.id if record.farmer else "", "name": record.farmer.get_translated_value("name", language_code) if record.farmer else ""},
            # "farmer": {"id": record.farmer.id if record.farmer else "", "name": record.farmer.name if record.farmer else ""},
            "date_of_consumption": format_date(record.date_of_consumption),
            # "vendor": {"id": record.vendor.id if record.vendor else "", "name": record.vendor.name if record.vendor else ""},
            # "inventory_type": {"id": record.inventory_type.id if record.inventory_type else "", "name": record.inventory_type.name if record.inventory_type else ""},
            # "inventory_category": {"id": record.inventory_category.id if record.inventory_category else "", "name": record.inventory_category.name if record.inventory_category else ""},
            # "inventory_items": {"id": record.inventory_items.id if record.inventory_items else "", "name": record.inventory_items.name if record.inventory_items else ""},
            "vendor": {"id": record.vendor.id if record.vendor else "", "name": record.vendor.get_translated_value("name", language_code) if record.vendor else ""},
            "inventory_type": {"id": record.inventory_type.id if record.inventory_type else "",  "name": record.inventory_type.get_translated_value("name", language_code) if record.inventory_type else ""},
            "inventory_category": {"id": record.inventory_category.id if record.inventory_category else "", "name": record.inventory_category.get_translated_value("name", language_code) if record.inventory_category else ""},
            "inventory_items": {"id": record.inventory_items.id if record.inventory_items else "", "name": record.inventory_items.get_translated_value("name", language_code) if record.inventory_items else ""},
            "quantity": str(record.quantity) if record.quantity else "",
            "purchase_amount": str(record.purchase_amount) if record.purchase_amount else "",
            "available_quans": record.available_quans,
            # "type": "fertilizers",
            "type": { "en": "fertilizers","ta": "à®‰à®°à®™à¯à®•à®³à¯" }.get(language_code, "fertilizers"),
            "language": {"default": "en"}
        })

    # Seeds
    myseeds_records = MySeeds.objects.filter(farmer_id=farmer_id, status=0, date_of_consumption__gte=date_from)
    for record in myseeds_records:
        purchase_data.append({
            "id": record.id,
            "farmer": {"id": record.farmer.id if record.farmer else "", "name": record.farmer.get_translated_value("name", language_code) if record.farmer else ""},
            # "farmer": {"id": record.farmer.id if record.farmer else "", "name": record.farmer.name if record.farmer else ""},
            "date_of_consumption": format_date(record.date_of_consumption),
            # "vendor": {"id": record.vendor.id if record.vendor else "", "name": record.vendor.name if record.vendor else ""},
            # "inventory_type": {"id": record.inventory_type.id if record.inventory_type else "", "name": record.inventory_type.name if record.inventory_type else ""},
            # "inventory_category": {"id": record.inventory_category.id if record.inventory_category else "", "name": record.inventory_category.name if record.inventory_category else ""},
            # "inventory_items": {"id": record.inventory_items.id if record.inventory_items else "", "name": record.inventory_items.name if record.inventory_items else ""},
            "vendor": {"id": record.vendor.id if record.vendor else "", "name": record.vendor.get_translated_value("name", language_code) if record.vendor else ""},
            "inventory_type": {"id": record.inventory_type.id if record.inventory_type else "",  "name": record.inventory_type.get_translated_value("name", language_code) if record.inventory_type else ""},
            "inventory_category": {"id": record.inventory_category.id if record.inventory_category else "", "name": record.inventory_category.get_translated_value("name", language_code) if record.inventory_category else ""},
            "inventory_items": {"id": record.inventory_items.id if record.inventory_items else "", "name": record.inventory_items.get_translated_value("name", language_code) if record.inventory_items else ""},
            "quantity": str(record.quantity) if record.quantity else "",
            "purchase_amount": str(record.purchase_amount) if record.purchase_amount else "",
            "available_quans": record.available_quans,
            # "type": "seeds",
            "type": { "en": "seeds","ta": "à®µà®¿à®¤à¯ˆà®•à®³à¯" }.get(language_code, "seeds"),
            "language": {"default": "en"}
        })

    # Combine everything into the response
    return Response({
        "success": True,
        "expenses": expenses_data,
        "purchases": purchase_data
    }, status=status.HTTP_200_OK)
 
@api_view(['POST'])
def total_expense_and_purchase_amount(request, farmer_id): 
    time_period = request.data.get('time_period', None)

    if not time_period:
        return Response({"detail": "Time period is required."}, status=400)

    if time_period not in ['week', '30days', 'year']:
        return Response({"detail": "Invalid time period. Use 'week', '30days', or 'year'."}, status=400)

    # Get the farmer object
    farmer = get_object_or_404(Farmer, id=farmer_id)
    current_date = timezone.now()
 
    if time_period == 'week':
        date_from = current_date - timedelta(weeks=1)
    elif time_period == '30days':
        date_from = current_date - timedelta(days=30)
    elif time_period == 'year':
        date_from = current_date - timedelta(days=365)
 
    expenses = MyExpense.objects.filter(farmer=farmer, status=0, created_day__gte=date_from)
    total_expense = expenses.aggregate(total_amount=Sum('amount'))['total_amount'] or 0
 
    machinery = MyMachinery.objects.filter(farmer=farmer, status=0, date_of_consumption__gte=date_from)
    total_machinery = machinery.aggregate(total_amount=Sum('purchase_amount'))['total_amount'] or 0

    tools = MyTools.objects.filter(farmer=farmer, status=0, date_of_consumption__gte=date_from)
    total_tools = tools.aggregate(total_amount=Sum('purchase_amount'))['total_amount'] or 0

    fertilizers = MyFertilizers.objects.filter(farmer=farmer, status=0, date_of_consumption__gte=date_from)
    total_fertilizers = fertilizers.aggregate(total_amount=Sum('purchase_amount'))['total_amount'] or 0

    pesticides = MyPesticides.objects.filter(farmer=farmer, status=0, date_of_consumption__gte=date_from)
    total_pesticides = pesticides.aggregate(total_amount=Sum('purchase_amount'))['total_amount'] or 0

    seeds = MySeeds.objects.filter(farmer=farmer, status=0, date_of_consumption__gte=date_from)
    total_seeds = seeds.aggregate(total_amount=Sum('purchase_amount'))['total_amount'] or 0

    fuel = MyFuel.objects.filter(farmer=farmer, status=0, date_of_consumption__gte=date_from)
    total_fuel = fuel.aggregate(total_amount=Sum('purchase_amount'))['total_amount'] or 0

    vehicles = MyVehicle.objects.filter(farmer=farmer, status=0, date_of_consumption__gte=date_from)
    total_vehicles = vehicles.aggregate(total_amount=Sum('purchase_amount'))['total_amount'] or 0

    # Combine all totals into one response
    total_purchase = total_machinery + total_tools + total_fertilizers + total_pesticides + total_seeds + total_fuel + total_vehicles

    expenseamount = total_purchase + total_expense

    # Return a combined response with total expense and total purchase
    return Response(
        {
            "success": True, 
            "expenseamount": expenseamount,
            "language":
            {
                "default":"en"
            }
        },
        status=200
    )
 
@api_view(['GET'])
def get_farmer_land_details(request, farmer_id):
    # Fetch the farmer's lands
    lands = MyLand.objects.filter(farmer_id=farmer_id)

    land_data = []
    for land in lands:
        # Fetch the survey details for the land
        surveys = MyLandSurveyDetails.objects.filter(MyLand=land)
        survey_data = []
        for survey in surveys:
            survey_data.append({
                'survey_no': survey.survey_no,
                'survey_measurement_value': survey.survey_measurement_value,
                'survey_measurement_unit': survey.survey_measurement_unit.name if survey.survey_measurement_unit else None,
                'status': survey.status,
                'created_at': survey.created_at,
                'updated_at': survey.updated_at,
            })
        
        # Fetch the documents for the land
        documents = MyLandDocument.objects.filter(myland=land)
        document_data = []
        for document in documents:
            document_data.append({
                'document_category': document.document_category.name if document.document_category else None,
                'upload_document': document.upload_document.url if document.upload_document else None,
                'status': document.status,
                'created_at': document.created_at,
                'updated_at': document.updated_at,
            })
        
        # Prepare the land data with surveys and documents
        land_data.append({
            'land_name': land.name,
            'measurement_value': land.measurement_value,
            'measurement_unit': land.measurement_unit.name if land.measurement_unit else None,
            'soil_type': land.soil_type.name if land.soil_type else None,
            'country': land.country.name if land.country else None,
            'state': land.state.name if land.state else None,
            'city': land.city.name if land.city else None,
            'village': land.village.name if land.village else None,
            'door_no': land.door_no,
            'locations': land.locations,
            'latitude': land.latitude,
            'longitude': land.longitude,
            'patta_number': land.patta_number,
            'description': land.description,
            'status': land.status,
            'created_at': land.created_at,
            'updated_at': land.updated_at,
            'survey_details': survey_data,
            'documents': document_data,
            'language':{
                "default":"en"
            }
        })
    
    return JsonResponse({'farmer_id': farmer_id, 'land_details': land_data}, status=200)
  
@api_view(['POST', 'PUT', 'DELETE'])
def manage_consumption(request, id):
    # Fetch the farmer object based on the id
    try:
        farmer = Farmer.objects.get(id=id)
    except Farmer.DoesNotExist:
        return Response({"detail": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)

    if request.method == 'POST': 
        inventory_data = request.data
        serializer = MyInventoryInsertionsSerializer(data=inventory_data)
 
        if serializer.is_valid(): 
            updated_by_user = farmer  
 
            inventory_instance = serializer.save(
                updated_at=timezone.now(),
                farmer=updated_by_user , 
            )
 
            document_data = inventory_data.get('document', None)
            if document_data:
                document_serializer = MyInventoryDocumentsSerializer(data=document_data)
                if document_serializer.is_valid(): 
                    document_serializer.create(
                        validated_data=document_serializer.validated_data,
                        my_inventory=inventory_instance,
                        updated_at=timezone.now(),
                        updated_by=updated_by_user   
                    )
                else: 
                    return Response(document_serializer.errors, status=status.HTTP_400_BAD_REQUEST)
 
            return Response(
                {
                    "success": True,
                    "message": "Inventory added successfully!",
                    "data": serializer.data
                },
                status=status.HTTP_201_CREATED
            )

        # Return serializer validation errors if any
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


    # Handle other HTTP methods if necessary (PUT, DELETE)
    # (You can extend the functionality for PUT and DELETE as needed)

    # Handle invalid request method
        # return Response({"detail": "Method not allowed."}, status=status.HTTP_405_METHOD_NOT_ALLOWED)

    elif request.method == 'PUT':
        fuel_id = request.data.get('fuel_id')
        try:
            inventory_instance = MyInventory.objects.get(id=id)
        except MyInventory.DoesNotExist:
            return Response({"detail": "Inventory not found."}, status=status.HTTP_404_NOT_FOUND)

        inventory_data = request.data
        serializer = MyInventoryInsertionsSerializer(inventory_instance, data=inventory_data, partial=True)

        if serializer.is_valid():
            updated_by_user = farmer.user  # Assign CustomUser instance here
            inventory_instance = serializer.save(
                updated_at=timezone.now(),
                updated_by=updated_by_user
            )

            document_data = inventory_data.get('document', None)
            if document_data:
                document_serializer = MyInventoryDocumentsSerializer(data=document_data)
                if document_serializer.is_valid():
                    document_serializer.save(
                        my_inventory=inventory_instance,
                        updated_at=timezone.now(),
                        updated_by=updated_by_user
                    )
                else:
                    return Response(document_serializer.errors, status=status.HTTP_400_BAD_REQUEST)

            return Response(serializer.data, status=status.HTTP_200_OK)

        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

    elif request.method == 'DELETE':
        try:
            inventory_instance = MyInventory.objects.get(id=id)
        except MyInventory.DoesNotExist:
            return Response({"detail": "Inventory not found."}, status=status.HTTP_404_NOT_FOUND)

        updated_by_user = farmer.farmer_user  # Assign CustomUser instance here
        inventory_instance.status = 2
        inventory_instance.updated_at = timezone.now()
        inventory_instance.updated_by = updated_by_user
        
        inventory_instance.save()

        return Response({"detail": "Inventory status updated to 2 (marked for deletion)."}, status=status.HTTP_200_OK)
   
# @api_view(['POST'])
# def add_fuel(request, farmer_id):
#     # Fetch the farmer instance based on the farmer_id
#     farmer = get_object_or_404(Farmer, id=farmer_id)

#     # Create a mutable copy of the data to ensure we can modify it
#     mutable_data = request.data.copy()

#     # Handle multiple fuel data or a single fuel entry
#     if isinstance(mutable_data, list):
#         for fuel_data in mutable_data:
#             for field in fuel_data:
#                 if fuel_data[field] is None:
#                     fuel_data[field] = ""  # Replace None with empty string
#             fuel_data['farmer'] = farmer.id
#             fuel_data['created_at'] = timezone.now()
#             fuel_data['created_by'] = farmer.farmer_user.id
#     else:
#         for field in mutable_data:
#             if mutable_data[field] is None:
#                 mutable_data[field] = ""  # Replace None with empty string
#         mutable_data['farmer'] = farmer.id
#         mutable_data['created_at'] = timezone.now()
#         mutable_data['created_by'] = farmer.farmer_user.id

#     # Initialize the serializer with the mutable data
#     serializer = MyFuelAddSerializer(data=mutable_data, many=isinstance(mutable_data, list))

#     # Validate the serializer
#     if serializer.is_valid():
#         # Save the fuel record (the fuel instance is created here)
#         fuel_instance = serializer.save(farmer=farmer)

#         # Handle the documents uploaded with fuel (optional)
#         file_data = request.data.get('documents', None)  # Get the documents if provided
#         if file_data:
#             # Initialize grouped documents to handle file_type categorization
#             grouped_documents = {}

#             # Process each document and its corresponding file_type
#             for doc_data in file_data:
#                 file_type_id = doc_data.get('file_type')
#                 documents = doc_data.get('documents', [])

#                 if not documents:
#                     return Response(
#                         {"success": False, "message": f"No documents provided for file type {file_type_id}."},
#                         status=status.HTTP_400_BAD_REQUEST
#                     )

#                 # Check if file_type_id is None and create a new file type if necessary
#                 if file_type_id is None:
#                     new_file_type = doc_data.get('new_file_type')
#                     if not new_file_type:
#                         return Response({"error": f"New file type for document is required."}, status=status.HTTP_400_BAD_REQUEST)
                        
#                     # Create a new file type if not exists
#                     file_type, created = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=1)
                    
#                 else:
#                     # Get the existing file type
#                     file_type = get_object_or_404(DocumentCategory, id=file_type_id)

#                 if file_type_id not in grouped_documents:
#                     grouped_documents[file_type_id] = []

#                 # Process the documents, creating FuelDocument entries
#                 for i, document_base64 in enumerate(documents):
#                     try:
#                         # Validate MIME type (only image/jpeg, image/png, and application/pdf)
#                         if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
#                             mime_type = validate_image_type(document_base64)  # Validate the MIME type
#                             if mime_type:
#                                 # Extract the base64 data and decode it
#                                 document_data = document_base64.split(';base64,')[1]
#                                 document_bytes = base64.b64decode(document_data)

#                                 # Check file size (10MB max)
#                                 max_file_size = 10 * 1024 * 1024  # 10MB
#                                 if len(document_bytes) > max_file_size:
#                                     return Response({'error': f'File is too large. Max size is 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

#                                 # Create a document name and ContentFile
#                                 document_name = f"fuel_{farmer_id}_{file_type_id}_{i}.{mime_type.split('/')[1]}"
#                                 document_file = ContentFile(document_bytes, name=document_name)

#                                 # Create FuelDocument instance and save it
#                                 fuel_document_instance = MyFuelDocuments.objects.create(
#                                     farmer=farmer,
#                                     fuel=fuel_instance,  # Link to the fuel instance
#                                     file_type=file_type,
#                                     document=document_file,
#                                     created_at=timezone.now(),
#                                     created_by=farmer.farmer_user
#                                 )

#                                 # Append the document info to the grouped_documents list
#                                 document_data = {
#                                     'document_id': fuel_document_instance.id,
#                                     'document_category': {
#                                         'id': file_type.id,
#                                         'name': file_type.name
#                                     },
#                                     'upload_document': request.build_absolute_uri(f'/SuperAdmin{document_file.name}'),
#                                     'language': {
#                                         'default': 'en'
#                                     }
#                                 }

#                                 grouped_documents[file_type_id].append(document_data)
#                             else:
#                                 return Response({'error': 'Invalid MIME type for the document.'}, status=status.HTTP_400_BAD_REQUEST)
#                         else:
#                             return Response({'error': 'Invalid file format. Only image/jpeg, image/png, and application/pdf are allowed.'}, status=status.HTTP_400_BAD_REQUEST)

#                     except Exception as e:
#                         return Response({'error': f"Error processing document: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

#             # Prepare formatted document data for response
#             formatted_documents = []
#             for file_type_id, documents in grouped_documents.items():
#                 formatted_documents.append({
#                     'category_id': file_type_id,
#                     'documents': documents
#                 })
#         else:
#             formatted_documents = []  
 
#         inventory_type_id = mutable_data.get('inventory_type')
#         new_inventory_item_id = request.data.get("inventory_items")

#         if inventory_type_id and new_inventory_item_id:
#             # Retrieve the new inventory item, which should have status=0 (active)
#             new_inventory_item = get_object_or_404(InventoryItems, id=new_inventory_item_id, status=0)

#             # Retrieve the last created MyFuel entry with the same inventory_type and set previous inventory items to inactive
#             last_inventory_item = MyFuel.objects.filter(
#                 inventory_type=fuel_instance.inventory_type,
#                 inventory_items__status=0
#             ).latest('created_at')  # Assuming 'created_at' is the field indicating the creation time

#             if last_inventory_item:
#                 # Update the status of the previous inventory item to 1 (inactive)
#                 MyFuel.objects.filter(
#                     inventory_type=fuel_instance.inventory_type,
#                     inventory_items=last_inventory_item.inventory_items
#                 ).update(status=1)

#             # Set the new inventory item to the fuel instance
#             fuel_instance.inventory_items = new_inventory_item

#             # Recalculate the available quantity for the inventory type
#             total_quantity = MyFuel.objects.filter(
#                 farmer = farmer,
#                 inventory_type=inventory_type_id,
#                 inventory_items=new_inventory_item
#             ).aggregate(total_quantity=Sum('quantity'))['total_quantity'] or 0

#             # Update the fuel instance with the recalculated available quantity
#             fuel_instance.available_quans = total_quantity
#             fuel_instance.save()

#         fuel_instance.quantity = request.data.get("quantity", fuel_instance.quantity)
#         fuel_instance.purchase_amount = request.data.get("purchase_amount", fuel_instance.purchase_amount)
#         fuel_instance.description = request.data.get("description", fuel_instance.description)

#         # Save the updated fuel record
#         fuel_instance.save()

#         # Return the response with the fuel and document details
#         return Response(
#             {
#                 "success": True,
#                 "message": "Fuel added successfully!",
#                 "data": serializer.data,
#                 "documents": formatted_documents,  # Include the grouped and formatted documents if provided
#                 "language": {
#                     "default": "en"
#                 }
#             },
#             status=status.HTTP_201_CREATED
#         )

#     # If serializer is invalid, return errors
#     return Response(
#         {
#             "success": False,
#             "message": "Failed to add fuel. Please check the input data.",
#             "errors": serializer.errors
#         },
#         status=status.HTTP_400_BAD_REQUEST
#     )

# @api_view(['POST'])
# def add_fuel(request, farmer_id):
#     farmer = get_object_or_404(Farmer, id=farmer_id)
#     data = request.data.copy()

#     # Required field check
#     required_fields = [
#         'date_of_consumption', 'inventory_type', 'inventory_category',
#         'inventory_items', 'vendor', 'quantity', 'purchase_amount', 'paid_amount'
#     ]
#     missing_fields = [field for field in required_fields if not data.get(field)]
#     if missing_fields:
#         return Response({
#             "success": False,
#             "message": f"Missing required fields: {', '.join(missing_fields)}"
#         }, status=status.HTTP_400_BAD_REQUEST)

#     # Metadata
#     data['farmer'] = farmer.id
#     data['created_at'] = timezone.now()
#     data['created_by'] = farmer.farmer_user.id

#     serializer = MyFuelAddSerializer(data=data)
#     if serializer.is_valid():
#         fuel_instance = serializer.save()

#         # --- Handle Optional Documents ---
#         file_data = request.data.get('documents', None)
#         formatted_documents = []
#         if file_data:
#             grouped_documents = {}
#             for doc_data in file_data:
#                 file_type_id = doc_data.get('file_type')
#                 documents = doc_data.get('documents', [])

#                 if not documents:
#                     return Response(
#                         {"success": False, "message": f"No documents for file type {file_type_id}"},
#                         status=status.HTTP_400_BAD_REQUEST
#                     )

#                 if file_type_id is None:
#                     new_file_type = doc_data.get('new_file_type')
#                     if not new_file_type:
#                         return Response({"error": f"New file type required."}, status=status.HTTP_400_BAD_REQUEST)
#                     file_type, _ = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=1)
#                 else:
#                     file_type = get_object_or_404(DocumentCategory, id=file_type_id)

#                 if file_type_id not in grouped_documents:
#                     grouped_documents[file_type_id] = []

#                 for i, document_base64 in enumerate(documents):
#                     try:
#                         if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
#                             mime_type = validate_image_type(document_base64)
#                             if mime_type:
#                                 document_data = document_base64.split(';base64,')[1]
#                                 document_bytes = base64.b64decode(document_data)
#                                 if len(document_bytes) > 10 * 1024 * 1024:
#                                     return Response({'error': 'File too large. Max 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

#                                 document_name = f"fuel_{farmer_id}_{file_type_id}_{i}.{mime_type.split('/')[1]}"
#                                 document_file = ContentFile(document_bytes, name=document_name)

#                                 fuel_doc = MyFuelDocuments.objects.create(
#                                     farmer=farmer,
#                                     fuel=fuel_instance,
#                                     file_type=file_type,
#                                     document=document_file,
#                                     created_at=timezone.now(),
#                                     created_by=farmer.farmer_user
#                                 )

#                                 grouped_documents[file_type_id].append({
#                                     'document_id': fuel_doc.id,
#                                     'document_category': {
#                                         'id': file_type.id,
#                                         'name': file_type.name
#                                     },
#                                     'upload_document': request.build_absolute_uri(f'/SuperAdmin{document_file.name}'),
#                                     'language': {"default": "en"}
#                                 })
#                             else:
#                                 return Response({'error': 'Invalid MIME type.'}, status=status.HTTP_400_BAD_REQUEST)
#                         else:
#                             return Response({'error': 'Unsupported file format.'}, status=status.HTTP_400_BAD_REQUEST)

#                     except Exception as e:
#                         return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)

#             for file_type_id, docs in grouped_documents.items():
#                 formatted_documents.append({
#                     'category_id': file_type_id,
#                     'documents': docs
#                 })

#         # --- Inventory Logic ---
#         inventory_type_id = data.get('inventory_type')
#         new_inventory_item_id = data.get("inventory_items")
#         if inventory_type_id and new_inventory_item_id:
#             new_inventory_item = get_object_or_404(InventoryItems, id=new_inventory_item_id, status=0)

#             try:
#                 last_item = MyFuel.objects.filter(
#                     inventory_type=fuel_instance.inventory_type,
#                     inventory_items__status=0
#                 ).latest('created_at')
#                 MyFuel.objects.filter(
#                     inventory_type=fuel_instance.inventory_type,
#                     inventory_items=last_item.inventory_items
#                 ).update(status=1)
#             except MyFuel.DoesNotExist:
#                 pass

#             fuel_instance.inventory_items = new_inventory_item
#             total_quantity = MyFuel.objects.filter(
#                 farmer=farmer,
#                 inventory_type=inventory_type_id,
#                 inventory_items=new_inventory_item
#             ).aggregate(total=Sum('quantity'))['total'] or 0

#             fuel_instance.available_quans = total_quantity
#             fuel_instance.save()

#         # --- Create Outstanding Entry ---
#         purchase_amount = float(data.get('purchase_amount', 0))
#         paid_amount = float(data.get('paid_amount', 0))
#         vendor_id = data.get('vendor')

#         # Initial values
#         balance = 0
#         paid = 0
#         to_pay = 0
#         paid_date = None
#         total_paid = 0
#         received = 0
#         to_receive = 0
#         received_date = None
#         total_received = 0

#         if paid_amount < purchase_amount:
#             # Vendor to be paid more: Outstanding Payable
#             balance = purchase_amount - paid_amount
#             to_receive = balance
#             total_received = paid_amount
#             received_date = timezone.now() if paid_amount > 0 else None

#         elif paid_amount > purchase_amount:
#             # Vendor paid extra: Advance or extra payment
#             balance = paid_amount - purchase_amount
#             to_pay = balance
#             paid = 0
#             total_paid = 0
#             received = paid_amount
#             total_received = paid_amount
#             received_date = timezone.now()

#         else:
#             # Exact payment
#             total_received = paid_amount
#             received_date = timezone.now()

#         Outstanding.objects.create(
#             farmer=farmer,
#             vendor_id=vendor_id,
#             fuel_purchase=fuel_instance,
#             balance=balance,
#             paid=paid,
#             to_pay=to_pay,
#             paid_date=paid_date,
#             total_paid=total_paid,
#             received=received,
#             to_receive=to_receive,
#             received_date=received_date,
#             total_received=total_received,
#             payment_amount=paid_amount,
#             created_by=farmer.farmer_user,
#             created_at=timezone.now()
#         )

#         return Response({
#             "success": True,
#             "message": "Fuel added successfully!",
#             "data": serializer.data,
#             "documents": formatted_documents,
#             "language": {"default": "en"}
#         }, status=status.HTTP_201_CREATED)

#     return Response({
#         "success": False,
#         "message": "Validation failed.",
#         "errors": serializer.errors
#     }, status=status.HTTP_400_BAD_REQUEST)

 
# old 15-09-2025
# @api_view(['POST'])
# def add_fuel(request, farmer_id):
#     farmer = get_object_or_404(Farmer, id=farmer_id)
#     data = request.data.copy()

#     # Required fields validation
#     required_fields = [
#         'date_of_consumption', 'inventory_type', 'inventory_category',
#         'inventory_items', 'vendor', 'quantity', 'purchase_amount', 'paid_amount'
#     ]
#     missing_fields = [field for field in required_fields if not data.get(field)]
#     if missing_fields:
#         return Response({
#             "success": False,
#             "message": f"Missing required fields: {', '.join(missing_fields)}"
#         }, status=status.HTTP_400_BAD_REQUEST)

#     # Vendor & inventory type validation
#     vendor_id = data.get('vendor')
#     inventory_type_id = data.get('inventory_type')
#     vendor = get_object_or_404(MyVendor, id=vendor_id)

#     if not vendor.inventory_type.filter(id=inventory_type_id).exists():
#         return Response({
#             "success": False,
#             "message": "This vendor is not associated with the selected inventory type."
#         }, status=status.HTTP_400_BAD_REQUEST)

#     # Metadata
#     data['farmer'] = farmer.id
#     data['created_at'] = timezone.now()
#     data['created_by'] = farmer.farmer_user.id

#     serializer = MyFuelAddSerializer(data=data)
#     if serializer.is_valid():
#         fuel_instance = serializer.save()

#         # --- Optional Documents ---
#         file_data = request.data.get('documents', None)
#         formatted_documents = []
#         if file_data:
#             grouped_documents = {}
#             for doc_data in file_data:
#                 file_type_id = doc_data.get('file_type')
#                 documents = doc_data.get('documents', [])

#                 if not documents:
#                     return Response({"success": False, "message": f"No documents for file type {file_type_id}"}, status=status.HTTP_400_BAD_REQUEST)

#                 if file_type_id is None:
#                     new_file_type = doc_data.get('new_file_type')
#                     if not new_file_type:
#                         return Response({"error": f"New file type required."}, status=status.HTTP_400_BAD_REQUEST)
#                     file_type, _ = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=1)
#                 else:
#                     file_type = get_object_or_404(DocumentCategory, id=file_type_id)

#                 if file_type_id not in grouped_documents:
#                     grouped_documents[file_type_id] = []

#                 for i, document_base64 in enumerate(documents):
#                     try:
#                         if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
#                             mime_type = validate_image_type(document_base64)
#                             if mime_type:
#                                 document_data = document_base64.split(';base64,')[1]
#                                 document_bytes = base64.b64decode(document_data)
#                                 if len(document_bytes) > 10 * 1024 * 1024:
#                                     return Response({'error': 'File too large. Max 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

#                                 document_name = f"fuel_{farmer_id}_{file_type_id}_{i}.{mime_type.split('/')[1]}"
#                                 document_file = ContentFile(document_bytes, name=document_name)

#                                 fuel_doc = MyFuelDocuments.objects.create(
#                                     farmer=farmer,
#                                     fuel=fuel_instance,
#                                     file_type=file_type,
#                                     document=document_file,
#                                     created_at=timezone.now(),
#                                     created_by=farmer.farmer_user
#                                 )

#                                 grouped_documents[file_type_id].append({
#                                     'document_id': fuel_doc.id,
#                                     'document_category': {'id': file_type.id, 'name': file_type.name},
#                                     'upload_document': request.build_absolute_uri(f'/SuperAdmin{document_file.name}'),
#                                     'language': {"default": "en"}
#                                 })
#                             else:
#                                 return Response({'error': 'Invalid MIME type.'}, status=status.HTTP_400_BAD_REQUEST)
#                         else:
#                             return Response({'error': 'Unsupported file format.'}, status=status.HTTP_400_BAD_REQUEST)
#                     except Exception as e:
#                         return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)

#             for file_type_id, docs in grouped_documents.items():
#                 formatted_documents.append({
#                     'category_id': file_type_id,
#                     'documents': docs
#                 })

#         # --- Inventory Logic ---
#         new_inventory_item_id = data.get("inventory_items")
#         if inventory_type_id and new_inventory_item_id:
#             new_inventory_item = get_object_or_404(InventoryItems, id=new_inventory_item_id, status=0)

#             try:
#                 last_item = MyFuel.objects.filter(
#                     farmer = farmer,
#                     inventory_type=fuel_instance.inventory_type,
#                     inventory_items__status=0
#                 ).latest('created_at')
#                 MyFuel.objects.filter(
#                     farmer = farmer,
#                     inventory_type=fuel_instance.inventory_type,
#                     inventory_items=last_item.inventory_items
#                 ).update(status=1)
#             except MyFuel.DoesNotExist:
#                 pass

#             fuel_instance.inventory_items = new_inventory_item
#             total_quantity = MyFuel.objects.filter(
#                 farmer=farmer,
#                 inventory_type=inventory_type_id,
#                 inventory_items=new_inventory_item
#             ).aggregate(total=Sum('quantity'))['total'] or 0

#             fuel_instance.available_quans = total_quantity
#             fuel_instance.save()

#         # --- Create Outstanding ---
#         purchase_amount = float(data.get('purchase_amount', 0))
#         paid_amount = float(data.get('paid_amount', 0))

#         balance = 0
#         paid = 0
#         to_pay = 0
#         paid_date = None
#         total_paid = 0
#         received = 0
#         to_receive = 0
#         received_date = None
#         total_received = 0

#         if paid_amount < purchase_amount:
#             balance = purchase_amount - paid_amount
#             to_receive = balance
#             total_received = paid_amount
#             received_date = timezone.now() if paid_amount > 0 else None
#         elif paid_amount > purchase_amount:
#             balance = paid_amount - purchase_amount
#             to_pay = balance
#             received = paid_amount
#             total_received = paid_amount
#             received_date = timezone.now()
#         else:
#             total_received = paid_amount
#             received_date = timezone.now()

#         Outstanding.objects.create(
#             farmer=farmer,
#             vendor=vendor,
#             fuel_purchase=fuel_instance,
#             balance=balance,
#             paid=paid,
#             to_pay=to_pay,
#             paid_date=paid_date,
#             total_paid=total_paid,
#             received=received,
#             to_receive=to_receive,
#             received_date=received_date,
#             total_received=total_received,
#             payment_amount=paid_amount,
#             created_by=farmer.farmer_user,
#             created_at=timezone.now()
#         )

#         return Response({
#             "success": True,
#             "message": "Fuel added successfully!",
#             "data": serializer.data,
#             "documents": formatted_documents,
#             "language": {"default": "en"}
#         }, status=status.HTTP_201_CREATED)

#     return Response({
#         "success": False,
#         "message": "Validation failed.",
#         "errors": serializer.errors
#     }, status=status.HTTP_400_BAD_REQUEST)
 

# new 15-09-2025
 
@api_view(['POST'])
def add_fuel(request, farmer_id):
    farmer = get_object_or_404(Farmer, id=farmer_id)
    data = request.data.copy()
    user = request.user  # logged-in user

    # --- If fuel_id provided, reset previous fuel and update outstanding ---
    fuel_id = data.get('fuel_id')
    if fuel_id:
        fuel = get_object_or_404(MyFuel, pk=fuel_id)
        fuel.status = 0
        fuel.save()

        inv = get_object_or_404(MyInventory, fuel_purchase=fuel)
        inv.status = 0
        inv.save()

        FarmerNotification.objects.create(
            farmer=farmer,
            name='New Purchase Created',
            message=f'{fuel.inventory_items.name}',
            type='Fuel'
        )

    # --- Validate required fields ---
    required_fields = [
        'date_of_consumption', 'inventory_type', 'inventory_category',
        'inventory_items', 'vendor', 'quantity', 'purchase_amount', 'paid_amount'
    ]
    missing_fields = [field for field in required_fields if not data.get(field)]
    if missing_fields:
        return Response({
            "success": False,
            "message": f"Missing required fields: {', '.join(missing_fields)}"
        }, status=status.HTTP_400_BAD_REQUEST)

    # --- Validate vendor and inventory_type relationship ---
    vendor_id = data.get('vendor')
    inventory_type_id = data.get('inventory_type')
    vendor = get_object_or_404(MyVendor, id=vendor_id)

    if not vendor.inventory_type.filter(id=inventory_type_id).exists():
        return Response({
            "success": False,
            "message": "This vendor is not associated with the selected inventory type."
        }, status=status.HTTP_400_BAD_REQUEST)

    # --- Prepare metadata for serializer ---
    data['farmer'] = farmer.id
    data['created_at'] = timezone.now()
    data['created_by'] = farmer.farmer_user.id  # Assuming farmer_user is the User instance

    serializer = MyFuelAddSerializer(data=data)
    if serializer.is_valid():
        fuel_instance = serializer.save()

        # --- Optional Documents Handling ---
        file_data = request.data.get('documents', None)
        formatted_documents = []
        if file_data:
            grouped_documents = {}
            for doc_data in file_data:
                file_type_id = doc_data.get('file_type')
                documents = doc_data.get('documents', [])

                if not documents:
                    return Response({"success": False, "message": f"No documents for file type {file_type_id}"}, status=status.HTTP_400_BAD_REQUEST)

                if file_type_id is None:
                    new_file_type = doc_data.get('new_file_type')
                    if not new_file_type:
                        return Response({"error": "New file type required."}, status=status.HTTP_400_BAD_REQUEST)
                    file_type, _ = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=1)
                    file_type_id = file_type.id
                else:
                    file_type = get_object_or_404(DocumentCategory, id=file_type_id)

                if file_type_id not in grouped_documents:
                    grouped_documents[file_type_id] = []

                for i, document_base64 in enumerate(documents):
                    try:
                        if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
                            mime_type = validate_image_type(document_base64)
                            if mime_type:
                                document_data = document_base64.split(';base64,')[1]
                                document_bytes = base64.b64decode(document_data)
                                if len(document_bytes) > 10 * 1024 * 1024:
                                    return Response({'error': 'File too large. Max 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

                                ext = mime_type.split('/')[1]
                                document_name = f"fuel_{farmer_id}_{file_type_id}_{i}.{ext}"
                                document_file = ContentFile(document_bytes, name=document_name)

                                fuel_doc = MyFuelDocuments.objects.create(
                                    farmer=farmer,
                                    fuel=fuel_instance,
                                    file_type=file_type,
                                    document=document_file,
                                    created_at=timezone.now(),
                                    created_by=farmer.farmer_user
                                )

                                grouped_documents[file_type_id].append({
                                    'document_id': fuel_doc.id,
                                    'document_category': {'id': file_type.id, 'name': file_type.name},
                                    'upload_document': request.build_absolute_uri(fuel_doc.document.url),
                                    'language': {"default": "en"}
                                })
                            else:
                                return Response({'error': 'Invalid MIME type.'}, status=status.HTTP_400_BAD_REQUEST)
                        else:
                            return Response({'error': 'Unsupported file format.'}, status=status.HTTP_400_BAD_REQUEST)
                    except Exception as e:
                        return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)

            for file_type_id_key, docs in grouped_documents.items():
                formatted_documents.append({
                    'category_id': file_type_id_key,
                    'documents': docs
                })

        # --- Inventory logic ---
        new_inventory_item_id = data.get("inventory_items")
        if inventory_type_id and new_inventory_item_id:
            new_inventory_item = get_object_or_404(InventoryItems, id=new_inventory_item_id, status=0)

            try:
                last_item = MyFuel.objects.filter(
                    farmer=farmer,
                    inventory_type=fuel_instance.inventory_type,
                    inventory_items__status=0
                ).latest('created_at')
                # Mark last fuel's inventory_items status to 1 (inactive)
                MyFuel.objects.filter(
                    farmer=farmer,
                    inventory_type=fuel_instance.inventory_type,
                    inventory_items=last_item.inventory_items
                ).update(status=1)
            except MyFuel.DoesNotExist:
                # No previous fuel found, skip update
                pass

            fuel_instance.inventory_items = new_inventory_item

            # Calculate total quantity for this inventory item & type for this farmer
            total_quantity = MyFuel.objects.filter(
                farmer=farmer,
                inventory_type=inventory_type_id,
                inventory_items=new_inventory_item
            ).aggregate(total=Sum('quantity'))['total'] or 0

            fuel_instance.available_quans = total_quantity
            fuel_instance.save()

        # --- Vendor Outstanding & Balance Update Logic ---
        purchase_amount = float(data.get('purchase_amount', 0))
        paid_amount = float(data.get('paid_amount', 0))

        net_change = paid_amount - purchase_amount  # Positive means vendor owes you; negative means you owe vendor
        current_balance = vendor.opening_balance or 0
        updated_balance = current_balance + net_change

        # Set credit/debit flags and opening_balance accordingly
        if updated_balance > 0:
            # Vendor owes you money (receivables)
            vendor.credit = True
            vendor.debit = False
            vendor.opening_balance = updated_balance
        elif updated_balance < 0:
            # You owe vendor money (payables)
            vendor.credit = False
            vendor.debit = True
            vendor.opening_balance = abs(updated_balance)
        else:
            # No outstanding balance
            vendor.credit = False
            vendor.debit = False
            vendor.opening_balance = 0

        # Update payables or receivables amounts on vendor accordingly
        if net_change < 0:
            # You owe vendor money â†’ payables increase
            vendor.payables = (vendor.payables or 0) + abs(net_change)
        elif net_change > 0:
            # Vendor owes you money â†’ receivables increase
            vendor.receivables = (vendor.receivables or 0) + net_change

        vendor.save()

        # Sync balances to customer if vendor is also a customer
        if vendor.is_customer_is_vendor and hasattr(vendor, 'customer'):
            customer = vendor.customer
            customer.opening_balance = vendor.opening_balance
            customer.payables = vendor.payables
            customer.receivables = vendor.receivables
            customer.is_credit = vendor.credit
            customer.save()

        # Prepare Outstanding record fields
        balance = abs(net_change)
        now = timezone.now()

        # Depending on net_change, set appropriate Outstanding fields
        if net_change < 0:
            # Payables case (you owe vendor)
            to_pay = abs(net_change)
            Outstanding.objects.create(
                farmer=farmer,
                vendor=vendor,
                fuel_purchase=fuel_instance,
                balance=purchase_amount,
                paid=paid_amount,
                to_pay=to_pay,
                paid_date=now,
                total_paid=paid_amount,
                identify=1,
                created_by=farmer.farmer_user,
                created_at=now
            )
        elif net_change > 0:
            # Receivables case (vendor owes you)
            to_receive = net_change
            Outstanding.objects.create(
                farmer=farmer,
                vendor=vendor,
                fuel_purchase=fuel_instance,
                balance=balance,
                paid=paid_amount,
                to_receive=to_receive,
                received_date=now,
                total_received=paid_amount,
                identify=1,
                created_by=farmer.farmer_user,
                created_at=now
            )
        else:
            # Exact payment, no outstanding balance
            Outstanding.objects.create(
                farmer=farmer,
                vendor=vendor,
                fuel_purchase=fuel_instance,
                balance=0,
                paid=paid_amount,
                to_pay=0,
                paid_date=now,
                total_paid=paid_amount,
                received=paid_amount,
                to_receive=0,
                received_date=now,
                total_received=paid_amount,
                identify=1,
                created_by=farmer.farmer_user,
                created_at=now
            )

        # Optional: Create Farmer Notification
        FarmerNotification.objects.create(
            farmer=farmer,
            name='New Purchase Created',
            message=f'{fuel_instance.inventory_items.name}',
            type='Fuel'
        )

        return Response({
            "success": True,
            "message": "Fuel added successfully!",
            "data": serializer.data,
            "documents": formatted_documents,
            "language": {"default": "en"}
        }, status=status.HTTP_201_CREATED)

    return Response({
        "success": False,
        "message": "Validation failed.",
        "errors": serializer.errors
    }, status=status.HTTP_400_BAD_REQUEST)




# @api_view(['POST'])
# def add_seeds(request, farmer_id):
#     # Fetch the farmer instance based on the farmer_id
#     farmer = get_object_or_404(Farmer, id=farmer_id,status=0)

#     # Create a mutable copy of the data to ensure we can modify it
#     mutable_data = request.data.copy()

#     # Handle multiple seeds data or a single seed entry
#     if isinstance(mutable_data, list):
#         for seed_data in mutable_data:
#             for field in seed_data:
#                 if seed_data[field] is None:
#                     seed_data[field] = ""  # Replace None with empty string
#             seed_data['farmer'] = farmer.id
#             seed_data['created_at'] = timezone.now()
#             seed_data['created_by'] = farmer.farmer_user.id
#     else:
#         for field in mutable_data:
#             if mutable_data[field] is None:
#                 mutable_data[field] = ""  # Replace None with empty string
#         mutable_data['farmer'] = farmer.id
#         mutable_data['created_at'] = timezone.now()
#         mutable_data['created_by'] = farmer.farmer_user.id

#     # Initialize the serializer with the mutable data
#     serializer = MySeedsAddSerializer(data=mutable_data, many=isinstance(mutable_data, list))

#     # Validate the serializer
#     if serializer.is_valid():
#         # Save the seed record (the seed instance is created here)
#         seed_instance = serializer.save(farmer=farmer)

#         # Handle the inventory_type and related inventory_item
#         inventory_type_id = mutable_data.get('inventory_type')
#         new_inventory_item_id = request.data.get("inventory_items")

#         if inventory_type_id and new_inventory_item_id:
#             # Retrieve the new inventory item, which should have status=0 (active)
#             new_inventory_item = get_object_or_404(InventoryItems, id=new_inventory_item_id, status=0)

#             # Retrieve the last created MySeeds entry with the same inventory_type and set previous inventory items to inactive
#             last_inventory_item = MySeeds.objects.filter(
#                 inventory_type=seed_instance.inventory_type,
#                 inventory_items__status=0
#             ).latest('created_at')  # Assuming 'created_at' is the field indicating the creation time

#             if last_inventory_item:
#                 # Update the status of the previous inventory item to 1 (inactive)
#                 MySeeds.objects.filter(
#                     inventory_type=seed_instance.inventory_type,
#                     inventory_items=last_inventory_item.inventory_items
#                 ).update(status=1)

#             # Set the new inventory item to the seed instance
#             seed_instance.inventory_items = new_inventory_item

#             # Recalculate the available quantity for the inventory type
#             total_quantity = MySeeds.objects.filter(
#                 inventory_type=inventory_type_id,
#                 inventory_items=new_inventory_item
#             ).aggregate(total_quantity=Sum('quantity'))['total_quantity'] or 0

#             # Update the seed instance with the recalculated available quantity
#             seed_instance.available_quans = total_quantity
#             seed_instance.save()

#         # Handle the documents uploaded with seeds (optional)
#         file_data = request.data.get('documents', None)  # Get the documents if provided
#         if file_data:
#             # Initialize grouped documents to handle file_type categorization
#             grouped_documents = {}

#             # Process each document and its corresponding file_type
#             for doc_data in file_data:
#                 file_type_id = doc_data.get('file_type')
#                 documents = doc_data.get('documents', [])

#                 if not documents:
#                     return Response(
#                         {"success": False, "message": f"No documents provided for file type {file_type_id}."},
#                         status=status.HTTP_400_BAD_REQUEST
#                     )

#                 # Check if file_type_id is None and create a new file type if necessary
#                 if file_type_id is None:
#                     new_file_type = doc_data.get('new_file_type')
#                     if not new_file_type:
#                         return Response({"error": f"New file type for document is required."}, status=status.HTTP_400_BAD_REQUEST)
                    
#                     # Create a new file type if not exists
#                     file_type, created = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=3)  # Assuming doctype=3 for seeds
                    
#                 else:
#                     # Get the existing file type
#                     file_type = get_object_or_404(DocumentCategory, id=file_type_id)

#                 if file_type_id not in grouped_documents:
#                     grouped_documents[file_type_id] = []

#                 # Process the documents, creating SeedDocument entries
#                 for i, document_base64 in enumerate(documents):
#                     try:
#                         # Validate MIME type (only image/jpeg, image/png, and application/pdf)
#                         if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
#                             mime_type = validate_image_type(document_base64)  # Validate the MIME type
#                             if mime_type:
#                                 # Extract the base64 data and decode it
#                                 document_data = document_base64.split(';base64,')[1]
#                                 document_bytes = base64.b64decode(document_data)

#                                 # Check file size (10MB max)
#                                 max_file_size = 10 * 1024 * 1024  # 10MB
#                                 if len(document_bytes) > max_file_size:
#                                     return Response({'error': f'File is too large. Max size is 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

#                                 # Create a document name and ContentFile
#                                 document_name = f"seed_{farmer_id}_{file_type_id}_{i}.{mime_type.split('/')[1]}"
#                                 document_file = ContentFile(document_bytes, name=document_name)

#                                 # Create SeedDocument instance and save it
#                                 seed_document_instance = MyseedsDocuments.objects.create(
#                                     farmer=farmer,
#                                     seeds=seed_instance,  # Link to the seed instance
#                                     file_type=file_type,
#                                     document=document_file,
#                                     created_at=timezone.now(),
#                                     created_by=farmer.farmer_user
#                                 )

#                                 # Append the document info to the grouped_documents list
#                                 document_data = {
#                                     'document_id': seed_document_instance.id,
#                                     'document_category': {
#                                         'id': file_type.id,
#                                         'name': file_type.name
#                                     },
#                                     'upload_document': request.build_absolute_uri(f'/SuperAdmin{document_file.name}'),
#                                     'language': {
#                                         'default': 'en'
#                                     }
#                                 }

#                                 grouped_documents[file_type_id].append(document_data)
#                             else:
#                                 return Response({'error': 'Invalid MIME type for the document.'}, status=status.HTTP_400_BAD_REQUEST)
#                         else:
#                             return Response({'error': 'Invalid file format. Only image/jpeg, image/png, and application/pdf are allowed.'}, status=status.HTTP_400_BAD_REQUEST)

#                     except Exception as e:
#                         return Response({'error': f"Error processing document: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

#             # Prepare formatted document data for response
#             formatted_documents = []
#             for file_type_id, documents in grouped_documents.items():
#                 formatted_documents.append({
#                     'category_id': file_type_id,
#                     'documents': documents
#                 })
#         else:
#             formatted_documents = []  # If no documents are provided, return an empty list

#         # Save any additional fields from the request (e.g., quantity, purchase_amount, description)
#         seed_instance.quantity = request.data.get("quantity", seed_instance.quantity)
#         seed_instance.purchase_amount = request.data.get("purchase_amount", seed_instance.purchase_amount)
#         seed_instance.description = request.data.get("description", seed_instance.description)

#         # Save the updated seed record
#         seed_instance.save()

#         # Return the response with the seed and document details
#         return Response(
#             {
#                 "success": True,
#                 "message": "Seed added successfully!",
#                 "data": serializer.data,
#                 "documents": formatted_documents,  # Include the grouped and formatted documents if provided
#                 "language": {
#                     "default": "en"
#                 }
#             },
#             status=status.HTTP_201_CREATED
#         )

#     # If serializer is invalid, return errors
#     return Response(
#         {
#             "success": False,
#             "message": "Failed to add seed. Please check the input data.",
#             "errors": serializer.errors
#         },
#         status=status.HTTP_400_BAD_REQUEST
#     )
 
# @api_view(['POST'])
# def add_seeds(request, farmer_id):
#     farmer = get_object_or_404(Farmer, id=farmer_id, status=0)
    
#     # Create a mutable copy of the request data
#     mutable_data = request.data.copy()

#     # Required fields validation
#     required_fields = [
#         'date_of_consumption', 'inventory_type', 'inventory_category',
#         'inventory_items', 'vendor', 'quantity', 'quantity_unit', 
#         'purchase_amount', 'paid_amount'
#     ]
    
#     missing_fields = [field for field in required_fields if not mutable_data.get(field)]
#     if missing_fields:
#         return Response({
#             "success": False,
#             "message": f"Missing required fields: {', '.join(missing_fields)}"
#         }, status=status.HTTP_400_BAD_REQUEST)

#     # Handle the seed data structure (list or single item)
#     if isinstance(mutable_data, list):
#         for seed_data in mutable_data:
#             for field in seed_data:
#                 if seed_data[field] is None:
#                     seed_data[field] = ""  # Replace None with empty string
#             seed_data['farmer'] = farmer.id
#             seed_data['created_at'] = timezone.now()
#             seed_data['created_by'] = farmer.farmer_user.id
#     else:
#         for field in mutable_data:
#             if mutable_data[field] is None:
#                 mutable_data[field] = ""  # Replace None with empty string
#         mutable_data['farmer'] = farmer.id
#         mutable_data['created_at'] = timezone.now()
#         mutable_data['created_by'] = farmer.farmer_user.id

#     # Initialize the serializer with the mutable data
#     serializer = MySeedsAddSerializer(data=mutable_data, many=isinstance(mutable_data, list))

#     # Validate the serializer
#     if serializer.is_valid():
#         # Save the seed record (the seed instance is created here)
#         seed_instance = serializer.save(farmer=farmer)

#         # Handle the inventory_type and related inventory_item
#         inventory_type_id = mutable_data.get('inventory_type')
#         new_inventory_item_id = mutable_data.get("inventory_items")

#         if inventory_type_id and new_inventory_item_id:
#             # Retrieve the new inventory item, which should have status=0 (active)
#             new_inventory_item = get_object_or_404(InventoryItems, id=new_inventory_item_id, status=0)

#             # Update previous inventory items to inactive
#             try:
#                 last_inventory_item = MySeeds.objects.filter(
#                     inventory_type=seed_instance.inventory_type,
#                     inventory_items__status=0
#                 ).latest('created_at')  # Assuming 'created_at' is the field indicating the creation time

#                 if last_inventory_item:
#                     MySeeds.objects.filter(
#                         inventory_type=seed_instance.inventory_type,
#                         inventory_items=last_inventory_item.inventory_items
#                     ).update(status=1)

#             except MySeeds.DoesNotExist:
#                 pass

#             # Set the new inventory item to the seed instance
#             seed_instance.inventory_items = new_inventory_item

#             # Recalculate the available quantity for the inventory type
#             total_quantity = MySeeds.objects.filter(
#                 inventory_type=inventory_type_id,
#                 inventory_items=new_inventory_item
#             ).aggregate(total_quantity=Sum('quantity'))['total_quantity'] or 0

#             seed_instance.available_quans = total_quantity
#             seed_instance.save()

#         # Handle the documents uploaded with seeds (optional)
#         file_data = request.data.get('documents', None)
#         if file_data:
#             grouped_documents = {}

#             # Process each document and its corresponding file_type
#             for doc_data in file_data:
#                 file_type_id = doc_data.get('file_type')
#                 documents = doc_data.get('documents', [])

#                 if not documents:
#                     return Response(
#                         {"success": False, "message": f"No documents provided for file type {file_type_id}."},
#                         status=status.HTTP_400_BAD_REQUEST
#                     )

#                 # Check if file_type_id is None and create a new file type if necessary
#                 if file_type_id is None:
#                     new_file_type = doc_data.get('new_file_type')
#                     if not new_file_type:
#                         return Response({"error": f"New file type for document is required."}, status=status.HTTP_400_BAD_REQUEST)
                    
#                     file_type, created = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=3)
                    
#                 else:
#                     file_type = get_object_or_404(DocumentCategory, id=file_type_id)

#                 if file_type_id not in grouped_documents:
#                     grouped_documents[file_type_id] = []

#                 for i, document_base64 in enumerate(documents):
#                     try:
#                         if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
#                             mime_type = validate_image_type(document_base64)
#                             if mime_type:
#                                 document_data = document_base64.split(';base64,')[1]
#                                 document_bytes = base64.b64decode(document_data)
#                                 if len(document_bytes) > 10 * 1024 * 1024:
#                                     return Response({'error': 'File too large. Max 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

#                                 document_name = f"seed_{farmer_id}_{file_type_id}_{i}.{mime_type.split('/')[1]}"
#                                 document_file = ContentFile(document_bytes, name=document_name)

#                                 seed_doc = MyseedsDocuments.objects.create(
#                                     farmer=farmer,
#                                     seeds=seed_instance,
#                                     file_type=file_type,
#                                     document=document_file,
#                                     created_at=timezone.now(),
#                                     created_by=farmer.farmer_user
#                                 )

#                                 grouped_documents[file_type_id].append({
#                                     'document_id': seed_doc.id,
#                                     'document_category': {'id': file_type.id, 'name': file_type.name},
#                                     'upload_document': request.build_absolute_uri(f'/SuperAdmin{document_file.name}'),
#                                     'language': {"default": "en"}
#                                 })
#                             else:
#                                 return Response({'error': 'Invalid MIME type.'}, status=status.HTTP_400_BAD_REQUEST)
#                         else:
#                             return Response({'error': 'Unsupported file format.'}, status=status.HTTP_400_BAD_REQUEST)
#                     except Exception as e:
#                         return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)

#             formatted_documents = []
#             for file_type_id, docs in grouped_documents.items():
#                 formatted_documents.append({
#                     'category_id': file_type_id,
#                     'documents': docs
#                 })
#         else:
#             formatted_documents = []  # If no documents are provided, return an empty list

#         # Save any additional fields from the request (e.g., quantity, purchase_amount, description)
#         seed_instance.quantity = mutable_data.get("quantity", seed_instance.quantity)
#         seed_instance.purchase_amount = mutable_data.get("purchase_amount", seed_instance.purchase_amount)
#         seed_instance.description = mutable_data.get("description", seed_instance.description)

#         # Save the updated seed record
#         seed_instance.save()

#         # Create Outstanding record
#         purchase_amount = float(mutable_data.get('purchase_amount', 0))
#         paid_amount = float(mutable_data.get('paid_amount', 0))

#         balance = 0
#         paid = 0
#         to_pay = 0
#         paid_date = None
#         total_paid = 0
#         received = 0
#         to_receive = 0
#         received_date = None
#         total_received = 0

#         if paid_amount < purchase_amount:
#             balance = purchase_amount - paid_amount
#             to_receive = balance
#             total_received = paid_amount
#             received_date = timezone.now() if paid_amount > 0 else None
#         elif paid_amount > purchase_amount:
#             balance = paid_amount - purchase_amount
#             to_pay = balance
#             received = paid_amount
#             total_received = paid_amount
#             received_date = timezone.now()
#         else:
#             total_received = paid_amount
#             received_date = timezone.now()

#         Outstanding.objects.create(
#             farmer=farmer,
#             vendor=seed_instance.vendor,
#             fuel_purchase=None,
#             seed_purchase=seed_instance,
#             balance=balance,
#             paid=paid,
#             to_pay=to_pay,
#             paid_date=paid_date,
#             total_paid=total_paid,
#             received=received,
#             to_receive=to_receive,
#             received_date=received_date,
#             total_received=total_received,
#             payment_amount=paid_amount,
#             created_by=farmer.farmer_user,
#             created_at=timezone.now(),
#             status=0
#         )

#         return Response({
#             "success": True,
#             "message": "Seed added successfully!",
#             "data": serializer.data,
#             "documents": formatted_documents,
#             "language": {"default": "en"}
#         }, status=status.HTTP_201_CREATED)

#     return Response({
#         "success": False,
#         "message": "Validation failed.",
#         "errors": serializer.errors
#     }, status=status.HTTP_400_BAD_REQUEST)

#old 15-09-2025
# @api_view(['POST'])
# def add_seeds(request, farmer_id):
#     # Retrieve the farmer object, ensure the farmer is active (status=0)
#     farmer = get_object_or_404(Farmer, id=farmer_id, status=0)

#     # Create a mutable copy of the request data
#     mutable_data = request.data.copy()

#     # Required fields validation
#     required_fields = [
#         'date_of_consumption', 'inventory_type', 'inventory_category',
#         'inventory_items', 'vendor', 'quantity', 'quantity_unit', 
#         'purchase_amount', 'paid_amount'
#     ]
    
#     missing_fields = [field for field in required_fields if not mutable_data.get(field)]
#     if missing_fields:
#         return Response({
#             "success": False,
#             "message": f"Missing required fields: {', '.join(missing_fields)}"
#         }, status=status.HTTP_400_BAD_REQUEST)

#     # Handle the seed data structure (list or single item)
#     if isinstance(mutable_data, list):
#         for seed_data in mutable_data:
#             for field in seed_data:
#                 if seed_data[field] is None:
#                     seed_data[field] = ""  # Replace None with empty string
#             seed_data['farmer'] = farmer.id
#             seed_data['created_at'] = timezone.now()
#             seed_data['created_by'] = farmer.farmer_user.id
#     else:
#         for field in mutable_data:
#             if mutable_data[field] is None:
#                 mutable_data[field] = ""  # Replace None with empty string
#         mutable_data['farmer'] = farmer.id
#         mutable_data['created_at'] = timezone.now()
#         mutable_data['created_by'] = farmer.farmer_user.id

#     # Initialize the serializer with the mutable data
#     serializer = MySeedsAddSerializer(data=mutable_data, many=isinstance(mutable_data, list))

#     # Validate the serializer
#     if serializer.is_valid():
#         # Save the seed record (the seed instance is created here)
#         seed_instance = serializer.save(farmer=farmer)

#         # Handle the inventory_type and related inventory_item
#         inventory_type_id = mutable_data.get('inventory_type')
#         new_inventory_item_id = mutable_data.get("inventory_items")

#         if inventory_type_id and new_inventory_item_id:
#             # Retrieve the new inventory item, which should have status=0 (active)
#             new_inventory_item = get_object_or_404(InventoryItems, id=new_inventory_item_id, status=0)

#             # Update previous inventory items to inactive
#             try:
#                 last_inventory_item = MySeeds.objects.filter(
#                     farmer = farmer,
#                     inventory_type=seed_instance.inventory_type,
#                     inventory_items__status=0
#                 ).latest('created_at')  # Assuming 'created_at' is the field indicating the creation time

#                 if last_inventory_item:
#                     MySeeds.objects.filter(
#                         farmer = farmer,
#                         inventory_type=seed_instance.inventory_type,
#                         inventory_items=last_inventory_item.inventory_items
#                     ).update(status=1)

#             except MySeeds.DoesNotExist:
#                 pass

#             # Set the new inventory item to the seed instance
#             seed_instance.inventory_items = new_inventory_item

#             # Recalculate the available quantity for the inventory type
#             total_quantity = MySeeds.objects.filter(
#                 farmer = farmer,
#                 inventory_type=inventory_type_id,
#                 inventory_items=new_inventory_item
#             ).aggregate(total_quantity=Sum('quantity'))['total_quantity'] or 0

#             seed_instance.available_quans = total_quantity
#             seed_instance.save()

#         # Handle the documents uploaded with seeds (optional)
#         file_data = request.data.get('documents', None)
#         if file_data:
#             grouped_documents = {}

#             # Process each document and its corresponding file_type
#             for doc_data in file_data:
#                 file_type_id = doc_data.get('file_type')
#                 documents = doc_data.get('documents', [])

#                 if not documents:
#                     return Response(
#                         {"success": False, "message": f"No documents provided for file type {file_type_id}."},
#                         status=status.HTTP_400_BAD_REQUEST
#                     )

#                 # Check if file_type_id is None and create a new file type if necessary
#                 if file_type_id is None:
#                     new_file_type = doc_data.get('new_file_type')
#                     if not new_file_type:
#                         return Response({"error": f"New file type for document is required."}, status=status.HTTP_400_BAD_REQUEST)
                    
#                     file_type, created = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=3)
                    
#                 else:
#                     file_type = get_object_or_404(DocumentCategory, id=file_type_id)

#                 if file_type_id not in grouped_documents:
#                     grouped_documents[file_type_id] = []

#                 for i, document_base64 in enumerate(documents):
#                     try:
#                         if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
#                             mime_type = validate_image_type(document_base64)
#                             if mime_type:
#                                 document_data = document_base64.split(';base64,')[1]
#                                 document_bytes = base64.b64decode(document_data)
#                                 if len(document_bytes) > 10 * 1024 * 1024:
#                                     return Response({'error': 'File too large. Max 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

#                                 document_name = f"seed_{farmer_id}_{file_type_id}_{i}.{mime_type.split('/')[1]}"
#                                 document_file = ContentFile(document_bytes, name=document_name)

#                                 seed_doc = MyseedsDocuments.objects.create(
#                                     farmer=farmer,
#                                     seeds=seed_instance,
#                                     file_type=file_type,
#                                     document=document_file,
#                                     created_at=timezone.now(),
#                                     created_by=farmer.farmer_user
#                                 )

#                                 grouped_documents[file_type_id].append({
#                                     'document_id': seed_doc.id,
#                                     'document_category': {'id': file_type.id, 'name': file_type.name},
#                                     'upload_document': request.build_absolute_uri(f'/SuperAdmin{document_file.name}'),
#                                     'language': {"default": "en"}
#                                 })
#                             else:
#                                 return Response({'error': 'Invalid MIME type.'}, status=status.HTTP_400_BAD_REQUEST)
#                         else:
#                             return Response({'error': 'Unsupported file format.'}, status=status.HTTP_400_BAD_REQUEST)
#                     except Exception as e:
#                         return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)

#             formatted_documents = []
#             for file_type_id, docs in grouped_documents.items():
#                 formatted_documents.append({
#                     'category_id': file_type_id,
#                     'documents': docs
#                 })
#         else:
#             formatted_documents = []  # If no documents are provided, return an empty list

#         # Save any additional fields from the request (e.g., quantity, purchase_amount, description)
#         seed_instance.quantity = mutable_data.get("quantity", seed_instance.quantity)
#         seed_instance.purchase_amount = mutable_data.get("purchase_amount", seed_instance.purchase_amount)
#         seed_instance.description = mutable_data.get("description", seed_instance.description)

#         # Save the updated seed record
#         seed_instance.save()

#         # Create Outstanding record
#         purchase_amount = float(mutable_data.get('purchase_amount', 0))
#         paid_amount = float(mutable_data.get('paid_amount', 0))

#         balance = 0
#         paid = 0
#         to_pay = 0
#         paid_date = None
#         total_paid = 0
#         received = 0
#         to_receive = 0
#         received_date = None
#         total_received = 0

#         if paid_amount < purchase_amount:
#             balance = purchase_amount - paid_amount
#             to_receive = balance
#             total_received = paid_amount
#             received_date = timezone.now() if paid_amount > 0 else None
#         elif paid_amount > purchase_amount:
#             balance = paid_amount - purchase_amount
#             to_pay = balance
#             received = paid_amount
#             total_received = paid_amount
#             received_date = timezone.now()
#         else:
#             total_received = paid_amount
#             received_date = timezone.now()

#         # Ensure all necessary fields are populated
#         Outstanding.objects.create(
#             farmer=farmer,
#             vendor=seed_instance.vendor,  # Ensure that seed_instance has a valid vendor
#             seeds_purchase=seed_instance,  # Corrected: seeds_purchase is linked to the seed instance
#             balance=balance,
#             paid=paid,
#             to_pay=to_pay,
#             paid_date=paid_date,
#             total_paid=total_paid,
#             received=received,
#             to_receive=to_receive,
#             received_date=received_date,
#             total_received=total_received,
#             payment_amount=paid_amount,
#             created_by=farmer.farmer_user,
#             created_at=timezone.now(),
#             status=0
#         )

#         return Response({
#             "success": True,
#             "message": "Seed added successfully!",
#             "data": serializer.data,
#             "documents": formatted_documents,
#             "language": {"default": "en"}
#         }, status=status.HTTP_201_CREATED)

#     return Response({
#         "success": False,
#         "message": "Validation failed.",
#         "errors": serializer.errors
#     }, status=status.HTTP_400_BAD_REQUEST)

@api_view(['POST'])
def add_seeds(request, farmer_id):
    farmer = get_object_or_404(Farmer, id=farmer_id, status=0)
    data = request.data.copy()
    user = request.user

    # Required fields validation
    required_fields = [
        'date_of_consumption', 'inventory_type'
        'inventory_items', 'vendor', 'quantity', 'quantity_unit', 
        'purchase_amount', 'paid_amount'
    ]
    missing_fields = [field for field in required_fields if not data.get(field)]
    if missing_fields:
        return Response({
            "success": False,
            "message": f"Missing required fields: {', '.join(missing_fields)}"
        }, status=status.HTTP_400_BAD_REQUEST)

    # Replace None with empty strings where applicable
    for key in data:
        if data[key] is None:
            data[key] = ""

    data['farmer'] = farmer.id
    data['created_at'] = timezone.now()
    data['created_by'] = farmer.farmer_user.id

    serializer = MySeedsAddSerializer(data=data)
    if serializer.is_valid():
        seed_instance = serializer.save()

        # Handle resetting previous inventory (status to 1)
        inventory_type_id = data.get('inventory_type')
        new_inventory_item_id = data.get("inventory_items")

        if inventory_type_id and new_inventory_item_id:
            new_inventory_item = get_object_or_404(InventoryItems, id=new_inventory_item_id, status=0)

            try:
                last_inventory_item = MySeeds.objects.filter(
                    farmer=farmer,
                    inventory_type=seed_instance.inventory_type,
                    inventory_items__status=0
                ).latest('created_at')

                if last_inventory_item:
                    MySeeds.objects.filter(
                        farmer=farmer,
                        inventory_type=seed_instance.inventory_type,
                        inventory_items=last_inventory_item.inventory_items
                    ).update(status=1)
            except MySeeds.DoesNotExist:
                pass

            seed_instance.inventory_items = new_inventory_item
            total_quantity = MySeeds.objects.filter(
                farmer=farmer,
                inventory_type=inventory_type_id,
                inventory_items=new_inventory_item
            ).aggregate(total=Sum('quantity'))['total'] or 0
            seed_instance.available_quans = total_quantity
            seed_instance.save()

        # Document handling
        file_data = request.data.get('documents', None)
        formatted_documents = []
        if file_data:
            grouped_documents = {}

            for doc_data in file_data:
                file_type_id = doc_data.get('file_type')
                documents = doc_data.get('documents', [])

                if not documents:
                    return Response({
                        "success": False,
                        "message": f"No documents provided for file type {file_type_id}."
                    }, status=status.HTTP_400_BAD_REQUEST)

                if file_type_id is None:
                    new_file_type = doc_data.get('new_file_type')
                    if not new_file_type:
                        return Response({"error": "New file type required."}, status=status.HTTP_400_BAD_REQUEST)
                    file_type, _ = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=3)
                    file_type_id = file_type.id
                else:
                    file_type = get_object_or_404(DocumentCategory, id=file_type_id)

                if file_type_id not in grouped_documents:
                    grouped_documents[file_type_id] = []

                for i, document_base64 in enumerate(documents):
                    try:
                        if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
                            mime_type = validate_image_type(document_base64)
                            if mime_type:
                                document_data = document_base64.split(';base64,')[1]
                                document_bytes = base64.b64decode(document_data)
                                if len(document_bytes) > 10 * 1024 * 1024:
                                    return Response({'error': 'File too large. Max 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

                                ext = mime_type.split('/')[1]
                                document_name = f"seed_{farmer_id}_{file_type_id}_{i}.{ext}"
                                document_file = ContentFile(document_bytes, name=document_name)

                                seed_doc = MyseedsDocuments.objects.create(
                                    farmer=farmer,
                                    seeds=seed_instance,
                                    file_type=file_type,
                                    document=document_file,
                                    created_at=timezone.now(),
                                    created_by=farmer.farmer_user
                                )

                                grouped_documents[file_type_id].append({
                                    'document_id': seed_doc.id,
                                    'document_category': {'id': file_type.id, 'name': file_type.name},
                                    'upload_document': request.build_absolute_uri(seed_doc.document.url),
                                    'language': {"default": "en"}
                                })
                            else:
                                return Response({'error': 'Invalid MIME type.'}, status=status.HTTP_400_BAD_REQUEST)
                        else:
                            return Response({'error': 'Unsupported file format.'}, status=status.HTTP_400_BAD_REQUEST)
                    except Exception as e:
                        return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)

            for file_type_key, docs in grouped_documents.items():
                formatted_documents.append({
                    'category_id': file_type_key,
                    'documents': docs
                })

        # Update fields if present
        seed_instance.quantity = data.get("quantity", seed_instance.quantity)
        seed_instance.purchase_amount = data.get("purchase_amount", seed_instance.purchase_amount)
        seed_instance.description = data.get("description", seed_instance.description)
        seed_instance.save()

        # Optional: Create FarmerNotification if you want
        # FarmerNotification.objects.create(
        #     farmer=farmer,
        #     name='New Seed Purchase Created',
        #     message=f'{seed_instance.inventory_items.name}',
        #     type='Seeds'
        # )

        return Response({
            "success": True,
            "message": "Seed added successfully!",
            "data": serializer.data,
            "documents": formatted_documents,
            "language": {"default": "en"}
        }, status=status.HTTP_201_CREATED)

    return Response({
        "success": False,
        "message": "Validation failed.",
        "errors": serializer.errors
    }, status=status.HTTP_400_BAD_REQUEST)


# @api_view(['POST'])
# def create_inventory_with_documents(request):
#     if request.method == 'POST':
#         data = request.data

#         inventory_type_id = data.get('inventory_type')
#         try:
#             inventory_type = InventoryType.objects.get(id=inventory_type_id)
#         except InventoryType.DoesNotExist:
#             return Response({'error': 'Invalid inventory type'}, status=status.HTTP_400_BAD_REQUEST)

#         # Process different inventory types
#         # if inventory_type.id == 6:
#         #     # Fuel specific logic (simplified here)
#         #     try:
#         #         farmer = Farmer.objects.get(id=data.get('farmer'))
#         #         crop = MyCrop.objects.get(id=data.get('crop'))
#         #         inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
#         #         inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))
#         #     except (Farmer.DoesNotExist, MyCrop.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist):
#         #         return Response({'error': 'Invalid references to farmer, crop, category, or inventory items'}, status=status.HTTP_400_BAD_REQUEST)

#         #     # Fetch the last fuel instance for the selected inventory items and inventory type
#         #     fuel_instance = MyFuel.objects.filter(
#         #         inventory_items=inventory_items,
#         #         inventory_type=inventory_type,
#         #         farmer=farmer
#         #     ).order_by('-updated_at').first()

#         #     if not fuel_instance:
#         #         return Response({'error': 'No fuel records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

#         #     total_available_quans = fuel_instance.available_quans
#         #     quantity_utilized = Decimal(data.get('quantity_utilized', 0))

#         #     if quantity_utilized > total_available_quans:
#         #         return Response({'error': 'Not enough fuel available for the requested quantity'}, status=status.HTTP_400_BAD_REQUEST)

#         #     fuel_instance.available_quans -= quantity_utilized
#         #     fuel_instance.save()

#         #     available_quans_in_inventory = total_available_quans - quantity_utilized

#         #     # Update the previous MyFuel inventory item to inactive (status=1)
#         #     last_inventory_item = MyFuel.objects.filter(
#         #         farmer = farmer,
#         #         inventory_type=inventory_type,
#         #         inventory_items__status=0
#         #     ).latest('created_at')

#         #     if last_inventory_item:
#         #         MyFuel.objects.filter(
#         #             farmer = farmer,
#         #             inventory_type=inventory_type,
#         #             inventory_items=last_inventory_item.inventory_items
#         #         ).update(status=1)

#         #     # Update the previous MyInventory item to inactive (status=1)
#         #     last_inventory_item_inventory = MyInventory.objects.filter(
#         #         farmer = farmer,
#         #         inventory_type=inventory_type,
#         #         inventory_items=inventory_items,
#         #         status=0  # Only active items
#         #     ).order_by('-created_at').first()

#         #     if last_inventory_item_inventory:
#         #         # Set the previous MyInventory item as inactive (status=1)
#         #         last_inventory_item_inventory.status = 1
#         #         last_inventory_item_inventory.save()

#         #     # Create new inventory object
#         #     my_inventory = MyInventory.objects.create(
#         #         farmer=farmer,
#         #         date_of_consumption=data.get('date_of_consumption'),
#         #         crop=crop,
#         #         inventory_type=inventory_type,
#         #         inventory_category=inventory_category,
#         #         inventory_items=inventory_items,
#         #         quantity_utilized=quantity_utilized,
#         #         available_quans=available_quans_in_inventory,
#         #         description=data.get('description'),
#         #         status=0,  # New item is active (status=0)
#         #         created_at=timezone.now(),
#         #         updated_at=timezone.now(),
#         #     )

#         if inventory_type.id == 6:
#             # Fuel specific logic (simplified here)
#             try:
#                 farmer = Farmer.objects.get(id=data.get('farmer'))
#                 crop = MyCrop.objects.get(id=data.get('crop'))
#                 inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
#                 inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))
#             except (Farmer.DoesNotExist, MyCrop.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist) as e:
#                 return Response({'error': f'Invalid reference to: {str(e)}'}, status=status.HTTP_400_BAD_REQUEST)

#             # Fetch the last fuel instance for the selected inventory items and inventory type
#             fuel_instance = MyFuel.objects.filter(
#                 inventory_items=inventory_items,
#                 inventory_type=inventory_type,
#                 farmer=farmer
#             ).order_by('-updated_at').first()

#             if not fuel_instance:
#                 return Response({'error': 'No fuel records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

#             # Convert available_quans and quantity_utilized to Decimal
#             total_available_quans = Decimal(str(fuel_instance.available_quans))  # Ensure it's a Decimal
#             quantity_utilized = Decimal(str(data.get('quantity_utilized', 0)))  # Ensure quantity_utilized is Decimal

#             # Check if quantity_utilized is greater than total_available_quans
#             if quantity_utilized > total_available_quans:
#                 return Response({'error': 'Not enough fuel available for the requested quantity'}, status=status.HTTP_400_BAD_REQUEST)

#             # Update the fuel instance by reducing the available quantity
#             fuel_instance.available_quans = total_available_quans - quantity_utilized
#             fuel_instance.save()

#             available_quans_in_inventory = total_available_quans - quantity_utilized

#             # Update the previous MyFuel inventory item to inactive (status=1)
#             last_inventory_item = MyFuel.objects.filter(
#                 farmer=farmer,
#                 inventory_type=inventory_type,
#                 inventory_items__status=0  # Only active items
#             ).latest('created_at')  # Order by created_at to find the latest active inventory item

#             if last_inventory_item:
#                 # Set the last inventory item to inactive
#                 last_inventory_item.status = 1  # Mark as inactive (status=1)
#                 last_inventory_item.save()

#             # Update the previous MyInventory item to inactive (status=1)
#             last_inventory_item_inventory = MyInventory.objects.filter(
#                 farmer=farmer,
#                 inventory_type=inventory_type,
#                 inventory_items=inventory_items,
#                 status=0  # Only active items
#             ).order_by('-created_at').first()

#             if last_inventory_item_inventory:
#                 # Set the last inventory item to inactive (status=1)
#                 last_inventory_item_inventory.status = 1
#                 last_inventory_item_inventory.save()

#             # Create new inventory object
#             my_inventory = MyInventory.objects.create(
#                 farmer=farmer,
#                 date_of_consumption=data.get('date_of_consumption'),
#                 crop=crop,
#                 inventory_type=inventory_type,
#                 inventory_category=inventory_category,
#                 inventory_items=inventory_items,
#                 quantity_utilized=quantity_utilized,
#                 available_quans=available_quans_in_inventory,
#                 description=data.get('description'),
#                 status=0,  # New item is active (status=0)
#                 created_at=timezone.now(),
#                 updated_at=timezone.now(),
#             )

#         elif inventory_type.id == 2:
#             # For inventory type 2, these fields are required
#             try:
#                 farmer = Farmer.objects.get(id=data.get('farmer'))
#                 inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
#                 inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))
#                 crop = MyCrop.objects.get(id=data.get('crop'))
#                 date_of_consumption = data.get('date_of_consumption')
#                 usage_hours = data.get('usage_hours')

#                 # Ensure usage_hours is a valid number and convert to Decimal
#                 if usage_hours:
#                     usage_hours = Decimal(str(usage_hours))  # Ensure it's a Decimal for comparison or calculations
#                 else:
#                     usage_hours = Decimal('0')  # If not provided, assume 0 hours

#                 if not date_of_consumption:
#                     return Response({'error': 'Date of consumption is required for inventory type 2'}, status=status.HTTP_400_BAD_REQUEST)

#                 if not usage_hours or usage_hours <= 0:
#                     return Response({'error': 'Usage hours must be greater than zero for inventory type 2'}, status=status.HTTP_400_BAD_REQUEST)

#             except (Farmer.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist, MyCrop.DoesNotExist) as e:
#                 return Response({'error': f'Invalid reference to: {str(e)}'}, status=status.HTTP_400_BAD_REQUEST)

#             # Create new inventory object for type 2
#             my_inventory = MyInventory.objects.create(
#                 farmer=farmer,
#                 date_of_consumption=date_of_consumption,
#                 crop=crop,
#                 inventory_type=inventory_type,
#                 inventory_category=inventory_category,
#                 inventory_items=inventory_items,
#                 usage_hours=usage_hours,  # usage_hours is now a Decimal
#                 description=data.get('description'),
#                 status=0,  # New item is active (status=0)
#                 created_at=timezone.now(),
#                 updated_at=timezone.now(),
#             )

#         # elif inventory_type.id == 2:
#         #     # For inventory type 2, these fields are required
#         #     try:
#         #         farmer = Farmer.objects.get(id=data.get('farmer'))
#         #         inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
#         #         inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))
#         #         crop = MyCrop.objects.get(id=data.get('crop'))
#         #         date_of_consumption = data.get('date_of_consumption')
#         #         usage_hours = data.get('usage_hours')

#         #         if not date_of_consumption:
#         #             return Response({'error': 'Date of consumption is required for inventory type 2'}, status=status.HTTP_400_BAD_REQUEST)

#         #         if not usage_hours:
#         #             return Response({'error': 'Usage hours are required for inventory type 2'}, status=status.HTTP_400_BAD_REQUEST)

#         #     except (Farmer.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist, MyCrop.DoesNotExist):
#         #         return Response({'error': 'Invalid references to farmer, inventory category, inventory items, or crop'}, status=status.HTTP_400_BAD_REQUEST)

#         #     # Create new inventory object for type 2
#         #     my_inventory = MyInventory.objects.create(
#         #         farmer=farmer,
#         #         date_of_consumption=date_of_consumption,
#         #         crop=crop,
#         #         inventory_type=inventory_type,
#         #         inventory_category=inventory_category,
#         #         inventory_items=inventory_items,
#         #         usage_hours=usage_hours,
#         #         description=data.get('description'),
#         #         status=0,  # New item is active (status=0)
#         #         created_at=timezone.now(),
#         #         updated_at=timezone.now(),
#         #     )
 
#         # elif inventory_type.id == 4:
#         #     # Inventory type 4 specific logic (similar to inventory type 6 but without usage_hours)
#         #     try:
#         #         # Fetch necessary objects
#         #         farmer = Farmer.objects.get(id=data.get('farmer'))
#         #         crop = MyCrop.objects.get(id=data.get('crop'))
#         #         inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
#         #         inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))
#         #     except (Farmer.DoesNotExist, MyCrop.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist):
#         #         return Response({'error': 'Invalid references to farmer, crop, category, or inventory items'}, status=status.HTTP_400_BAD_REQUEST)

#         #     # Fetch the last inventory instance for the selected inventory items and inventory type
#         #     inventory_instance = MyInventory.objects.filter(
#         #         inventory_items=inventory_items,
#         #         inventory_type=inventory_type,
#         #         farmer=farmer
#         #     ).order_by('-updated_at').first()

#         #     if not inventory_instance:
#         #         return Response({'error': 'No inventory records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

#         #     total_available_quans = inventory_instance.available_quans
#         #     quantity_utilized = Decimal(data.get('quantity_utilized', 0))

#         #     if quantity_utilized > total_available_quans:
#         #         return Response({'error': 'Not enough available quantity for the requested quantity'}, status=status.HTTP_400_BAD_REQUEST)

#         #     # Deduct quantity from the inventory item
#         #     inventory_instance.available_quans -= quantity_utilized
#         #     inventory_instance.save()

#         #     available_quans_in_inventory = total_available_quans - quantity_utilized

#         #     # Update the previous MyInventory inventory item to inactive (status=1)
#         #     last_inventory_item_inventory = MyInventory.objects.filter(
#         #         farmer = farmer,
#         #         inventory_type=inventory_type,
#         #         inventory_items=inventory_items,
#         #         status=0  # Only active items
#         #     ).order_by('-created_at').first()

#         #     if last_inventory_item_inventory:
#         #         # Set the previous MyInventory item as inactive (status=1)

#         #         last_inventory_item_inventory.status = 1
#         #         last_inventory_item_inventory.save()

#         #     # Create new inventory object for inventory type 4
#         #     my_inventory = MyInventory.objects.create(
#         #         farmer=farmer,
#         #         date_of_consumption=data.get('date_of_consumption'),
#         #         crop=crop,
#         #         inventory_type=inventory_type,
#         #         inventory_category=inventory_category,
#         #         inventory_items=inventory_items,
#         #         quantity_utilized=quantity_utilized,
#         #         available_quans=available_quans_in_inventory,
#         #         description=data.get('description'),
#         #         status=0,  # New item is active (status=0)
#         #         created_at=timezone.now(),
#         #         updated_at=timezone.now(),
#         #     )

#         #     # Update the corresponding MyPesticides instance
#         #     if inventory_items.inventory_category.name == 'Pesticides':  # Ensure it is the correct category
#         #         try:
#         #             # Fetch the MyPesticides instance linked to the inventory items
#         #             pesticide_instance = MyPesticides.objects.get(farmer = farmer,inventory_items=inventory_items)
                    
#         #             # Deduct quantity from the available stock in MyPesticides
#         #             if pesticide_instance.available_quans >= quantity_utilized:
#         #                 pesticide_instance.available_quans -= quantity_utilized
#         #                 pesticide_instance.save()
#         #             else:
#         #                 return Response({'error': 'Not enough pesticides available in stock'}, status=status.HTTP_400_BAD_REQUEST)
#         #         except MyPesticides.DoesNotExist:
#         #             return Response({'error': 'Pesticides record not found for the selected inventory item'}, status=status.HTTP_400_BAD_REQUEST)

#         # elif inventory_type.id == 4:
#         #     # Inventory type 4 specific logic (similar to inventory type 6 but without usage_hours)
#         #     try:
#         #         # Fetch necessary objects
#         #         farmer = Farmer.objects.get(id=data.get('farmer'))
#         #         crop = MyCrop.objects.get(id=data.get('crop'))
#         #         inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
#         #         inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))
#         #     except (Farmer.DoesNotExist, MyCrop.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist):
#         #         return Response({'error': 'Invalid references to farmer, crop, category, or inventory items'}, status=status.HTTP_400_BAD_REQUEST)

#         #     # Fetch the last inventory instance for the selected inventory items and inventory type
#         #     inventory_instance = MyInventory.objects.filter(
#         #         inventory_items=inventory_items,
#         #         inventory_type=inventory_type,
#         #         farmer=farmer
#         #     ).order_by('-updated_at').first()

#         #     if not inventory_instance:
#         #         return Response({'error': 'No inventory records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

#         #     # Ensure total_available_quans is a Decimal
#         #     total_available_quans = Decimal(str(inventory_instance.available_quans))  # Convert to Decimal if it's a string
#         #     quantity_utilized = Decimal(data.get('quantity_utilized', 0))  # Ensure quantity_utilized is Decimal

#         #     if quantity_utilized > total_available_quans:
#         #         return Response({'error': 'Not enough available quantity for the requested quantity'}, status=status.HTTP_400_BAD_REQUEST)

#         #     # Deduct quantity from the inventory item

#         #     inventory_instance.available_quans = inventory_instance.available_quans - quantity_utilized
#         #     inventory_instance.save()

#         #     # inventory_instance.available_quans -= quantity_utilized
#         #     # inventory_instance.save()

#         #     available_quans_in_inventory = total_available_quans - quantity_utilized

#         #     # Update the previous MyInventory inventory item to inactive (status=1)
#         #     last_inventory_item_inventory = MyInventory.objects.filter(
#         #         farmer=farmer,
#         #         inventory_type=inventory_type,
#         #         inventory_items=inventory_items,
#         #         status=0  # Only active items
#         #     ).order_by('-created_at').first()

#         #     if last_inventory_item_inventory:
#         #         # Set the previous MyInventory item as inactive (status=1)
#         #         last_inventory_item_inventory.status = 1
#         #         last_inventory_item_inventory.save()

#         #     # Create new inventory object for inventory type 4
#         #     my_inventory = MyInventory.objects.create(
#         #         farmer=farmer,
#         #         date_of_consumption=data.get('date_of_consumption'),
#         #         crop=crop,
#         #         inventory_type=inventory_type,
#         #         inventory_category=inventory_category,
#         #         inventory_items=inventory_items,
#         #         quantity_utilized=quantity_utilized,
#         #         available_quans=available_quans_in_inventory,
#         #         description=data.get('description'),
#         #         status=0,  # New item is active (status=0)
#         #         created_at=timezone.now(),
#         #         updated_at=timezone.now(),
#         #     )

#         #     # Update the corresponding MyPesticides instance
#         #     if inventory_items.inventory_category.name == 'Pesticides':  # Ensure it is the correct category
#         #         try:
#         #             # Fetch the MyPesticides instance linked to the inventory items
#         #             pesticide_instance = MyPesticides.objects.get(farmer=farmer, inventory_items=inventory_items)
                    
#         #             # Deduct quantity from the available stock in MyPesticides
#         #             if pesticide_instance.available_quans >= quantity_utilized:
#         #                 pesticide_instance.available_quans -= quantity_utilized
#         #                 pesticide_instance.save()
#         #             else:
#         #                 return Response({'error': 'Not enough pesticides available in stock'}, status=status.HTTP_400_BAD_REQUEST)
#         #         except MyPesticides.DoesNotExist:
#         #             return Response({'error': 'Pesticides record not found for the selected inventory item'}, status=status.HTTP_400_BAD_REQUEST)

#         #new
#         elif inventory_type.id == 4:
#             # Inventory type 4 specific logic (similar to inventory type 6 but without usage_hours)
#             try:
#                 # Fetch necessary objects
#                 farmer = Farmer.objects.get(id=data.get('farmer'))
#                 crop = MyCrop.objects.get(id=data.get('crop'))
#                 inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
#                 inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))
#             except (Farmer.DoesNotExist, MyCrop.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist):
#                 return Response({'error': 'Invalid references to farmer, crop, category, or inventory items'}, status=status.HTTP_400_BAD_REQUEST)

#             # Fetch the last inventory instance for the selected inventory items and inventory type
#             inventory_instance = MyInventory.objects.filter(
#                 inventory_items=inventory_items,
#                 inventory_type=inventory_type,
#                 farmer=farmer
#             ).order_by('-updated_at').first()

#             if not inventory_instance:
#                 return Response({'error': 'No inventory records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

#             # Ensure total_available_quans is a Decimal
#             total_available_quans = Decimal(str(inventory_instance.available_quans))  # Convert to Decimal if it's a string
#             quantity_utilized = Decimal(data.get('quantity_utilized', 0))  # Ensure quantity_utilized is Decimal

#             if quantity_utilized > total_available_quans:
#                 return Response({'error': 'Not enough available quantity for the requested quantity'}, status=status.HTTP_400_BAD_REQUEST)

#             # Deduct quantity from the inventory item
#             inventory_instance.available_quans = total_available_quans - quantity_utilized  # Fixed line
#             inventory_instance.save()

#             available_quans_in_inventory = total_available_quans - quantity_utilized

#             # Update the previous MyInventory inventory item to inactive (status=1)
#             last_inventory_item_inventory = MyInventory.objects.filter(
#                 farmer=farmer,
#                 inventory_type=inventory_type,
#                 inventory_items=inventory_items,
#                 status=0  # Only active items
#             ).order_by('-created_at').first()

#             if last_inventory_item_inventory:
#                 # Set the previous MyInventory item as inactive (status=1)
#                 last_inventory_item_inventory.status = 1
#                 last_inventory_item_inventory.save()

#             # Create new inventory object for inventory type 4
#             my_inventory = MyInventory.objects.create(
#                 farmer=farmer,
#                 date_of_consumption=data.get('date_of_consumption'),
#                 crop=crop,
#                 inventory_type=inventory_type,
#                 inventory_category=inventory_category,
#                 inventory_items=inventory_items,
#                 quantity_utilized=quantity_utilized,
#                 available_quans=available_quans_in_inventory,
#                 description=data.get('description'),
#                 status=0,  # New item is active (status=0)
#                 created_at=timezone.now(),
#                 updated_at=timezone.now(),
#             )

#             # Update the corresponding MyPesticides instance
#             if inventory_items.inventory_category.name == 'Pesticides':  # Ensure it is the correct category
#                 try:
#                     # Fetch the MyPesticides instance linked to the inventory items
#                     pesticide_instance = MyPesticides.objects.get(farmer=farmer, inventory_items=inventory_items)

#                     # Deduct quantity from the available stock in MyPesticides
#                     if pesticide_instance.available_quans >= quantity_utilized:
#                         pesticide_instance.available_quans -= quantity_utilized
#                         pesticide_instance.save()
#                     else:
#                         return Response({'error': 'Not enough pesticides available in stock'}, status=status.HTTP_400_BAD_REQUEST)
#                 except MyPesticides.DoesNotExist:
#                     return Response({'error': 'Pesticides record not found for the selected inventory item'}, status=status.HTTP_400_BAD_REQUEST)



#         # elif inventory_type.id == 7:
#         #     # Inventory type 4 specific logic (similar to inventory type 6 but without usage_hours)
#         #     try:
#         #         # Fetch necessary objects
#         #         farmer = Farmer.objects.get(id=data.get('farmer'))
#         #         crop = MyCrop.objects.get(id=data.get('crop'))
#         #         inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
#         #         inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))
#         #     except (Farmer.DoesNotExist, MyCrop.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist):
#         #         return Response({'error': 'Invalid references to farmer, crop, category, or inventory items'}, status=status.HTTP_400_BAD_REQUEST)

#         #     # Fetch the last inventory instance for the selected inventory items and inventory type
#         #     inventory_instance = MyInventory.objects.filter(
#         #         inventory_items=inventory_items,
#         #         inventory_type=inventory_type,
#         #         farmer=farmer
#         #     ).order_by('-updated_at').first()

#         #     if not inventory_instance:
#         #         return Response({'error': 'No inventory records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

#         #     total_available_quans = inventory_instance.available_quans
#         #     quantity_utilized = Decimal(data.get('quantity_utilized', 0))

#         #     if quantity_utilized > total_available_quans:
#         #         return Response({'error': 'Not enough available quantity for the requested quantity'}, status=status.HTTP_400_BAD_REQUEST)

#         #     # Deduct quantity from the inventory item
#         #     inventory_instance.available_quans -= quantity_utilized
#         #     inventory_instance.save()

#         #     available_quans_in_inventory = total_available_quans - quantity_utilized

#         #     # Update the previous MyInventory inventory item to inactive (status=1)
#         #     last_inventory_item_inventory = MyInventory.objects.filter(
#         #         farmer = farmer,
#         #         inventory_type=inventory_type,
#         #         inventory_items=inventory_items,
#         #         status=0  # Only active items
#         #     ).order_by('-created_at').first()

#         #     if last_inventory_item_inventory:
#         #         # Set the previous MyInventory item as inactive (status=1)
#         #         last_inventory_item_inventory.status = 1
#         #         last_inventory_item_inventory.save()

#         #     # Create new inventory object for inventory type 4
#         #     my_inventory = MyInventory.objects.create(
#         #         farmer=farmer,
#         #         date_of_consumption=data.get('date_of_consumption'),
#         #         crop=crop,
#         #         inventory_type=inventory_type,
#         #         inventory_category=inventory_category,
#         #         inventory_items=inventory_items,
#         #         quantity_utilized=quantity_utilized,
#         #         available_quans=available_quans_in_inventory,
#         #         description=data.get('description'),
#         #         status=0,  # New item is active (status=0)
#         #         created_at=timezone.now(),
#         #         updated_at=timezone.now(),
#         #     )

#         #     # Update the corresponding MyPesticides instance
#         #     if inventory_items.inventory_category.name == 'Seeds':  # Ensure it is the correct category
#         #         try:
#         #             # Fetch the MyPesticides instance linked to the inventory items
#         #             pesticide_instance = MySeeds.objects.get(farmer = farmer,inventory_items=inventory_items)
                    
#         #             # Deduct quantity from the available stock in MyPesticides
#         #             if pesticide_instance.available_quans >= quantity_utilized:
#         #                 pesticide_instance.available_quans -= quantity_utilized
#         #                 pesticide_instance.save()
#         #             else:
#         #                 return Response({'error': 'Not enough pesticides available in stock'}, status=status.HTTP_400_BAD_REQUEST)
#         #         except MySeeds.DoesNotExist:
#         #             return Response({'error': 'Pesticides record not found for the selected inventory item'}, status=status.HTTP_400_BAD_REQUEST)

#         # elif inventory_type.id == 7:
#         #     # Inventory type 7 specific logic (similar to inventory type 6 but without usage_hours)
#         #     try:
#         #         # Fetch necessary objects
#         #         farmer = Farmer.objects.get(id=data.get('farmer'))
#         #         crop = MyCrop.objects.get(id=data.get('crop'))
#         #         inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
#         #         inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))
#         #     except (Farmer.DoesNotExist, MyCrop.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist):
#         #         return Response({'error': 'Invalid references to farmer, crop, category, or inventory items'}, status=status.HTTP_400_BAD_REQUEST)

#         #     # Fetch the last inventory instance for the selected inventory items and inventory type
#         #     inventory_instance = MyInventory.objects.filter(
#         #         inventory_items=inventory_items,
#         #         inventory_type=inventory_type,
#         #         farmer=farmer
#         #     ).order_by('-updated_at').first()

#         #     if not inventory_instance:
#         #         return Response({'error': 'No inventory records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

#         #     # Ensure total_available_quans is a Decimal
#         #     total_available_quans = Decimal(str(inventory_instance.available_quans))  # Convert to Decimal if it's a string
#         #     quantity_utilized = Decimal(data.get('quantity_utilized', 0))  # Ensure quantity_utilized is Decimal

#         #     if quantity_utilized > total_available_quans:
#         #         return Response({'error': 'Not enough available quantity for the requested quantity'}, status=status.HTTP_400_BAD_REQUEST)

#         #     # Deduct quantity from the inventory item
#         #     inventory_instance.available_quans -= quantity_utilized
#         #     inventory_instance.save()

#         #     available_quans_in_inventory = total_available_quans - quantity_utilized

#         #     # Update the previous MyInventory inventory item to inactive (status=1)
#         #     last_inventory_item_inventory = MyInventory.objects.filter(
#         #         farmer=farmer,
#         #         inventory_type=inventory_type,
#         #         inventory_items=inventory_items,
#         #         status=0  # Only active items
#         #     ).order_by('-created_at').first()

#         #     if last_inventory_item_inventory:
#         #         # Set the previous MyInventory item as inactive (status=1)
#         #         last_inventory_item_inventory.status = 1
#         #         last_inventory_item_inventory.save()

#         #     # Create new inventory object for inventory type 7
#         #     my_inventory = MyInventory.objects.create(
#         #         farmer=farmer,
#         #         date_of_consumption=data.get('date_of_consumption'),
#         #         crop=crop,
#         #         inventory_type=inventory_type,
#         #         inventory_category=inventory_category,
#         #         inventory_items=inventory_items,
#         #         quantity_utilized=quantity_utilized,
#         #         available_quans=available_quans_in_inventory,
#         #         description=data.get('description'),
#         #         status=0,  # New item is active (status=0)
#         #         created_at=timezone.now(),
#         #         updated_at=timezone.now(),
#         #     )

#         #     # Update the corresponding MySeeds instance
#         #     if inventory_items.inventory_category.name == 'Seeds':  # Ensure it is the correct category
#         #         try:
#         #             # Fetch the MySeeds instance linked to the inventory items
#         #             seeds_instance = MySeeds.objects.get(farmer=farmer, inventory_items=inventory_items)
                    
#         #             # Deduct quantity from the available stock in MySeeds
#         #             if seeds_instance.available_quans >= quantity_utilized:
#         #                 seeds_instance.available_quans -= quantity_utilized
#         #                 seeds_instance.save()
#         #             else:
#         #                 return Response({'error': 'Not enough seeds available in stock'}, status=status.HTTP_400_BAD_REQUEST)
#         #         except MySeeds.DoesNotExist:
#         #             return Response({'error': 'Seeds record not found for the selected inventory item'}, status=status.HTTP_400_BAD_REQUEST)

#         #new
#         elif inventory_type.id == 7:
#             # Inventory type 7 specific logic (similar to inventory type 6 but without usage_hours)
#             try:
#                 # Fetch necessary objects
#                 farmer = Farmer.objects.get(id=data.get('farmer'))
#                 crop = MyCrop.objects.get(id=data.get('crop'))
#                 inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
#                 inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))
#             except (Farmer.DoesNotExist, MyCrop.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist):
#                 return Response({'error': 'Invalid references to farmer, crop, category, or inventory items'}, status=status.HTTP_400_BAD_REQUEST)

#             # Fetch the last inventory instance for the selected inventory items and inventory type
#             inventory_instance = MyInventory.objects.filter(
#                 inventory_items=inventory_items,
#                 inventory_type=inventory_type,
#                 farmer=farmer
#             ).order_by('-updated_at').first()

#             if not inventory_instance:
#                 return Response({'error': 'No inventory records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

#             # Ensure total_available_quans is a Decimal
#             total_available_quans = Decimal(str(inventory_instance.available_quans))  # Convert to Decimal if it's a string
#             quantity_utilized = Decimal(data.get('quantity_utilized', 0))  # Ensure quantity_utilized is Decimal

#             if quantity_utilized > total_available_quans:
#                 return Response({'error': 'Not enough available quantity for the requested quantity'}, status=status.HTTP_400_BAD_REQUEST)

#             # Deduct quantity from the inventory item
#             inventory_instance.available_quans = total_available_quans - quantity_utilized  # Fixed line
#             inventory_instance.save()

#             available_quans_in_inventory = total_available_quans - quantity_utilized

#             # Update the previous MyInventory inventory item to inactive (status=1)
#             last_inventory_item_inventory = MyInventory.objects.filter(
#                 farmer=farmer,
#                 inventory_type=inventory_type,
#                 inventory_items=inventory_items,
#                 status=0  # Only active items
#             ).order_by('-created_at').first()

#             if last_inventory_item_inventory:
#                 # Set the previous MyInventory item as inactive (status=1)
#                 last_inventory_item_inventory.status = 1
#                 last_inventory_item_inventory.save()

#             # Create new inventory object for inventory type 7
#             my_inventory = MyInventory.objects.create(
#                 farmer=farmer,
#                 date_of_consumption=data.get('date_of_consumption'),
#                 crop=crop,
#                 inventory_type=inventory_type,
#                 inventory_category=inventory_category,
#                 inventory_items=inventory_items,
#                 quantity_utilized=quantity_utilized,
#                 available_quans=available_quans_in_inventory,
#                 description=data.get('description'),
#                 status=0,  # New item is active (status=0)
#                 created_at=timezone.now(),
#                 updated_at=timezone.now(),
#             )

#             # Update the corresponding MySeeds instance
#             if inventory_items.inventory_category.name == 'Seeds':  # Ensure it is the correct category
#                 try:
#                     # Fetch the MySeeds instance linked to the inventory items
#                     seeds_instance = MySeeds.objects.get(farmer=farmer, inventory_items=inventory_items)

#                     # Deduct quantity from the available stock in MySeeds
#                     if seeds_instance.available_quans >= quantity_utilized:
#                         seeds_instance.available_quans -= quantity_utilized
#                         seeds_instance.save()
#                     else:
#                         return Response({'error': 'Not enough seeds available in stock'}, status=status.HTTP_400_BAD_REQUEST)
#                 except MySeeds.DoesNotExist:
#                     return Response({'error': 'Seeds record not found for the selected inventory item'}, status=status.HTTP_400_BAD_REQUEST)

#         # elif inventory_type.id == 5:
#         #     # Inventory type 4 specific logic (similar to inventory type 6 but without usage_hours)
#         #     try:
#         #         # Fetch necessary objects
#         #         farmer = Farmer.objects.get(id=data.get('farmer'))
#         #         crop = MyCrop.objects.get(id=data.get('crop'))
#         #         inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
#         #         inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))
#         #     except (Farmer.DoesNotExist, MyCrop.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist):
#         #         return Response({'error': 'Invalid references to farmer, crop, category, or inventory items'}, status=status.HTTP_400_BAD_REQUEST)

#         #     # Fetch the last inventory instance for the selected inventory items and inventory type
#         #     inventory_instance = MyInventory.objects.filter(
#         #         inventory_items=inventory_items,
#         #         inventory_type=inventory_type,
#         #         farmer=farmer
#         #     ).order_by('-updated_at').first()

#         #     if not inventory_instance:
#         #         return Response({'error': 'No inventory records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

#         #     total_available_quans = inventory_instance.available_quans
#         #     quantity_utilized = Decimal(data.get('quantity_utilized', 0))

#         #     if quantity_utilized > total_available_quans:
#         #         return Response({'error': 'Not enough available quantity for the requested quantity'}, status=status.HTTP_400_BAD_REQUEST)

#         #     # Deduct quantity from the inventory item
#         #     inventory_instance.available_quans -= quantity_utilized
#         #     inventory_instance.save()

#         #     available_quans_in_inventory = total_available_quans - quantity_utilized

#         #     # Update the previous MyInventory inventory item to inactive (status=1)
#         #     last_inventory_item_inventory = MyInventory.objects.filter(farmer = farmer,
#         #         inventory_type=inventory_type,
#         #         inventory_items=inventory_items,
#         #         status=0  # Only active items
#         #     ).order_by('-created_at').first()

#         #     if last_inventory_item_inventory:
#         #         # Set the previous MyInventory item as inactive (status=1)
#         #         last_inventory_item_inventory.status = 1
#         #         last_inventory_item_inventory.save()

#         #     # Create new inventory object for inventory type 4
#         #     my_inventory = MyInventory.objects.create(
#         #         farmer=farmer,
#         #         date_of_consumption=data.get('date_of_consumption'),
#         #         crop=crop,
#         #         inventory_type=inventory_type,
#         #         inventory_category=inventory_category,
#         #         inventory_items=inventory_items,
#         #         quantity_utilized=quantity_utilized,
#         #         available_quans=available_quans_in_inventory,
#         #         description=data.get('description'),
#         #         status=0,  # New item is active (status=0)
#         #         created_at=timezone.now(),
#         #         updated_at=timezone.now(),
#         #     )

#         #     # Update the corresponding MyPesticides instance
#         #     if inventory_items.inventory_category.name == 'Fertilizers':  # Ensure it is the correct category
#         #         try:
#         #             # Fetch the MyPesticides instance linked to the inventory items
#         #             pesticide_instance = MyFertilizers.objects.get(farmer = farmer,inventory_items=inventory_items)
                    
#         #             # Deduct quantity from the available stock in MyPesticides
#         #             if pesticide_instance.available_quans >= quantity_utilized:
#         #                 pesticide_instance.available_quans -= quantity_utilized
#         #                 pesticide_instance.save()
#         #             else:
#         #                 return Response({'error': 'Not enough fertilizers available in stock'}, status=status.HTTP_400_BAD_REQUEST)
#         #         except MyFertilizers.DoesNotExist:
#         #             return Response({'error': 'Fertilizers record not found for the selected inventory item'}, status=status.HTTP_400_BAD_REQUEST)
  
#         # elif inventory_type.id == 5:
#         #     # Inventory type 5 specific logic (similar to inventory type 6 but without usage_hours)
#         #     try:
#         #         # Fetch necessary objects
#         #         farmer = Farmer.objects.get(id=data.get('farmer'))
#         #         crop = MyCrop.objects.get(id=data.get('crop'))
#         #         inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
#         #         inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))
#         #     except (Farmer.DoesNotExist, MyCrop.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist):
#         #         return Response({'error': 'Invalid references to farmer, crop, category, or inventory items'}, status=status.HTTP_400_BAD_REQUEST)

#         #     # Fetch the last inventory instance for the selected inventory items and inventory type
#         #     inventory_instance = MyInventory.objects.filter(
#         #         inventory_items=inventory_items,
#         #         inventory_type=inventory_type,
#         #         farmer=farmer
#         #     ).order_by('-updated_at').first()

#         #     if not inventory_instance:
#         #         return Response({'error': 'No inventory records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

#         #     # ðŸ”§ FIX: Convert to Decimal safely
#         #     total_available_quans = Decimal(str(inventory_instance.available_quans))
#         #     quantity_utilized = Decimal(str(data.get('quantity_utilized', '0')))

#         #     if quantity_utilized > total_available_quans:
#         #         return Response({'error': 'Not enough available quantity for the requested quantity'}, status=status.HTTP_400_BAD_REQUEST)

#         #     # Deduct quantity from the inventory item
#         #     inventory_instance.available_quans -= quantity_utilized
#         #     inventory_instance.save()

#         #     available_quans_in_inventory = total_available_quans - quantity_utilized

#         #     # Update the previous MyInventory inventory item to inactive (status=1)
#         #     last_inventory_item_inventory = MyInventory.objects.filter(
#         #         farmer=farmer,
#         #         inventory_type=inventory_type,
#         #         inventory_items=inventory_items,
#         #         status=0  # Only active items
#         #     ).order_by('-created_at').first()

#         #     if last_inventory_item_inventory:
#         #         # Set the previous MyInventory item as inactive (status=1)
#         #         last_inventory_item_inventory.status = 1
#         #         last_inventory_item_inventory.save()

#         #     # Create new inventory object for inventory type 5
#         #     my_inventory = MyInventory.objects.create(
#         #         farmer=farmer,
#         #         date_of_consumption=data.get('date_of_consumption'),
#         #         crop=crop,
#         #         inventory_type=inventory_type,
#         #         inventory_category=inventory_category,
#         #         inventory_items=inventory_items,
#         #         quantity_utilized=quantity_utilized,
#         #         available_quans=available_quans_in_inventory,
#         #         description=data.get('description'),
#         #         status=0,  # New item is active (status=0)
#         #         created_at=timezone.now(),
#         #         updated_at=timezone.now(),
#         #     )

#         #     # Update the corresponding MyFertilizers instance
#         #     if inventory_items.inventory_category.name == 'Fertilizers':  # Ensure it is the correct category
#         #         try:
#         #             fertilizer_instance = MyFertilizers.objects.get(
#         #                 farmer=farmer,
#         #                 inventory_items=inventory_items
#         #             )

#         #             if fertilizer_instance.available_quans >= quantity_utilized:
#         #                 fertilizer_instance.available_quans -= quantity_utilized
#         #                 fertilizer_instance.save()
#         #             else:
#         #                 return Response({'error': 'Not enough fertilizers available in stock'}, status=status.HTTP_400_BAD_REQUEST)

#         #         except MyFertilizers.DoesNotExist:
#         #             return Response({'error': 'Fertilizers record not found for the selected inventory item'}, status=status.HTTP_400_BAD_REQUEST)

#         #new
#         elif inventory_type.id == 5:
#             # Inventory type 5 specific logic (similar to inventory type 6 but without usage_hours)
#             try:
#                 # Fetch necessary objects
#                 farmer = Farmer.objects.get(id=data.get('farmer'))
#                 crop = MyCrop.objects.get(id=data.get('crop'))
#                 inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
#                 inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))
#             except (Farmer.DoesNotExist, MyCrop.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist):
#                 return Response({'error': 'Invalid references to farmer, crop, category, or inventory items'}, status=status.HTTP_400_BAD_REQUEST)

#             # Fetch the last inventory instance for the selected inventory items and inventory type
#             inventory_instance = MyInventory.objects.filter(
#                 inventory_items=inventory_items,
#                 inventory_type=inventory_type,
#                 farmer=farmer
#             ).order_by('-updated_at').first()

#             if not inventory_instance:
#                 return Response({'error': 'No inventory records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

#             # ðŸ”§ FIX: Convert to Decimal safely
#             total_available_quans = Decimal(str(inventory_instance.available_quans))
#             quantity_utilized = Decimal(str(data.get('quantity_utilized', '0')))

#             if quantity_utilized > total_available_quans:
#                 return Response({'error': 'Not enough available quantity for the requested quantity'}, status=status.HTTP_400_BAD_REQUEST)

#             # Deduct quantity from the inventory item
#             inventory_instance.available_quans = total_available_quans - quantity_utilized  # âœ… Fixed here
#             inventory_instance.save()

#             available_quans_in_inventory = total_available_quans - quantity_utilized

#             # Update the previous MyInventory inventory item to inactive (status=1)
#             last_inventory_item_inventory = MyInventory.objects.filter(
#                 farmer=farmer,
#                 inventory_type=inventory_type,
#                 inventory_items=inventory_items,
#                 status=0  # Only active items
#             ).order_by('-created_at').first()

#             if last_inventory_item_inventory:
#                 # Set the previous MyInventory item as inactive (status=1)
#                 last_inventory_item_inventory.status = 1
#                 last_inventory_item_inventory.save()

#             # Create new inventory object for inventory type 5
#             my_inventory = MyInventory.objects.create(
#                 farmer=farmer,
#                 date_of_consumption=data.get('date_of_consumption'),
#                 crop=crop,
#                 inventory_type=inventory_type,
#                 inventory_category=inventory_category,
#                 inventory_items=inventory_items,
#                 quantity_utilized=quantity_utilized,
#                 available_quans=available_quans_in_inventory,
#                 description=data.get('description'),
#                 status=0,  # New item is active (status=0)
#                 created_at=timezone.now(),
#                 updated_at=timezone.now(),
#             )

#             # Update the corresponding MyFertilizers instance
#             if inventory_items.inventory_category.name == 'Fertilizers':  # Ensure it is the correct category
#                 try:
#                     fertilizer_instance = MyFertilizers.objects.get(
#                         farmer=farmer,
#                         inventory_items=inventory_items
#                     )

#                     if fertilizer_instance.available_quans >= quantity_utilized:
#                         fertilizer_instance.available_quans -= quantity_utilized
#                         fertilizer_instance.save()
#                     else:
#                         return Response({'error': 'Not enough fertilizers available in stock'}, status=status.HTTP_400_BAD_REQUEST)

#                 except MyFertilizers.DoesNotExist:
#                     return Response({'error': 'Fertilizers record not found for the selected inventory item'}, status=status.HTTP_400_BAD_REQUEST)


#         # elif inventory_type.id == 3:  # MyTools specific logic (new part)
#         #     try:
#         #         # Get the necessary fields for MyTools
#         #         farmer = Farmer.objects.get(id=data.get('farmer'))
#         #         inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
#         #         inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))
#         #         # Ensure the necessary fields for tools
#         #         items = data.get('items', None)
#         #         usage_hours = Decimal(data.get('usage_hours', 0))
#         #         # Validate tools-related fields
#         #         if not items or not usage_hours:
#         #             return Response({'error': 'Items and usage_hours are required for tools inventory.'}, status=status.HTTP_400_BAD_REQUEST)
#         #     except (Farmer.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist):
#         #         return Response({'error': 'Invalid references to farmer, category, or inventory items'}, status=status.HTTP_400_BAD_REQUEST)

#         #     # Fetch the last tools instance for the selected inventory items and inventory type
#         #     tool_instance = MyTools.objects.filter(
#         #         inventory_items=inventory_items,
#         #         inventory_type=inventory_type,
#         #         farmer=farmer
#         #     ).order_by('-updated_at').first()

#         #     if not tool_instance:
#         #         return Response({'error': 'No tools records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

#         #     total_available_quans = tool_instance.available_quans
#         #     quantity_utilized = Decimal(data.get('quantity_utilized', 0))

#         #     if quantity_utilized > total_available_quans:
#         #         return Response({'error': 'Not enough tools available for the requested quantity'}, status=status.HTTP_400_BAD_REQUEST)

#         #     tool_instance.available_quans -= quantity_utilized
#         #     tool_instance.save()

#         #     available_quans_in_inventory = total_available_quans - quantity_utilized

#         #     # Update the previous MyTools inventory item to inactive (status=1)
#         #     last_inventory_item = MyTools.objects.filter(
#         #         farmer = farmer,
#         #         inventory_type=inventory_type,
#         #         inventory_items__status=0
#         #     ).latest('created_at')

#         #     if last_inventory_item:
#         #         MyTools.objects.filter(
#         #             farmer = farmer,
#         #             inventory_type=inventory_type,
#         #             inventory_items=last_inventory_item.inventory_items
#         #         ).update(status=1)

#         #     # Update the previous MyInventory item to inactive (status=1)
#         #     last_inventory_item_inventory = MyInventory.objects.filter(
#         #         farmer = farmer,
#         #         inventory_type=inventory_type,
#         #         inventory_items=inventory_items,
#         #         status=0  # Only active items
#         #     ).order_by('-created_at').first()

#         #     if last_inventory_item_inventory:
#         #         # Set the previous MyInventory item as inactive (status=1)
#         #         last_inventory_item_inventory.status = 1
#         #         last_inventory_item_inventory.save()

#         #     # Create new inventory object for MyTools
#         #     my_inventory = MyInventory.objects.create(
#         #         farmer=farmer,
#         #         date_of_consumption=data.get('date_of_consumption'),
#         #         inventory_type=inventory_type,
#         #         inventory_category=inventory_category,
#         #         inventory_items=inventory_items,
#         #         quantity_utilized=quantity_utilized,
#         #         available_quans=available_quans_in_inventory,
#         #         description=data.get('description'),
#         #         status=0,  # New item is active (status=0)
#         #         created_at=timezone.now(),
#         #         updated_at=timezone.now(),
#         #         start_kilometer=data.get('start_kilometer', None),
#         #         end_kilometer=data.get('end_kilometer', None),
#         #         usage_hours=usage_hours,
#         #         tool_items=items  # Store the tool items here
#         #     )


#         # elif inventory_type.id == 3:  # MyTools specific logic (new part)
#         #     try:
#         #         # Get the necessary fields for MyTools
#         #         farmer = Farmer.objects.get(id=data.get('farmer'))
#         #         inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
#         #         inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))
                
#         #         # Ensure the necessary fields for tools
#         #         items = data.get('items', None)
#         #         usage_hours = Decimal(data.get('usage_hours', 0))  # Make sure usage_hours is a Decimal
                
#         #         # Validate tools-related fields
#         #         if not items or usage_hours <= 0:
#         #             return Response({'error': 'Items and valid usage_hours are required for tools inventory.'}, status=status.HTTP_400_BAD_REQUEST)
#         #     except (Farmer.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist):
#         #         return Response({'error': 'Invalid references to farmer, category, or inventory items'}, status=status.HTTP_400_BAD_REQUEST)

#         #     # Fetch the last tools instance for the selected inventory items and inventory type
#         #     tool_instance = MyTools.objects.filter(
#         #         inventory_items=inventory_items,
#         #         inventory_type=inventory_type,
#         #         farmer=farmer
#         #     ).order_by('-updated_at').first()

#         #     if not tool_instance:
#         #         return Response({'error': 'No tools records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

#         #     # Ensure all values are Decimal before doing arithmetic/comparisons
#         #     total_available_quans = Decimal(str(tool_instance.available_quans))  # Ensure it's Decimal
#         #     quantity_utilized = Decimal(str(data.get('quantity_utilized', '0')))  # Ensure it's Decimal

#         #     if quantity_utilized > total_available_quans:
#         #         return Response({'error': 'Not enough tools available for the requested quantity'}, status=status.HTTP_400_BAD_REQUEST)

#         #     tool_instance.available_quans -= quantity_utilized
#         #     tool_instance.save()

#         #     available_quans_in_inventory = total_available_quans - quantity_utilized

#         #     # Update the previous MyTools inventory item to inactive (status=1)
#         #     last_inventory_item = MyTools.objects.filter(
#         #         farmer=farmer,
#         #         inventory_type=inventory_type,
#         #         inventory_items__status=0
#         #     ).latest('created_at')

#         #     if last_inventory_item:
#         #         MyTools.objects.filter(
#         #             farmer=farmer,
#         #             inventory_type=inventory_type,
#         #             inventory_items=last_inventory_item.inventory_items
#         #         ).update(status=1)

#         #     # Update the previous MyInventory item to inactive (status=1)
#         #     last_inventory_item_inventory = MyInventory.objects.filter(
#         #         farmer=farmer,
#         #         inventory_type=inventory_type,
#         #         inventory_items=inventory_items,
#         #         status=0  # Only active items
#         #     ).order_by('-created_at').first()

#         #     if last_inventory_item_inventory:
#         #         # Set the previous MyInventory item as inactive (status=1)
#         #         last_inventory_item_inventory.status = 1
#         #         last_inventory_item_inventory.save()

#         #     # Create new inventory object for MyTools
#         #     my_inventory = MyInventory.objects.create(
#         #         farmer=farmer,
#         #         date_of_consumption=data.get('date_of_consumption'),
#         #         inventory_type=inventory_type,
#         #         inventory_category=inventory_category,
#         #         inventory_items=inventory_items,
#         #         quantity_utilized=quantity_utilized,
#         #         available_quans=available_quans_in_inventory,
#         #         description=data.get('description'),
#         #         status=0,  # New item is active (status=0)
#         #         created_at=timezone.now(),
#         #         updated_at=timezone.now(),
#         #         start_kilometer=data.get('start_kilometer', None),
#         #         end_kilometer=data.get('end_kilometer', None),
#         #         usage_hours=usage_hours,
#         #         tool_items=items  # Store the tool items here
#         #     )

#         #new
#         elif inventory_type.id == 3:  # MyTools specific logic (new part)
#             try:
#                 # Get the necessary fields for MyTools
#                 farmer = Farmer.objects.get(id=data.get('farmer'))
#                 inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
#                 inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))
                
#                 # Ensure the necessary fields for tools
#                 items = data.get('items', None)
#                 usage_hours = Decimal(data.get('usage_hours', 0))  # Make sure usage_hours is a Decimal
                
#                 # Validate tools-related fields
#                 if not items or usage_hours <= 0:
#                     return Response({'error': 'Items and valid usage_hours are required for tools inventory.'}, status=status.HTTP_400_BAD_REQUEST)
#             except (Farmer.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist):
#                 return Response({'error': 'Invalid references to farmer, category, or inventory items'}, status=status.HTTP_400_BAD_REQUEST)

#             # Fetch the last tools instance for the selected inventory items and inventory type
#             tool_instance = MyTools.objects.filter(
#                 inventory_items=inventory_items,
#                 inventory_type=inventory_type,
#                 farmer=farmer
#             ).order_by('-updated_at').first()

#             if not tool_instance:
#                 return Response({'error': 'No tools records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

#             # Ensure all values are Decimal before doing arithmetic/comparisons
#             total_available_quans = Decimal(str(tool_instance.available_quans))  # Ensure it's Decimal
#             quantity_utilized = Decimal(str(data.get('quantity_utilized', '0')))  # Ensure it's Decimal

#             if quantity_utilized > total_available_quans:
#                 return Response({'error': 'Not enough tools available for the requested quantity'}, status=status.HTTP_400_BAD_REQUEST)

#             # ðŸ”§ Fixed: safer subtraction
#             tool_instance.available_quans = total_available_quans - quantity_utilized
#             tool_instance.save()

#             available_quans_in_inventory = total_available_quans - quantity_utilized

#             # Update the previous MyTools inventory item to inactive (status=1)
#             last_inventory_item = MyTools.objects.filter(
#                 farmer=farmer,
#                 inventory_type=inventory_type,
#                 inventory_items__status=0
#             ).latest('created_at')

#             if last_inventory_item:
#                 MyTools.objects.filter(
#                     farmer=farmer,
#                     inventory_type=inventory_type,
#                     inventory_items=last_inventory_item.inventory_items
#                 ).update(status=1)

#             # Update the previous MyInventory item to inactive (status=1)
#             last_inventory_item_inventory = MyInventory.objects.filter(
#                 farmer=farmer,
#                 inventory_type=inventory_type,
#                 inventory_items=inventory_items,
#                 status=0  # Only active items
#             ).order_by('-created_at').first()

#             if last_inventory_item_inventory:
#                 # Set the previous MyInventory item as inactive (status=1)
#                 last_inventory_item_inventory.status = 1
#                 last_inventory_item_inventory.save()

#             # Create new inventory object for MyTools
#             my_inventory = MyInventory.objects.create(
#                 farmer=farmer,
#                 date_of_consumption=data.get('date_of_consumption'),
#                 inventory_type=inventory_type,
#                 inventory_category=inventory_category,
#                 inventory_items=inventory_items,
#                 quantity_utilized=quantity_utilized,
#                 available_quans=available_quans_in_inventory,
#                 description=data.get('description'),
#                 status=0,  # New item is active (status=0)
#                 created_at=timezone.now(),
#                 updated_at=timezone.now(),
#                 start_kilometer=data.get('start_kilometer', None),
#                 end_kilometer=data.get('end_kilometer', None),
#                 usage_hours=usage_hours,
#                 tool_items=items  # Store the tool items here
#             )


#         # elif inventory_type.id == 1:  # MyVehicle specific logic (new part)
#         #     try:
#         #         # Get the necessary fields for MyVehicle
#         #         farmer = Farmer.objects.get(id=data.get('farmer'))
#         #         inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
#         #         inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))
#         #         crop = MyCrop.objects.get(id=data.get('crop'))  # Crop field is required for MyVehicle
#         #         start_kilometer = Decimal(data.get('start_kilometer', 0))  # Required
#         #         end_kilometer = Decimal(data.get('end_kilometer', 0))  # Required
#         #     except (Farmer.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist, MyCrop.DoesNotExist):
#         #         return Response({'error': 'Invalid references to farmer, category, inventory items or crop'}, status=status.HTTP_400_BAD_REQUEST)

#         #     # Check for required fields
#         #     if start_kilometer <= 0 or end_kilometer <= 0:
#         #         return Response({'error': 'Start and End kilometer must be greater than zero.'}, status=status.HTTP_400_BAD_REQUEST)

#         #     if start_kilometer >= end_kilometer:
#         #         return Response({'error': 'Start kilometer cannot be greater than or equal to End kilometer.'}, status=status.HTTP_400_BAD_REQUEST)

#         #     # Fetch the last MyVehicle instance for the selected inventory items and inventory type
#         #     vehicle_instance = MyVehicle.objects.filter(
#         #         inventory_items=inventory_items,
#         #         inventory_type=inventory_type,
#         #         farmer=farmer
#         #     ).order_by('-updated_at').first()

#         #     if not vehicle_instance:
#         #         return Response({'error': 'No vehicle records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

#         #     # total_available_quans = vehicle_instance.available_quans
#         #     # quantity_utilized = Decimal(data.get('quantity_utilized', 0))

#         #     # if quantity_utilized > total_available_quans:
#         #     #     return Response({'error': 'Not enough vehicles available for the requested quantity'}, status=status.HTTP_400_BAD_REQUEST)

#         #     # vehicle_instance.available_quans -= quantity_utilized
#         #     vehicle_instance.save()

#         #     # available_quans_in_inventory = total_available_quans - quantity_utilized

#         #     # Update the previous MyVehicle inventory item to inactive (status=1)
#         #     last_inventory_item = MyVehicle.objects.filter(
#         #         inventory_type=inventory_type,
#         #         inventory_items__status=0,
#         #         farmer = farmer,
#         #     ).latest('created_at')

#         #     if last_inventory_item:
#         #         MyVehicle.objects.filter(farmer = farmer,
#         #             inventory_type=inventory_type,
#         #             inventory_items=last_inventory_item.inventory_items
#         #         ).update(status=1)

#         #     # Update the previous MyInventory item to inactive (status=1)
#         #     last_inventory_item_inventory = MyInventory.objects.filter(farmer = farmer,
#         #         inventory_type=inventory_type,
#         #         inventory_items=inventory_items,
#         #         status=0  # Only active items
#         #     ).order_by('-created_at').first()

#         #     if last_inventory_item_inventory:
#         #         last_inventory_item_inventory.status = 1
#         #         last_inventory_item_inventory.save()

#         #     # Create new inventory object for MyVehicle
#         #     my_inventory = MyInventory.objects.create(
#         #         farmer=farmer,
#         #         date_of_consumption=data.get('date_of_consumption'),
#         #         crop=crop,
#         #         inventory_type=inventory_type,
#         #         inventory_category=inventory_category,
#         #         inventory_items=inventory_items,
#         #         # quantity_utilized=quantity_utilized,
#         #         # available_quans=available_quans_in_inventory,
#         #         description=data.get('description'),
#         #         status=0,  # New item is active (status=0)
#         #         created_at=timezone.now(),
#         #         updated_at=timezone.now(),
#         #         start_kilometer=start_kilometer,
#         #         end_kilometer=end_kilometer,
#         #     )
 
#         elif inventory_type.id == 1:  # MyVehicle specific logic (new part)
#             try:
#                 # Get the necessary fields for MyVehicle
#                 farmer = Farmer.objects.get(id=data.get('farmer'))
#                 inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
#                 inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))
#                 crop = MyCrop.objects.get(id=data.get('crop'))  # Crop field is required for MyVehicle
                
#                 # Convert start_kilometer and end_kilometer to Decimal
#                 start_kilometer = Decimal(data.get('start_kilometer', '0'))  # Make sure it is Decimal
#                 end_kilometer = Decimal(data.get('end_kilometer', '0'))  # Make sure it is Decimal
                
#             except (Farmer.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist, MyCrop.DoesNotExist):
#                 return Response({'error': 'Invalid references to farmer, category, inventory items or crop'}, status=status.HTTP_400_BAD_REQUEST)

#             # Check for required fields
#             if start_kilometer <= 0 or end_kilometer <= 0:
#                 return Response({'error': 'Start and End kilometer must be greater than zero.'}, status=status.HTTP_400_BAD_REQUEST)

#             if start_kilometer >= end_kilometer:
#                 return Response({'error': 'Start kilometer cannot be greater than or equal to End kilometer.'}, status=status.HTTP_400_BAD_REQUEST)

#             # Fetch the last MyVehicle instance for the selected inventory items and inventory type
#             vehicle_instance = MyVehicle.objects.filter(
#                 inventory_items=inventory_items,
#                 inventory_type=inventory_type,
#                 farmer=farmer
#             ).order_by('-updated_at').first()

#             if not vehicle_instance:
#                 return Response({'error': 'No vehicle records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

#             # No quantity utilized in MyVehicle logic, so we don't need to perform this check
#             # total_available_quans = vehicle_instance.available_quans
#             # quantity_utilized = Decimal(data.get('quantity_utilized', 0))

#             # vehicle_instance.available_quans -= quantity_utilized
#             vehicle_instance.save()

#             # available_quans_in_inventory = total_available_quans - quantity_utilized

#             # Update the previous MyVehicle inventory item to inactive (status=1)
#             last_inventory_item = MyVehicle.objects.filter(
#                 inventory_type=inventory_type,
#                 inventory_items__status=0,
#                 farmer=farmer,
#             ).latest('created_at')

#             if last_inventory_item:
#                 MyVehicle.objects.filter(farmer=farmer,
#                                         inventory_type=inventory_type,
#                                         inventory_items=last_inventory_item.inventory_items
#                                         ).update(status=1)

#             # Update the previous MyInventory item to inactive (status=1)
#             last_inventory_item_inventory = MyInventory.objects.filter(farmer=farmer,
#                 inventory_type=inventory_type,
#                 inventory_items=inventory_items,
#                 status=0  # Only active items
#             ).order_by('-created_at').first()

#             if last_inventory_item_inventory:
#                 last_inventory_item_inventory.status = 1
#                 last_inventory_item_inventory.save()

#             # Create new inventory object for MyVehicle
#             my_inventory = MyInventory.objects.create(
#                 farmer=farmer,
#                 date_of_consumption=data.get('date_of_consumption'),
#                 crop=crop,
#                 inventory_type=inventory_type,
#                 inventory_category=inventory_category,
#                 inventory_items=inventory_items,
#                 # quantity_utilized=quantity_utilized,
#                 # available_quans=available_quans_in_inventory,
#                 description=data.get('description'),
#                 status=0,  # New item is active (status=0)
#                 created_at=timezone.now(),
#                 updated_at=timezone.now(),
#                 start_kilometer=start_kilometer,
#                 end_kilometer=end_kilometer,
#             )


#         # Process documents if provided
#         file_data = request.data.get('documents', None)  # Get the documents if provided
#         if file_data:
#             # Initialize grouped documents to handle file_type categorization
#             grouped_documents = {}

#             # Process each document and its corresponding file_type
#             for doc_data in file_data:
#                 file_type_id = doc_data.get('file_type')
#                 documents = doc_data.get('documents', [])

#                 if not documents:
#                     return Response(
#                         {"success": False, "message": f"No documents provided for file type {file_type_id}."},
#                         status=status.HTTP_400_BAD_REQUEST
#                     )

#                 # Handle file type creation if necessary
#                 if file_type_id is None:
#                     new_file_type = doc_data.get('new_file_type')
#                     if not new_file_type:
#                         return Response({"error": f"New file type for document is required."}, status=status.HTTP_400_BAD_REQUEST)
                        
#                     # Create a new file type if not exists
#                     file_type, created = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=3)
#                 else:
#                     # Get the existing file type
#                     file_type = get_object_or_404(DocumentCategory, id=file_type_id)

#                 if file_type_id not in grouped_documents:
#                     grouped_documents[file_type_id] = []

#                 # Process the documents, creating document entries
#                 for i, document_base64 in enumerate(documents):
#                     try:
#                         # Validate MIME type (only image/jpeg, image/png, and application/pdf)
#                         if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
#                             mime_type = validate_image_type(document_base64)  # Validate the MIME type
#                             if mime_type:
#                                 # Extract the base64 data and decode it
#                                 document_data = document_base64.split(';base64,')[1]
#                                 document_bytes = base64.b64decode(document_data)

#                                 # Check file size (10MB max)
#                                 max_file_size = 10 * 1024 * 1024  # 10MB
#                                 if len(document_bytes) > max_file_size:
#                                     return Response({'error': f'File is too large. Max size is 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

#                                 # Create a document name and ContentFile
#                                 document_name = f"inventory_{my_inventory.id}_{file_type_id}_{i}.{mime_type.split('/')[1]}"
#                                 document_file = ContentFile(document_bytes, name=document_name)

#                                 # Create document instance and save it
#                                 document_instance = MyInventoryDocuments.objects.create(
#                                     farmer=farmer,
#                                     my_inventory=my_inventory,
#                                     file_type=file_type,
#                                     document=document_file,
#                                     created_at=timezone.now(),
#                                     created_by=farmer.farmer_user
#                                 )

#                                 # Append the document info to the grouped_documents list
#                                 document_data = {
#                                     'document_id': document_instance.id,
#                                     'document_category': {
#                                         'id': file_type.id,
#                                         'name': file_type.name
#                                     },
#                                     'upload_document': request.build_absolute_uri(f'/SuperAdmin{document_file.name}'),
#                                     'language': {
#                                         'default': 'en'
#                                     }
#                                 }

#                                 grouped_documents[file_type_id].append(document_data)
#                             else:
#                                 return Response({'error': 'Invalid MIME type for the document.'}, status=status.HTTP_400_BAD_REQUEST)
#                         else:
#                             return Response({'error': 'Invalid file format. Only image/jpeg, image/png, and application/pdf are allowed.'}, status=status.HTTP_400_BAD_REQUEST)

#                     except Exception as e:
#                         return Response({'error': f"Error processing document: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

#             # Return the grouped documents in the response
#             formatted_documents = []
#             for file_type_id, documents in grouped_documents.items():
#                 formatted_documents.append({
#                     'category_id': file_type_id,
#                     'documents': documents
#                 })

#             return Response({'success': True, 'formatted_documents': formatted_documents}, status=status.HTTP_200_OK)

#         return Response({'success': True, 'message': 'Inventory created successfully.'}, status=status.HTTP_200_OK)


#bala

@api_view(['POST'])
def create_inventory_with_documents(request):
    if request.method == 'POST':
        data = request.data

        inventory_type_id = data.get('inventory_type')
        try:
            inventory_type = InventoryType.objects.get(id=inventory_type_id)
        except InventoryType.DoesNotExist:
            return Response({'error': 'Invalid inventory type'}, status=status.HTTP_400_BAD_REQUEST)

        # Process different inventory types
        # if inventory_type.id == 6:
        #     # Fuel specific logic (simplified here)
        #     try:
        #         farmer = Farmer.objects.get(id=data.get('farmer'))
        #         crop = MyCrop.objects.get(id=data.get('crop'))
        #         inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
        #         inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))
        #     except (Farmer.DoesNotExist, MyCrop.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist):
        #         return Response({'error': 'Invalid references to farmer, crop, category, or inventory items'}, status=status.HTTP_400_BAD_REQUEST)

        #     # Fetch the last fuel instance for the selected inventory items and inventory type
        #     fuel_instance = MyFuel.objects.filter(
        #         inventory_items=inventory_items,
        #         inventory_type=inventory_type,
        #         farmer=farmer
        #     ).order_by('-updated_at').first()

        #     if not fuel_instance:
        #         return Response({'error': 'No fuel records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

        #     total_available_quans = fuel_instance.available_quans
        #     quantity_utilized = Decimal(data.get('quantity_utilized', 0))

        #     if quantity_utilized > total_available_quans:
        #         return Response({'error': 'Not enough fuel available for the requested quantity'}, status=status.HTTP_400_BAD_REQUEST)

        #     fuel_instance.available_quans -= quantity_utilized
        #     fuel_instance.save()

        #     available_quans_in_inventory = total_available_quans - quantity_utilized

        #     # Update the previous MyFuel inventory item to inactive (status=1)
        #     last_inventory_item = MyFuel.objects.filter(
        #         farmer = farmer,
        #         inventory_type=inventory_type,
        #         inventory_items__status=0
        #     ).latest('created_at')

        #     if last_inventory_item:
        #         MyFuel.objects.filter(
        #             farmer = farmer,
        #             inventory_type=inventory_type,
        #             inventory_items=last_inventory_item.inventory_items
        #         ).update(status=1)

        #     # Update the previous MyInventory item to inactive (status=1)
        #     last_inventory_item_inventory = MyInventory.objects.filter(
        #         farmer = farmer,
        #         inventory_type=inventory_type,
        #         inventory_items=inventory_items,
        #         status=0  # Only active items
        #     ).order_by('-created_at').first()

        #     if last_inventory_item_inventory:
        #         # Set the previous MyInventory item as inactive (status=1)
        #         last_inventory_item_inventory.status = 1
        #         last_inventory_item_inventory.save()

        #     # Create new inventory object
        #     my_inventory = MyInventory.objects.create(
        #         farmer=farmer,
        #         date_of_consumption=data.get('date_of_consumption'),
        #         crop=crop,
        #         inventory_type=inventory_type,
        #         inventory_category=inventory_category,
        #         inventory_items=inventory_items,
        #         quantity_utilized=quantity_utilized,
        #         available_quans=available_quans_in_inventory,
        #         description=data.get('description'),
        #         status=0,  # New item is active (status=0)
        #         created_at=timezone.now(),
        #         updated_at=timezone.now(),
        #     )

        if inventory_type.id == 6:
            # Fuel specific logic (simplified here)
            try:
                farmer = Farmer.objects.get(id=data.get('farmer'))
                crop = MyCrop.objects.get(id=data.get('crop'))
                # inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
                inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))
            except (Farmer.DoesNotExist, MyCrop.DoesNotExist,  InventoryItems.DoesNotExist) as e:
                return Response({'error': f'Invalid reference to: {str(e)}'}, status=status.HTTP_400_BAD_REQUEST)

            # Fetch the last fuel instance for the selected inventory items and inventory type
            fuel_instance = MyFuel.objects.filter(
                inventory_items=inventory_items,
                inventory_type=inventory_type,
                farmer=farmer
            ).order_by('-updated_at').first()

            if not fuel_instance:
                return Response({'error': 'No fuel records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

            # Convert available_quans and quantity_utilized to Decimal
            total_available_quans = Decimal(str(fuel_instance.available_quans))  # Ensure it's a Decimal
            quantity_utilized = Decimal(str(data.get('quantity_utilized', 0)))  # Ensure quantity_utilized is Decimal

            # Check if quantity_utilized is greater than total_available_quans
            if quantity_utilized > total_available_quans:
                return Response({'error': 'Not enough fuel available for the requested quantity'}, status=status.HTTP_400_BAD_REQUEST)

            # Update the fuel instance by reducing the available quantity
            fuel_instance.available_quans = total_available_quans - quantity_utilized
            fuel_instance.save()

            available_quans_in_inventory = total_available_quans - quantity_utilized

            # Update the previous MyFuel inventory item to inactive (status=1)
            last_inventory_item = MyFuel.objects.filter(
                farmer=farmer,
                inventory_type=inventory_type,
                inventory_items__status=0  # Only active items
            ).latest('created_at')  # Order by created_at to find the latest active inventory item

            if last_inventory_item:
                # Set the last inventory item to inactive
                last_inventory_item.status = 1  # Mark as inactive (status=1)
                last_inventory_item.save()

            # Update the previous MyInventory item to inactive (status=1)
            last_inventory_item_inventory = MyInventory.objects.filter(
                farmer=farmer,
                inventory_type=inventory_type,
                inventory_items=inventory_items,
                status=0  # Only active items
            ).order_by('-created_at').first()

            if last_inventory_item_inventory:
                # Set the last inventory item to inactive (status=1)
                last_inventory_item_inventory.status = 1
                last_inventory_item_inventory.save()

            # Create new inventory object
            my_inventory = MyInventory.objects.create(
                farmer=farmer,
                date_of_consumption=data.get('date_of_consumption'),
                crop=crop,
                inventory_type=inventory_type,
                # inventory_category=inventory_category,
                inventory_items=inventory_items,
                quantity_utilized=quantity_utilized,
                available_quans=available_quans_in_inventory,
                description=data.get('description'),
                status=0,  # New item is active (status=0)
                created_at=timezone.now(),
                updated_at=timezone.now(),
            )

        elif inventory_type.id == 2:
            # For inventory type 2, these fields are required
            try:
                farmer = Farmer.objects.get(id=data.get('farmer'))
                # inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
                inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))
                crop = MyCrop.objects.get(id=data.get('crop'))
                date_of_consumption = data.get('date_of_consumption')
                usage_hours = data.get('usage_hours')

                # Ensure usage_hours is a valid number and convert to Decimal
                if usage_hours:
                    usage_hours = Decimal(str(usage_hours))  # Ensure it's a Decimal for comparison or calculations
                else:
                    usage_hours = Decimal('0')  # If not provided, assume 0 hours

                if not date_of_consumption:
                    return Response({'error': 'Date of consumption is required for inventory type 2'}, status=status.HTTP_400_BAD_REQUEST)

                if not usage_hours or usage_hours <= 0:
                    return Response({'error': 'Usage hours must be greater than zero for inventory type 2'}, status=status.HTTP_400_BAD_REQUEST)

            except (Farmer.DoesNotExist,  InventoryItems.DoesNotExist, MyCrop.DoesNotExist) as e:
                return Response({'error': f'Invalid reference to: {str(e)}'}, status=status.HTTP_400_BAD_REQUEST)

            # Create new inventory object for type 2
            my_inventory = MyInventory.objects.create(
                farmer=farmer,
                date_of_consumption=date_of_consumption,
                crop=crop,
                inventory_type=inventory_type,
                # inventory_category=inventory_category,
                inventory_items=inventory_items,
                usage_hours=usage_hours,  # usage_hours is now a Decimal
                description=data.get('description'),
                status=0,  # New item is active (status=0)
                created_at=timezone.now(),
                updated_at=timezone.now(),
            )

        # elif inventory_type.id == 2:
        #     # For inventory type 2, these fields are required
        #     try:
        #         farmer = Farmer.objects.get(id=data.get('farmer'))
        #         inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
        #         inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))
        #         crop = MyCrop.objects.get(id=data.get('crop'))
        #         date_of_consumption = data.get('date_of_consumption')
        #         usage_hours = data.get('usage_hours')

        #         if not date_of_consumption:
        #             return Response({'error': 'Date of consumption is required for inventory type 2'}, status=status.HTTP_400_BAD_REQUEST)

        #         if not usage_hours:
        #             return Response({'error': 'Usage hours are required for inventory type 2'}, status=status.HTTP_400_BAD_REQUEST)

        #     except (Farmer.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist, MyCrop.DoesNotExist):
        #         return Response({'error': 'Invalid references to farmer, inventory category, inventory items, or crop'}, status=status.HTTP_400_BAD_REQUEST)

        #     # Create new inventory object for type 2
        #     my_inventory = MyInventory.objects.create(
        #         farmer=farmer,
        #         date_of_consumption=date_of_consumption,
        #         crop=crop,
        #         inventory_type=inventory_type,
        #         inventory_category=inventory_category,
        #         inventory_items=inventory_items,
        #         usage_hours=usage_hours,
        #         description=data.get('description'),
        #         status=0,  # New item is active (status=0)
        #         created_at=timezone.now(),
        #         updated_at=timezone.now(),
        #     )

        # elif inventory_type.id == 4:
        #     # Inventory type 4 specific logic (similar to inventory type 6 but without usage_hours)
        #     try:
        #         # Fetch necessary objects
        #         farmer = Farmer.objects.get(id=data.get('farmer'))
        #         crop = MyCrop.objects.get(id=data.get('crop'))
        #         inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
        #         inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))
        #     except (Farmer.DoesNotExist, MyCrop.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist):
        #         return Response({'error': 'Invalid references to farmer, crop, category, or inventory items'}, status=status.HTTP_400_BAD_REQUEST)

        #     # Fetch the last inventory instance for the selected inventory items and inventory type
        #     inventory_instance = MyInventory.objects.filter(
        #         inventory_items=inventory_items,
        #         inventory_type=inventory_type,
        #         farmer=farmer
        #     ).order_by('-updated_at').first()

        #     if not inventory_instance:
        #         return Response({'error': 'No inventory records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

        #     total_available_quans = inventory_instance.available_quans
        #     quantity_utilized = Decimal(data.get('quantity_utilized', 0))

        #     if quantity_utilized > total_available_quans:
        #         return Response({'error': 'Not enough available quantity for the requested quantity'}, status=status.HTTP_400_BAD_REQUEST)

        #     # Deduct quantity from the inventory item
        #     inventory_instance.available_quans -= quantity_utilized
        #     inventory_instance.save()

        #     available_quans_in_inventory = total_available_quans - quantity_utilized

        #     # Update the previous MyInventory inventory item to inactive (status=1)
        #     last_inventory_item_inventory = MyInventory.objects.filter(
        #         farmer = farmer,
        #         inventory_type=inventory_type,
        #         inventory_items=inventory_items,
        #         status=0  # Only active items
        #     ).order_by('-created_at').first()

        #     if last_inventory_item_inventory:
        #         # Set the previous MyInventory item as inactive (status=1)

        #         last_inventory_item_inventory.status = 1
        #         last_inventory_item_inventory.save()

        #     # Create new inventory object for inventory type 4
        #     my_inventory = MyInventory.objects.create(
        #         farmer=farmer,
        #         date_of_consumption=data.get('date_of_consumption'),
        #         crop=crop,
        #         inventory_type=inventory_type,
        #         inventory_category=inventory_category,
        #         inventory_items=inventory_items,
        #         quantity_utilized=quantity_utilized,
        #         available_quans=available_quans_in_inventory,
        #         description=data.get('description'),
        #         status=0,  # New item is active (status=0)
        #         created_at=timezone.now(),
        #         updated_at=timezone.now(),
        #     )

        #     # Update the corresponding MyPesticides instance
        #     if inventory_items.inventory_category.name == 'Pesticides':  # Ensure it is the correct category
        #         try:
        #             # Fetch the MyPesticides instance linked to the inventory items
        #             pesticide_instance = MyPesticides.objects.get(farmer = farmer,inventory_items=inventory_items)

        #             # Deduct quantity from the available stock in MyPesticides
        #             if pesticide_instance.available_quans >= quantity_utilized:
        #                 pesticide_instance.available_quans -= quantity_utilized
        #                 pesticide_instance.save()
        #             else:
        #                 return Response({'error': 'Not enough pesticides available in stock'}, status=status.HTTP_400_BAD_REQUEST)
        #         except MyPesticides.DoesNotExist:
        #             return Response({'error': 'Pesticides record not found for the selected inventory item'}, status=status.HTTP_400_BAD_REQUEST)

        # elif inventory_type.id == 4:
        #     # Inventory type 4 specific logic (similar to inventory type 6 but without usage_hours)
        #     try:
        #         # Fetch necessary objects
        #         farmer = Farmer.objects.get(id=data.get('farmer'))
        #         crop = MyCrop.objects.get(id=data.get('crop'))
        #         inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
        #         inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))
        #     except (Farmer.DoesNotExist, MyCrop.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist):
        #         return Response({'error': 'Invalid references to farmer, crop, category, or inventory items'}, status=status.HTTP_400_BAD_REQUEST)

        #     # Fetch the last inventory instance for the selected inventory items and inventory type
        #     inventory_instance = MyInventory.objects.filter(
        #         inventory_items=inventory_items,
        #         inventory_type=inventory_type,
        #         farmer=farmer
        #     ).order_by('-updated_at').first()

        #     if not inventory_instance:
        #         return Response({'error': 'No inventory records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

        #     # Ensure total_available_quans is a Decimal
        #     total_available_quans = Decimal(str(inventory_instance.available_quans))  # Convert to Decimal if it's a string
        #     quantity_utilized = Decimal(data.get('quantity_utilized', 0))  # Ensure quantity_utilized is Decimal

        #     if quantity_utilized > total_available_quans:
        #         return Response({'error': 'Not enough available quantity for the requested quantity'}, status=status.HTTP_400_BAD_REQUEST)

        #     # Deduct quantity from the inventory item

        #     inventory_instance.available_quans = inventory_instance.available_quans - quantity_utilized
        #     inventory_instance.save()

        #     # inventory_instance.available_quans -= quantity_utilized
        #     # inventory_instance.save()

        #     available_quans_in_inventory = total_available_quans - quantity_utilized

        #     # Update the previous MyInventory inventory item to inactive (status=1)
        #     last_inventory_item_inventory = MyInventory.objects.filter(
        #         farmer=farmer,
        #         inventory_type=inventory_type,
        #         inventory_items=inventory_items,
        #         status=0  # Only active items
        #     ).order_by('-created_at').first()

        #     if last_inventory_item_inventory:
        #         # Set the previous MyInventory item as inactive (status=1)
        #         last_inventory_item_inventory.status = 1
        #         last_inventory_item_inventory.save()

        #     # Create new inventory object for inventory type 4
        #     my_inventory = MyInventory.objects.create(
        #         farmer=farmer,
        #         date_of_consumption=data.get('date_of_consumption'),
        #         crop=crop,
        #         inventory_type=inventory_type,
        #         inventory_category=inventory_category,
        #         inventory_items=inventory_items,
        #         quantity_utilized=quantity_utilized,
        #         available_quans=available_quans_in_inventory,
        #         description=data.get('description'),
        #         status=0,  # New item is active (status=0)
        #         created_at=timezone.now(),
        #         updated_at=timezone.now(),
        #     )

        #     # Update the corresponding MyPesticides instance
        #     if inventory_items.inventory_category.name == 'Pesticides':  # Ensure it is the correct category
        #         try:
        #             # Fetch the MyPesticides instance linked to the inventory items
        #             pesticide_instance = MyPesticides.objects.get(farmer=farmer, inventory_items=inventory_items)

        #             # Deduct quantity from the available stock in MyPesticides
        #             if pesticide_instance.available_quans >= quantity_utilized:
        #                 pesticide_instance.available_quans -= quantity_utilized
        #                 pesticide_instance.save()
        #             else:
        #                 return Response({'error': 'Not enough pesticides available in stock'}, status=status.HTTP_400_BAD_REQUEST)
        #         except MyPesticides.DoesNotExist:
        #             return Response({'error': 'Pesticides record not found for the selected inventory item'}, status=status.HTTP_400_BAD_REQUEST)

        #new
        elif inventory_type.id == 4:
            # Inventory type 4 specific logic (similar to inventory type 6 but without usage_hours)
            try:
                # Fetch necessary objects
                farmer = Farmer.objects.get(id=data.get('farmer'))
                crop = MyCrop.objects.get(id=data.get('crop'))
                # inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
                inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))
            except (Farmer.DoesNotExist, MyCrop.DoesNotExist,  InventoryItems.DoesNotExist):
                return Response({'error': 'Invalid references to farmer, crop, category, or inventory items'}, status=status.HTTP_400_BAD_REQUEST)

            # Fetch the last inventory instance for the selected inventory items and inventory type
            inventory_instance = MyInventory.objects.filter(
                inventory_items=inventory_items,
                inventory_type=inventory_type,
                farmer=farmer
            ).order_by('-updated_at').first()

            if not inventory_instance:
                return Response({'error': 'No inventory records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

            # Ensure total_available_quans is a Decimal
            total_available_quans = Decimal(str(inventory_instance.available_quans))  # Convert to Decimal if it's a string
            quantity_utilized = Decimal(data.get('quantity_utilized', 0))  # Ensure quantity_utilized is Decimal

            if quantity_utilized > total_available_quans:
                return Response({'error': 'Not enough available quantity for the requested quantity'}, status=status.HTTP_400_BAD_REQUEST)

            # Deduct quantity from the inventory item
            inventory_instance.available_quans = total_available_quans - quantity_utilized  # Fixed line
            inventory_instance.save()

            available_quans_in_inventory = total_available_quans - quantity_utilized

            # Update the previous MyInventory inventory item to inactive (status=1)
            last_inventory_item_inventory = MyInventory.objects.filter(
                farmer=farmer,
                inventory_type=inventory_type,
                inventory_items=inventory_items,
                status=0  # Only active items
            ).order_by('-created_at').first()

            if last_inventory_item_inventory:
                # Set the previous MyInventory item as inactive (status=1)
                last_inventory_item_inventory.status = 1
                last_inventory_item_inventory.save()

            # Create new inventory object for inventory type 4
            my_inventory = MyInventory.objects.create(
                farmer=farmer,
                date_of_consumption=data.get('date_of_consumption'),
                crop=crop,
                inventory_type=inventory_type,
                # inventory_category=inventory_category,
                inventory_items=inventory_items,
                quantity_utilized=quantity_utilized,
                available_quans=available_quans_in_inventory,
                description=data.get('description'),
                status=0,  # New item is active (status=0)
                created_at=timezone.now(),
                updated_at=timezone.now(),
            )

            # Update the corresponding MyPesticides instance
            # if inventory_items.inventory_category.name == 'Pesticides':  # Ensure it is the correct category
            try:
                # Fetch the MyPesticides instance linked to the inventory items
                pesticide_instance = MyPesticides.objects.get(farmer=farmer, inventory_items=inventory_items)

                # Deduct quantity from the available stock in MyPesticides
                if pesticide_instance.available_quans >= quantity_utilized:
                    pesticide_instance.available_quans -= quantity_utilized
                    pesticide_instance.save()
                else:
                    return Response({'error': 'Not enough pesticides available in stock'}, status=status.HTTP_400_BAD_REQUEST)
            except MyPesticides.DoesNotExist:
                return Response({'error': 'Pesticides record not found for the selected inventory item'}, status=status.HTTP_400_BAD_REQUEST)



        # elif inventory_type.id == 7:
        #     # Inventory type 4 specific logic (similar to inventory type 6 but without usage_hours)
        #     try:
        #         # Fetch necessary objects
        #         farmer = Farmer.objects.get(id=data.get('farmer'))
        #         crop = MyCrop.objects.get(id=data.get('crop'))
        #         inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
        #         inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))
        #     except (Farmer.DoesNotExist, MyCrop.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist):
        #         return Response({'error': 'Invalid references to farmer, crop, category, or inventory items'}, status=status.HTTP_400_BAD_REQUEST)

        #     # Fetch the last inventory instance for the selected inventory items and inventory type
        #     inventory_instance = MyInventory.objects.filter(
        #         inventory_items=inventory_items,
        #         inventory_type=inventory_type,
        #         farmer=farmer
        #     ).order_by('-updated_at').first()

        #     if not inventory_instance:
        #         return Response({'error': 'No inventory records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

        #     total_available_quans = inventory_instance.available_quans
        #     quantity_utilized = Decimal(data.get('quantity_utilized', 0))

        #     if quantity_utilized > total_available_quans:
        #         return Response({'error': 'Not enough available quantity for the requested quantity'}, status=status.HTTP_400_BAD_REQUEST)

        #     # Deduct quantity from the inventory item
        #     inventory_instance.available_quans -= quantity_utilized
        #     inventory_instance.save()

        #     available_quans_in_inventory = total_available_quans - quantity_utilized

        #     # Update the previous MyInventory inventory item to inactive (status=1)
        #     last_inventory_item_inventory = MyInventory.objects.filter(
        #         farmer = farmer,
        #         inventory_type=inventory_type,
        #         inventory_items=inventory_items,
        #         status=0  # Only active items
        #     ).order_by('-created_at').first()

        #     if last_inventory_item_inventory:
        #         # Set the previous MyInventory item as inactive (status=1)
        #         last_inventory_item_inventory.status = 1
        #         last_inventory_item_inventory.save()

        #     # Create new inventory object for inventory type 4
        #     my_inventory = MyInventory.objects.create(
        #         farmer=farmer,
        #         date_of_consumption=data.get('date_of_consumption'),
        #         crop=crop,
        #         inventory_type=inventory_type,
        #         inventory_category=inventory_category,
        #         inventory_items=inventory_items,
        #         quantity_utilized=quantity_utilized,
        #         available_quans=available_quans_in_inventory,
        #         description=data.get('description'),
        #         status=0,  # New item is active (status=0)
        #         created_at=timezone.now(),
        #         updated_at=timezone.now(),
        #     )

        #     # Update the corresponding MyPesticides instance
        #     if inventory_items.inventory_category.name == 'Seeds':  # Ensure it is the correct category
        #         try:
        #             # Fetch the MyPesticides instance linked to the inventory items
        #             pesticide_instance = MySeeds.objects.get(farmer = farmer,inventory_items=inventory_items)

        #             # Deduct quantity from the available stock in MyPesticides
        #             if pesticide_instance.available_quans >= quantity_utilized:
        #                 pesticide_instance.available_quans -= quantity_utilized
        #                 pesticide_instance.save()
        #             else:
        #                 return Response({'error': 'Not enough pesticides available in stock'}, status=status.HTTP_400_BAD_REQUEST)
        #         except MySeeds.DoesNotExist:
        #             return Response({'error': 'Pesticides record not found for the selected inventory item'}, status=status.HTTP_400_BAD_REQUEST)

        # elif inventory_type.id == 7:
        #     # Inventory type 7 specific logic (similar to inventory type 6 but without usage_hours)
        #     try:
        #         # Fetch necessary objects
        #         farmer = Farmer.objects.get(id=data.get('farmer'))
        #         crop = MyCrop.objects.get(id=data.get('crop'))
        #         inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
        #         inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))
        #     except (Farmer.DoesNotExist, MyCrop.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist):
        #         return Response({'error': 'Invalid references to farmer, crop, category, or inventory items'}, status=status.HTTP_400_BAD_REQUEST)

        #     # Fetch the last inventory instance for the selected inventory items and inventory type
        #     inventory_instance = MyInventory.objects.filter(
        #         inventory_items=inventory_items,
        #         inventory_type=inventory_type,
        #         farmer=farmer
        #     ).order_by('-updated_at').first()

        #     if not inventory_instance:
        #         return Response({'error': 'No inventory records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

        #     # Ensure total_available_quans is a Decimal
        #     total_available_quans = Decimal(str(inventory_instance.available_quans))  # Convert to Decimal if it's a string
        #     quantity_utilized = Decimal(data.get('quantity_utilized', 0))  # Ensure quantity_utilized is Decimal

        #     if quantity_utilized > total_available_quans:
        #         return Response({'error': 'Not enough available quantity for the requested quantity'}, status=status.HTTP_400_BAD_REQUEST)

        #     # Deduct quantity from the inventory item
        #     inventory_instance.available_quans -= quantity_utilized
        #     inventory_instance.save()

        #     available_quans_in_inventory = total_available_quans - quantity_utilized

        #     # Update the previous MyInventory inventory item to inactive (status=1)
        #     last_inventory_item_inventory = MyInventory.objects.filter(
        #         farmer=farmer,
        #         inventory_type=inventory_type,
        #         inventory_items=inventory_items,
        #         status=0  # Only active items
        #     ).order_by('-created_at').first()

        #     if last_inventory_item_inventory:
        #         # Set the previous MyInventory item as inactive (status=1)
        #         last_inventory_item_inventory.status = 1
        #         last_inventory_item_inventory.save()

        #     # Create new inventory object for inventory type 7
        #     my_inventory = MyInventory.objects.create(
        #         farmer=farmer,
        #         date_of_consumption=data.get('date_of_consumption'),
        #         crop=crop,
        #         inventory_type=inventory_type,
        #         inventory_category=inventory_category,
        #         inventory_items=inventory_items,
        #         quantity_utilized=quantity_utilized,
        #         available_quans=available_quans_in_inventory,
        #         description=data.get('description'),
        #         status=0,  # New item is active (status=0)
        #         created_at=timezone.now(),
        #         updated_at=timezone.now(),
        #     )

        #     # Update the corresponding MySeeds instance
        #     if inventory_items.inventory_category.name == 'Seeds':  # Ensure it is the correct category
        #         try:
        #             # Fetch the MySeeds instance linked to the inventory items
        #             seeds_instance = MySeeds.objects.get(farmer=farmer, inventory_items=inventory_items)

        #             # Deduct quantity from the available stock in MySeeds
        #             if seeds_instance.available_quans >= quantity_utilized:
        #                 seeds_instance.available_quans -= quantity_utilized
        #                 seeds_instance.save()
        #             else:
        #                 return Response({'error': 'Not enough seeds available in stock'}, status=status.HTTP_400_BAD_REQUEST)
        #         except MySeeds.DoesNotExist:
        #             return Response({'error': 'Seeds record not found for the selected inventory item'}, status=status.HTTP_400_BAD_REQUEST)

        #new
        elif inventory_type.id == 7:
            # Inventory type 7 specific logic (similar to inventory type 6 but without usage_hours)
            try:
                # Fetch necessary objects
                farmer = Farmer.objects.get(id=data.get('farmer'))
                crop = MyCrop.objects.get(id=data.get('crop'))
                # inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
                inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))
            except (Farmer.DoesNotExist, MyCrop.DoesNotExist,  InventoryItems.DoesNotExist):
                return Response({'error': 'Invalid references to farmer, crop, category, or inventory items'}, status=status.HTTP_400_BAD_REQUEST)

            # Fetch the last inventory instance for the selected inventory items and inventory type
            inventory_instance = MyInventory.objects.filter(
                inventory_items=inventory_items,
                inventory_type=inventory_type,
                farmer=farmer
            ).order_by('-updated_at').first()

            if not inventory_instance:
                return Response({'error': 'No inventory records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

            # Ensure total_available_quans is a Decimal
            total_available_quans = Decimal(str(inventory_instance.available_quans))  # Convert to Decimal if it's a string
            quantity_utilized = Decimal(data.get('quantity_utilized', 0))  # Ensure quantity_utilized is Decimal

            if quantity_utilized > total_available_quans:
                return Response({'error': 'Not enough available quantity for the requested quantity'}, status=status.HTTP_400_BAD_REQUEST)

            # Deduct quantity from the inventory item
            inventory_instance.available_quans = total_available_quans - quantity_utilized  # Fixed line
            inventory_instance.save()

            available_quans_in_inventory = total_available_quans - quantity_utilized

            # Update the previous MyInventory inventory item to inactive (status=1)
            last_inventory_item_inventory = MyInventory.objects.filter(
                farmer=farmer,
                inventory_type=inventory_type,
                inventory_items=inventory_items,
                status=0  # Only active items
            ).order_by('-created_at').first()

            if last_inventory_item_inventory:
                # Set the previous MyInventory item as inactive (status=1)
                last_inventory_item_inventory.status = 1
                last_inventory_item_inventory.save()

            # Create new inventory object for inventory type 7
            my_inventory = MyInventory.objects.create(
                farmer=farmer,
                date_of_consumption=data.get('date_of_consumption'),
                crop=crop,
                inventory_type=inventory_type,
                # inventory_category=inventory_category,
                inventory_items=inventory_items,
                quantity_utilized=quantity_utilized,
                available_quans=available_quans_in_inventory,
                description=data.get('description'),
                status=0,  # New item is active (status=0)
                created_at=timezone.now(),
                updated_at=timezone.now(),
            )

            # Update the corresponding MySeeds instance
            # if inventory_items.inventory_category.name == 'Seeds':  # Ensure it is the correct category
            try:
                # Fetch the MySeeds instance linked to the inventory items
                seeds_instance = MySeeds.objects.get(farmer=farmer, inventory_items=inventory_items)

                # Deduct quantity from the available stock in MySeeds
                if seeds_instance.available_quans >= quantity_utilized:
                    seeds_instance.available_quans -= quantity_utilized
                    seeds_instance.save()
                else:
                    return Response({'error': 'Not enough seeds available in stock'}, status=status.HTTP_400_BAD_REQUEST)
            except MySeeds.DoesNotExist:
                return Response({'error': 'Seeds record not found for the selected inventory item'}, status=status.HTTP_400_BAD_REQUEST)

        # elif inventory_type.id == 5:
        #     # Inventory type 4 specific logic (similar to inventory type 6 but without usage_hours)
        #     try:
        #         # Fetch necessary objects
        #         farmer = Farmer.objects.get(id=data.get('farmer'))
        #         crop = MyCrop.objects.get(id=data.get('crop'))
        #         inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
        #         inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))
        #     except (Farmer.DoesNotExist, MyCrop.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist):
        #         return Response({'error': 'Invalid references to farmer, crop, category, or inventory items'}, status=status.HTTP_400_BAD_REQUEST)

        #     # Fetch the last inventory instance for the selected inventory items and inventory type
        #     inventory_instance = MyInventory.objects.filter(
        #         inventory_items=inventory_items,
        #         inventory_type=inventory_type,
        #         farmer=farmer
        #     ).order_by('-updated_at').first()

        #     if not inventory_instance:
        #         return Response({'error': 'No inventory records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

        #     total_available_quans = inventory_instance.available_quans
        #     quantity_utilized = Decimal(data.get('quantity_utilized', 0))

        #     if quantity_utilized > total_available_quans:
        #         return Response({'error': 'Not enough available quantity for the requested quantity'}, status=status.HTTP_400_BAD_REQUEST)

        #     # Deduct quantity from the inventory item
        #     inventory_instance.available_quans -= quantity_utilized
        #     inventory_instance.save()

        #     available_quans_in_inventory = total_available_quans - quantity_utilized

        #     # Update the previous MyInventory inventory item to inactive (status=1)
        #     last_inventory_item_inventory = MyInventory.objects.filter(farmer = farmer,
        #         inventory_type=inventory_type,
        #         inventory_items=inventory_items,
        #         status=0  # Only active items
        #     ).order_by('-created_at').first()

        #     if last_inventory_item_inventory:
        #         # Set the previous MyInventory item as inactive (status=1)
        #         last_inventory_item_inventory.status = 1
        #         last_inventory_item_inventory.save()

        #     # Create new inventory object for inventory type 4
        #     my_inventory = MyInventory.objects.create(
        #         farmer=farmer,
        #         date_of_consumption=data.get('date_of_consumption'),
        #         crop=crop,
        #         inventory_type=inventory_type,
        #         inventory_category=inventory_category,
        #         inventory_items=inventory_items,
        #         quantity_utilized=quantity_utilized,
        #         available_quans=available_quans_in_inventory,
        #         description=data.get('description'),
        #         status=0,  # New item is active (status=0)
        #         created_at=timezone.now(),
        #         updated_at=timezone.now(),
        #     )

        #     # Update the corresponding MyPesticides instance
        #     if inventory_items.inventory_category.name == 'Fertilizers':  # Ensure it is the correct category
        #         try:
        #             # Fetch the MyPesticides instance linked to the inventory items
        #             pesticide_instance = MyFertilizers.objects.get(farmer = farmer,inventory_items=inventory_items)

        #             # Deduct quantity from the available stock in MyPesticides
        #             if pesticide_instance.available_quans >= quantity_utilized:
        #                 pesticide_instance.available_quans -= quantity_utilized
        #                 pesticide_instance.save()
        #             else:
        #                 return Response({'error': 'Not enough fertilizers available in stock'}, status=status.HTTP_400_BAD_REQUEST)
        #         except MyFertilizers.DoesNotExist:
        #             return Response({'error': 'Fertilizers record not found for the selected inventory item'}, status=status.HTTP_400_BAD_REQUEST)

        # elif inventory_type.id == 5:
        #     # Inventory type 5 specific logic (similar to inventory type 6 but without usage_hours)
        #     try:
        #         # Fetch necessary objects
        #         farmer = Farmer.objects.get(id=data.get('farmer'))
        #         crop = MyCrop.objects.get(id=data.get('crop'))
        #         inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
        #         inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))
        #     except (Farmer.DoesNotExist, MyCrop.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist):
        #         return Response({'error': 'Invalid references to farmer, crop, category, or inventory items'}, status=status.HTTP_400_BAD_REQUEST)

        #     # Fetch the last inventory instance for the selected inventory items and inventory type
        #     inventory_instance = MyInventory.objects.filter(
        #         inventory_items=inventory_items,
        #         inventory_type=inventory_type,
        #         farmer=farmer
        #     ).order_by('-updated_at').first()

        #     if not inventory_instance:
        #         return Response({'error': 'No inventory records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

        #     # ðŸ”§ FIX: Convert to Decimal safely
        #     total_available_quans = Decimal(str(inventory_instance.available_quans))
        #     quantity_utilized = Decimal(str(data.get('quantity_utilized', '0')))

        #     if quantity_utilized > total_available_quans:
        #         return Response({'error': 'Not enough available quantity for the requested quantity'}, status=status.HTTP_400_BAD_REQUEST)

        #     # Deduct quantity from the inventory item
        #     inventory_instance.available_quans -= quantity_utilized
        #     inventory_instance.save()

        #     available_quans_in_inventory = total_available_quans - quantity_utilized

        #     # Update the previous MyInventory inventory item to inactive (status=1)
        #     last_inventory_item_inventory = MyInventory.objects.filter(
        #         farmer=farmer,
        #         inventory_type=inventory_type,
        #         inventory_items=inventory_items,
        #         status=0  # Only active items
        #     ).order_by('-created_at').first()

        #     if last_inventory_item_inventory:
        #         # Set the previous MyInventory item as inactive (status=1)
        #         last_inventory_item_inventory.status = 1
        #         last_inventory_item_inventory.save()

        #     # Create new inventory object for inventory type 5
        #     my_inventory = MyInventory.objects.create(
        #         farmer=farmer,
        #         date_of_consumption=data.get('date_of_consumption'),
        #         crop=crop,
        #         inventory_type=inventory_type,
        #         inventory_category=inventory_category,
        #         inventory_items=inventory_items,
        #         quantity_utilized=quantity_utilized,
        #         available_quans=available_quans_in_inventory,
        #         description=data.get('description'),
        #         status=0,  # New item is active (status=0)
        #         created_at=timezone.now(),
        #         updated_at=timezone.now(),
        #     )

        #     # Update the corresponding MyFertilizers instance
        #     if inventory_items.inventory_category.name == 'Fertilizers':  # Ensure it is the correct category
        #         try:
        #             fertilizer_instance = MyFertilizers.objects.get(
        #                 farmer=farmer,
        #                 inventory_items=inventory_items
        #             )

        #             if fertilizer_instance.available_quans >= quantity_utilized:
        #                 fertilizer_instance.available_quans -= quantity_utilized
        #                 fertilizer_instance.save()
        #             else:
        #                 return Response({'error': 'Not enough fertilizers available in stock'}, status=status.HTTP_400_BAD_REQUEST)

        #         except MyFertilizers.DoesNotExist:
        #             return Response({'error': 'Fertilizers record not found for the selected inventory item'}, status=status.HTTP_400_BAD_REQUEST)

        #new
        elif inventory_type.id == 5:
            # Inventory type 5 specific logic (similar to inventory type 6 but without usage_hours)
            try:
                # Fetch necessary objects
                farmer = Farmer.objects.get(id=data.get('farmer'))
                crop = MyCrop.objects.get(id=data.get('crop'))
                # inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
                inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))
            except (Farmer.DoesNotExist, MyCrop.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist):
                return Response({'error': 'Invalid references to farmer, crop, category, or inventory items'}, status=status.HTTP_400_BAD_REQUEST)

            # Fetch the last inventory instance for the selected inventory items and inventory type
            inventory_instance = MyInventory.objects.filter(
                inventory_items=inventory_items,
                inventory_type=inventory_type,
                farmer=farmer
            ).order_by('-updated_at').first()

            if not inventory_instance:
                return Response({'error': 'No inventory records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

            # ðŸ”§ FIX: Convert to Decimal safely
            total_available_quans = Decimal(str(inventory_instance.available_quans))
            quantity_utilized = Decimal(str(data.get('quantity_utilized', '0')))

            if quantity_utilized > total_available_quans:
                return Response({'error': 'Not enough available quantity for the requested quantity'}, status=status.HTTP_400_BAD_REQUEST)

            # Deduct quantity from the inventory item
            inventory_instance.available_quans = total_available_quans - quantity_utilized  # âœ… Fixed here
            inventory_instance.save()

            available_quans_in_inventory = total_available_quans - quantity_utilized

            # Update the previous MyInventory inventory item to inactive (status=1)
            last_inventory_item_inventory = MyInventory.objects.filter(
                farmer=farmer,
                inventory_type=inventory_type,
                inventory_items=inventory_items,
                status=0  # Only active items
            ).order_by('-created_at').first()

            if last_inventory_item_inventory:
                # Set the previous MyInventory item as inactive (status=1)
                last_inventory_item_inventory.status = 1
                last_inventory_item_inventory.save()

            # Create new inventory object for inventory type 5
            my_inventory = MyInventory.objects.create(
                farmer=farmer,
                date_of_consumption=data.get('date_of_consumption'),
                crop=crop,
                inventory_type=inventory_type,
                # inventory_category=inventory_category,
                inventory_items=inventory_items,
                quantity_utilized=quantity_utilized,
                available_quans=available_quans_in_inventory,
                description=data.get('description'),
                status=0,  # New item is active (status=0)
                created_at=timezone.now(),
                updated_at=timezone.now(),
            )

            # Update the corresponding MyFertilizers instance
            # if inventory_items.inventory_category.name == 'Fertilizers':  # Ensure it is the correct category
            try:
                fertilizer_instance = MyFertilizers.objects.get(
                    farmer=farmer,
                    inventory_items=inventory_items
                )

                if fertilizer_instance.available_quans >= quantity_utilized:
                    fertilizer_instance.available_quans -= quantity_utilized
                    fertilizer_instance.save()
                else:
                    return Response({'error': 'Not enough fertilizers available in stock'}, status=status.HTTP_400_BAD_REQUEST)

            except MyFertilizers.DoesNotExist:
                return Response({'error': 'Fertilizers record not found for the selected inventory item'}, status=status.HTTP_400_BAD_REQUEST)


        # elif inventory_type.id == 3:  # MyTools specific logic (new part)
        #     try:
        #         # Get the necessary fields for MyTools
        #         farmer = Farmer.objects.get(id=data.get('farmer'))
        #         inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
        #         inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))
        #         # Ensure the necessary fields for tools
        #         items = data.get('items', None)
        #         usage_hours = Decimal(data.get('usage_hours', 0))
        #         # Validate tools-related fields
        #         if not items or not usage_hours:
        #             return Response({'error': 'Items and usage_hours are required for tools inventory.'}, status=status.HTTP_400_BAD_REQUEST)
        #     except (Farmer.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist):
        #         return Response({'error': 'Invalid references to farmer, category, or inventory items'}, status=status.HTTP_400_BAD_REQUEST)

        #     # Fetch the last tools instance for the selected inventory items and inventory type
        #     tool_instance = MyTools.objects.filter(
        #         inventory_items=inventory_items,
        #         inventory_type=inventory_type,
        #         farmer=farmer
        #     ).order_by('-updated_at').first()

        #     if not tool_instance:
        #         return Response({'error': 'No tools records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

        #     total_available_quans = tool_instance.available_quans
        #     quantity_utilized = Decimal(data.get('quantity_utilized', 0))

        #     if quantity_utilized > total_available_quans:
        #         return Response({'error': 'Not enough tools available for the requested quantity'}, status=status.HTTP_400_BAD_REQUEST)

        #     tool_instance.available_quans -= quantity_utilized
        #     tool_instance.save()

        #     available_quans_in_inventory = total_available_quans - quantity_utilized

        #     # Update the previous MyTools inventory item to inactive (status=1)
        #     last_inventory_item = MyTools.objects.filter(
        #         farmer = farmer,
        #         inventory_type=inventory_type,
        #         inventory_items__status=0
        #     ).latest('created_at')

        #     if last_inventory_item:
        #         MyTools.objects.filter(
        #             farmer = farmer,
        #             inventory_type=inventory_type,
        #             inventory_items=last_inventory_item.inventory_items
        #         ).update(status=1)

        #     # Update the previous MyInventory item to inactive (status=1)
        #     last_inventory_item_inventory = MyInventory.objects.filter(
        #         farmer = farmer,
        #         inventory_type=inventory_type,
        #         inventory_items=inventory_items,
        #         status=0  # Only active items
        #     ).order_by('-created_at').first()

        #     if last_inventory_item_inventory:
        #         # Set the previous MyInventory item as inactive (status=1)
        #         last_inventory_item_inventory.status = 1
        #         last_inventory_item_inventory.save()

        #     # Create new inventory object for MyTools
        #     my_inventory = MyInventory.objects.create(
        #         farmer=farmer,
        #         date_of_consumption=data.get('date_of_consumption'),
        #         inventory_type=inventory_type,
        #         inventory_category=inventory_category,
        #         inventory_items=inventory_items,
        #         quantity_utilized=quantity_utilized,
        #         available_quans=available_quans_in_inventory,
        #         description=data.get('description'),
        #         status=0,  # New item is active (status=0)
        #         created_at=timezone.now(),
        #         updated_at=timezone.now(),
        #         start_kilometer=data.get('start_kilometer', None),
        #         end_kilometer=data.get('end_kilometer', None),
        #         usage_hours=usage_hours,
        #         tool_items=items  # Store the tool items here
        #     )


        # elif inventory_type.id == 3:  # MyTools specific logic (new part)
        #     try:
        #         # Get the necessary fields for MyTools
        #         farmer = Farmer.objects.get(id=data.get('farmer'))
        #         inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
        #         inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))

        #         # Ensure the necessary fields for tools
        #         items = data.get('items', None)
        #         usage_hours = Decimal(data.get('usage_hours', 0))  # Make sure usage_hours is a Decimal

        #         # Validate tools-related fields
        #         if not items or usage_hours <= 0:
        #             return Response({'error': 'Items and valid usage_hours are required for tools inventory.'}, status=status.HTTP_400_BAD_REQUEST)
        #     except (Farmer.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist):
        #         return Response({'error': 'Invalid references to farmer, category, or inventory items'}, status=status.HTTP_400_BAD_REQUEST)

        #     # Fetch the last tools instance for the selected inventory items and inventory type
        #     tool_instance = MyTools.objects.filter(
        #         inventory_items=inventory_items,
        #         inventory_type=inventory_type,
        #         farmer=farmer
        #     ).order_by('-updated_at').first()

        #     if not tool_instance:
        #         return Response({'error': 'No tools records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

        #     # Ensure all values are Decimal before doing arithmetic/comparisons
        #     total_available_quans = Decimal(str(tool_instance.available_quans))  # Ensure it's Decimal
        #     quantity_utilized = Decimal(str(data.get('quantity_utilized', '0')))  # Ensure it's Decimal

        #     if quantity_utilized > total_available_quans:
        #         return Response({'error': 'Not enough tools available for the requested quantity'}, status=status.HTTP_400_BAD_REQUEST)

        #     tool_instance.available_quans -= quantity_utilized
        #     tool_instance.save()

        #     available_quans_in_inventory = total_available_quans - quantity_utilized

        #     # Update the previous MyTools inventory item to inactive (status=1)
        #     last_inventory_item = MyTools.objects.filter(
        #         farmer=farmer,
        #         inventory_type=inventory_type,
        #         inventory_items__status=0
        #     ).latest('created_at')

        #     if last_inventory_item:
        #         MyTools.objects.filter(
        #             farmer=farmer,
        #             inventory_type=inventory_type,
        #             inventory_items=last_inventory_item.inventory_items
        #         ).update(status=1)

        #     # Update the previous MyInventory item to inactive (status=1)
        #     last_inventory_item_inventory = MyInventory.objects.filter(
        #         farmer=farmer,
        #         inventory_type=inventory_type,
        #         inventory_items=inventory_items,
        #         status=0  # Only active items
        #     ).order_by('-created_at').first()

        #     if last_inventory_item_inventory:
        #         # Set the previous MyInventory item as inactive (status=1)
        #         last_inventory_item_inventory.status = 1
        #         last_inventory_item_inventory.save()

        #     # Create new inventory object for MyTools
        #     my_inventory = MyInventory.objects.create(
        #         farmer=farmer,
        #         date_of_consumption=data.get('date_of_consumption'),
        #         inventory_type=inventory_type,
        #         inventory_category=inventory_category,
        #         inventory_items=inventory_items,
        #         quantity_utilized=quantity_utilized,
        #         available_quans=available_quans_in_inventory,
        #         description=data.get('description'),
        #         status=0,  # New item is active (status=0)
        #         created_at=timezone.now(),
        #         updated_at=timezone.now(),
        #         start_kilometer=data.get('start_kilometer', None),
        #         end_kilometer=data.get('end_kilometer', None),
        #         usage_hours=usage_hours,
        #         tool_items=items  # Store the tool items here
        #     )

        #new
        elif inventory_type.id == 3:  # MyTools specific logic (new part)
            try:
                # Get the necessary fields for MyTools
                farmer = Farmer.objects.get(id=data.get('farmer'))
                # inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
                inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))

                # Ensure the necessary fields for tools
                items = data.get('items', None)
                usage_hours = Decimal(data.get('usage_hours', 0))  # Make sure usage_hours is a Decimal

                # Validate tools-related fields
                if not items or usage_hours <= 0:
                    return Response({'error': 'Items and valid usage_hours are required for tools inventory.'}, status=status.HTTP_400_BAD_REQUEST)
            except (Farmer.DoesNotExist, InventoryItems.DoesNotExist):
                return Response({'error': 'Invalid references to farmer, category, or inventory items'}, status=status.HTTP_400_BAD_REQUEST)

            # Fetch the last tools instance for the selected inventory items and inventory type
            tool_instance = MyTools.objects.filter(
                inventory_items=inventory_items,
                inventory_type=inventory_type,
                farmer=farmer
            ).order_by('-updated_at').first()

            if not tool_instance:
                return Response({'error': 'No tools records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

            # Ensure all values are Decimal before doing arithmetic/comparisons
            total_available_quans = Decimal(str(tool_instance.available_quans))  # Ensure it's Decimal
            quantity_utilized = Decimal(str(data.get('quantity_utilized', '0')))  # Ensure it's Decimal

            if quantity_utilized > total_available_quans:
                return Response({'error': 'Not enough tools available for the requested quantity'}, status=status.HTTP_400_BAD_REQUEST)

            # ðŸ”§ Fixed: safer subtraction
            tool_instance.available_quans = total_available_quans - quantity_utilized
            tool_instance.save()

            available_quans_in_inventory = total_available_quans - quantity_utilized

            # Update the previous MyTools inventory item to inactive (status=1)
            last_inventory_item = MyTools.objects.filter(
                farmer=farmer,
                inventory_type=inventory_type,
                inventory_items__status=0
            ).latest('created_at')

            if last_inventory_item:
                MyTools.objects.filter(
                    farmer=farmer,
                    inventory_type=inventory_type,
                    inventory_items=last_inventory_item.inventory_items
                ).update(status=1)

            # Update the previous MyInventory item to inactive (status=1)
            last_inventory_item_inventory = MyInventory.objects.filter(
                farmer=farmer,
                inventory_type=inventory_type,
                inventory_items=inventory_items,
                status=0  # Only active items
            ).order_by('-created_at').first()

            if last_inventory_item_inventory:
                # Set the previous MyInventory item as inactive (status=1)
                last_inventory_item_inventory.status = 1
                last_inventory_item_inventory.save()

            # Create new inventory object for MyTools
            my_inventory = MyInventory.objects.create(
                farmer=farmer,
                date_of_consumption=data.get('date_of_consumption'),
                inventory_type=inventory_type,
                # inventory_category=inventory_category,
                inventory_items=inventory_items,
                quantity_utilized=quantity_utilized,
                available_quans=available_quans_in_inventory,
                description=data.get('description'),
                status=0,  # New item is active (status=0)
                created_at=timezone.now(),
                updated_at=timezone.now(),
                start_kilometer=data.get('start_kilometer', None),
                end_kilometer=data.get('end_kilometer', None),
                usage_hours=usage_hours,
                tool_items=items  # Store the tool items here
            )


        # elif inventory_type.id == 1:  # MyVehicle specific logic (new part)
        #     try:
        #         # Get the necessary fields for MyVehicle
        #         farmer = Farmer.objects.get(id=data.get('farmer'))
        #         inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
        #         inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))
        #         crop = MyCrop.objects.get(id=data.get('crop'))  # Crop field is required for MyVehicle
        #         start_kilometer = Decimal(data.get('start_kilometer', 0))  # Required
        #         end_kilometer = Decimal(data.get('end_kilometer', 0))  # Required
        #     except (Farmer.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist, MyCrop.DoesNotExist):
        #         return Response({'error': 'Invalid references to farmer, category, inventory items or crop'}, status=status.HTTP_400_BAD_REQUEST)

        #     # Check for required fields
        #     if start_kilometer <= 0 or end_kilometer <= 0:
        #         return Response({'error': 'Start and End kilometer must be greater than zero.'}, status=status.HTTP_400_BAD_REQUEST)

        #     if start_kilometer >= end_kilometer:
        #         return Response({'error': 'Start kilometer cannot be greater than or equal to End kilometer.'}, status=status.HTTP_400_BAD_REQUEST)

        #     # Fetch the last MyVehicle instance for the selected inventory items and inventory type
        #     vehicle_instance = MyVehicle.objects.filter(
        #         inventory_items=inventory_items,
        #         inventory_type=inventory_type,
        #         farmer=farmer
        #     ).order_by('-updated_at').first()

        #     if not vehicle_instance:
        #         return Response({'error': 'No vehicle records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

        #     # total_available_quans = vehicle_instance.available_quans
        #     # quantity_utilized = Decimal(data.get('quantity_utilized', 0))

        #     # if quantity_utilized > total_available_quans:
        #     #     return Response({'error': 'Not enough vehicles available for the requested quantity'}, status=status.HTTP_400_BAD_REQUEST)

        #     # vehicle_instance.available_quans -= quantity_utilized
        #     vehicle_instance.save()

        #     # available_quans_in_inventory = total_available_quans - quantity_utilized

        #     # Update the previous MyVehicle inventory item to inactive (status=1)
        #     last_inventory_item = MyVehicle.objects.filter(
        #         inventory_type=inventory_type,
        #         inventory_items__status=0,
        #         farmer = farmer,
        #     ).latest('created_at')

        #     if last_inventory_item:
        #         MyVehicle.objects.filter(farmer = farmer,
        #             inventory_type=inventory_type,
        #             inventory_items=last_inventory_item.inventory_items
        #         ).update(status=1)

        #     # Update the previous MyInventory item to inactive (status=1)
        #     last_inventory_item_inventory = MyInventory.objects.filter(farmer = farmer,
        #         inventory_type=inventory_type,
        #         inventory_items=inventory_items,
        #         status=0  # Only active items
        #     ).order_by('-created_at').first()

        #     if last_inventory_item_inventory:
        #         last_inventory_item_inventory.status = 1
        #         last_inventory_item_inventory.save()

        #     # Create new inventory object for MyVehicle
        #     my_inventory = MyInventory.objects.create(
        #         farmer=farmer,
        #         date_of_consumption=data.get('date_of_consumption'),
        #         crop=crop,
        #         inventory_type=inventory_type,
        #         inventory_category=inventory_category,
        #         inventory_items=inventory_items,
        #         # quantity_utilized=quantity_utilized,
        #         # available_quans=available_quans_in_inventory,
        #         description=data.get('description'),
        #         status=0,  # New item is active (status=0)
        #         created_at=timezone.now(),
        #         updated_at=timezone.now(),
        #         start_kilometer=start_kilometer,
        #         end_kilometer=end_kilometer,
        #     )

        elif inventory_type.id == 1:  # MyVehicle specific logic (new part)
            try:
                # Get the necessary fields for MyVehicle
                farmer = Farmer.objects.get(id=data.get('farmer'))
                # inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
                inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))
                crop = MyCrop.objects.get(id=data.get('crop'))  # Crop field is required for MyVehicle

                # Convert start_kilometer and end_kilometer to Decimal
                start_kilometer = Decimal(data.get('start_kilometer', '0'))  # Make sure it is Decimal
                end_kilometer = Decimal(data.get('end_kilometer', '0'))  # Make sure it is Decimal

            except (Farmer.DoesNotExist, InventoryItems.DoesNotExist, MyCrop.DoesNotExist):
                return Response({'error': 'Invalid references to farmer, category, inventory items or crop'}, status=status.HTTP_400_BAD_REQUEST)

            # Check for required fields
            if start_kilometer <= 0 or end_kilometer <= 0:
                return Response({'error': 'Start and End kilometer must be greater than zero.'}, status=status.HTTP_400_BAD_REQUEST)

            if start_kilometer >= end_kilometer:
                return Response({'error': 'Start kilometer cannot be greater than or equal to End kilometer.'}, status=status.HTTP_400_BAD_REQUEST)

            # Fetch the last MyVehicle instance for the selected inventory items and inventory type
            vehicle_instance = MyVehicle.objects.filter(
                inventory_items=inventory_items,
                inventory_type=inventory_type,
                farmer=farmer
            ).order_by('-updated_at').first()

            if not vehicle_instance:
                return Response({'error': 'No vehicle records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

            # No quantity utilized in MyVehicle logic, so we don't need to perform this check
            # total_available_quans = vehicle_instance.available_quans
            # quantity_utilized = Decimal(data.get('quantity_utilized', 0))

            # vehicle_instance.available_quans -= quantity_utilized
            vehicle_instance.save()

            # available_quans_in_inventory = total_available_quans - quantity_utilized

            # Update the previous MyVehicle inventory item to inactive (status=1)
            last_inventory_item = MyVehicle.objects.filter(
                inventory_type=inventory_type,
                inventory_items__status=0,
                farmer=farmer,
            ).latest('created_at')

            if last_inventory_item:
                MyVehicle.objects.filter(farmer=farmer,
                                        inventory_type=inventory_type,
                                        inventory_items=last_inventory_item.inventory_items
                                        ).update(status=1)

            # Update the previous MyInventory item to inactive (status=1)
            last_inventory_item_inventory = MyInventory.objects.filter(farmer=farmer,
                inventory_type=inventory_type,
                inventory_items=inventory_items,
                status=0  # Only active items
            ).order_by('-created_at').first()

            if last_inventory_item_inventory:
                last_inventory_item_inventory.status = 1
                last_inventory_item_inventory.save()

            # Create new inventory object for MyVehicle
            my_inventory = MyInventory.objects.create(
                farmer=farmer,
                date_of_consumption=data.get('date_of_consumption'),
                crop=crop,
                inventory_type=inventory_type,
                # inventory_category=inventory_category,
                inventory_items=inventory_items,
                # quantity_utilized=quantity_utilized,
                # available_quans=available_quans_in_inventory,
                description=data.get('description'),
                status=0,  # New item is active (status=0)
                created_at=timezone.now(),
                updated_at=timezone.now(),
                start_kilometer=start_kilometer,
                end_kilometer=end_kilometer,
            )


        # Process documents if provided
        file_data = request.data.get('documents', None)  # Get the documents if provided
        if file_data:
            # Initialize grouped documents to handle file_type categorization
            grouped_documents = {}

            # Process each document and its corresponding file_type
            for doc_data in file_data:
                file_type_id = doc_data.get('file_type')
                documents = doc_data.get('documents', [])

                if not documents:
                    return Response(
                        {"success": False, "message": f"No documents provided for file type {file_type_id}."},
                        status=status.HTTP_400_BAD_REQUEST
                    )

                # Handle file type creation if necessary
                if file_type_id is None:
                    new_file_type = doc_data.get('new_file_type')
                    if not new_file_type:
                        return Response({"error": f"New file type for document is required."}, status=status.HTTP_400_BAD_REQUEST)

                    # Create a new file type if not exists
                    file_type, created = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=3)
                else:
                    # Get the existing file type
                    file_type = get_object_or_404(DocumentCategory, id=file_type_id)

                if file_type_id not in grouped_documents:
                    grouped_documents[file_type_id] = []

                # Process the documents, creating document entries
                for i, document_base64 in enumerate(documents):
                    try:
                        # Validate MIME type (only image/jpeg, image/png, and application/pdf)
                        if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
                            mime_type = validate_image_type(document_base64)  # Validate the MIME type
                            if mime_type:
                                # Extract the base64 data and decode it
                                document_data = document_base64.split(';base64,')[1]
                                document_bytes = base64.b64decode(document_data)

                                # Check file size (10MB max)
                                max_file_size = 10 * 1024 * 1024  # 10MB
                                if len(document_bytes) > max_file_size:
                                    return Response({'error': f'File is too large. Max size is 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

                                # Create a document name and ContentFile
                                document_name = f"inventory_{my_inventory.id}_{file_type_id}_{i}.{mime_type.split('/')[1]}"
                                document_file = ContentFile(document_bytes, name=document_name)

                                # Create document instance and save it
                                document_instance = MyInventoryDocuments.objects.create(
                                    farmer=farmer,
                                    my_inventory=my_inventory,
                                    file_type=file_type,
                                    document=document_file,
                                    created_at=timezone.now(),
                                    created_by=farmer.farmer_user
                                )

                                # Append the document info to the grouped_documents list
                                document_data = {
                                    'document_id': document_instance.id,
                                    'document_category': {
                                        'id': file_type.id,
                                        'name': file_type.name
                                    },
                                    'upload_document': request.build_absolute_uri(f'/SuperAdmin{document_file.name}'),
                                    'language': {
                                        'default': 'en'
                                    }
                                }

                                grouped_documents[file_type_id].append(document_data)
                            else:
                                return Response({'error': 'Invalid MIME type for the document.'}, status=status.HTTP_400_BAD_REQUEST)
                        else:
                            return Response({'error': 'Invalid file format. Only image/jpeg, image/png, and application/pdf are allowed.'}, status=status.HTTP_400_BAD_REQUEST)

                    except Exception as e:
                        return Response({'error': f"Error processing document: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

            # Return the grouped documents in the response
            formatted_documents = []
            for file_type_id, documents in grouped_documents.items():
                formatted_documents.append({
                    'category_id': file_type_id,
                    'documents': documents
                })

            return Response({'success': True, 'formatted_documents': formatted_documents}, status=status.HTTP_200_OK)

        return Response({'success': True, 'message': 'Inventory created successfully.'}, status=status.HTTP_200_OK)
    
@api_view(['POST'])
def create_soil_test(request, farmer_id):
    try:
        # Fetch the farmer object
        farmer = get_object_or_404(Farmer, id=farmer_id)
        print(f"Fetching farmer with id: {farmer_id}")

        # Get the soil test details from the request
        land_id = request.data.get('my_land')
        documents_data = request.data.get('document', [])  # List of documents (file types and files)

        # Validate that the required fields are provided
        if not land_id or not documents_data:
            return Response(
                {"success": False, "message": "my_land, and documents are required."},
                status=status.HTTP_400_BAD_REQUEST
            )

        # Allowed file types and size limit (10MB)
        allowed_file_types = ['application/pdf', 'image/jpeg', 'image/png']
        max_file_size = 10 * 1024 * 1024  # 10MB

        soil_test_details = []

        # Process each file type and its corresponding documents
        for doc_data in documents_data:
            file_type_id = doc_data.get('file_type')
            documents = doc_data.get('documents', [])

            # Check if file_type_id is None
            if file_type_id is None:
                new_file_type = doc_data.get('new_file_type')  # Assuming you send new file types like "new_file_type"
                if not new_file_type:
                    return Response({"error": f"New file type for file is required."}, status=status.HTTP_400_BAD_REQUEST)
                
                # Check if the file type already exists
                file_type, created = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=0)
                
                if created:
                    print(f"New file type created: {file_type.name}")
                else:
                    print(f"File type '{new_file_type}' already exists. Using the existing one.")
            else:
                # Fetch the existing file type if file_type_id is provided
                file_type = get_object_or_404(DocumentCategory, id=file_type_id)

            # Loop through the provided documents to create SoilTest entries
            for i, document_base64 in enumerate(documents):
                try:
                    # Validate MIME type for images or PDF
                    if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
                        mime_type = validate_image_type(document_base64)  # This should validate the MIME type
                        if mime_type:
                            # Extract the base64 data (remove the prefix)
                            document_data = document_base64.split(';base64,')[1]

                            # Decode the base64 data to bytes
                            document_bytes = base64.b64decode(document_data)

                            # Check file size (after decoding)
                            if len(document_bytes) > max_file_size:
                                return Response({'error': f'File is too large. Max size is 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

                            # Create a file name
                            document_name = f"soil_test_{farmer_id}_{file_type.id}_{i}.{mime_type.split('/')[1]}"

                            # Create the document file (ContentFile)
                            document_file = ContentFile(document_bytes, name=document_name)

                            # Fetch related MyLand
                            my_land = get_object_or_404(MyLand, id=land_id, status=0)
 
                            soil_test = Soil_Test(
                                farmer=farmer,
                                my_land=my_land,
                                file_type=file_type,
                                file=document_file,  
                                created_by=farmer.farmer_user  
                            )
                            soil_test.save()
 
                            soil_test_details.append({
                                'id': soil_test.id,
                                'file_name': soil_test.file.name,
                                'file_type': soil_test.file_type.name,
                                'my_land': soil_test.my_land.name,
                            })
                        else:
                            return Response({'error': 'Invalid MIME type for the document.'}, status=status.HTTP_400_BAD_REQUEST)
                    else:
                        return Response({'error': 'Invalid file format. Only image/jpeg, image/png, and application/pdf are allowed.'}, status=status.HTTP_400_BAD_REQUEST)

                except Exception as e:
                    return Response({'error': f"Error processing document: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

        return Response({
            "success": True,
            "message": f"{len(soil_test_details)} soil test files uploaded successfully.",
            "soil_test_details": soil_test_details,
            "language": {"default": "en"}
        }, status=status.HTTP_201_CREATED)

    except Exception as e:
        return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
 
def validate_image_type(document_base64):
    """
    This function validates the MIME type of the base64 string
    """
    if document_base64.startswith("data:image/jpeg"):
        return "image/jpeg"
    elif document_base64.startswith("data:image/png"):
        return "image/png"
    elif document_base64.startswith("data:image/heic"):
        return "image/heic"
    elif document_base64.startswith("data:application/pdf"):
        return "application/pdf"
    return None
 
# @api_view(['GET'])
# def get_soil_test_report(request, farmer_id):
#     try: 
#         farmer = get_object_or_404(Farmer, id=farmer_id,status=0)
 
#         my_land_id = request.query_params.get('my_land')
 
#         if not my_land_id:
#             return Response(
#                 {"success": False, "message": "my_land is required."},
#                 status=status.HTTP_400_BAD_REQUEST
#             )
 
#         my_land = get_object_or_404(MyLand, id=my_land_id, status=0)
 
#         soil_tests = Soil_Test.objects.filter(
#             farmer=farmer,
#             my_land=my_land,
#         )
 
#         if not soil_tests.exists():
#             return Response(
#                 {"success": False, "message": "No soil test reports found for the specified parameters."},
#                 status=status.HTTP_404_NOT_FOUND
#             )
 
#         soil_test_details = []
#         for soil_test in soil_tests:
#             soil_test_details.append({
#                 "id": soil_test.id,
#                 "farmer": soil_test.farmer.id,
#                 "my_land": soil_test.my_land.id, 
#                 "file_type": soil_test.file_type.name if soil_test.file_type else "Unknown",
#                 "file": request.build_absolute_uri(f'/SuperAdmin{soil_test.file.url}' if soil_test.file else soil_test.file.url) if soil_test.file else "",
#                 "uploaded_at": soil_test.uploaded_at,
#             })

#         return Response({
#             "success": True,
#             "soil_test_reports": soil_test_details,
#             "language": {
#                 "default": "en"
#             }
#         }, status=status.HTTP_200_OK)

#     except Exception as e:
#         return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@api_view(['GET'])
def get_soil_test_report(request, farmer_id):
    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'  # Fallback to 'en' if no preference is found

    try: 
        farmer = get_object_or_404(Farmer, id=farmer_id,status=0)
 
        my_land_id = request.query_params.get('my_land')
 
        if not my_land_id:
            return Response(
                {"success": False, "message": "my_land is required."},
                status=status.HTTP_400_BAD_REQUEST
            )
 
        my_land = get_object_or_404(MyLand, id=my_land_id, status=0)
 
        soil_tests = Soil_Test.objects.filter(
            farmer=farmer,
            my_land=my_land,
        )
 
        if not soil_tests.exists():
            return Response(
                {"success": False, "message": "No soil test reports found for the specified parameters."},
                status=status.HTTP_404_NOT_FOUND
            )
 
        soil_test_details = []
        for soil_test in soil_tests:
            soil_test_details.append({
                "id": soil_test.id,
                "farmer": soil_test.farmer.id,
                "my_land": soil_test.my_land.id, 
                "file_type": soil_test.file_type.get_translated_value("name", language_code) if soil_test.file_type else "Unknown",
                "file": request.build_absolute_uri(f'/SuperAdmin{soil_test.file.url}' if soil_test.file else soil_test.file.url) if soil_test.file else "",
                "uploaded_at": soil_test.uploaded_at,
            })

        return Response({
            "success": True,
            "soil_test_reports": soil_test_details,
            "language": {
                "default": "en"
            }
        }, status=status.HTTP_200_OK)

    except Exception as e:
        return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


@api_view(['GET'])
def filter_crops(request, farmer_id):
    # Get the land_id from query parameters
    land_id = request.query_params.get('land_id', None)

    if land_id is None:
        return Response({"detail": "land_id is required."}, status=status.HTTP_400_BAD_REQUEST)

    # Filter crops by the farmer_id and land_id
    crops = MyCrop.objects.filter(farmer_id=farmer_id, land_id=land_id,status=0)

    if not crops.exists():
        return Response({"detail": "No crops found for the specified farmer and land."}, status=status.HTTP_404_NOT_FOUND)

    # Build the response manually (returning only the id and crop name)
    crop_data = []
    for crop in crops:
        crop_data.append({
            "id": crop.id,
            "name": crop.crop.name if crop.crop else  "",  
            "language":{
                "default":"en"
            }
        })

    return Response(crop_data, status=status.HTTP_200_OK)
 
# @api_view(['GET'])
# def dashboard_task_list(request, farmer_id):
#     # Retrieve the optional land_id from the query parameters (if provided)
#     land_id = request.query_params.get('land_id')

#     try:
#         # Query MySchedule model for the last 5 entries based on the farmer_id and order by created_at
#         schedules = MySchedule.objects.filter(farmer_id=farmer_id).order_by('-created_at')[:5]
        
#         # Prepare the response data with the 'my_land' IDs, crop details, and schedule details
#         schedule_data = []

#         # Get the date format from the settings or use the fallback format
#         try:
#             settings = GeneralSetting.objects.first()
#             date_format = convert_to_strftime_format(settings.date_format)
#         except Exception as e:
#             date_format = '%d-%m-%Y'  # Fallback to the default format

#         for schedule in schedules:
#             # Prepare the schedule info
#             schedule_info = {
#                 'id': schedule.id,
#                 'schedule': schedule.schedule,
#                 'start_date': schedule.start_date.strftime(date_format) if schedule.start_date else "",
#                 'end_date': schedule.end_date.strftime(date_format) if schedule.end_date else "",
#                 'schedule_status': schedule.schedule_status.id if schedule.schedule_status else None,
#                 'schedule_status_name': schedule.schedule_status.name,
#                 'comment': schedule.comment,
#                 'schedule_choice': schedule.schedule_choice,
#                 'created_at': schedule.created_at,
#                 'updated_at': schedule.updated_at,
#                 'my_land_id': schedule.my_land.id if schedule.my_land else "",
#                 'land_name': schedule.my_land.name if schedule.my_land else "",  # Land name added
#                 'farmer_id': schedule.farmer.id,
#                 'farmer_name': schedule.farmer.name if schedule.farmer else "",  # Farmer name added
#                 # Crop details
#                 'crop_id': schedule.my_crop.id if schedule.my_crop else None,
#                 'crop_name': schedule.my_crop.crop.name if schedule.my_crop else None,
#                 'crop_image': request.build_absolute_uri(f'/SuperAdmin{schedule.my_crop.crop.img.url}' if schedule.my_crop.crop.img else schedule.my_crop.crop.img.url) if schedule.my_crop.crop.img else "",
#             }
#             schedule_data.append(schedule_info)

#         # If a specific land_id is passed in the query parameters, filter for it
#         if land_id:
#             schedule_data = [schedule for schedule in schedule_data if str(schedule['my_land_id']) == land_id]
        
#         return Response({
#             'schedules': schedule_data,
#             'language': {'default': 'en'}
#         })
    
#     except MySchedule.DoesNotExist:
#         return Response({'error': 'No schedules found for the given farmer_id'}, status=status.HTTP_404_NOT_FOUND)

@api_view(['GET'])
def dashboard_task_list(request, farmer_id):
    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'  # Fallback to 'en' if no preference is found
    # Retrieve the optional land_id from the query parameters (if provided)
    land_id = request.query_params.get('land_id')

    try:
        # Query MySchedule model for the last 5 entries based on the farmer_id and order by created_at
        schedules = MySchedule.objects.filter(farmer_id=farmer_id).order_by('-created_at')[:5]
        
        # Prepare the response data with the 'my_land' IDs, crop details, and schedule details
        schedule_data = []

        # Get the date format from the settings or use the fallback format
        try:
            settings = GeneralSetting.objects.first()
            date_format = convert_to_strftime_format(settings.date_format)
        except Exception as e:
            date_format = '%d-%m-%Y'  # Fallback to the default format

        for schedule in schedules:
            # Prepare the schedule info
            schedule_info = {
                'id': schedule.id,
                'schedule': schedule.get_translated_value("schedule", language_code) if schedule else "",
                'start_date': schedule.start_date.strftime(date_format) if schedule.start_date else "",
                'end_date': schedule.end_date.strftime(date_format) if schedule.end_date else "",
                'schedule_status': schedule.schedule_status.id if schedule.schedule_status else None,
                'schedule_status_name': schedule.schedule_status.get_translated_value("name", language_code) if schedule.schedule_status else "",
                'comment': schedule.get_translated_value("comment", language_code) if schedule else "",
                'schedule_choice': schedule.schedule_choice,
                'created_at': schedule.created_at,
                'updated_at': schedule.updated_at,
                'my_land_id': schedule.my_land.id if schedule.my_land else "",
                'land_name': schedule.my_land.get_translated_value("name", language_code) if schedule.my_land else "",  # Land name added
                'farmer_id': schedule.farmer.id,
                'farmer_name': schedule.farmer.get_translated_value("name", language_code) if schedule.farmer else "",  # Farmer name added
                # Crop details
                'crop_id': schedule.my_crop.id if schedule.my_crop else None,
                'crop_name': schedule.my_crop.crop.get_translated_value("name", language_code) if schedule.my_crop else None,
                'crop_image': request.build_absolute_uri(f'/SuperAdmin{schedule.my_crop.crop.img.url}' if schedule.my_crop.crop.img else schedule.my_crop.crop.img.url) if schedule.my_crop.crop.img else "",
            }
            schedule_data.append(schedule_info)

        # If a specific land_id is passed in the query parameters, filter for it
        if land_id:
            schedule_data = [schedule for schedule in schedule_data if str(schedule['my_land_id']) == land_id]
        
        return Response({
            'schedules': schedule_data,
            'language': {'default': 'en'}
        })
    
    except MySchedule.DoesNotExist:
        return Response({'error': 'No schedules found for the given farmer_id'}, status=status.HTTP_404_NOT_FOUND)



@api_view(['GET'])
def get_monthly_expenses_and_sales(request, farmer_id):
    # Get the current date
    today = datetime.today()
    current_month = today.month
    current_year = today.year

    # Get the first day of the current month and the last day of the current month
    first_day_of_month = today.replace(day=1)
    # Get the last day of the current month
    if current_month == 12:
        last_day_of_month = today.replace(year=current_year + 1, month=1, day=1) - timedelta(days=1)
    else:
        last_day_of_month = today.replace(month=current_month + 1, day=1) - timedelta(days=1)

    # Get the land_id from the query parameters
    land_id = request.query_params.get('land_id')
    if not land_id:
        return Response({'error': 'land_id is required in the query parameters'}, status=status.HTTP_400_BAD_REQUEST)

    # Get daily sales data for the current month for the specific land
    sales_data = MySales.objects.filter(
        farmer_id=farmer_id,
        my_crop__land_id=land_id,  # Accessing land through my_crop relationship
        dates_of_sales__range=[first_day_of_month, last_day_of_month]
    ).values('dates_of_sales').annotate(total_sales=Sum('sales_amount')).order_by('dates_of_sales')

    # Get daily expenses data for the current month for the specific land
    expenses_data = MyExpense.objects.filter(
        farmer_id=farmer_id,
        my_crop__land_id=land_id,  # Accessing land through my_crop relationship
        created_day__range=[first_day_of_month, last_day_of_month]
    ).values('created_day').annotate(total_expenses=Sum('amount')).order_by('created_day')

    # Prepare the response data structure
    daily_sales = defaultdict(float)
    daily_expenses = defaultdict(float)

    total_sales_amount = 0  # To hold the total sales amount for the month
    total_expenses_amount = 0  # To hold the total expenses amount for the month

    for sale in sales_data:
        daily_sales[sale['dates_of_sales']] = sale['total_sales']
        total_sales_amount += sale['total_sales']  # Add to the total sales amount
        
    for expense in expenses_data:
        daily_expenses[expense['created_day']] = expense['total_expenses']
        total_expenses_amount += expense['total_expenses']  # Add to the total expenses amount

    # Prepare the final graph data
    days_in_month = [first_day_of_month + timedelta(days=i) for i in range((last_day_of_month - first_day_of_month).days + 1)]
    
    sales_graph = []
    expenses_graph = []

    for day in days_in_month:
        sales_graph.append({
            "day": day.strftime('%d'),
            "amount": daily_sales.get(day.date(), 0)
        })
        
        expenses_graph.append({
            "day": day.strftime('%d'),
            "amount": daily_expenses.get(day.date(), 0)
        })

    # Returning the response with sales and expenses graphs and the total amounts
    return Response({
        "total_sales_amount": total_sales_amount, 
        "total_expenses_amount": total_expenses_amount,
        "sales": sales_graph, 
        "expenses": expenses_graph, 
        "language": {"default": "en"}
    }, status=status.HTTP_200_OK)

# Outstanding Dashboard Graph Count(Customer, Vendor, Both) 
@api_view(['GET'])
def payables_receivables_count(request, farmer_id):
     
    customers = MyCustomer.objects.filter(farmer_id=farmer_id, status=0, is_customer_is_vendor=False)
     
    receivables_customers = customers.filter(is_credit=True)
    payables_customers = customers.filter(is_credit=False)
     
    total_receivables = 0
    total_payables = 0
     
    customer_receivables = receivables_customers.aggregate(Sum('opening_balance'))['opening_balance__sum'] or 0
    customer_payables = payables_customers.aggregate(Sum('opening_balance'))['opening_balance__sum'] or 0

    total_receivables += customer_receivables
    total_payables += customer_payables
     
    vendors = MyVendor.objects.filter(farmer_id=farmer_id, status=0, is_customer_is_vendor=False)
     
    receivables_vendors = vendors.filter(credit=True)
    payables_vendors = vendors.filter(debit=True)
     
    vendor_receivables = receivables_vendors.aggregate(Sum('opening_balance'))['opening_balance__sum'] or 0
    vendor_payables = payables_vendors.aggregate(Sum('opening_balance'))['opening_balance__sum'] or 0

    total_receivables += vendor_receivables
    total_payables += vendor_payables
     
    both_customers = MyCustomer.objects.filter(farmer_id=farmer_id, status=0, is_customer_is_vendor=True)
    both_vendors = MyVendor.objects.filter(farmer_id=farmer_id, status=0, is_customer_is_vendor=True)
 
    receivables_both_customers = both_customers.filter(is_credit=True)
    payables_both_customers = both_customers.filter(is_credit=False)
    receivables_both_vendors = both_vendors.filter(credit=True)
    payables_both_vendors = both_vendors.filter(debit=True)
 
    both_receivables = (
        receivables_both_customers.aggregate(Sum('opening_balance'))['opening_balance__sum'] or 0
    ) + (
        receivables_both_vendors.aggregate(Sum('opening_balance'))['opening_balance__sum'] or 0
    )
    
    both_payables = (
        payables_both_customers.aggregate(Sum('opening_balance'))['opening_balance__sum'] or 0
    ) + (
        payables_both_vendors.aggregate(Sum('opening_balance'))['opening_balance__sum'] or 0
    )

    total_receivables += both_receivables
    total_payables += both_payables
     
    return Response({
        "detail": "Total payables and receivables for customers and vendors fetched successfully.",
        "vendor": {
            "payables": vendor_payables,
            "receivables": vendor_receivables
        },
        "customer": {
            "payables": customer_payables,
            "receivables": customer_receivables
        },
        "both": {
            "payables": both_payables,
            "receivables": both_receivables
        },
        "total": {
            "payables": total_payables,
            "receivables": total_receivables
        },
        "language": {
            "default": "en"
        }
    }, status=status.HTTP_200_OK)
 
# Outstanding Dashboard List(Customer, Vendor, Both)  
@api_view(['GET'])
def payables_receivables_list(request, farmer_id): 
    # Fetch the necessary data
    customers = MyCustomer.objects.filter(farmer_id=farmer_id, status=0, is_customer_is_vendor=False)
    vendors = MyVendor.objects.filter(farmer_id=farmer_id, status=0, is_customer_is_vendor=False)
    customer_vendor = MyCustomer.objects.filter(farmer_id=farmer_id, status=0, is_customer_is_vendor=True)
    vendor_customer = MyVendor.objects.filter(farmer_id=farmer_id, status=0, is_customer_is_vendor=True)

    # Initialize lists to store payables and receivables
    customer_data = {"payables": [], "receivables": []}
    vendor_data = {"payables": [], "receivables": []}
    customer_vendor_data = {"payables": [], "receivables": []}
    vendor_customer_data = {"payables": [], "receivables": []}

    # Process customer data and categorize as payables or receivables
    for customer in customers:
        customer_info = {
            "id": customer.id,
            "customer_name": customer.customer_name,
            "shop_name": customer.shop_name,
            "is_credit": customer.is_credit,
            "opening_balance": customer.opening_balance,
        }
        if customer.is_credit:
            customer_data["receivables"].append(customer_info)
        else:
            customer_data["payables"].append(customer_info)

    # Process vendor data and categorize as payables or receivables
    for vendor in vendors:
        vendor_info = {
            "id": vendor.id,
            "vendor_name": vendor.name,
            "business_name": vendor.business_name,
            "is_credit": vendor.credit,
            "opening_balance": vendor.opening_balance,
        }
        if vendor.credit:
            vendor_data["receivables"].append(vendor_info)
        else:
            vendor_data["payables"].append(vendor_info)

    # Process customer_vendor data and categorize as payables or receivables
    for customer_vendor_item in customer_vendor:
        customer_vendor_info = {
            "id": customer_vendor_item.id,
            "customer_name": customer_vendor_item.customer_name,
            "shop_name": customer_vendor_item.shop_name,
            "is_credit": customer_vendor_item.is_credit,
            "opening_balance": customer_vendor_item.opening_balance,
        }
        if customer_vendor_item.is_credit:
            customer_vendor_data["receivables"].append(customer_vendor_info)
        else:
            customer_vendor_data["payables"].append(customer_vendor_info)

    # Process vendor_customer data and categorize as payables or receivables
    for vendor_customer_item in vendor_customer:
        vendor_customer_info = {
            "id": vendor_customer_item.id,
            "vendor_name": vendor_customer_item.name,
            "business_name": vendor_customer_item.business_name,
            "is_credit": vendor_customer_item.credit,
            "opening_balance": vendor_customer_item.opening_balance,
        }
        if vendor_customer_item.credit:
            vendor_customer_data["receivables"].append(vendor_customer_info)
        else:
            vendor_customer_data["payables"].append(vendor_customer_info)

    # Merging customer_vendor_list and vendor_customer_list into a single list
    combined_vendor_customer_data = {
        "payables": customer_vendor_data["payables"] + vendor_customer_data["payables"],
        "receivables": customer_vendor_data["receivables"] + vendor_customer_data["receivables"]
    }

    # Return response with categorized data and the merged list
    return Response({
        "detail": "Customers payables and receivables fetched successfully.",
        "customer_list": customer_data,
        "vendor_list": vendor_data,
        "both_customer_vendor": combined_vendor_customer_data,
        "language": {
            "default": "en"
        }
    }, status=status.HTTP_200_OK)

# Outsatanding Customer Sales Payables List
@api_view(['GET'])
def customer_sales_payables_list(request, farmer_id):
    # Get the customer_id from the query parameters if provided
    customer_id = request.query_params.get('customer_id', None)

    # Base queryset
    customers = MyCustomer.objects.filter(farmer_id=farmer_id, status=0, is_customer_is_vendor=False)

    # If customer_id is provided, filter customers by customer_id
    if customer_id:
        customers = customers.filter(id=customer_id)

    customer_sales_data = {"payables": []}  # Only keep receivables

    for customer in customers:
        # Only include customers where is_credit is True
        if customer.is_credit is False:
            sales = MySales.objects.filter(farmer_id=farmer_id, my_customer=customer)

            # List to hold individual receivable sales for this customer
            payables_sales = []

            for sale in sales:
                sale_data = {
                    "sales_id": sale.id,
                    "sales_date": sale.dates_of_sales,
                    "crop_id": sale.my_crop.id if sale.my_crop else None,  # Add crop ID
                    "crop_name": sale.my_crop.crop.name if sale.my_crop else None,  # Add crop name   
                    "total_sales_amount": sale.total_sales_amount,
                    "amount_paid": sale.amount_paid,  
                    "received_amount": 0.0,
                    "topay_amount": 0.0
                }

                payables_sales.append(sale_data)

            # Only add customer entry if they have receivable sales
            if payables_sales:
                customer_sales_data["payables"].append({
                    "customer_id": customer.id,
                    "customer_name": customer.customer_name,
                    "shop_name": customer.shop_name,
                    "customer_image": request.build_absolute_uri(f'/assets{customer.customer_img.url}' if customer.customer_img else customer.customer_img.url) if customer.customer_img else "",
                    "sales": payables_sales
                })

    return Response({
        "detail": "Customer payables fetched successfully.",
        "customer_sales": customer_sales_data,
        "language": {
            "default": "en"
        }
    }, status=status.HTTP_200_OK)

# Outsatanding Vendor Purchase Payables List
# @api_view(['GET'])
# def vendor_purchase_payables_list(request, farmer_id):   
#     vendor_id = request.query_params.get('vendor_id', None)
 
#     # Fetching vendors based on the farmer ID and the status.
#     vendors = MyVendor.objects.filter(farmer_id=farmer_id, status=0, is_customer_is_vendor=False)
 
#     if vendor_id:
#         vendors = vendors.filter(id=vendor_id)

#     vendor_inventory_data = {"payables": []}   

#     for vendor in vendors: 
#         if vendor.credit is False: 
#             # For fuel purchases
#             fuel_purchases = MyFuel.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1]) 
#             payables_fuel = []

#             for fuel in fuel_purchases:
#                 fuel_data = {
#                     "fuel_purchase_id": fuel.id,
#                     "purchase_date": fuel.date_of_consumption,
#                     "inventory_type": fuel.inventory_type.name if fuel.inventory_type else None,  
#                     "inventory_item": fuel.inventory_items.name if fuel.inventory_items else None,   
#                     "total_purchase_amount": fuel.purchase_amount,
#                     "amount_paid": 0.0,   
#                     "received_amount": 0.0,   
#                     "topay_amount": 0.0
#                 }
#                 payables_fuel.append(fuel_data)

#             # For seeds
#             seed_purchases = MySeeds.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1]) 
#             payables_seeds = []

#             for seed in seed_purchases:
#                 seed_data = {
#                     "seed_purchase_id": seed.id,
#                     "purchase_date": seed.date_of_consumption,
#                     "inventory_type": seed.inventory_type.name if seed.inventory_type else None,  
#                     "inventory_item": seed.inventory_items.name if seed.inventory_items else None,   
#                     "total_purchase_amount": seed.purchase_amount,
#                     "amount_paid": 0.0,   
#                     "received_amount": 0.0,   
#                     "topay_amount": 0.0
#                 }
#                 payables_seeds.append(seed_data)

#             # For pesticides
#             pesticide_purchases = MyPesticides.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1]) 
#             payables_pesticides = []

#             for pesticide in pesticide_purchases:
#                 pesticide_data = {
#                     "pesticide_purchase_id": pesticide.id,
#                     "purchase_date": pesticide.date_of_consumption,
#                     "inventory_type": pesticide.inventory_type.name if pesticide.inventory_type else None,  
#                     "inventory_item": pesticide.inventory_items.name if pesticide.inventory_items else None,   
#                     "total_purchase_amount": pesticide.purchase_amount,
#                     "amount_paid": 0.0,   
#                     "received_amount": 0.0,   
#                     "topay_amount": 0.0
#                 }
#                 payables_pesticides.append(pesticide_data)

#             # For fertilizers
#             fertilizer_purchases = MyFertilizers.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1]) 
#             payables_fertilizers = []

#             for fertilizer in fertilizer_purchases:
#                 fertilizer_data = {
#                     "fertilizer_purchase_id": fertilizer.id,
#                     "purchase_date": fertilizer.date_of_consumption,
#                     "inventory_type": fertilizer.inventory_type.name if fertilizer.inventory_type else None,  
#                     "inventory_item": fertilizer.inventory_items.name if fertilizer.inventory_items else None,   
#                     "total_purchase_amount": fertilizer.purchase_amount,
#                     "amount_paid": 0.0,   
#                     "received_amount": 0.0,   
#                     "topay_amount": 0.0
#                 }
#                 payables_fertilizers.append(fertilizer_data)

#             # For vehicles
#             vehicle_purchases = MyVehicle.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1]) 
#             payables_vehicles = []

#             for vehicle in vehicle_purchases:
#                 vehicle_data = {
#                     "vehicle_purchase_id": vehicle.id,
#                     "purchase_date": vehicle.date_of_consumption,
#                     "inventory_type": vehicle.inventory_type.name if vehicle.inventory_type else None,  
#                     "inventory_item": vehicle.inventory_items.name if vehicle.inventory_items else None,   
#                     "total_purchase_amount": vehicle.purchase_amount,
#                     "amount_paid": 0.0,   
#                     "received_amount": 0.0,   
#                     "topay_amount": 0.0
#                 }
#                 payables_vehicles.append(vehicle_data)

#             # For machinery
#             machinery_purchases = MyMachinery.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1]) 
#             payables_machinery = []

#             for machinery in machinery_purchases:
#                 machinery_data = {
#                     "machinery_purchase_id": machinery.id,
#                     "purchase_date": machinery.date_of_consumption,
#                     "inventory_type": machinery.inventory_type.name if machinery.inventory_type else None,  
#                     "inventory_item": machinery.inventory_items.name if machinery.inventory_items else None,   
#                     "total_purchase_amount": machinery.purchase_amount,
#                     "amount_paid": 0.0,   
#                     "received_amount": 0.0,   
#                     "topay_amount": 0.0
#                 }
#                 payables_machinery.append(machinery_data)

#             # For tools
#             tool_purchases = MyTools.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1]) 
#             payables_tools = []

#             for tool in tool_purchases:
#                 tool_data = {
#                     "tool_purchase_id": tool.id,
#                     "purchase_date": tool.date_of_consumption,
#                     "inventory_type": tool.inventory_type.name if tool.inventory_type else None,  
#                     "inventory_item": tool.inventory_items.name if tool.inventory_items else None,   
#                     "total_purchase_amount": tool.purchase_amount,
#                     "amount_paid": 0.0,   
#                     "received_amount": 0.0,   
#                     "topay_amount": 0.0
#                 }
#                 payables_tools.append(tool_data)

#             # If any items exist for the vendor, append to the final structure
#             if any([payables_fuel, payables_seeds, payables_pesticides, payables_fertilizers, payables_vehicles, payables_machinery, payables_tools]):
#                 vendor_inventory_data["payables"].append({
#                     "vendor_id": vendor.id,
#                     "vendor_name": vendor.name,
#                     "business_name": vendor.business_name,
#                     "vendor_image": request.build_absolute_uri(f'/assets{vendor.vendor_image.url}' if vendor.vendor_image else vendor.vendor_image.url) if vendor.vendor_image else "",
#                     "fuel_purchases": payables_fuel,
#                     "seed_purchases": payables_seeds,
#                     "pesticide_purchases": payables_pesticides,
#                     "fertilizer_purchases": payables_fertilizers,
#                     "vehicle_purchases": payables_vehicles,
#                     "machinery_purchases": payables_machinery,
#                     "tool_purchases": payables_tools
#                 })

#     return Response({
#         "detail": "Vendor inventory payables fetched successfully.",
#         "vendor_inventory_data": vendor_inventory_data,
#         "language": {
#             "default": "en"
#         }
#     }, status=status.HTTP_200_OK)

@api_view(['GET'])
def vendor_purchase_payables_list(request, farmer_id):   
    vendor_id = request.query_params.get('vendor_id', None)
 
    # Fetching vendors based on the farmer ID and the status.
    vendors = MyVendor.objects.filter(farmer_id=farmer_id, status=0, is_customer_is_vendor=False)
 
    if vendor_id:
        vendors = vendors.filter(id=vendor_id)

    vendor_inventory_data = {"payables": []}   

    for vendor in vendors: 
        if vendor.credit is False: 
            # For fuel purchases
            fuel_purchases = MyFuel.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1]) 
            payables_fuel = []

            for fuel in fuel_purchases:
                fuel_data = {
                    "id": fuel.id,
                    "purchase_date": fuel.date_of_consumption,
                    "inventory_type": fuel.inventory_type.name if fuel.inventory_type else None,  
                    "inventory_item": fuel.inventory_items.name if fuel.inventory_items else None,   
                    "total_purchase_amount": fuel.purchase_amount,
                    "amount_paid": 0.0,   
                    "received_amount": 0.0,   
                    "topay_amount": 0.0
                }
                payables_fuel.append(fuel_data)

            # For seeds
            seed_purchases = MySeeds.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1]) 
            payables_seeds = []

            for seed in seed_purchases:
                seed_data = {
                    "id": seed.id,
                    "purchase_date": seed.date_of_consumption,
                    "inventory_type": seed.inventory_type.name if seed.inventory_type else None,  
                    "inventory_item": seed.inventory_items.name if seed.inventory_items else None,   
                    "total_purchase_amount": seed.purchase_amount,
                    "amount_paid": 0.0,   
                    "received_amount": 0.0,   
                    "topay_amount": 0.0
                }
                payables_seeds.append(seed_data)

            # For pesticides
            pesticide_purchases = MyPesticides.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1]) 
            payables_pesticides = []

            for pesticide in pesticide_purchases:
                pesticide_data = {
                    "id": pesticide.id,
                    "purchase_date": pesticide.date_of_consumption,
                    "inventory_type": pesticide.inventory_type.name if pesticide.inventory_type else None,  
                    "inventory_item": pesticide.inventory_items.name if pesticide.inventory_items else None,   
                    "total_purchase_amount": pesticide.purchase_amount,
                    "amount_paid": 0.0,   
                    "received_amount": 0.0,   
                    "topay_amount": 0.0
                }
                payables_pesticides.append(pesticide_data)

            # For fertilizers
            fertilizer_purchases = MyFertilizers.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1]) 
            payables_fertilizers = []

            for fertilizer in fertilizer_purchases:
                fertilizer_data = {
                    "id": fertilizer.id,
                    "purchase_date": fertilizer.date_of_consumption,
                    "inventory_type": fertilizer.inventory_type.name if fertilizer.inventory_type else None,  
                    "inventory_item": fertilizer.inventory_items.name if fertilizer.inventory_items else None,   
                    "total_purchase_amount": fertilizer.purchase_amount,
                    "amount_paid": 0.0,   
                    "received_amount": 0.0,   
                    "topay_amount": 0.0
                }
                payables_fertilizers.append(fertilizer_data)

            # For vehicles
            vehicle_purchases = MyVehicle.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1]) 
            payables_vehicles = []

            for vehicle in vehicle_purchases:
                vehicle_data = {
                    "id": vehicle.id,
                    "purchase_date": vehicle.date_of_consumption,
                    "inventory_type": vehicle.inventory_type.name if vehicle.inventory_type else None,  
                    "inventory_item": vehicle.inventory_items.name if vehicle.inventory_items else None,   
                    "total_purchase_amount": vehicle.purchase_amount,
                    "amount_paid": 0.0,   
                    "received_amount": 0.0,   
                    "topay_amount": 0.0
                }
                payables_vehicles.append(vehicle_data)

            # For machinery
            machinery_purchases = MyMachinery.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1]) 
            payables_machinery = []

            for machinery in machinery_purchases:
                machinery_data = {
                    "id": machinery.id,
                    "purchase_date": machinery.date_of_consumption,
                    "inventory_type": machinery.inventory_type.name if machinery.inventory_type else None,  
                    "inventory_item": machinery.inventory_items.name if machinery.inventory_items else None,   
                    "total_purchase_amount": machinery.purchase_amount,
                    "amount_paid": 0.0,   
                    "received_amount": 0.0,   
                    "topay_amount": 0.0
                }
                payables_machinery.append(machinery_data)

            # For tools
            tool_purchases = MyTools.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1]) 
            payables_tools = []

            for tool in tool_purchases:
                tool_data = {
                    "id": tool.id,
                    "purchase_date": tool.date_of_consumption,
                    "inventory_type": tool.inventory_type.name if tool.inventory_type else None,  
                    "inventory_item": tool.inventory_items.name if tool.inventory_items else None,   
                    "total_purchase_amount": tool.purchase_amount,
                    "amount_paid": 0.0,   
                    "received_amount": 0.0,   
                    "topay_amount": 0.0
                }
                payables_tools.append(tool_data)

            # If any items exist for the vendor, append to the final structure
            if any([payables_fuel, payables_seeds, payables_pesticides, payables_fertilizers, payables_vehicles, payables_machinery, payables_tools]):
                vendor_inventory_data["payables"].append({
                    "vendor_id": vendor.id,
                    "vendor_name": vendor.name,
                    "business_name": vendor.business_name,
                    "vendor_image": request.build_absolute_uri(f'/assets{vendor.vendor_image.url}' if vendor.vendor_image else vendor.vendor_image.url) if vendor.vendor_image else "",
                    "fuel_purchases": payables_fuel,
                    "seed_purchases": payables_seeds,
                    "pesticide_purchases": payables_pesticides,
                    "fertilizer_purchases": payables_fertilizers,
                    "vehicle_purchases": payables_vehicles,
                    "machinery_purchases": payables_machinery,
                    "tool_purchases": payables_tools
                })

    return Response({
        "detail": "Vendor inventory payables fetched successfully.",
        "vendor_inventory_data": vendor_inventory_data,
        "language": {
            "default": "en"
        }
    }, status=status.HTTP_200_OK)


# Outsatanding Vendor Purchase Receivables List
# @api_view(['GET'])
# def vendor_purchase_receivables_list(request, farmer_id): 
#     vendor_id = request.query_params.get('vendor_id', None)

#     # Fetch vendors for the farmer who are marked as credit vendors
#     vendors = MyVendor.objects.filter(farmer_id=farmer_id, status=0, is_customer_is_vendor=False)

#     if vendor_id:
#         vendors = vendors.filter(id=vendor_id)

#     vendor_inventory_data = {"receivables": []}   

#     for vendor in vendors: 
#         if vendor.credit is True:  # â† Switch condition for receivables
#             # Fuel
#             fuel_purchases = MyFuel.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1]) 
#             receivables_fuel = [
#                 {
#                     "fuel_purchase_id": fuel.id,
#                     "purchase_date": fuel.date_of_consumption,
#                     "inventory_type": fuel.inventory_type.name if fuel.inventory_type else None,
#                     "inventory_item": fuel.inventory_items.name if fuel.inventory_items else None,
#                     "total_purchase_amount": fuel.purchase_amount,
#                     "amount_paid": 0.0,
#                     "received_amount": 0.0,
#                     "toreceive_amount": 0.0
#                 }
#                 for fuel in fuel_purchases
#             ]

#             # Seeds
#             seed_purchases = MySeeds.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1]) 
#             receivables_seeds = [
#                 {
#                     "seed_purchase_id": seed.id,
#                     "purchase_date": seed.date_of_consumption,
#                     "inventory_type": seed.inventory_type.name if seed.inventory_type else None,
#                     "inventory_item": seed.inventory_items.name if seed.inventory_items else None,
#                     "total_purchase_amount": seed.purchase_amount,
#                     "amount_paid": 0.0,
#                     "received_amount": 0.0,
#                     "toreceive_amount": 0.0
#                 }
#                 for seed in seed_purchases
#             ]

#             # Pesticides
#             pesticide_purchases = MyPesticides.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1]) 
#             receivables_pesticides = [
#                 {
#                     "pesticide_purchase_id": pesticide.id,
#                     "purchase_date": pesticide.date_of_consumption,
#                     "inventory_type": pesticide.inventory_type.name if pesticide.inventory_type else None,
#                     "inventory_item": pesticide.inventory_items.name if pesticide.inventory_items else None,
#                     "total_purchase_amount": pesticide.purchase_amount,
#                     "amount_paid": 0.0,
#                     "received_amount": 0.0,
#                     "toreceive_amount": 0.0
#                 }
#                 for pesticide in pesticide_purchases
#             ]

#             # Fertilizers
#             fertilizer_purchases = MyFertilizers.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1]) 
#             receivables_fertilizers = [
#                 {
#                     "fertilizer_purchase_id": fertilizer.id,
#                     "purchase_date": fertilizer.date_of_consumption,
#                     "inventory_type": fertilizer.inventory_type.name if fertilizer.inventory_type else None,
#                     "inventory_item": fertilizer.inventory_items.name if fertilizer.inventory_items else None,
#                     "total_purchase_amount": fertilizer.purchase_amount,
#                     "amount_paid": 0.0,
#                     "received_amount": 0.0,
#                     "toreceive_amount": 0.0
#                 }
#                 for fertilizer in fertilizer_purchases
#             ]

#             # Vehicles
#             vehicle_purchases = MyVehicle.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1]) 
#             receivables_vehicles = [
#                 {
#                     "vehicle_purchase_id": vehicle.id,
#                     "purchase_date": vehicle.date_of_consumption,
#                     "inventory_type": vehicle.inventory_type.name if vehicle.inventory_type else None,
#                     "inventory_item": vehicle.inventory_items.name if vehicle.inventory_items else None,
#                     "total_purchase_amount": vehicle.purchase_amount,
#                     "amount_paid": 0.0,
#                     "received_amount": 0.0,
#                     "toreceive_amount": 0.0
#                 }
#                 for vehicle in vehicle_purchases
#             ]

#             # Machinery
#             machinery_purchases = MyMachinery.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1]) 
#             receivables_machinery = [
#                 {
#                     "machinery_purchase_id": machinery.id,
#                     "purchase_date": machinery.date_of_consumption,
#                     "inventory_type": machinery.inventory_type.name if machinery.inventory_type else None,
#                     "inventory_item": machinery.inventory_items.name if machinery.inventory_items else None,
#                     "total_purchase_amount": machinery.purchase_amount,
#                     "amount_paid": 0.0,
#                     "received_amount": 0.0,
#                     "toreceive_amount": 0.0
#                 }
#                 for machinery in machinery_purchases
#             ]

#             # Tools
#             tool_purchases = MyTools.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1]) 
#             receivables_tools = [
#                 {
#                     "tool_purchase_id": tool.id,
#                     "purchase_date": tool.date_of_consumption,
#                     "inventory_type": tool.inventory_type.name if tool.inventory_type else None,
#                     "inventory_item": tool.inventory_items.name if tool.inventory_items else None,
#                     "total_purchase_amount": tool.purchase_amount,
#                     "amount_paid": 0.0,
#                     "received_amount": 0.0,
#                     "toreceive_amount": 0.0
#                 }
#                 for tool in tool_purchases
#             ]

#             if any([receivables_fuel, receivables_seeds, receivables_pesticides, receivables_fertilizers, receivables_vehicles, receivables_machinery, receivables_tools]):
#                 vendor_inventory_data["receivables"].append({
#                     "vendor_id": vendor.id,
#                     "vendor_name": vendor.name,
#                     "business_name": vendor.business_name,
#                     "vendor_image": request.build_absolute_uri(f'/assets{vendor.vendor_image.url}' if vendor.vendor_image else vendor.vendor_image.url) if vendor.vendor_image else "",
#                     "fuel_receivables": receivables_fuel,
#                     "seed_receivables": receivables_seeds,
#                     "pesticide_receivables": receivables_pesticides,
#                     "fertilizer_receivables": receivables_fertilizers,
#                     "vehicle_receivables": receivables_vehicles,
#                     "machinery_receivables": receivables_machinery,
#                     "tool_receivables": receivables_tools
#                 })

#     return Response({
#         "detail": "Vendor inventory receivables fetched successfully.",
#         "vendor_inventory_data": vendor_inventory_data,
#         "language": {
#             "default": "en"
#         }
#     }, status=status.HTTP_200_OK)

@api_view(['GET'])
def vendor_purchase_receivables_list(request, farmer_id): 
    vendor_id = request.query_params.get('vendor_id', None)

    # Fetch vendors for the farmer who are marked as credit vendors
    vendors = MyVendor.objects.filter(farmer_id=farmer_id, status=0, is_customer_is_vendor=False)

    if vendor_id:
        vendors = vendors.filter(id=vendor_id)

    vendor_inventory_data = {"receivables": []}   

    for vendor in vendors: 
        if vendor.credit is True:  # â† Switch condition for receivables
            # Fuel
            fuel_purchases = MyFuel.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1]) 
            receivables_fuel = [
                {
                    "id": fuel.id,
                    "purchase_date": fuel.date_of_consumption,
                    "inventory_type": fuel.inventory_type.name if fuel.inventory_type else None,
                    "inventory_item": fuel.inventory_items.name if fuel.inventory_items else None,
                    "total_purchase_amount": fuel.purchase_amount,
                    "amount_paid": 0.0,
                    "received_amount": 0.0,
                    "toreceive_amount": 0.0
                }
                for fuel in fuel_purchases
            ]

            # Seeds
            seed_purchases = MySeeds.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1]) 
            receivables_seeds = [
                {
                    "id": seed.id,
                    "purchase_date": seed.date_of_consumption,
                    "inventory_type": seed.inventory_type.name if seed.inventory_type else None,
                    "inventory_item": seed.inventory_items.name if seed.inventory_items else None,
                    "total_purchase_amount": seed.purchase_amount,
                    "amount_paid": 0.0,
                    "received_amount": 0.0,
                    "toreceive_amount": 0.0
                }
                for seed in seed_purchases
            ]

            # Pesticides
            pesticide_purchases = MyPesticides.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1]) 
            receivables_pesticides = [
                {
                    "id": pesticide.id,
                    "purchase_date": pesticide.date_of_consumption,
                    "inventory_type": pesticide.inventory_type.name if pesticide.inventory_type else None,
                    "inventory_item": pesticide.inventory_items.name if pesticide.inventory_items else None,
                    "total_purchase_amount": pesticide.purchase_amount,
                    "amount_paid": 0.0,
                    "received_amount": 0.0,
                    "toreceive_amount": 0.0
                }
                for pesticide in pesticide_purchases
            ]

            # Fertilizers
            fertilizer_purchases = MyFertilizers.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1]) 
            receivables_fertilizers = [
                {
                    "id": fertilizer.id,
                    "purchase_date": fertilizer.date_of_consumption,
                    "inventory_type": fertilizer.inventory_type.name if fertilizer.inventory_type else None,
                    "inventory_item": fertilizer.inventory_items.name if fertilizer.inventory_items else None,
                    "total_purchase_amount": fertilizer.purchase_amount,
                    "amount_paid": 0.0,
                    "received_amount": 0.0,
                    "toreceive_amount": 0.0
                }
                for fertilizer in fertilizer_purchases
            ]

            # Vehicles
            vehicle_purchases = MyVehicle.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1]) 
            receivables_vehicles = [
                {
                    "id": vehicle.id,
                    "purchase_date": vehicle.date_of_consumption,
                    "inventory_type": vehicle.inventory_type.name if vehicle.inventory_type else None,
                    "inventory_item": vehicle.inventory_items.name if vehicle.inventory_items else None,
                    "total_purchase_amount": vehicle.purchase_amount,
                    "amount_paid": 0.0,
                    "received_amount": 0.0,
                    "toreceive_amount": 0.0
                }
                for vehicle in vehicle_purchases
            ]

            # Machinery
            machinery_purchases = MyMachinery.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1]) 
            receivables_machinery = [
                {
                    "id": machinery.id,
                    "purchase_date": machinery.date_of_consumption,
                    "inventory_type": machinery.inventory_type.name if machinery.inventory_type else None,
                    "inventory_item": machinery.inventory_items.name if machinery.inventory_items else None,
                    "total_purchase_amount": machinery.purchase_amount,
                    "amount_paid": 0.0,
                    "received_amount": 0.0,
                    "toreceive_amount": 0.0
                }
                for machinery in machinery_purchases
            ]

            # Tools
            tool_purchases = MyTools.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1]) 
            receivables_tools = [
                {
                    "id": tool.id,
                    "purchase_date": tool.date_of_consumption,
                    "inventory_type": tool.inventory_type.name if tool.inventory_type else None,
                    "inventory_item": tool.inventory_items.name if tool.inventory_items else None,
                    "total_purchase_amount": tool.purchase_amount,
                    "amount_paid": 0.0,
                    "received_amount": 0.0,
                    "toreceive_amount": 0.0
                }
                for tool in tool_purchases
            ]

            if any([receivables_fuel, receivables_seeds, receivables_pesticides, receivables_fertilizers, receivables_vehicles, receivables_machinery, receivables_tools]):
                vendor_inventory_data["receivables"].append({
                    "vendor_id": vendor.id,
                    "vendor_name": vendor.name,
                    "business_name": vendor.business_name,
                    "vendor_image": request.build_absolute_uri(f'/assets{vendor.vendor_image.url}' if vendor.vendor_image else vendor.vendor_image.url) if vendor.vendor_image else "",
                    "fuel_receivables": receivables_fuel,
                    "seed_receivables": receivables_seeds,
                    "pesticide_receivables": receivables_pesticides,
                    "fertilizer_receivables": receivables_fertilizers,
                    "vehicle_receivables": receivables_vehicles,
                    "machinery_receivables": receivables_machinery,
                    "tool_receivables": receivables_tools
                })

    return Response({
        "detail": "Vendor inventory receivables fetched successfully.",
        "vendor_inventory_data": vendor_inventory_data,
        "language": {
            "default": "en"
        }
    }, status=status.HTTP_200_OK)


# Outsatanding Customer Sales Receivables List
@api_view(['GET'])
def customer_sales_receivables_list(request, farmer_id):
    # Get the customer_id from the query parameters if provided
    customer_id = request.query_params.get('customer_id', None)

    # Base queryset
    customers = MyCustomer.objects.filter(farmer_id=farmer_id, status=0, is_customer_is_vendor=False)

    # If customer_id is provided, filter customers by customer_id
    if customer_id:
        customers = customers.filter(id=customer_id)

    customer_sales_data = {"receivables": []}  # Only keep receivables

    for customer in customers:
        # Only include customers where is_credit is True
        if customer.is_credit is True:
            sales = MySales.objects.filter(farmer_id=farmer_id, my_customer=customer,status=0)

            # List to hold individual receivable sales for this customer
            receivable_sales = []

            for sale in sales:
                sale_data = {
                    "sales_id": sale.id,
                    "sales_date": sale.dates_of_sales,
                    "crop_id": sale.my_crop.id if sale.my_crop else None,  # Add crop ID
                    "crop_name": sale.my_crop.crop.name if sale.my_crop else None,  # Add crop name   
                    "total_sales_amount": sale.total_sales_amount,
                    "amount_paid": sale.amount_paid,  
                    "received_amount": 0.0,
                    "topay_amount": 0.0
                }

                receivable_sales.append(sale_data)

            # Only add customer entry if they have receivable sales
            if receivable_sales:
                customer_sales_data["receivables"].append({
                    "customer_id": customer.id,
                    "customer_name": customer.customer_name,
                    "shop_name": customer.shop_name,
                    "customer_image": request.build_absolute_uri(f'/assets{customer.customer_img.url}' if customer.customer_img else customer.customer_img.url) if customer.customer_img else "",
                    "sales": receivable_sales
                })

    return Response({
        "detail": "Customer receivables fetched successfully.",
        "customer_sales": customer_sales_data,
        "language": {
            "default": "en"
        }
    }, status=status.HTTP_200_OK)

# Outsatanding Customer & Vendor Receivables List 
@api_view(['GET'])
def customer_vendor_receivables_list(request, farmer_id):
    vendor_id = request.query_params.get('vendor_id')
    customer_id = request.query_params.get('customer_id')

    vendors = MyVendor.objects.filter(farmer_id=farmer_id, status=0, is_customer_is_vendor=True)
    customers = MyCustomer.objects.filter(farmer_id=farmer_id, status=0, is_customer_is_vendor=True)

    if vendor_id:
        vendors = vendors.filter(id=vendor_id)
    if customer_id:
        customers = customers.filter(id=customer_id)

    data = {
        "vendor_receivables": [],
        "customer_receivables": []
    }

    for vendor in vendors:
        if vendor.credit is True:
            # Fuel
            fuel_purchases = MyFuel.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1])
            fuel_receivables = [{
                "fuel_purchase_id": fuel.id,
                "purchase_date": fuel.date_of_consumption,
                "inventory_type": fuel.inventory_type.name if fuel.inventory_type else None,
                "inventory_item": fuel.inventory_items.name if fuel.inventory_items else None,
                "total_purchase_amount": fuel.purchase_amount,
                "amount_paid": 0.0,
                "received_amount": 0.0,
                "toreceive_amount": 0.0
            } for fuel in fuel_purchases]

            # Seeds
            seed_receivables = [{
                "seed_purchase_id": seed.id,
                "purchase_date": seed.date_of_consumption,
                "inventory_type": seed.inventory_type.name if seed.inventory_type else None,
                "inventory_item": seed.inventory_items.name if seed.inventory_items else None,
                "total_purchase_amount": seed.purchase_amount,
                "amount_paid": 0.0,
                "received_amount": 0.0,
                "toreceive_amount": 0.0
            } for seed in MySeeds.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1])]

            # Pesticides
            pesticide_receivables = [{
                "pesticide_purchase_id": pesticide.id,
                "purchase_date": pesticide.date_of_consumption,
                "inventory_type": pesticide.inventory_type.name if pesticide.inventory_type else None,
                "inventory_item": pesticide.inventory_items.name if pesticide.inventory_items else None,
                "total_purchase_amount": pesticide.purchase_amount,
                "amount_paid": 0.0,
                "received_amount": 0.0,
                "toreceive_amount": 0.0
            } for pesticide in MyPesticides.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1])]

            # Fertilizers
            fertilizer_receivables = [{
                "fertilizer_purchase_id": fertilizer.id,
                "purchase_date": fertilizer.date_of_consumption,
                "inventory_type": fertilizer.inventory_type.name if fertilizer.inventory_type else None,
                "inventory_item": fertilizer.inventory_items.name if fertilizer.inventory_items else None,
                "total_purchase_amount": fertilizer.purchase_amount,
                "amount_paid": 0.0,
                "received_amount": 0.0,
                "toreceive_amount": 0.0
            } for fertilizer in MyFertilizers.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1])]

            # Vehicles
            vehicle_receivables = [{
                "vehicle_purchase_id": vehicle.id,
                "purchase_date": vehicle.date_of_consumption,
                "inventory_type": vehicle.inventory_type.name if vehicle.inventory_type else None,
                "inventory_item": vehicle.inventory_items.name if vehicle.inventory_items else None,
                "total_purchase_amount": vehicle.purchase_amount,
                "amount_paid": 0.0,
                "received_amount": 0.0,
                "toreceive_amount": 0.0
            } for vehicle in MyVehicle.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1])]

            # Machinery
            machinery_receivables = [{
                "machinery_purchase_id": machinery.id,
                "purchase_date": machinery.date_of_consumption,
                "inventory_type": machinery.inventory_type.name if machinery.inventory_type else None,
                "inventory_item": machinery.inventory_items.name if machinery.inventory_items else None,
                "total_purchase_amount": machinery.purchase_amount,
                "amount_paid": 0.0,
                "received_amount": 0.0,
                "toreceive_amount": 0.0
            } for machinery in MyMachinery.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1])]

            # Tools
            tool_receivables = [{
                "tool_purchase_id": tool.id,
                "purchase_date": tool.date_of_consumption,
                "inventory_type": tool.inventory_type.name if tool.inventory_type else None,
                "inventory_item": tool.inventory_items.name if tool.inventory_items else None,
                "total_purchase_amount": tool.purchase_amount,
                "amount_paid": 0.0,
                "received_amount": 0.0,
                "toreceive_amount": 0.0
            } for tool in MyTools.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1])]

            if any([fuel_receivables, seed_receivables, pesticide_receivables, fertilizer_receivables, vehicle_receivables, machinery_receivables, tool_receivables]):
                data["vendor_receivables"].append({
                    "vendor_id": vendor.id,
                    "vendor_name": vendor.name,
                    "business_name": vendor.business_name,
                    "vendor_image": request.build_absolute_uri(f'/assets{vendor.vendor_image.url}' if vendor.vendor_image else vendor.vendor_image.url) if vendor.vendor_image else "",
                    "fuel_receivables": fuel_receivables,
                    "seed_receivables": seed_receivables,
                    "pesticide_receivables": pesticide_receivables,
                    "fertilizer_receivables": fertilizer_receivables,
                    "vehicle_receivables": vehicle_receivables,
                    "machinery_receivables": machinery_receivables,
                    "tool_receivables": tool_receivables
                })

    for customer in customers:
        if customer.is_credit is True:
            sales = MySales.objects.filter(farmer_id=farmer_id, my_customer=customer,status=0)
            receivable_sales = [{
                "sales_id": sale.id,
                "sales_date": sale.dates_of_sales,
                "crop_id": sale.my_crop.id if sale.my_crop else None,
                "crop_name": sale.my_crop.crop.name if sale.my_crop else None,
                "total_sales_amount": sale.total_sales_amount,
                "amount_paid": sale.amount_paid,
                "received_amount": 0.0,
                "topay_amount": 0.0
            } for sale in sales]

            if receivable_sales:
                data["customer_receivables"].append({
                    "customer_id": customer.id,
                    "customer_name": customer.customer_name,
                    "shop_name": customer.shop_name,
                    "customer_image": request.build_absolute_uri(f'/assets{customer.customer_img.url}' if customer.customer_img else customer.customer_img.url) if customer.customer_img else "",
                    "sales": receivable_sales
                })

    return Response({
        "detail": "Vendor and Customer receivables fetched successfully.",
        "data": data,
        "language": {
            "default": "en"
        }
    }, status=status.HTTP_200_OK)

# Outsatanding Customer & Vendor Payables List
@api_view(['GET'])
def customer_vendor_payables_list(request, farmer_id):
    vendor_id = request.query_params.get('vendor_id')
    customer_id = request.query_params.get('customer_id')

    vendors = MyVendor.objects.filter(farmer_id=farmer_id, status=0, is_customer_is_vendor=True)
    customers = MyCustomer.objects.filter(farmer_id=farmer_id, status=0, is_customer_is_vendor=True)

    if vendor_id:
        vendors = vendors.filter(id=vendor_id)
    if customer_id:
        customers = customers.filter(id=customer_id)

    data = {
        "vendor_payables": [],
        "customer_payables": []
    }

    for vendor in vendors:
        if vendor.credit is False:
            # Fuel
            fuel_purchases = MyFuel.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1])
            fuel_payables = [{
                "fuel_purchase_id": fuel.id,
                "purchase_date": fuel.date_of_consumption,
                "inventory_type": fuel.inventory_type.name if fuel.inventory_type else None,
                "inventory_item": fuel.inventory_items.name if fuel.inventory_items else None,
                "total_purchase_amount": fuel.purchase_amount,
                "amount_paid": 0.0,
                "paid_amount": 0.0,
                "topay_amount": 0.0
            } for fuel in fuel_purchases]

            # Seeds
            seed_payables = [{
                "seed_purchase_id": seed.id,
                "purchase_date": seed.date_of_consumption,
                "inventory_type": seed.inventory_type.name if seed.inventory_type else None,
                "inventory_item": seed.inventory_items.name if seed.inventory_items else None,
                "total_purchase_amount": seed.purchase_amount,
                "amount_paid": 0.0,
                "paid_amount": 0.0,
                "topay_amount": 0.0
            } for seed in MySeeds.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1])]

            # Pesticides
            pesticide_payables = [{
                "pesticide_purchase_id": pesticide.id,
                "purchase_date": pesticide.date_of_consumption,
                "inventory_type": pesticide.inventory_type.name if pesticide.inventory_type else None,
                "inventory_item": pesticide.inventory_items.name if pesticide.inventory_items else None,
                "total_purchase_amount": pesticide.purchase_amount,
                "amount_paid": 0.0,
                "paid_amount": 0.0,
                "topay_amount": 0.0
            } for pesticide in MyPesticides.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1])]

            # Fertilizers
            fertilizer_payables = [{
                "fertilizer_purchase_id": fertilizer.id,
                "purchase_date": fertilizer.date_of_consumption,
                "inventory_type": fertilizer.inventory_type.name if fertilizer.inventory_type else None,
                "inventory_item": fertilizer.inventory_items.name if fertilizer.inventory_items else None,
                "total_purchase_amount": fertilizer.purchase_amount,
                "amount_paid": 0.0,
                "paid_amount": 0.0,
                "topay_amount": 0.0
            } for fertilizer in MyFertilizers.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1])]

            # Vehicles
            vehicle_payables = [{
                "vehicle_purchase_id": vehicle.id,
                "purchase_date": vehicle.date_of_consumption,
                "inventory_type": vehicle.inventory_type.name if vehicle.inventory_type else None,
                "inventory_item": vehicle.inventory_items.name if vehicle.inventory_items else None,
                "total_purchase_amount": vehicle.purchase_amount,
                "amount_paid": 0.0,
                "paid_amount": 0.0,
                "topay_amount": 0.0
            } for vehicle in MyVehicle.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1])]

            # Machinery
            machinery_payables = [{
                "machinery_purchase_id": machinery.id,
                "purchase_date": machinery.date_of_consumption,
                "inventory_type": machinery.inventory_type.name if machinery.inventory_type else None,
                "inventory_item": machinery.inventory_items.name if machinery.inventory_items else None,
                "total_purchase_amount": machinery.purchase_amount,
                "amount_paid": 0.0,
                "paid_amount": 0.0,
                "topay_amount": 0.0
            } for machinery in MyMachinery.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1])]

            # Tools
            tool_payables = [{
                "tool_purchase_id": tool.id,
                "purchase_date": tool.date_of_consumption,
                "inventory_type": tool.inventory_type.name if tool.inventory_type else None,
                "inventory_item": tool.inventory_items.name if tool.inventory_items else None,
                "total_purchase_amount": tool.purchase_amount,
                "amount_paid": 0.0,
                "paid_amount": 0.0,
                "topay_amount": 0.0
            } for tool in MyTools.objects.filter(farmer_id=farmer_id, vendor=vendor, status__in=[0, 1])]

            if any([fuel_payables, seed_payables, pesticide_payables, fertilizer_payables, vehicle_payables, machinery_payables, tool_payables]):
                data["vendor_payables"].append({
                    "vendor_id": vendor.id,
                    "vendor_name": vendor.name,
                    "business_name": vendor.business_name,
                    "vendor_image": request.build_absolute_uri(f'/assets{vendor.vendor_image.url}' if vendor.vendor_image else vendor.vendor_image.url) if vendor.vendor_image else "",
                    "fuel_payables": fuel_payables,
                    "seed_payables": seed_payables,
                    "pesticide_payables": pesticide_payables,
                    "fertilizer_payables": fertilizer_payables,
                    "vehicle_payables": vehicle_payables,
                    "machinery_payables": machinery_payables,
                    "tool_payables": tool_payables
                })

    for customer in customers:
        if customer.is_credit is False:
            sales = MySales.objects.filter(farmer_id=farmer_id, my_customer=customer,status=0)
            payable_sales = [{
                "sales_id": sale.id,
                "sales_date": sale.dates_of_sales,
                "crop_id": sale.my_crop.id if sale.my_crop else None,
                "crop_name": sale.my_crop.crop.name if sale.my_crop else None,
                "total_sales_amount": sale.total_sales_amount,
                "amount_paid": sale.amount_paid,
                "paid_amount": 0.0,
                "topay_amount": 0.0
            } for sale in sales]

            if payable_sales:
                data["customer_payables"].append({
                    "customer_id": customer.id,
                    "customer_name": customer.customer_name,
                    "shop_name": customer.shop_name,
                    "customer_image": request.build_absolute_uri(f'/assets{customer.customer_img.url}' if customer.customer_img else customer.customer_img.url) if customer.customer_img else "",
                    "sales": payable_sales
                })

    return Response({
        "detail": "Vendor and Customer payables fetched successfully.",
        "data": data,
        "language": {
            "default": "en"
        }
    }, status=status.HTTP_200_OK)


@api_view(['POST'])
def create_outstanding(request): 
    if request.method == 'POST':
        try:
            # Extract data from the request body
            farmer_id = request.data.get('farmer')
            customer_id = request.data.get('customer')
            sale_id = request.data.get('sale')
            balance = request.data.get('balance')
            payment = request.data.get('payment')
            to_receive = request.data.get('to_receive')
            payment_date = request.data.get('payment_date')  # should be in valid datetime format

            # Retrieve related objects
            farmer = Farmer.objects.get(id=farmer_id)
            customer = MyCustomer.objects.get(id=customer_id)
            sale = MySales.objects.get(id=sale_id)

            # Perform the necessary calculation
            total_received = float(sale.total_sales_amount) - float(to_receive)

            # Create the Outstanding record
            outstanding = Outstanding.objects.create(
                farmer=farmer,
                customer=customer,
                sale=sale,
                balance=float(balance),
                received=float(payment),
                to_receive=float(to_receive),
                received_date=payment_date,
                total_received=total_received,
                created_at=timezone.now(),
            )

            # Prepare the response data with detailed information
            response_data = {
                'status': 'success',
                'message': 'Outstanding created successfully',
                'outstanding': {
                    'id': outstanding.id,
                    'farmer': farmer.id,
                    'customer': customer.id,
                    'sale': sale.id,
                    'balance': outstanding.balance,
                    'received': outstanding.received,
                    'to_receive': outstanding.to_receive,
                    'received_date': outstanding.received_date,
                    'total_received': outstanding.total_received,
                    'created_at': outstanding.created_at,
                }
            }

            # Return a success response with the details of the created outstanding object
            return Response(response_data, status=status.HTTP_201_CREATED)

        except Exception as e:
            # Handle exceptions and return an error response
            return Response({
                'status': 'error',
                'message': str(e)
            }, status=status.HTTP_400_BAD_REQUEST)


@api_view(['GET'])
def vendor_purchase_list(request, farmer_id): 
    vendor_id = request.query_params.get('vendor_id', None)

    if not vendor_id:
        return Response({"error": "vendor_id query parameter is required"}, status=status.HTTP_400_BAD_REQUEST)
 
    try:
        vendor = MyVendor.objects.get(id=vendor_id)
    except MyVendor.DoesNotExist:
        return Response({"error": "Vendor not found"}, status=status.HTTP_404_NOT_FOUND)
 
    try:
        farmer = Farmer.objects.get(id=farmer_id)
    except Farmer.DoesNotExist:
        return Response({"error": "Farmer not found"}, status=status.HTTP_404_NOT_FOUND)
 
    purchases = MyFuel.objects.filter(vendor=vendor, farmer=farmer).values(
        'id', 'date_of_consumption', 'inventory_type', 'inventory_category', 
        'quantity', 'purchase_amount', 'status', 'description'
    )   

    if not purchases:
        return Response({"message": "No purchases found for this vendor and farmer"}, status=status.HTTP_404_NOT_FOUND)
 
    return Response(purchases, status=status.HTTP_200_OK)

@api_view(['GET'])
def crop_details(request, farmer_id, land_id, crop_id):
    try:
        # Fetch the crop using crop_id from the database
        crop = MyCrop.objects.get(id=crop_id, farmer_id=farmer_id, land_id=land_id,status=0)

        # Get survey details associated with the crop
        survey_details = crop.survey_details.all()
        survey_data = [
            {
                "id": survey.id,
                "survey_no": survey.survey_no,
                "survey_measurement_value": survey.survey_measurement_value,
                "survey_measurement_unit": survey.survey_measurement_unit.name if survey.survey_measurement_unit else None
            }
            for survey in survey_details
        ]
        
        # Construct the crop data with names for related objects
        crop_data = {
            "id": crop.id,
            "farmer": {
                "id": crop.farmer.id if crop.farmer else None,
                "name": crop.farmer.name if crop.farmer else None
            },
            "crop_type": {
                "id": crop.crop_type.id if crop.crop_type else None,
                "name": crop.crop_type.name if crop.crop_type else None
            },
            "crop": {
                "id": crop.crop.id if crop.crop else None,
                "name": crop.crop.name if crop.crop else None
            },
            "crop_img": request.build_absolute_uri(f'/SuperAdmin{crop.crop.img.url}' if crop.crop.img else crop.crop.img.url) if crop.crop.img else "",
            "harvesting_type": {
                "id": crop.harvesting_type.id if crop.harvesting_type else None,
                "name": crop.harvesting_type.name if crop.harvesting_type else None
            },
            "plantation_date": crop.plantation_date,
            "land": {
                "id": crop.land.id if crop.land else None,
                "name": crop.land.name if crop.land else None
            },
            "soil_type": {
                "id": crop.soil_type.id if crop.soil_type else None,
                "name": crop.soil_type.name if crop.soil_type else None
            },
            "taluk": {
                "id": crop.taluk.id if crop.taluk else None,
                "name": crop.taluk.name if crop.taluk else None
            },
            "village": {
                "id": crop.village.id if crop.village else None,
                "name": crop.village.name if crop.village else None
            },
            "measurement_value": crop.measurement_value,
            "measurement_unit": {
                "id": crop.measurement_unit.id if crop.measurement_unit else None,
                "name": crop.measurement_unit.name if crop.measurement_unit else None
            },
            "status": crop.status,
            "description": crop.description,
            "code": crop.code,
            "created_at": crop.created_at,
            "updated_at": crop.updated_at,
            "survey_details": survey_data
        }

        return Response(crop_data, status=status.HTTP_200_OK)

    except MyCrop.DoesNotExist:
        return Response({"error": "Crop not found."}, status=status.HTTP_404_NOT_FOUND)

@api_view(['POST'])
def deactivate_my_expense(request, farmer_id):
    try: 
        farmer = Farmer.objects.get(id=farmer_id)
    except Farmer.DoesNotExist:
        return Response({"error": "Farmer not found"}, status=status.HTTP_400_BAD_REQUEST)

    try: 
        my_expense_id = request.data.get('my_expense_id')
        if not my_expense_id:
            return Response({"error": "MyExpense ID is required in the payload."}, status=status.HTTP_400_BAD_REQUEST)
 
        my_expense = MyExpense.objects.get(id=my_expense_id, farmer=farmer)
    except MyExpense.DoesNotExist:
        return Response({"error": "MyExpense record not found or not associated with the specified farmer"}, status=status.HTTP_400_BAD_REQUEST)
 
    my_expense.status = 2
    my_expense.save()

    return Response({"message": "MyExpense deactivated successfully", "language": {"default": "en"}}, status=status.HTTP_200_OK)

@api_view(['POST'])
def delete_my_land_survey(request):
    try:
        # Extract the survey ID (pk) from the request body
        pk = request.data.get('survey_id', None)

        if not pk:
            return Response({"detail": "Survey ID is required."}, status=status.HTTP_400_BAD_REQUEST)

        # Fetch the MyLandSurveyDetails object by the provided primary key (pk)
        survey_detail = MyLandSurveyDetails.objects.get(pk=pk)

        # Delete the object
        survey_detail.delete()

        # Return success response
        return Response({"detail": "MyLandSurveyDetails deleted successfully."}, status=status.HTTP_200_OK)

    except MyLandSurveyDetails.DoesNotExist:
        return Response({"detail": "MyLandSurveyDetails not found."}, status=status.HTTP_404_NOT_FOUND)
 
@api_view(['POST'])
def delete_my_land_document(request):
    try:
        # Extract the document ID (pk) from the request body
        pk = request.data.get('document_id', None)

        if not pk:
            return Response({"detail": "Document ID is required."}, status=status.HTTP_400_BAD_REQUEST)
        
        # Fetch the MyLandDocument object by the provided primary key (pk)
        survey_detail = MyLandDocument.objects.get(pk=pk)

        # Delete the object
        survey_detail.delete()

        # Return success response
        return Response({"detail": "MyLandDocument deleted successfully."}, status=status.HTTP_200_OK)

    except MyLandDocument.DoesNotExist:
        return Response({"detail": "MyLandDocument not found."}, status=status.HTTP_404_NOT_FOUND)
    
@api_view(['POST'])
def delete_my_sales_document(request):
    try:
        # Extract the document ID (pk) from the request body
        pk = request.data.get('document_id', None)

        if not pk:
            return Response({"detail": "Document ID is required."}, status=status.HTTP_400_BAD_REQUEST)

        # Fetch the SalesDocument object by the provided primary key (pk)
        sales = SalesDocument.objects.get(pk=pk)

        # Delete the object
        sales.delete()

        # Return success response
        return Response({"detail": "SalesDocument deleted successfully."}, status=status.HTTP_200_OK)

    except SalesDocument.DoesNotExist:
        return Response({"detail": "SalesDocument not found."}, status=status.HTTP_404_NOT_FOUND)

@api_view(['POST'])
def delete_my_sales_deduction_reason(request):
    try:
        # Extract the deduction reason ID (pk) from the request body
        pk = request.data.get('deduction_reason_id', None)

        if not pk:
            return Response({"detail": "Deduction Reason ID is required."}, status=status.HTTP_400_BAD_REQUEST)

        # Fetch the DeductionReasons object by the provided primary key (pk)
        sales = DeductionReasons.objects.get(pk=pk)

        # Delete the object
        sales.delete()

        # Return success response
        return Response({"detail": "Deduction Reasons deleted successfully."}, status=status.HTTP_200_OK)

    except DeductionReasons.DoesNotExist:
        return Response({"detail": "Deduction Reasons not found."}, status=status.HTTP_404_NOT_FOUND)

@api_view(['POST'])
def delete_my_fuel_document(request):
    try:
        # Extract the document ID (pk) from the request body
        pk = request.data.get('document_id', None)

        if not pk:
            return Response({"detail": "Document ID is required."}, status=status.HTTP_400_BAD_REQUEST)
        
        # Fetch the MyFuelDocuments object by the provided primary key (pk)
        fuel_document = MyFuelDocuments.objects.get(pk=pk)

        # Delete the object
        fuel_document.delete()

        # Return success response
        return Response({"detail": "MyFuelDocuments deleted successfully."}, status=status.HTTP_200_OK)

    except MyFuelDocuments.DoesNotExist:
        return Response({"detail": "MyFuelDocuments not found."}, status=status.HTTP_404_NOT_FOUND)
 
 

@api_view(['GET'])
def get_farmer_land_usage(request, farmer_id):
    try:
        # Fetch the farmer
        farmer = Farmer.objects.get(id=farmer_id, status=0)

        # Fetch only active subscriptions
        subscriptions = farmer.subscriptions.filter(status=0)

        if not subscriptions.exists():
            return Response({"detail": "No subscriptions found for this farmer."}, status=status.HTTP_404_NOT_FOUND)

        # Collect the unique package IDs from subscriptions
        package_ids = subscriptions.values_list('packages', flat=True).distinct()

        # Initialize a list to hold package details
        package_details = []

        # Iterate through each package and gather usage counts
        for package_id in package_ids:
            try:
                package = PackageManagement.objects.get(id=package_id)
            except PackageManagement.DoesNotExist:
                continue  # Skip if package not found

            # Usage counts
            land_count_used = MyLand.objects.filter(farmer=farmer, status=0).count()
            crop_count_used = MyCrop.objects.filter(farmer=farmer, status=0).count()
            expense_count_used = MyExpense.objects.filter(farmer=farmer, status=0).count()
            sales_count_used = MySales.objects.filter(farmer=farmer, status=0).count()
            customer_count_used = MyCustomer.objects.filter(farmer=farmer, status=0).count()
            myfuel_count_used = MyFuel.objects.filter(farmer=farmer, status=0).count()
            myvehicle_count_used = MyVehicle.objects.filter(farmer=farmer, status=0).count()
            mymachinery_count_used = MyMachinery.objects.filter(farmer=farmer, status=0).count()
            mytools_count_used = MyTools.objects.filter(farmer=farmer, status=0).count()
            mypesticides_count_used = MyPesticides.objects.filter(farmer=farmer, status=0).count()
            myfertilizers_count_used = MyFertilizers.objects.filter(farmer=farmer, status=0).count()
            myseeds_count_used = MySeeds.objects.filter(farmer=farmer, status=0).count()
            myvendor_count_used = MyVendor.objects.filter(farmer=farmer, status=0).count()
            employee_count_used = Employee.objects.filter(farmer=farmer, status=0).count()

            # Add package usage details to the list
            package_details.append({
                "id": package.id,
                "name": package.name,
                "myland_count": package.myland_count,
                "land_count_used": land_count_used,
                "mycrops_count": package.mycrops_count,
                "crop_count_used": crop_count_used,
                "myexpense_count": package.myexpense_count,
                "expense_count_used": expense_count_used,
                "mysale_count": package.mysale_count,
                "sales_count_used": sales_count_used,
                "customer_count": package.customer_count,
                "customer_count_used": customer_count_used,
                "myfuel_count": package.myfuel_count,
                "myfuel_count_used": myfuel_count_used,
                "myvechicle_count": package.myvechicle_count,
                "myvehicle_count_used": myvehicle_count_used,
                "mymachinery_count": package.mymachinery_count,
                "mymachinery_count_used": mymachinery_count_used,
                "mytools_count": package.mytools_count,
                "mytools_count_used": mytools_count_used,
                "mypesticides_count": package.mypesticides_count,
                "mypesticides_count_used": mypesticides_count_used,
                "myfertilizers_count": package.myfertilizers_count,
                "myfertilizers_count_used": myfertilizers_count_used,
                "myseeds_count": package.myseeds_count,
                "myseeds_count_used": myseeds_count_used,
                "myinventory_vendors": package.myinventory_vendors,
                "myvendor_count_used": myvendor_count_used,
                "employee_count": package.employee_count,
                "employee_count_used": employee_count_used,
                "employee_count": package.employee_count,
                "is_widget": package.is_widget,
            })

        return Response({
            # "farmer": {
            #     "name": farmer.name,
            #     "start_date": farmer.subscription_start_date,
            #     "end_date": farmer.subscription_end_date,
            #     "package_details": package_details
            # }
            "name": farmer.name,
            "start_date": farmer.subscription_start_date,
            "end_date": farmer.subscription_end_date,
            "package_details": package_details
        }, status=status.HTTP_200_OK)

    except Farmer.DoesNotExist:
        return Response({"detail": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)

 
@api_view(['GET'])
def get_all_reasons(request):
    language_code = request.GET.get('lang', 'en') 
    reasons = Reasons.objects.all() 
    reason_list = [{'id': reason.id, 'name': reason.get_translated_value('name', language_code)} for reason in reasons] 
    return Response(reason_list)


@api_view(['GET'])
def get_all_rupees(request): 
    rupees = Rupee.objects.all() 
    rupees_list = [{'id': rupees.id, 'name': rupees.name} for rupees in rupees] 
    return Response(rupees_list)
 
 
@api_view(['POST'])
def get_expense_totals(request):
    # Retrieve the farmer_id and time_period from the request body
    farmer_id = request.data.get('farmer_id')
    time_period = request.data.get('time_period')

    if not farmer_id or not time_period:
        return Response({"error": "Both 'farmer_id' and 'time_period' are required."}, status=400)
 
    today = timezone.now().date()
 
    if time_period == "year":
        start_date = today.replace(year=today.year - 1)   
    elif time_period == "30days":
        start_date = today - timedelta(days=30)  # 30 days ago
    elif time_period == "week":
        start_date = today - timedelta(weeks=1)  # 1 week ago
    else:
        return Response({"error": "Invalid time_period. Use 'year', '30days', or 'week'."}, status=400)

    # Filter expenses by the given farmer_id and time range
    expenses = MyExpense.objects.filter(
        farmer_id=farmer_id,
        created_day__gte=start_date
    ).values('type_expenses__name') \
        .annotate(total_amount=Sum('amount')) \
        .order_by('type_expenses__name')  # Optional: Order the results by type_expenses name

    # Calculate the total amount for the farmer in the given time period
    total_amount = MyExpense.objects.filter(
        farmer_id=farmer_id,
        created_day__gte=start_date
    ).aggregate(total=Sum('amount'))['total']

    if not total_amount:  # If total_amount is None, handle the case
        return Response({"error": "No expenses found for the given time period."}, status=400)

    # Calculate the percentage for each type_expenses
    expense_data = []
    for expense in expenses:
        expense_data.append({
            'type_expenses__name': expense['type_expenses__name'],
            'total_amount': expense['total_amount'],
            'percentage': (expense['total_amount'] / total_amount) * 100
        })

    return Response(expense_data)

# @api_view(['GET'])
# def get_fuel_inventory_details(request, farmer_id, inventory_type_id, inventory_items_id):
#     # Fetch the farmer, inventory type, and inventory items
#     farmer = get_object_or_404(Farmer, id=farmer_id)
#     inventory_type = get_object_or_404(InventoryType, id=inventory_type_id)
#     inventory_items = get_object_or_404(InventoryItems, id=inventory_items_id)

#     # Filter inventories based on farmer, inventory type, and inventory items
#     inventories = MyInventory.objects.filter(
#         farmer=farmer, 
#         inventory_type=inventory_type, 
#         inventory_items=inventory_items
#     )

#     # Prepare response data
#     response_data = {
#         'fuel_purchase': [],
#         'fuel_consumption': []
#     }

#     # Iterate over the inventories to structure the response
#     for inventory in inventories:
#         # Fuel Purchase
#         if inventory.fuel_purchase:
#             fuel_purchase_data = {
#                 'id': inventory.fuel_purchase.id,
#                 'vendor': {
#                     'id': inventory.fuel_purchase.vendor.id if inventory.fuel_purchase.vendor else None,
#                     'name': inventory.fuel_purchase.vendor.name if inventory.fuel_purchase.vendor else "Unknown",
#                 },
#                 'inventory_type': {
#                     'id': inventory.fuel_purchase.inventory_type.id if inventory.fuel_purchase.inventory_type else None,
#                     'name': inventory.fuel_purchase.inventory_type.name if inventory.fuel_purchase.inventory_type else "Unknown",
#                 },
#                 'inventory_category': {
#                     'id': inventory.fuel_purchase.inventory_category.id if inventory.fuel_purchase.inventory_category else None,
#                     'name': inventory.fuel_purchase.inventory_category.name if inventory.fuel_purchase.inventory_category else "Unknown",
#                 },
#                 'inventory_items': {
#                     'id': inventory.fuel_purchase.inventory_items.id if inventory.fuel_purchase.inventory_items else None,
#                     'name': inventory.fuel_purchase.inventory_items.name if inventory.fuel_purchase.inventory_items else "Unknown",
#                 },
#                 'quantity': str(inventory.fuel_purchase.quantity) if inventory.fuel_purchase.quantity else "0.00",
#                 'purchase_amount': str(inventory.fuel_purchase.purchase_amount) if inventory.fuel_purchase.purchase_amount else "0.00",
#                 'description': inventory.fuel_purchase.description if inventory.fuel_purchase.description else "N/A",
#                 'date_of_consumption': str(inventory.fuel_purchase.date_of_consumption) if inventory.fuel_purchase.date_of_consumption else "N/A",
#                 'available_quans': str(inventory.fuel_purchase.available_quans) if inventory.fuel_purchase.available_quans else "0.00",
#                 'created_at': str(inventory.fuel_purchase.created_at) if inventory.fuel_purchase.created_at else "N/A",
#                 'updated_at': str(inventory.fuel_purchase.updated_at) if inventory.fuel_purchase.updated_at else "N/A",
#                 'farmer': {
#                     'id': inventory.fuel_purchase.farmer.id if inventory.fuel_purchase.farmer else None,
#                     'name': inventory.fuel_purchase.farmer.name if inventory.fuel_purchase.farmer else "Unknown",
#                 },
#                 'documents': {}  # Dictionary to group documents by file_type
#             }

#             # Add document details for fuel purchase, grouped by file_type
#             fuel_purchase_documents = MyFuelDocuments.objects.filter(fuel=inventory.fuel_purchase)
#             for doc in fuel_purchase_documents:
#                 file_type = doc.file_type.name if doc.file_type else "Unknown"
#                 file_type_id = doc.file_type.id if doc.file_type else None
#                 document_data = {
#                     'id': doc.id,
#                     'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
#                 }

#                 # Group documents by file_type
#                 if file_type not in fuel_purchase_data['documents']:
#                     fuel_purchase_data['documents'][file_type] = {
#                         'id': file_type_id,
#                         'name': file_type,
#                         'documents': []
#                     }
#                 fuel_purchase_data['documents'][file_type]['documents'].append(document_data)

#             response_data['fuel_purchase'].append(fuel_purchase_data)

#         # Fuel Consumption
#         fuel_consumption_data = {
#             'id': inventory.id,
#             'quantity_utilized': str(inventory.quantity_utilized) if inventory.quantity_utilized else "0.00",
#             'date_of_consumption': str(inventory.date_of_consumption) if inventory.date_of_consumption else "N/A",
#             'description': inventory.description if inventory.description else "N/A",
#             'start_kilometer': str(inventory.start_kilometer) if inventory.start_kilometer else "0.00",
#             'end_kilometer': str(inventory.end_kilometer) if inventory.end_kilometer else "0.00",
#             'usage_hours': str(inventory.usage_hours) if inventory.usage_hours else "0.00",
#             'tool_items': inventory.tool_items if inventory.tool_items else "N/A",
#             'rental': str(inventory.rental) if inventory.rental else "1",
#             'vehicle_purchase': {
#                 'id': inventory.vehicle_purchase.id if inventory.vehicle_purchase else None,
#                 'name': inventory.vehicle_purchase.name if inventory.vehicle_purchase else "Unknown"
#             },
#             'machinery_purchase': {
#                 'id': inventory.machinery_purchase.id if inventory.machinery_purchase else None,
#                 'name': inventory.machinery_purchase.name if inventory.machinery_purchase else "Unknown"
#             },
#             'tool_purchase': {
#                 'id': inventory.tool_purchase.id if inventory.tool_purchase else None,
#                 'name': inventory.tool_purchase.name if inventory.tool_purchase else "Unknown"
#             },
#             'fertilizer_purchase': {
#                 'id': inventory.fertilizer_purchase.id if inventory.fertilizer_purchase else None,
#                 'name': inventory.fertilizer_purchase.name if inventory.fertilizer_purchase else "Unknown"
#             },
#             'pesticide_purchase': {
#                 'id': inventory.pesticide_purchase.id if inventory.pesticide_purchase else None,
#                 'name': inventory.pesticide_purchase.name if inventory.pesticide_purchase else "Unknown"
#             },
#             'seeds_purchase': {
#                 'id': inventory.seeds_purchase.id if inventory.seeds_purchase else None,
#                 'name': inventory.seeds_purchase.name if inventory.seeds_purchase else "Unknown"
#             },
#             'status': inventory.status,
#             'created_at': str(inventory.created_at) if inventory.created_at else "N/A",
#             'updated_at': str(inventory.updated_at) if inventory.updated_at else "N/A",
#             'farmer': {
#                 'id': inventory.farmer.id if inventory.farmer else None,
#                 'name': inventory.farmer.name if inventory.farmer else "Unknown",
#             },
#             'documents': {}  # Dictionary to group documents by file_type
#         }

#         # Add document details for consumption, grouped by file_type
#         inventory_documents = MyInventoryDocuments.objects.filter(my_inventory=inventory)
#         for doc in inventory_documents:
#             file_type = doc.file_type.name if doc.file_type else "Unknown"
#             file_type_id = doc.file_type.id if doc.file_type else None
#             document_data = {
#                 'id': doc.id,
#                 'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
#             }

#             # Group documents by file_type
#             if file_type not in fuel_consumption_data['documents']:
#                 fuel_consumption_data['documents'][file_type] = {
#                     'id': file_type_id,
#                     'name': file_type,
#                     'documents': []
#                 }
#             fuel_consumption_data['documents'][file_type]['documents'].append(document_data)

#         response_data['fuel_consumption'].append(fuel_consumption_data)

#     return Response(response_data)

# @api_view(['GET'])
# def get_fuel_inventory_details(request, farmer_id, inventory_type_id, inventory_items_id): 
#     farmer = get_object_or_404(Farmer, id=farmer_id)
#     inventory_type = get_object_or_404(InventoryType, id=inventory_type_id)
#     inventory_items = get_object_or_404(InventoryItems, id=inventory_items_id)
 
#     inventories = MyInventory.objects.filter(
#         farmer=farmer, 
#         inventory_type=inventory_type, 
#         inventory_items=inventory_items
#     )
 
#     response_data = {
#         'fuel_purchase': [],
#         'fuel_consumption': []
#     }
 
#     for inventory in inventories: 
        
#         if inventory.fuel_purchase:
#             fuel_purchase_data = {
#                 'id': inventory.fuel_purchase.id,
#                 'vendor': {
#                     'id': inventory.fuel_purchase.vendor.id if inventory.fuel_purchase.vendor else None,
#                     'name': inventory.fuel_purchase.vendor.name if inventory.fuel_purchase.vendor else "Unknown",
#                 },
#                 'inventory_type': {
#                     'id': inventory.fuel_purchase.inventory_type.id if inventory.fuel_purchase.inventory_type else None,
#                     'name': inventory.fuel_purchase.inventory_type.name if inventory.fuel_purchase.inventory_type else "Unknown",
#                 },
#                 'inventory_category': {
#                     'id': inventory.fuel_purchase.inventory_category.id if inventory.fuel_purchase.inventory_category else None,
#                     'name': inventory.fuel_purchase.inventory_category.name if inventory.fuel_purchase.inventory_category else "Unknown",
#                 },
#                 'inventory_items': {
#                     'id': inventory.fuel_purchase.inventory_items.id if inventory.fuel_purchase.inventory_items else None,
#                     'name': inventory.fuel_purchase.inventory_items.name if inventory.fuel_purchase.inventory_items else "Unknown",
#                 },
#                 'quantity': str(inventory.fuel_purchase.quantity) if inventory.fuel_purchase.quantity else "0.00",
#                 'purchase_amount': str(inventory.fuel_purchase.purchase_amount) if inventory.fuel_purchase.purchase_amount else "0.00",
#                 'description': inventory.fuel_purchase.description if inventory.fuel_purchase.description else "N/A",
#                 'date_of_consumption': str(inventory.fuel_purchase.date_of_consumption) if inventory.fuel_purchase.date_of_consumption else "N/A",
#                 'available_quans': str(inventory.fuel_purchase.available_quans) if inventory.fuel_purchase.available_quans else "0.00",
#                 'created_at': str(inventory.fuel_purchase.created_at) if inventory.fuel_purchase.created_at else "N/A",
#                 'updated_at': str(inventory.fuel_purchase.updated_at) if inventory.fuel_purchase.updated_at else "N/A",
#                 'farmer': {
#                     'id': inventory.fuel_purchase.farmer.id if inventory.fuel_purchase.farmer else None,
#                     'name': inventory.fuel_purchase.farmer.name if inventory.fuel_purchase.farmer else "Unknown",
#                 },
#                 'documents': {}  # Dictionary to group documents by file_type
#             }

#             # Add document details for fuel purchase, grouped by file_type
#             fuel_purchase_documents = MyFuelDocuments.objects.filter(fuel=inventory.fuel_purchase)
#             for doc in fuel_purchase_documents:
#                 file_type = doc.file_type.name if doc.file_type else "Unknown"
#                 file_type_id = doc.file_type.id if doc.file_type else None
#                 document_data = {
#                     'id': doc.id,
#                     'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
#                 }

#                 # Group documents by file_type
#                 if file_type not in fuel_purchase_data['documents']:
#                     fuel_purchase_data['documents'][file_type] = {
#                         'id': file_type_id,
#                         'name': file_type,
#                         'documents': []
#                     }
#                 fuel_purchase_data['documents'][file_type]['documents'].append(document_data)

#             # Include crop data in fuel purchase response
    

#             response_data['fuel_purchase'].append(fuel_purchase_data)
 
#         fuel_consumption_data = {
#             'id': inventory.id,
#             'quantity_utilized': str(inventory.quantity_utilized) if inventory.quantity_utilized else "0.00",
#             'date_of_consumption': str(inventory.date_of_consumption) if inventory.date_of_consumption else "N/A",
#             'description': inventory.description if inventory.description else "N/A",
#             'start_kilometer': str(inventory.start_kilometer) if inventory.start_kilometer else "0.00",
#             'end_kilometer': str(inventory.end_kilometer) if inventory.end_kilometer else "0.00",
#             'usage_hours': str(inventory.usage_hours) if inventory.usage_hours else "0.00",
#             'tool_items': inventory.tool_items if inventory.tool_items else "N/A",
#             'rental': str(inventory.rental) if inventory.rental else "1",
#             'crop_id': inventory.crop.id if inventory.crop else None,
#             'crop_name': inventory.crop.crop.name if inventory.crop else "Unknown Crop",  
#             'crop_description': inventory.crop.description if inventory.crop and inventory.crop.description else "N/A",  # Added null check
#             'image_url': request.build_absolute_uri(f'/assets{inventory.crop.crop.img.url}' if inventory.crop and inventory.crop.crop.img else '/assets/images/default_crop.png'),
#             'land': {
#                 'id': inventory.crop.land.id if inventory.crop and inventory.crop.land else None,
#                 'name': inventory.crop.land.name if inventory.crop and inventory.crop.land else "Unknown Land",
#             },
#             'vehicle_purchase': {
#                 'id': inventory.vehicle_purchase.id if inventory.vehicle_purchase else None,
#                 'name': inventory.vehicle_purchase.name if inventory.vehicle_purchase else "Unknown"
#             },
#             'machinery_purchase': {
#                 'id': inventory.machinery_purchase.id if inventory.machinery_purchase else None,
#                 'name': inventory.machinery_purchase.name if inventory.machinery_purchase else "Unknown"
#             },
#             'tool_purchase': {
#                 'id': inventory.tool_purchase.id if inventory.tool_purchase else None,
#                 'name': inventory.tool_purchase.name if inventory.tool_purchase else "Unknown"
#             },
#             'fertilizer_purchase': {
#                 'id': inventory.fertilizer_purchase.id if inventory.fertilizer_purchase else None,
#                 'name': inventory.fertilizer_purchase.name if inventory.fertilizer_purchase else "Unknown"
#             },
#             'pesticide_purchase': {
#                 'id': inventory.pesticide_purchase.id if inventory.pesticide_purchase else None,
#                 'name': inventory.pesticide_purchase.name if inventory.pesticide_purchase else "Unknown"
#             },
#             'seeds_purchase': {
#                 'id': inventory.seeds_purchase.id if inventory.seeds_purchase else None,
#                 'name': inventory.seeds_purchase.name if inventory.seeds_purchase else "Unknown"
#             },
#             'status': inventory.status,
#             'created_at': str(inventory.created_at) if inventory.created_at else "N/A",
#             'updated_at': str(inventory.updated_at) if inventory.updated_at else "N/A",
#             'farmer': {
#                 'id': inventory.farmer.id if inventory.farmer else None,
#                 'name': inventory.farmer.name if inventory.farmer else "Unknown",
#             },
#             'documents': {}  # Dictionary to group documents by file_type
#         }
 
#         inventory_documents = MyInventoryDocuments.objects.filter(my_inventory=inventory)
#         for doc in inventory_documents:
#             file_type = doc.file_type.name if doc.file_type else "Unknown"
#             file_type_id = doc.file_type.id if doc.file_type else None
#             document_data = {
#                 'id': doc.id,
#                 'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
#             }
 
#             if file_type not in fuel_consumption_data['documents']:
#                 fuel_consumption_data['documents'][file_type] = {
#                     'id': file_type_id,
#                     'name': file_type,
#                     'documents': []
#                 }
#             fuel_consumption_data['documents'][file_type]['documents'].append(document_data)
 

#         response_data['fuel_consumption'].append(fuel_consumption_data)

#     return Response(response_data)

@api_view(['GET'])
def get_fuel_inventory_details(request, farmer_id, inventory_type_id, inventory_items_id): 
    farmer = get_object_or_404(Farmer, id=farmer_id)
    inventory_type = get_object_or_404(InventoryType, id=inventory_type_id)
    inventory_items = get_object_or_404(InventoryItems, id=inventory_items_id)
    
    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'

    inventories = MyInventory.objects.filter(
        farmer=farmer, 
        inventory_type=inventory_type, 
        inventory_items=inventory_items
    )
 
    response_data = {
        'fuel_purchase': [],
        'fuel_consumption': []
    }
 
    for inventory in inventories: 
        
        if inventory.fuel_purchase:
            fuel_purchase_data = {
                'id': inventory.fuel_purchase.id,
                'vendor': {
                    'id': inventory.fuel_purchase.vendor.id if inventory.fuel_purchase.vendor else None,
                    'name': inventory.fuel_purchase.vendor.get_translated_value("name", language_code) if inventory.fuel_purchase.vendor else "Unknown",
                },
                'inventory_type': {
                    'id': inventory.fuel_purchase.inventory_type.id if inventory.fuel_purchase.inventory_type else None,
                    'name': inventory.fuel_purchase.inventory_type.get_translated_value("name", language_code) if inventory.fuel_purchase.inventory_type else "Unknown",
                },
                'inventory_category': {
                    'id': inventory.fuel_purchase.inventory_category.id if inventory.fuel_purchase.inventory_category else None,
                    'name': inventory.fuel_purchase.inventory_category.get_translated_value("name", language_code) if inventory.fuel_purchase.inventory_category else "Unknown",
                },
                'inventory_items': {
                    'id': inventory.fuel_purchase.inventory_items.id if inventory.fuel_purchase.inventory_items else None,
                    'name': inventory.fuel_purchase.inventory_items.get_translated_value("name", language_code) if inventory.fuel_purchase.inventory_items else "Unknown",
                },
                'quantity': str(inventory.fuel_purchase.quantity) if inventory.fuel_purchase.quantity else "0.00",
                'purchase_amount': str(inventory.fuel_purchase.purchase_amount) if inventory.fuel_purchase.purchase_amount else "0.00",
                'description': inventory.fuel_purchase.get_translated_value("description", language_code) if inventory.fuel_purchase.description else "N/A",
                'date_of_consumption': str(inventory.fuel_purchase.date_of_consumption) if inventory.fuel_purchase.date_of_consumption else "N/A",
                'available_quans': str(inventory.fuel_purchase.available_quans) if inventory.fuel_purchase.available_quans else "0.00",
                'created_at': str(inventory.fuel_purchase.created_at) if inventory.fuel_purchase.created_at else "N/A",
                'updated_at': str(inventory.fuel_purchase.updated_at) if inventory.fuel_purchase.updated_at else "N/A",
                'farmer': {
                    'id': inventory.fuel_purchase.farmer.id if inventory.fuel_purchase.farmer else None,
                    'name': inventory.fuel_purchase.farmer.get_translated_value("name", language_code) if inventory.fuel_purchase.farmer else "Unknown",
                },
                'documents': {}  # Dictionary to group documents by file_type
            }

            # Add document details for fuel purchase, grouped by file_type
            fuel_purchase_documents = MyFuelDocuments.objects.filter(fuel=inventory.fuel_purchase)
            for doc in fuel_purchase_documents:
                file_type = doc.file_type.get_translated_value("name", language_code) if doc.file_type else "Unknown"
                file_type_id = doc.file_type.id if doc.file_type else None
                document_data = {
                    'id': doc.id,
                    'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
                }

                # Group documents by file_type
                if file_type not in fuel_purchase_data['documents']:
                    fuel_purchase_data['documents'][file_type] = {
                        'id': file_type_id,
                        'name': file_type,
                        'documents': []
                    }
                fuel_purchase_data['documents'][file_type]['documents'].append(document_data)

            # Include crop data in fuel purchase response
    

            response_data['fuel_purchase'].append(fuel_purchase_data)
 
        fuel_consumption_data = {
            'id': inventory.id,
            'quantity_utilized': str(inventory.quantity_utilized) if inventory.quantity_utilized else "0.00",
            'date_of_consumption': str(inventory.date_of_consumption) if inventory.date_of_consumption else "N/A",
            'description': inventory.get_translated_value("description", language_code) if inventory.description else "N/A",
            'start_kilometer': str(inventory.start_kilometer) if inventory.start_kilometer else "0.00",
            'end_kilometer': str(inventory.end_kilometer) if inventory.end_kilometer else "0.00",
            'usage_hours': str(inventory.usage_hours) if inventory.usage_hours else "0.00",
            'tool_items': inventory.tool_items if inventory.tool_items else "N/A",
            'rental': str(inventory.rental) if inventory.rental else "1",
            'crop_id': inventory.crop.id if inventory.crop else None,
            'crop_name': inventory.crop.crop.get_translated_value("name", language_code) if inventory.crop else "Unknown Crop",  
            'crop_description': inventory.crop.get_translated_value("description", language_code) if inventory.crop and inventory.crop.description else "N/A",  # Added null check
            'image_url': request.build_absolute_uri(f'/assets{inventory.crop.crop.img.url}' if inventory.crop and inventory.crop.crop.img else '/assets/images/default_crop.png'),
            'land': {
                'id': inventory.crop.land.id if inventory.crop and inventory.crop.land else None,
                'name': inventory.crop.land.get_translated_value("name", language_code) if inventory.crop and inventory.crop.land else "Unknown Land",
            },
            'vehicle_purchase': {
                'id': inventory.vehicle_purchase.id if inventory.vehicle_purchase else None,
                'name': inventory.vehicle_purchase.get_translated_value("name", language_code) if inventory.vehicle_purchase else "Unknown"
            },
            'machinery_purchase': {
                'id': inventory.machinery_purchase.id if inventory.machinery_purchase else None,
                'name': inventory.machinery_purchase.get_translated_value("name", language_code) if inventory.machinery_purchase else "Unknown"
            },
            'tool_purchase': {
                'id': inventory.tool_purchase.id if inventory.tool_purchase else None,
                'name': inventory.tool_purchase.get_translated_value("name", language_code) if inventory.tool_purchase else "Unknown"
            },
            'fertilizer_purchase': {
                'id': inventory.fertilizer_purchase.id if inventory.fertilizer_purchase else None,
                'name': inventory.fertilizer_purchase.get_translated_value("name", language_code) if inventory.fertilizer_purchase else "Unknown"
            },
            'pesticide_purchase': {
                'id': inventory.pesticide_purchase.id if inventory.pesticide_purchase else None,
                'name': inventory.pesticide_purchase.get_translated_value("name", language_code) if inventory.pesticide_purchase else "Unknown"
            },
            'seeds_purchase': {
                'id': inventory.seeds_purchase.id if inventory.seeds_purchase else None,
                'name': inventory.seeds_purchase.get_translated_value("name", language_code) if inventory.seeds_purchase else "Unknown"
            },
            'status': inventory.status,
            'created_at': str(inventory.created_at) if inventory.created_at else "N/A",
            'updated_at': str(inventory.updated_at) if inventory.updated_at else "N/A",
            'farmer': {
                'id': inventory.farmer.id if inventory.farmer else None,
                'name': inventory.farmer.get_translated_value("name", language_code) if inventory.farmer else "Unknown",
            },
            'documents': {}  # Dictionary to group documents by file_type
        }
 
        inventory_documents = MyInventoryDocuments.objects.filter(my_inventory=inventory)
        for doc in inventory_documents:
            file_type = doc.file_type.get_translated_value("name", language_code) if doc.file_type else "Unknown"
            file_type_id = doc.file_type.id if doc.file_type else None
            document_data = {
                'id': doc.id,
                'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
            }
 
            if file_type not in fuel_consumption_data['documents']:
                fuel_consumption_data['documents'][file_type] = {
                    'id': file_type_id,
                    'name': file_type,
                    'documents': []
                }
            fuel_consumption_data['documents'][file_type]['documents'].append(document_data)
 

        response_data['fuel_consumption'].append(fuel_consumption_data)

    return Response(response_data)


# @api_view(['PUT'])
# def update_inventory_with_documents(request, inventory_id):
#     if request.method == 'PUT':
#         data = request.data

#         # Fetch the existing inventory by ID
#         try:
#             my_inventory = MyInventory.objects.get(id=inventory_id, status=0)
#         except MyInventory.DoesNotExist:
#             return Response({'error': 'Inventory not found'}, status=status.HTTP_404_NOT_FOUND)

#         # Fetch the inventory type and handle exceptions for invalid types
#         inventory_type_id = data.get('inventory_type')
#         try:
#             inventory_type = InventoryType.objects.get(id=inventory_type_id)
#         except InventoryType.DoesNotExist:
#             return Response({'error': 'Invalid inventory type'}, status=status.HTTP_400_BAD_REQUEST)

#         # Process different inventory types
#         if inventory_type.id == 6:
#             # Fuel specific logic (simplified here)
#             try:
#                 farmer = Farmer.objects.get(id=data.get('farmer'))  # Fetch farmer using the provided farmer ID
#                 crop = MyCrop.objects.get(id=data.get('crop'))
#                 inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
#                 inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))
#             except (Farmer.DoesNotExist, MyCrop.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist):
#                 return Response({'error': 'Invalid references to farmer, crop, category, or inventory items'}, status=status.HTTP_400_BAD_REQUEST)

#             # Fetch the last fuel instance for the selected inventory items and inventory type
#             fuel_instance = MyFuel.objects.filter(
#                 inventory_items=inventory_items,
#                 inventory_type=inventory_type,
#                 farmer=farmer
#             ).order_by('-updated_at').first()

#             if not fuel_instance:
#                 return Response({'error': 'No fuel records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

#             total_available_quans = fuel_instance.available_quans
#             quantity_utilized = Decimal(data.get('quantity_utilized', 0))

#             if quantity_utilized > total_available_quans:
#                 return Response({'error': 'Not enough fuel available for the requested quantity'}, status=status.HTTP_400_BAD_REQUEST)

#             fuel_instance.available_quans -= quantity_utilized
#             fuel_instance.save()

#             available_quans_in_inventory = total_available_quans - quantity_utilized

#             # Update existing inventory object
#             my_inventory.date_of_consumption = data.get('date_of_consumption', my_inventory.date_of_consumption)
#             my_inventory.crop = crop
#             my_inventory.inventory_category = inventory_category
#             my_inventory.inventory_items = inventory_items
#             my_inventory.quantity_utilized = quantity_utilized
#             my_inventory.available_quans = available_quans_in_inventory
#             my_inventory.description = data.get('description', my_inventory.description)
#             my_inventory.status = 0  # Update to active (status=0)
#             my_inventory.updated_at = timezone.now()
#             my_inventory.save()

#         elif inventory_type.id == 4:
#             # Pesticide specific logic (like Fuel but for Pesticides)
#             try:
#                 farmer = Farmer.objects.get(id=data.get('farmer'))  # Fetch farmer using the provided farmer ID
#                 crop = MyCrop.objects.get(id=data.get('crop'))
#                 inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
#                 inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))
#             except (Farmer.DoesNotExist, MyCrop.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist):
#                 return Response({'error': 'Invalid references to farmer, crop, category, or inventory items'}, status=status.HTTP_400_BAD_REQUEST)

#             # Fetch the last pesticide instance for the selected inventory items and inventory type
#             pesticide_instance = MyPesticides.objects.filter(
#                 inventory_items=inventory_items,
#                 inventory_type=inventory_type,
#                 farmer=farmer
#             ).order_by('-updated_at').first()

#             if not pesticide_instance:
#                 return Response({'error': 'No pesticide records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

#             total_available_quans = pesticide_instance.available_quans
#             quantity_utilized = Decimal(data.get('quantity_utilized', 0))

#             if quantity_utilized > total_available_quans:
#                 return Response({'error': 'Not enough pesticide available for the requested quantity'}, status=status.HTTP_400_BAD_REQUEST)

#             pesticide_instance.available_quans -= quantity_utilized
#             pesticide_instance.save()

#             available_quans_in_inventory = total_available_quans - quantity_utilized

#             # Update existing inventory object for pesticides
#             my_inventory.date_of_consumption = data.get('date_of_consumption', my_inventory.date_of_consumption)
#             my_inventory.crop = crop
#             my_inventory.inventory_category = inventory_category
#             my_inventory.inventory_items = inventory_items
#             my_inventory.quantity_utilized = quantity_utilized
#             my_inventory.available_quans = available_quans_in_inventory
#             my_inventory.description = data.get('description', my_inventory.description)
#             my_inventory.status = 0  # Update to active (status=0)
#             my_inventory.updated_at = timezone.now()
#             my_inventory.save()

#         elif inventory_type.id == 7:
#             # Pesticide specific logic (like Fuel but for Pesticides)
#             try:
#                 farmer = Farmer.objects.get(id=data.get('farmer'))  # Fetch farmer using the provided farmer ID
#                 crop = MyCrop.objects.get(id=data.get('crop'))
#                 inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
#                 inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))
#             except (Farmer.DoesNotExist, MyCrop.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist):
#                 return Response({'error': 'Invalid references to farmer, crop, category, or inventory items'}, status=status.HTTP_400_BAD_REQUEST)

#             # Fetch the last pesticide instance for the selected inventory items and inventory type
#             pesticide_instance = MySeeds.objects.filter(
#                 inventory_items=inventory_items,
#                 inventory_type=inventory_type,
#                 farmer=farmer
#             ).order_by('-updated_at').first()

#             if not pesticide_instance:
#                 return Response({'error': 'No seeds records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

#             total_available_quans = pesticide_instance.available_quans
#             quantity_utilized = Decimal(data.get('quantity_utilized', 0))

#             if quantity_utilized > total_available_quans:
#                 return Response({'error': 'Not enough seeds available for the requested quantity'}, status=status.HTTP_400_BAD_REQUEST)

#             pesticide_instance.available_quans -= quantity_utilized
#             pesticide_instance.save()

#             available_quans_in_inventory = total_available_quans - quantity_utilized

#             # Update existing inventory object for pesticides
#             my_inventory.date_of_consumption = data.get('date_of_consumption', my_inventory.date_of_consumption)
#             my_inventory.crop = crop
#             my_inventory.inventory_category = inventory_category
#             my_inventory.inventory_items = inventory_items
#             my_inventory.quantity_utilized = quantity_utilized
#             my_inventory.available_quans = available_quans_in_inventory
#             my_inventory.description = data.get('description', my_inventory.description)
#             my_inventory.status = 0  # Update to active (status=0)
#             my_inventory.updated_at = timezone.now()
#             my_inventory.save()

#         elif inventory_type.id == 5:
#             # Pesticide specific logic (like Fuel but for Pesticides)
#             try:
#                 farmer = Farmer.objects.get(id=data.get('farmer'))  # Fetch farmer using the provided farmer ID
#                 crop = MyCrop.objects.get(id=data.get('crop'))
#                 inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'))
#                 inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'))
#             except (Farmer.DoesNotExist, MyCrop.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist):
#                 return Response({'error': 'Invalid references to farmer, crop, category, or inventory items'}, status=status.HTTP_400_BAD_REQUEST)

#             # Fetch the last pesticide instance for the selected inventory items and inventory type
#             pesticide_instance = MyFertilizers.objects.filter(
#                 inventory_items=inventory_items,
#                 inventory_type=inventory_type,
#                 farmer=farmer
#             ).order_by('-updated_at').first()

#             if not pesticide_instance:
#                 return Response({'error': 'No fertilizers records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

#             total_available_quans = pesticide_instance.available_quans
#             quantity_utilized = Decimal(data.get('quantity_utilized', 0))

#             if quantity_utilized > total_available_quans:
#                 return Response({'error': 'Not enough fertilizers available for the requested quantity'}, status=status.HTTP_400_BAD_REQUEST)

#             pesticide_instance.available_quans -= quantity_utilized
#             pesticide_instance.save()

#             available_quans_in_inventory = total_available_quans - quantity_utilized

#             # Update existing inventory object for pesticides
#             my_inventory.date_of_consumption = data.get('date_of_consumption', my_inventory.date_of_consumption)
#             my_inventory.crop = crop
#             my_inventory.inventory_category = inventory_category
#             my_inventory.inventory_items = inventory_items
#             my_inventory.quantity_utilized = quantity_utilized
#             my_inventory.available_quans = available_quans_in_inventory
#             my_inventory.description = data.get('description', my_inventory.description)
#             my_inventory.status = 0  # Update to active (status=0)
#             my_inventory.updated_at = timezone.now()
#             my_inventory.save()

#         elif inventory_type.id == 2:
#             # Validate required fields for inventory type 2
#             required_fields = ['date_of_consumption', 'crop', 'inventory_category', 'inventory_items', 'usage_hours']
#             missing_fields = []

#             # Check for missing required fields
#             for field in required_fields:
#                 if not data.get(field):
#                     missing_fields.append(field)

#             if missing_fields:
#                 return Response(
#                     {'error': f'Missing required fields: {", ".join(missing_fields)}'},
#                     status=status.HTTP_400_BAD_REQUEST
#                 )

#             # Fetch the associated models for crop, inventory_category, and inventory_items
#             try:
#                 crop = MyCrop.objects.get(id=data['crop'])
#                 inventory_category = InventoryCategory.objects.get(id=data['inventory_category'])
#                 inventory_items = InventoryItems.objects.get(id=data['inventory_items'])
#             except (MyCrop.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist) as e:
#                 return Response({'error': f'Invalid reference: {str(e)}'}, status=status.HTTP_400_BAD_REQUEST)

#             # Get the usage_hours and any optional fields like description
#             usage_hours = Decimal(data.get('usage_hours', 0))

#             # Optionally handle other fields like start_kilometer, end_kilometer, tool_items
#             start_kilometer = Decimal(data.get('start_kilometer', 0))
#             end_kilometer = Decimal(data.get('end_kilometer', 0))
#             tool_items = data.get('tool_items', '')

#             # Update the inventory with the validated fields
#             my_inventory.date_of_consumption = data['date_of_consumption']
#             my_inventory.crop = crop
#             my_inventory.inventory_category = inventory_category
#             my_inventory.inventory_items = inventory_items
#             my_inventory.usage_hours = usage_hours
#             my_inventory.start_kilometer = start_kilometer
#             my_inventory.end_kilometer = end_kilometer
#             my_inventory.tool_items = tool_items
#             my_inventory.description = data.get('description', my_inventory.description)  # Optional field 
#             my_inventory.updated_at = timezone.now()
#             my_inventory.save()

#         elif inventory_type.id == 3:
#             # Required fields for Inventory Type 3
#             required_fields = ['date_of_consumption', 'crop', 'inventory_items', 'usage_hours']
#             missing_fields = []

#             # Check for missing required fields
#             for field in required_fields:
#                 if not data.get(field):
#                     missing_fields.append(field)

#             if missing_fields:
#                 return Response(
#                     {'error': f'Missing required fields: {", ".join(missing_fields)}'},
#                     status=status.HTTP_400_BAD_REQUEST
#                 )

#             # Fetch the associated models for crop, inventory_items (this is your "items")
#             try:
#                 crop = MyCrop.objects.get(id=data['crop'])
#                 inventory_items = InventoryItems.objects.get(id=data['inventory_items'])
#             except (MyCrop.DoesNotExist, InventoryItems.DoesNotExist) as e:
#                 return Response({'error': f'Invalid reference: {str(e)}'}, status=status.HTTP_400_BAD_REQUEST)

#             # Get the usage_hours and any optional fields like description and tool_items
#             usage_hours = Decimal(data.get('usage_hours', 0))
#             tool_items = data.get('tool_items', '')

#             # Optional fields
#             description = data.get('description', '')

#             # Update the inventory with the validated fields
#             my_inventory.date_of_consumption = data['date_of_consumption']
#             my_inventory.crop = crop
#             my_inventory.inventory_items = inventory_items  # This is the 'items' field
#             my_inventory.usage_hours = usage_hours
#             my_inventory.tool_items = tool_items  # This is the 'tool_items' field
#             my_inventory.description = description  # Optional field
#             my_inventory.updated_at = timezone.now()
#             my_inventory.save()

#         elif inventory_type.id == 1:
#             # Required fields for Inventory Type 1
#             required_fields = ['date_of_consumption', 'crop', 'start_kilometer', 'end_kilometer']
#             missing_fields = []

#             # Check for missing required fields
#             for field in required_fields:
#                 if not data.get(field):
#                     missing_fields.append(field)

#             if missing_fields:
#                 return Response(
#                     {'error': f'Missing required fields: {", ".join(missing_fields)}'},
#                     status=status.HTTP_400_BAD_REQUEST
#                 )

#             # Fetch the associated models for crop
#             try:
#                 crop = MyCrop.objects.get(id=data['crop'])
#             except MyCrop.DoesNotExist:
#                 return Response({'error': 'Invalid crop reference'}, status=status.HTTP_400_BAD_REQUEST)

#             # Get the start and end kilometers
#             try:
#                 start_kilometer = Decimal(data['start_kilometer'])
#                 end_kilometer = Decimal(data['end_kilometer'])
#             except (KeyError, ValueError):
#                 return Response({'error': 'Invalid values for start_kilometer or end_kilometer'}, status=status.HTTP_400_BAD_REQUEST)

#             # Optional fields
#             description = data.get('description', '')

#             # Update the inventory with the validated fields
#             my_inventory.date_of_consumption = data['date_of_consumption']
#             my_inventory.crop = crop
#             my_inventory.start_kilometer = start_kilometer
#             my_inventory.end_kilometer = end_kilometer
#             my_inventory.description = description  # Optional field
#             my_inventory.updated_at = timezone.now()
#             my_inventory.save()

#         # Handling file uploads for inventory type 7 (documents)
#         file_data = request.data.get('documents', None)  # Get the documents if provided
#         grouped_documents = {}

#         if file_data:
#             # Process each document and its corresponding file_type
#             for doc_data in file_data:
#                 file_type_id = doc_data.get('file_type')
#                 documents = doc_data.get('documents', [])

#                 if not documents:
#                     return Response(
#                         {"success": False, "message": f"No documents provided for file type {file_type_id}."},
#                         status=status.HTTP_400_BAD_REQUEST
#                     )

#                 # Handle file type creation if necessary
#                 if file_type_id is None:
#                     new_file_type = doc_data.get('new_file_type')
#                     if not new_file_type:
#                         return Response({"error": f"New file type for document is required."}, status=status.HTTP_400_BAD_REQUEST)
                        
#                     # Create a new file type if not exists
#                     file_type, created = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=3)
#                 else:
#                     # Get the existing file type
#                     file_type = get_object_or_404(DocumentCategory, id=file_type_id)

#                 if file_type_id not in grouped_documents:
#                     grouped_documents[file_type_id] = []

#                 # Process the documents, creating document entries
#                 for i, document_base64 in enumerate(documents):
#                     try:
#                         # Validate MIME type (only image/jpeg, image/png, and application/pdf)
#                         if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
#                             mime_type = validate_image_type(document_base64)  # Validate the MIME type
#                             if mime_type:
#                                 # Extract the base64 data and decode it
#                                 document_data = document_base64.split(';base64,')[1]
#                                 document_bytes = base64.b64decode(document_data)

#                                 # Check file size (10MB max)
#                                 max_file_size = 10 * 1024 * 1024  # 10MB
#                                 if len(document_bytes) > max_file_size:
#                                     return Response({'error': f'File is too large. Max size is 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

#                                 # Create a document name and ContentFile
#                                 document_name = f"inventory_{my_inventory.id}_{file_type_id}_{i}.{mime_type.split('/')[1]}"
#                                 document_file = ContentFile(document_bytes, name=document_name)

#                                 # Create document entry
#                                 document_instance = MyInventoryDocuments.objects.create(
#                                     my_inventory=my_inventory,
#                                     file_type=file_type,
#                                     document=document_file,
#                                     created_at=timezone.now(),
#                                 )

#                                 # Append document data to grouped documents
#                                 document_data = {
#                                     'document_id': document_instance.id,
#                                     'document_category': {
#                                         'id': file_type.id,
#                                         'name': file_type.name
#                                     },
#                                     'upload_document': request.build_absolute_uri(f'/SuperAdmin{document_file.name}'),
#                                     'language': {
#                                         'default': 'en'
#                                     }
#                                 }

#                                 grouped_documents[file_type_id].append(document_data)
#                             else:
#                                 return Response({'error': 'Invalid MIME type for the document.'}, status=status.HTTP_400_BAD_REQUEST)
#                         else:
#                             return Response({'error': 'Invalid file format. Only image/jpeg, image/png, and application/pdf are allowed.'}, status=status.HTTP_400_BAD_REQUEST)

#                     except Exception as e:
#                         return Response({'error': f"Error processing document: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

#             # Collect formatted documents
#             formatted_documents = []
#             for file_type_id, documents in grouped_documents.items():
#                 formatted_documents.append({
#                     'category_id': file_type_id,
#                     'documents': documents
#                 })
#         else:
#             formatted_documents = []

#         # Prepare the response with all the necessary details
#         response_data = {
#             'success': True,
#             'message': 'Inventory updated successfully.',
#             'inventory_details': {
#                 'id': my_inventory.id,
#                 'status': my_inventory.status,
#                 'date_of_consumption': my_inventory.date_of_consumption,
#                 'crop': my_inventory.crop.crop.name if my_inventory.crop else None,
#                 'inventory_category': my_inventory.inventory_category.name if my_inventory.inventory_category else None,
#                 'inventory_items': my_inventory.inventory_items.name if my_inventory.inventory_items else None,
#                 'quantity_utilized': str(my_inventory.quantity_utilized),
#                 'available_quans': str(my_inventory.available_quans),
#                 'description': my_inventory.description,
#                 'usage_hours': str(my_inventory.usage_hours) if my_inventory.usage_hours else None,
#                 'start_kilometer': str(my_inventory.start_kilometer) if my_inventory.start_kilometer else None,
#                 'end_kilometer': str(my_inventory.end_kilometer) if my_inventory.end_kilometer else None,
#                 'tool_items': my_inventory.tool_items,
#                 'updated_at': my_inventory.updated_at,
#             },
#             'documents': formatted_documents
#         }

#         return Response(response_data, status=status.HTTP_200_OK)

@api_view(['PUT'])
def update_inventory_with_documents(request, inventory_id):
    if request.method == 'PUT':
        data = request.data

        # Fetch the existing inventory by ID
        try:
            my_inventory = MyInventory.objects.get(id=inventory_id, status=0)
        except MyInventory.DoesNotExist:
            return Response({'error': 'Inventory not found'}, status=status.HTTP_404_NOT_FOUND)

        # Fetch the inventory type and handle exceptions for invalid types
        inventory_type_id = data.get('inventory_type')
        try:
            inventory_type = InventoryType.objects.get(id=inventory_type_id, status=0)
        except InventoryType.DoesNotExist:
            return Response({'error': 'Invalid inventory type'}, status=status.HTTP_400_BAD_REQUEST)

        try:
            farmer_id = my_inventory.farmer.id
            user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
            language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
        except UserLanguagePreference.DoesNotExist:
            language_code = 'en'

        # Process different inventory types
        if inventory_type.id == 6:
            # Fuel specific logic (simplified here)
            try:
                farmer = Farmer.objects.get(id=data.get('farmer'), status=0)  # Fetch farmer using the provided farmer ID
                crop = MyCrop.objects.get(id=data.get('crop'), status=0)
                inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'), status=0)
                inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'), status=0)
            except (Farmer.DoesNotExist, MyCrop.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist):
                return Response({'error': 'Invalid references to farmer, crop, category, or inventory items'}, status=status.HTTP_400_BAD_REQUEST)

            # Fetch the last fuel instance for the selected inventory items and inventory type
            fuel_instance = MyFuel.objects.filter(
                inventory_items=inventory_items,
                inventory_type=inventory_type,
                farmer=farmer, status=0
            ).order_by('-updated_at').first()

            if not fuel_instance:
                return Response({'error': 'No fuel records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

            total_available_quans = fuel_instance.available_quans
            quantity_utilized = Decimal(data.get('quantity_utilized', 0))

            if quantity_utilized > total_available_quans:
                return Response({'error': 'Not enough fuel available for the requested quantity'}, status=status.HTTP_400_BAD_REQUEST)

            fuel_instance.available_quans -= quantity_utilized
            fuel_instance.save()

            available_quans_in_inventory = total_available_quans - quantity_utilized

            # Update existing inventory object
            my_inventory.date_of_consumption = data.get('date_of_consumption', my_inventory.date_of_consumption)
            my_inventory.crop = crop
            my_inventory.inventory_category = inventory_category
            my_inventory.inventory_items = inventory_items
            my_inventory.quantity_utilized = quantity_utilized
            my_inventory.available_quans = available_quans_in_inventory
            my_inventory.description = data.get('description', my_inventory.description)
            my_inventory.status = 0  # Update to active (status=0)
            my_inventory.updated_at = timezone.now()
            my_inventory.save()

        elif inventory_type.id == 4:
            # Pesticide specific logic (like Fuel but for Pesticides)
            try:
                farmer = Farmer.objects.get(id=data.get('farmer'), status=0)  # Fetch farmer using the provided farmer ID
                crop = MyCrop.objects.get(id=data.get('crop'), status=0)
                inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'), status=0)
                inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'), status=0)
            except (Farmer.DoesNotExist, MyCrop.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist):
                return Response({'error': 'Invalid references to farmer, crop, category, or inventory items'}, status=status.HTTP_400_BAD_REQUEST)

            # Fetch the last pesticide instance for the selected inventory items and inventory type
            pesticide_instance = MyPesticides.objects.filter(
                inventory_items=inventory_items,
                inventory_type=inventory_type,
                farmer=farmer, status=0
            ).order_by('-updated_at').first()

            if not pesticide_instance:
                return Response({'error': 'No pesticide records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

            total_available_quans = pesticide_instance.available_quans
            quantity_utilized = Decimal(data.get('quantity_utilized', 0))

            if quantity_utilized > total_available_quans:
                return Response({'error': 'Not enough pesticide available for the requested quantity'}, status=status.HTTP_400_BAD_REQUEST)

            pesticide_instance.available_quans -= quantity_utilized
            pesticide_instance.save()

            available_quans_in_inventory = total_available_quans - quantity_utilized

            # Update existing inventory object for pesticides
            my_inventory.date_of_consumption = data.get('date_of_consumption', my_inventory.date_of_consumption)
            my_inventory.crop = crop
            my_inventory.inventory_category = inventory_category
            my_inventory.inventory_items = inventory_items
            my_inventory.quantity_utilized = quantity_utilized
            my_inventory.available_quans = available_quans_in_inventory
            my_inventory.description = data.get('description', my_inventory.description)
            my_inventory.status = 0  # Update to active (status=0)
            my_inventory.updated_at = timezone.now()
            my_inventory.save()

        elif inventory_type.id == 7:
            # Pesticide specific logic (like Fuel but for Pesticides)
            try:
                farmer = Farmer.objects.get(id=data.get('farmer'), status=0)  # Fetch farmer using the provided farmer ID
                crop = MyCrop.objects.get(id=data.get('crop'), status=0)
                inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'), status=0)
                inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'), status=0)
            except (Farmer.DoesNotExist, MyCrop.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist):
                return Response({'error': 'Invalid references to farmer, crop, category, or inventory items'}, status=status.HTTP_400_BAD_REQUEST)

            # Fetch the last pesticide instance for the selected inventory items and inventory type
            pesticide_instance = MySeeds.objects.filter(
                inventory_items=inventory_items,
                inventory_type=inventory_type,
                farmer=farmer, status=0
            ).order_by('-updated_at').first()

            if not pesticide_instance:
                return Response({'error': 'No seeds records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

            total_available_quans = pesticide_instance.available_quans
            quantity_utilized = Decimal(data.get('quantity_utilized', 0))

            if quantity_utilized > total_available_quans:
                return Response({'error': 'Not enough seeds available for the requested quantity'}, status=status.HTTP_400_BAD_REQUEST)

            pesticide_instance.available_quans -= quantity_utilized
            pesticide_instance.save()

            available_quans_in_inventory = total_available_quans - quantity_utilized

            # Update existing inventory object for pesticides
            my_inventory.date_of_consumption = data.get('date_of_consumption', my_inventory.date_of_consumption)
            my_inventory.crop = crop
            my_inventory.inventory_category = inventory_category
            my_inventory.inventory_items = inventory_items
            my_inventory.quantity_utilized = quantity_utilized
            my_inventory.available_quans = available_quans_in_inventory
            my_inventory.description = data.get('description', my_inventory.description)
            my_inventory.status = 0  # Update to active (status=0)
            my_inventory.updated_at = timezone.now()
            my_inventory.save()

        elif inventory_type.id == 5:
            # Pesticide specific logic (like Fuel but for Pesticides)
            try:
                farmer = Farmer.objects.get(id=data.get('farmer'),status=0)  # Fetch farmer using the provided farmer ID
                crop = MyCrop.objects.get(id=data.get('crop'),status=0)
                inventory_category = InventoryCategory.objects.get(id=data.get('inventory_category'),status=0)
                inventory_items = InventoryItems.objects.get(id=data.get('inventory_items'),status=0)
            except (Farmer.DoesNotExist, MyCrop.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist):
                return Response({'error': 'Invalid references to farmer, crop, category, or inventory items'}, status=status.HTTP_400_BAD_REQUEST)

            # Fetch the last pesticide instance for the selected inventory items and inventory type
            pesticide_instance = MyFertilizers.objects.filter(
                inventory_items=inventory_items,
                inventory_type=inventory_type,
                farmer=farmer,status=0
            ).order_by('-updated_at').first()

            if not pesticide_instance:
                return Response({'error': 'No fertilizers records found for the selected items'}, status=status.HTTP_400_BAD_REQUEST)

            total_available_quans = pesticide_instance.available_quans
            quantity_utilized = Decimal(data.get('quantity_utilized', 0))

            if quantity_utilized > total_available_quans:
                return Response({'error': 'Not enough fertilizers available for the requested quantity'}, status=status.HTTP_400_BAD_REQUEST)

            pesticide_instance.available_quans -= quantity_utilized
            pesticide_instance.save()

            available_quans_in_inventory = total_available_quans - quantity_utilized

            # Update existing inventory object for pesticides
            my_inventory.date_of_consumption = data.get('date_of_consumption', my_inventory.date_of_consumption)
            my_inventory.crop = crop
            my_inventory.inventory_category = inventory_category
            my_inventory.inventory_items = inventory_items
            my_inventory.quantity_utilized = quantity_utilized
            my_inventory.available_quans = available_quans_in_inventory
            my_inventory.description = data.get('description', my_inventory.description)
            my_inventory.status = 0  # Update to active (status=0)
            my_inventory.updated_at = timezone.now()
            my_inventory.save()

        elif inventory_type.id == 2:
            # Validate required fields for inventory type 2
            required_fields = ['date_of_consumption', 'crop', 'inventory_category', 'inventory_items', 'usage_hours']
            missing_fields = []

            # Check for missing required fields
            for field in required_fields:
                if not data.get(field):
                    missing_fields.append(field)

            if missing_fields:
                return Response(
                    {'error': f'Missing required fields: {", ".join(missing_fields)}'},
                    status=status.HTTP_400_BAD_REQUEST
                )

            # Fetch the associated models for crop, inventory_category, and inventory_items
            try:
                crop = MyCrop.objects.get(id=data['crop'])
                inventory_category = InventoryCategory.objects.get(id=data['inventory_category'])
                inventory_items = InventoryItems.objects.get(id=data['inventory_items'])
            except (MyCrop.DoesNotExist, InventoryCategory.DoesNotExist, InventoryItems.DoesNotExist) as e:
                return Response({'error': f'Invalid reference: {str(e)}'}, status=status.HTTP_400_BAD_REQUEST)

            # Get the usage_hours and any optional fields like description
            usage_hours = Decimal(data.get('usage_hours', 0))

            # Optionally handle other fields like start_kilometer, end_kilometer, tool_items
            start_kilometer = Decimal(data.get('start_kilometer', 0))
            end_kilometer = Decimal(data.get('end_kilometer', 0))
            tool_items = data.get('tool_items', '')

            # Update the inventory with the validated fields
            my_inventory.date_of_consumption = data['date_of_consumption']
            my_inventory.crop = crop
            my_inventory.inventory_category = inventory_category
            my_inventory.inventory_items = inventory_items
            my_inventory.usage_hours = usage_hours
            my_inventory.start_kilometer = start_kilometer
            my_inventory.end_kilometer = end_kilometer
            my_inventory.tool_items = tool_items
            my_inventory.description = data.get('description', my_inventory.description)  # Optional field 
            my_inventory.updated_at = timezone.now()
            my_inventory.save()

        elif inventory_type.id == 3:
            # Required fields for Inventory Type 3
            required_fields = ['date_of_consumption', 'crop', 'inventory_items', 'usage_hours']
            missing_fields = []

            # Check for missing required fields
            for field in required_fields:
                if not data.get(field):
                    missing_fields.append(field)

            if missing_fields:
                return Response(
                    {'error': f'Missing required fields: {", ".join(missing_fields)}'},
                    status=status.HTTP_400_BAD_REQUEST
                )

            # Fetch the associated models for crop, inventory_items (this is your "items")
            try:
                crop = MyCrop.objects.get(id=data['crop'])
                inventory_items = InventoryItems.objects.get(id=data['inventory_items'])
            except (MyCrop.DoesNotExist, InventoryItems.DoesNotExist) as e:
                return Response({'error': f'Invalid reference: {str(e)}'}, status=status.HTTP_400_BAD_REQUEST)

            # Get the usage_hours and any optional fields like description and tool_items
            usage_hours = Decimal(data.get('usage_hours', 0))
            tool_items = data.get('tool_items', '')

            # Optional fields
            description = data.get('description', '')

            # Update the inventory with the validated fields
            my_inventory.date_of_consumption = data['date_of_consumption']
            my_inventory.crop = crop
            my_inventory.inventory_items = inventory_items  # This is the 'items' field
            my_inventory.usage_hours = usage_hours
            my_inventory.tool_items = tool_items  # This is the 'tool_items' field
            my_inventory.description = description  # Optional field
            my_inventory.updated_at = timezone.now()
            my_inventory.save()

        elif inventory_type.id == 1:
            # Required fields for Inventory Type 1
            required_fields = ['date_of_consumption', 'crop', 'start_kilometer', 'end_kilometer']
            missing_fields = []

            # Check for missing required fields
            for field in required_fields:
                if not data.get(field):
                    missing_fields.append(field)

            if missing_fields:
                return Response(
                    {'error': f'Missing required fields: {", ".join(missing_fields)}'},
                    status=status.HTTP_400_BAD_REQUEST
                )

            # Fetch the associated models for crop
            try:
                crop = MyCrop.objects.get(id=data['crop'])
            except MyCrop.DoesNotExist:
                return Response({'error': 'Invalid crop reference'}, status=status.HTTP_400_BAD_REQUEST)

            # Get the start and end kilometers
            try:
                start_kilometer = Decimal(data['start_kilometer'])
                end_kilometer = Decimal(data['end_kilometer'])
            except (KeyError, ValueError):
                return Response({'error': 'Invalid values for start_kilometer or end_kilometer'}, status=status.HTTP_400_BAD_REQUEST)

            # Optional fields
            description = data.get('description', '')

            # Update the inventory with the validated fields
            my_inventory.date_of_consumption = data['date_of_consumption']
            my_inventory.crop = crop
            my_inventory.start_kilometer = start_kilometer
            my_inventory.end_kilometer = end_kilometer
            my_inventory.description = description  # Optional field
            my_inventory.updated_at = timezone.now()
            my_inventory.save()

        translated_json = {
            "description": {}
        }
        try:
            if my_inventory.description:
                for lang in target_language:
                    translated_text = GoogleTranslator(source='auto', target=lang).translate(my_inventory.description)
                    translated_json["description"][lang] = translated_text
            my_inventory.translate_json = translated_json
            my_inventory.save()
        except Exception as e:
            print("Error in Translating Data")

        # Handling file uploads for inventory type 7 (documents)
        file_data = request.data.get('documents', None)  # Get the documents if provided
        grouped_documents = {}

        if file_data:
            # Process each document and its corresponding file_type
            for doc_data in file_data:
                file_type_id = doc_data.get('file_type')
                documents = doc_data.get('documents', [])

                if not documents:
                    return Response(
                        {"success": False, "message": f"No documents provided for file type {file_type_id}."},
                        status=status.HTTP_400_BAD_REQUEST
                    )

                # Handle file type creation if necessary
                if file_type_id is None:
                    new_file_type = doc_data.get('new_file_type')
                    if not new_file_type:
                        return Response({"error": f"New file type for document is required."}, status=status.HTTP_400_BAD_REQUEST)
                        
                    # Create a new file type if not exists
                    file_type, created = DocumentCategory.objects.get_or_create(name=new_file_type, doctype=3)
                else:
                    # Get the existing file type
                    file_type = get_object_or_404(DocumentCategory, id=file_type_id)

                if file_type_id not in grouped_documents:
                    grouped_documents[file_type_id] = []

                # Process the documents, creating document entries
                for i, document_base64 in enumerate(documents):
                    try:
                        # Validate MIME type (only image/jpeg, image/png, and application/pdf)
                        if document_base64.startswith("data:image/") or document_base64.startswith("data:application/pdf"):
                            mime_type = validate_image_type(document_base64)  # Validate the MIME type
                            if mime_type:
                                # Extract the base64 data and decode it
                                document_data = document_base64.split(';base64,')[1]
                                document_bytes = base64.b64decode(document_data)

                                # Check file size (10MB max)
                                max_file_size = 10 * 1024 * 1024  # 10MB
                                if len(document_bytes) > max_file_size:
                                    return Response({'error': f'File is too large. Max size is 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

                                # Create a document name and ContentFile
                                document_name = f"inventory_{my_inventory.id}_{file_type_id}_{i}.{mime_type.split('/')[1]}"
                                document_file = ContentFile(document_bytes, name=document_name)

                                # Create document entry
                                document_instance = MyInventoryDocuments.objects.create(
                                    my_inventory=my_inventory,
                                    file_type=file_type,
                                    document=document_file,
                                    created_at=timezone.now(),
                                )

                                # Append document data to grouped documents
                                document_data = {
                                    'document_id': document_instance.id,
                                    'document_category': {
                                        'id': file_type.id,
                                        'name': file_type.name
                                    },
                                    'upload_document': request.build_absolute_uri(f'/SuperAdmin{document_file.name}'),
                                    'language': {
                                        'default': 'en'
                                    }
                                }

                                grouped_documents[file_type_id].append(document_data)
                            else:
                                return Response({'error': 'Invalid MIME type for the document.'}, status=status.HTTP_400_BAD_REQUEST)
                        else:
                            return Response({'error': 'Invalid file format. Only image/jpeg, image/png, and application/pdf are allowed.'}, status=status.HTTP_400_BAD_REQUEST)

                    except Exception as e:
                        return Response({'error': f"Error processing document: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

            # Collect formatted documents
            formatted_documents = []
            for file_type_id, documents in grouped_documents.items():
                formatted_documents.append({
                    'category_id': file_type_id,
                    'documents': documents
                })
        else:
            formatted_documents = []

        # Prepare the response with all the necessary details
        response_data = {
            'success': True,
            'message': 'Inventory updated successfully.',
            'inventory_details': {
                'id': my_inventory.id,
                'status': my_inventory.status,
                'date_of_consumption': my_inventory.date_of_consumption,
                'crop': my_inventory.crop.crop.get_translated_value("name", language_code) if my_inventory.crop else None,
                'inventory_category': my_inventory.inventory_category.get_translated_value("name", language_code) if my_inventory.inventory_category else None,
                'inventory_items': my_inventory.inventory_items.get_translated_value("name", language_code) if my_inventory.inventory_items else None,
                'quantity_utilized': str(my_inventory.quantity_utilized),
                'available_quans': str(my_inventory.available_quans),
                'description': my_inventory.get_translated_value("description", language_code) if my_inventory.description else '',
                'usage_hours': str(my_inventory.usage_hours) if my_inventory.usage_hours else None,
                'start_kilometer': str(my_inventory.start_kilometer) if my_inventory.start_kilometer else None,
                'end_kilometer': str(my_inventory.end_kilometer) if my_inventory.end_kilometer else None,
                'tool_items': my_inventory.tool_items,
                'updated_at': my_inventory.updated_at,
            },
            'documents': formatted_documents
        }

        return Response(response_data, status=status.HTTP_200_OK)


@api_view(['POST'])
def verify_payment_mobile(request):
    try:
        razorpay_payment_id = request.data.get('razorpay_payment_id')
        razorpay_order_id = request.data.get('razorpay_order_id')
        razorpay_signature = request.data.get('razorpay_signature')
        packid = request.data.get('package_id')
        farmerid = request.data.get('farmer_id')

        if razorpay_payment_id and razorpay_order_id and razorpay_signature:
            try:
                farmer = get_object_or_404(Farmer, pk=farmerid)
                AddSubcription.objects.filter(farmers=farmer, status=0).update(status=3)

                package = get_object_or_404(PackageManagement, pk=packid)
                package_validity = package.package_validity
                package_duration_code = package.package_duration.code
                startdate = timezone.now().date()
                if package_duration_code == 0:  # Days
                    enddate = startdate + timedelta(days=package_validity)
                elif package_duration_code == 1:  # Months
                    enddate = startdate + relativedelta(months=package_validity)
                elif package_duration_code == 2:  # Years
                    enddate = startdate + relativedelta(years=package_validity)
                elif package_duration_code == 3:  # No end date
                    enddate = None
                
                if enddate:
                    remaining = (enddate - timezone.now().date()).days
                    remainingdays = max(remaining, 0)
                else:
                    remainingdays = None
                
                subscription = AddSubcription.objects.create(
                    farmers=farmer,
                    packages=package,
                    status=0,
                    startdate=startdate,
                    enddate=enddate,
                    remainingdays = remainingdays,
                    renewal = True,
                    created_by = farmer.farmer_user,
                    created_at= timezone.now()
                )
                subscription.payment_mode=0
                subscription.transaction_id=razorpay_payment_id
                subscription.payment_status=0
                subscription.save()
                return JsonResponse({'status': 'success', 'message': 'Payment verified successfully'})

            except Exception as e:
                print(e)
                return JsonResponse({'status': 'failure', 'message': 'Payment Not successful'})
        else:
            return JsonResponse({'status': 'failure', 'message': 'Missing payment details'})
    except Exception as e:
        print(e)
        return JsonResponse({'status': 'failure', 'message': 'Missing payment details'})

# @api_view(['GET'])
# def get_machinery_inventory_details(request, farmer_id, inventory_type_id, inventory_items_id):
#     # Fetch the farmer, inventory type, and inventory items
#     farmer = get_object_or_404(Farmer, id=farmer_id)
#     inventory_type = get_object_or_404(InventoryType, id=inventory_type_id)
#     inventory_items = get_object_or_404(InventoryItems, id=inventory_items_id)

#     # Filter inventories based on farmer, inventory type, and inventory items
#     inventories = MyInventory.objects.filter(
#         farmer=farmer, 
#         inventory_type=inventory_type, 
#         inventory_items=inventory_items
#     )

#     # Prepare response data
#     response_data = {
#         'machinery_purchase': [],
#         'machinery_consumption': []  # Include fuel_consumption if necessary for comparison
#     }

#     # Iterate over the inventories to structure the response
#     for inventory in inventories:
#         # Machinery Purchase
#         if inventory.machinery_purchase:
#             machinery_data = {
#                 'id': inventory.machinery_purchase.id,
#                 'vendor': {
#                     'id': inventory.machinery_purchase.vendor.id if inventory.machinery_purchase.vendor else None,
#                     'name': inventory.machinery_purchase.vendor.name if inventory.machinery_purchase.vendor else "Unknown",
#                 },
#                 'inventory_type': {
#                     'id': inventory.machinery_purchase.inventory_type.id if inventory.machinery_purchase.inventory_type else None,
#                     'name': inventory.machinery_purchase.inventory_type.name if inventory.machinery_purchase.inventory_type else "Unknown",
#                 },
#                 'inventory_category': {
#                     'id': inventory.machinery_purchase.inventory_category.id if inventory.machinery_purchase.inventory_category else None,
#                     'name': inventory.machinery_purchase.inventory_category.name if inventory.machinery_purchase.inventory_category else "Unknown",
#                 },
#                 'inventory_items': {
#                     'id': inventory.machinery_purchase.inventory_items.id if inventory.machinery_purchase.inventory_items else None,
#                     'name': inventory.machinery_purchase.inventory_items.name if inventory.machinery_purchase.inventory_items else "Unknown",
#                 },
#                 'fuel_capacity': str(inventory.machinery_purchase.fuel_capacity) if inventory.machinery_purchase.fuel_capacity else "0.00",
#                 'purchase_amount': str(inventory.machinery_purchase.purchase_amount) if inventory.machinery_purchase.purchase_amount else "0.00",
#                 'warranty_start_date': str(inventory.machinery_purchase.warranty_start_date) if inventory.machinery_purchase.warranty_start_date else "N/A",
#                 'warranty_end_date': str(inventory.machinery_purchase.warranty_end_date) if inventory.machinery_purchase.warranty_end_date else "N/A",
#                 'description': inventory.machinery_purchase.description if inventory.machinery_purchase.description else "N/A",
#                 'created_at': str(inventory.machinery_purchase.created_at) if inventory.machinery_purchase.created_at else "N/A",
#                 'updated_at': str(inventory.machinery_purchase.updated_at) if inventory.machinery_purchase.updated_at else "N/A",
#                 'farmer': {
#                     'id': inventory.machinery_purchase.farmer.id if inventory.machinery_purchase.farmer else None,
#                     'name': inventory.machinery_purchase.farmer.name if inventory.machinery_purchase.farmer else "Unknown",
#                 },
#                 'documents': {}  # Dictionary to group documents by file_type
#             }

 

#             # Add document details for machinery purchase, grouped by file_type
#             machinery_documents = MyMachineryDocuments.objects.filter(machinary=inventory.machinery_purchase)
#             for doc in machinery_documents:
#                 file_type = doc.file_type.name if doc.file_type else "Unknown"
#                 file_type_id = doc.file_type.id if doc.file_type else None
#                 document_data = {
#                     'id': doc.id,
#                     'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
#                 }

#                 # Group documents by file_type
#                 if file_type not in machinery_data['documents']:
#                     machinery_data['documents'][file_type] = {
#                         'id': file_type_id,
#                         'name': file_type,
#                         'documents': []
#                     }
#                 machinery_data['documents'][file_type]['documents'].append(document_data)

    

#             response_data['machinery_purchase'].append(machinery_data)

#         # Fuel Consumption (If this is still relevant for machinery inventory)
#         fuel_consumption_data = {
#             'id': inventory.id,
#             'quantity_utilized': str(inventory.quantity_utilized) if inventory.quantity_utilized else "0.00",
#             'date_of_consumption': str(inventory.date_of_consumption) if inventory.date_of_consumption else "N/A",
#             'description': inventory.description if inventory.description else "N/A",
#             'start_kilometer': str(inventory.start_kilometer) if inventory.start_kilometer else "0.00",
#             'end_kilometer': str(inventory.end_kilometer) if inventory.end_kilometer else "0.00",
#             'usage_hours': str(inventory.usage_hours) if inventory.usage_hours else "0.00",
#             'tool_items': inventory.tool_items if inventory.tool_items else "N/A",
#             'rental': str(inventory.rental) if inventory.rental else "1",
#             'crop_id': inventory.crop.id,
#             'crop_name': inventory.crop.crop.name,
#             'crop_description': inventory.crop.description if inventory.crop.description else "N/A",
#             'image_url': request.build_absolute_uri(f'/assets{inventory.crop.crop.img.url}' if inventory.crop.crop.img else '/assets/images/default_crop.png'),
#             'land': {
#                 'id': inventory.crop.land.id if inventory.crop.land else None,
#                 'name': inventory.crop.land.name if inventory.crop.land else "Unknown Land",
#             },
#             'vehicle_purchase': {
#                 'id': inventory.vehicle_purchase.id if inventory.vehicle_purchase else None,
#                 'name': inventory.vehicle_purchase.name if inventory.vehicle_purchase else "Unknown",
#             },
#             'machinery_purchase': {
#                 'id': inventory.machinery_purchase.id if inventory.machinery_purchase else None,
#                 'name': inventory.machinery_purchase.inventory_items.name if inventory.machinery_purchase else "Unknown"
#             },
#             'tool_purchase': {
#                 'id': inventory.tool_purchase.id if inventory.tool_purchase else None,
#                 'name': inventory.tool_purchase.name if inventory.tool_purchase else "Unknown"
#             },
#             'fertilizer_purchase': {
#                 'id': inventory.fertilizer_purchase.id if inventory.fertilizer_purchase else None,
#                 'name': inventory.fertilizer_purchase.name if inventory.fertilizer_purchase else "Unknown"
#             },
#             'pesticide_purchase': {
#                 'id': inventory.pesticide_purchase.id if inventory.pesticide_purchase else None,
#                 'name': inventory.pesticide_purchase.name if inventory.pesticide_purchase else "Unknown"
#             },
#             'seeds_purchase': {
#                 'id': inventory.seeds_purchase.id if inventory.seeds_purchase else None,
#                 'name': inventory.seeds_purchase.name if inventory.seeds_purchase else "Unknown"
#             },
#             'status': inventory.status,
#             'created_at': str(inventory.created_at) if inventory.created_at else "N/A",
#             'updated_at': str(inventory.updated_at) if inventory.updated_at else "N/A",
#             'farmer': {
#                 'id': inventory.farmer.id if inventory.farmer else None,
#                 'name': inventory.farmer.name if inventory.farmer else "Unknown",
#             },
#             'documents': {}  # Dictionary to group documents by file_type
#         }

#         # Add document details for consumption, grouped by file_type
#         inventory_documents = MyInventoryDocuments.objects.filter(my_inventory=inventory)
#         for doc in inventory_documents:
#             file_type = doc.file_type.name if doc.file_type else "Unknown"
#             file_type_id = doc.file_type.id if doc.file_type else None
#             document_data = {
#                 'id': doc.id,
#                 'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
#             }

#             # Group documents by file_type
#             if file_type not in fuel_consumption_data['documents']:
#                 fuel_consumption_data['documents'][file_type] = {
#                     'id': file_type_id,
#                     'name': file_type,
#                     'documents': []
#                 }
#             fuel_consumption_data['documents'][file_type]['documents'].append(document_data)

#         response_data['machinery_consumption'].append(fuel_consumption_data)

#     return Response(response_data)

# @api_view(['GET'])
# def get_machinery_inventory_details(request, farmer_id, inventory_type_id, inventory_items_id):
#     # Fetch the farmer, inventory type, and inventory items
#     farmer = get_object_or_404(Farmer, id=farmer_id)
#     inventory_type = get_object_or_404(InventoryType, id=inventory_type_id)
#     inventory_items = get_object_or_404(InventoryItems, id=inventory_items_id)

#     # Filter inventories based on farmer, inventory type, and inventory items
#     inventories = MyInventory.objects.filter(
#         farmer=farmer, 
#         inventory_type=inventory_type, 
#         inventory_items=inventory_items
#     )

#     # Prepare response data
#     response_data = {
#         'machinery_purchase': [],
#         'machinery_consumption': []  # Include fuel_consumption if necessary for comparison
#     }

#     # Iterate over the inventories to structure the response
#     for inventory in inventories: 
#         if inventory.machinery_purchase:
#             machinery_data = {
#                 'id': inventory.machinery_purchase.id,
#                 'vendor': {
#                     'id': inventory.machinery_purchase.vendor.id if inventory.machinery_purchase.vendor else None,
#                     'name': inventory.machinery_purchase.vendor.name if inventory.machinery_purchase.vendor else "Unknown",
#                 },
#                 'inventory_type': {
#                     'id': inventory.machinery_purchase.inventory_type.id if inventory.machinery_purchase.inventory_type else None,
#                     'name': inventory.machinery_purchase.inventory_type.name if inventory.machinery_purchase.inventory_type else "Unknown",
#                 },
#                 'inventory_category': {
#                     'id': inventory.machinery_purchase.inventory_category.id if inventory.machinery_purchase.inventory_category else None,
#                     'name': inventory.machinery_purchase.inventory_category.name if inventory.machinery_purchase.inventory_category else "Unknown",
#                 },
#                 'inventory_items': {
#                     'id': inventory.machinery_purchase.inventory_items.id if inventory.machinery_purchase.inventory_items else None,
#                     'name': inventory.machinery_purchase.inventory_items.name if inventory.machinery_purchase.inventory_items else "Unknown",
#                 },
#                 'fuel_capacity': str(inventory.machinery_purchase.fuel_capacity) if inventory.machinery_purchase.fuel_capacity else "0.00",
#                 'purchase_amount': str(inventory.machinery_purchase.purchase_amount) if inventory.machinery_purchase.purchase_amount else "0.00",
#                 'warranty_start_date': str(inventory.machinery_purchase.warranty_start_date) if inventory.machinery_purchase.warranty_start_date else "N/A",
#                 'warranty_end_date': str(inventory.machinery_purchase.warranty_end_date) if inventory.machinery_purchase.warranty_end_date else "N/A",
#                 'description': inventory.machinery_purchase.description if inventory.machinery_purchase.description else "N/A",
#                 'created_at': str(inventory.machinery_purchase.created_at) if inventory.machinery_purchase.created_at else "N/A",
#                 'updated_at': str(inventory.machinery_purchase.updated_at) if inventory.machinery_purchase.updated_at else "N/A",
#                 'farmer': {
#                     'id': inventory.machinery_purchase.farmer.id if inventory.machinery_purchase.farmer else None,
#                     'name': inventory.machinery_purchase.farmer.name if inventory.machinery_purchase.farmer else "Unknown",
#                 },
#                 'documents': {}  # Dictionary to group documents by file_type
#             }

#             # Add document details for machinery purchase, grouped by file_type
#             machinery_documents = MyMachineryDocuments.objects.filter(machinary=inventory.machinery_purchase)
#             for doc in machinery_documents:
#                 file_type = doc.file_type.name if doc.file_type else "Unknown"
#                 file_type_id = doc.file_type.id if doc.file_type else None
#                 document_data = {
#                     'id': doc.id,
#                     'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
#                 }

#                 # Group documents by file_type
#                 if file_type not in machinery_data['documents']:
#                     machinery_data['documents'][file_type] = {
#                         'id': file_type_id,
#                         'name': file_type,
#                         'documents': []
#                     }
#                 machinery_data['documents'][file_type]['documents'].append(document_data)

#             response_data['machinery_purchase'].append(machinery_data)
 
#         fuel_consumption_data = {
#             'id': inventory.id,
#             'quantity_utilized': str(inventory.quantity_utilized) if inventory.quantity_utilized else "0.00",
#             'date_of_consumption': str(inventory.date_of_consumption) if inventory.date_of_consumption else "N/A",
#             'description': inventory.description if inventory.description else "N/A",
#             'start_kilometer': str(inventory.start_kilometer) if inventory.start_kilometer else "0.00",
#             'end_kilometer': str(inventory.end_kilometer) if inventory.end_kilometer else "0.00",
#             'usage_hours': str(inventory.usage_hours) if inventory.usage_hours else "0.00",
#             'tool_items': inventory.tool_items if inventory.tool_items else "N/A",
#             'rental': str(inventory.rental) if inventory.rental else "1",
#             'crop_id': inventory.crop.id if inventory.crop else None,
#             'crop_name': inventory.crop.crop.name if inventory.crop else "Unknown Crop",  
#             'crop_description': inventory.crop.description if inventory.crop and inventory.crop.description else "N/A",  # Added null check
#             'image_url': request.build_absolute_uri(f'/assets{inventory.crop.crop.img.url}' if inventory.crop and inventory.crop.crop.img else '/assets/images/default_crop.png'),
#             'land': {
#                 'id': inventory.crop.land.id if inventory.crop and inventory.crop.land else None,
#                 'name': inventory.crop.land.name if inventory.crop and inventory.crop.land else "Unknown Land",
#             },
#             'vehicle_purchase': {
#                 'id': inventory.vehicle_purchase.id if inventory.vehicle_purchase else None,
#                 'name': inventory.vehicle_purchase.name if inventory.vehicle_purchase else "Unknown",
#             },
#             'machinery_purchase': {
#                 'id': inventory.machinery_purchase.id if inventory.machinery_purchase else None,
#                 'name': inventory.machinery_purchase.inventory_items.name if inventory.machinery_purchase else "Unknown"
#             },
#             'tool_purchase': {
#                 'id': inventory.tool_purchase.id if inventory.tool_purchase else None,
#                 'name': inventory.tool_purchase.name if inventory.tool_purchase else "Unknown"
#             },
#             'fertilizer_purchase': {
#                 'id': inventory.fertilizer_purchase.id if inventory.fertilizer_purchase else None,
#                 'name': inventory.fertilizer_purchase.name if inventory.fertilizer_purchase else "Unknown"
#             },
#             'pesticide_purchase': {
#                 'id': inventory.pesticide_purchase.id if inventory.pesticide_purchase else None,
#                 'name': inventory.pesticide_purchase.name if inventory.pesticide_purchase else "Unknown"
#             },
#             'seeds_purchase': {
#                 'id': inventory.seeds_purchase.id if inventory.seeds_purchase else None,
#                 'name': inventory.seeds_purchase.name if inventory.seeds_purchase else "Unknown"
#             },
#             'status': inventory.status,
#             'created_at': str(inventory.created_at) if inventory.created_at else "N/A",
#             'updated_at': str(inventory.updated_at) if inventory.updated_at else "N/A",
#             'farmer': {
#                 'id': inventory.farmer.id if inventory.farmer else None,
#                 'name': inventory.farmer.name if inventory.farmer else "Unknown",
#             },
#             'documents': {}  # Dictionary to group documents by file_type
#         }

#         # Add document details for consumption, grouped by file_type
#         inventory_documents = MyInventoryDocuments.objects.filter(my_inventory=inventory)
#         for doc in inventory_documents:
#             file_type = doc.file_type.name if doc.file_type else "Unknown"
#             file_type_id = doc.file_type.id if doc.file_type else None
#             document_data = {
#                 'id': doc.id,
#                 'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
#             }

#             # Group documents by file_type
#             if file_type not in fuel_consumption_data['documents']:
#                 fuel_consumption_data['documents'][file_type] = {
#                     'id': file_type_id,
#                     'name': file_type,
#                     'documents': []
#                 }
#             fuel_consumption_data['documents'][file_type]['documents'].append(document_data)

#         response_data['machinery_consumption'].append(fuel_consumption_data)

#     return Response(response_data)

@api_view(['GET'])
def get_machinery_inventory_details(request, farmer_id, inventory_type_id, inventory_items_id):
    # Fetch the farmer, inventory type, and inventory items
    farmer = get_object_or_404(Farmer, id=farmer_id)
    inventory_type = get_object_or_404(InventoryType, id=inventory_type_id)
    inventory_items = get_object_or_404(InventoryItems, id=inventory_items_id)

    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'

    # Filter inventories based on farmer, inventory type, and inventory items
    inventories = MyInventory.objects.filter(
        farmer=farmer, 
        inventory_type=inventory_type, 
        inventory_items=inventory_items
    )

    # Prepare response data
    response_data = {
        'machinery_purchase': [],
        'machinery_consumption': []  # Include fuel_consumption if necessary for comparison
    }

    # Iterate over the inventories to structure the response
    for inventory in inventories: 
        if inventory.machinery_purchase:
            machinery_data = {
                'id': inventory.machinery_purchase.id,
                'vendor': {
                    'id': inventory.machinery_purchase.vendor.id if inventory.machinery_purchase.vendor else None,
                    'name': inventory.machinery_purchase.vendor.get_translated_value("name", language_code) if inventory.machinery_purchase.vendor else "Unknown",
                },
                'inventory_type': {
                    'id': inventory.machinery_purchase.inventory_type.id if inventory.machinery_purchase.inventory_type else None,
                    'name': inventory.machinery_purchase.inventory_type.get_translated_value("name", language_code) if inventory.machinery_purchase.inventory_type else "Unknown",
                },
                'inventory_category': {
                    'id': inventory.machinery_purchase.inventory_category.id if inventory.machinery_purchase.inventory_category else None,
                    'name': inventory.machinery_purchase.inventory_category.get_translated_value("name", language_code) if inventory.machinery_purchase.inventory_category else "Unknown",
                },
                'inventory_items': {
                    'id': inventory.machinery_purchase.inventory_items.id if inventory.machinery_purchase.inventory_items else None,
                    'name': inventory.machinery_purchase.inventory_items.get_translated_value("name", language_code) if inventory.machinery_purchase.inventory_items else "Unknown",
                },
                'fuel_capacity': str(inventory.machinery_purchase.fuel_capacity) if inventory.machinery_purchase.fuel_capacity else "0.00",
                'purchase_amount': str(inventory.machinery_purchase.purchase_amount) if inventory.machinery_purchase.purchase_amount else "0.00",
                'warranty_start_date': str(inventory.machinery_purchase.warranty_start_date) if inventory.machinery_purchase.warranty_start_date else "N/A",
                'warranty_end_date': str(inventory.machinery_purchase.warranty_end_date) if inventory.machinery_purchase.warranty_end_date else "N/A",
                'description': inventory.machinery_purchase.description if inventory.machinery_purchase.description else "N/A",
                'created_at': str(inventory.machinery_purchase.created_at) if inventory.machinery_purchase.created_at else "N/A",
                'updated_at': str(inventory.machinery_purchase.updated_at) if inventory.machinery_purchase.updated_at else "N/A",
                'farmer': {
                    'id': inventory.machinery_purchase.farmer.id if inventory.machinery_purchase.farmer else None,
                    'name': inventory.machinery_purchase.farmer.get_translated_value("name", language_code) if inventory.machinery_purchase.farmer else "Unknown",
                },
                'documents': {}  # Dictionary to group documents by file_type
            }

            # Add document details for machinery purchase, grouped by file_type
            machinery_documents = MyMachineryDocuments.objects.filter(machinary=inventory.machinery_purchase)
            for doc in machinery_documents:
                file_type = doc.file_type.get_translated_value("name", language_code) if doc.file_type else "Unknown"
                file_type_id = doc.file_type.id if doc.file_type else None
                document_data = {
                    'id': doc.id,
                    'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
                }

                # Group documents by file_type
                if file_type not in machinery_data['documents']:
                    machinery_data['documents'][file_type] = {
                        'id': file_type_id,
                        'name': file_type,
                        'documents': []
                    }
                machinery_data['documents'][file_type]['documents'].append(document_data)

            response_data['machinery_purchase'].append(machinery_data)
 
        fuel_consumption_data = {
            'id': inventory.id,
            'quantity_utilized': str(inventory.quantity_utilized) if inventory.quantity_utilized else "0.00",
            'date_of_consumption': str(inventory.date_of_consumption) if inventory.date_of_consumption else "N/A",
            'description': inventory.get_translated_value("description", language_code) if inventory.description else "N/A",
            'start_kilometer': str(inventory.start_kilometer) if inventory.start_kilometer else "0.00",
            'end_kilometer': str(inventory.end_kilometer) if inventory.end_kilometer else "0.00",
            'usage_hours': str(inventory.usage_hours) if inventory.usage_hours else "0.00",
            'tool_items': inventory.tool_items if inventory.tool_items else "N/A",
            'rental': str(inventory.rental) if inventory.rental else "1",
            'crop_id': inventory.crop.id if inventory.crop else None,
            'crop_name': inventory.crop.crop.get_translated_value("name", language_code) if inventory.crop else "Unknown Crop",  
            'crop_description': inventory.crop.get_translated_value("description", language_code) if inventory.crop and inventory.crop.description else "N/A",  # Added null check
            'image_url': request.build_absolute_uri(f'/assets{inventory.crop.crop.img.url}' if inventory.crop and inventory.crop.crop.img else '/assets/images/default_crop.png'),
            'land': {
                'id': inventory.crop.land.id if inventory.crop and inventory.crop.land else None,
                'name': inventory.crop.land.get_translated_value("name", language_code) if inventory.crop and inventory.crop.land else "Unknown Land",
            },
            'vehicle_purchase': {
                'id': inventory.vehicle_purchase.id if inventory.vehicle_purchase else None,
                'name': inventory.vehicle_purchase.get_translated_value("name", language_code) if inventory.vehicle_purchase else "Unknown",
            },
            'machinery_purchase': {
                'id': inventory.machinery_purchase.id if inventory.machinery_purchase else None,
                'name': inventory.machinery_purchase.inventory_items.get_translated_value("name", language_code) if inventory.machinery_purchase else "Unknown"
            },
            'tool_purchase': {
                'id': inventory.tool_purchase.id if inventory.tool_purchase else None,
                'name': inventory.tool_purchase.get_translated_value("name", language_code) if inventory.tool_purchase else "Unknown"
            },
            'fertilizer_purchase': {
                'id': inventory.fertilizer_purchase.id if inventory.fertilizer_purchase else None,
                'name': inventory.fertilizer_purchase.get_translated_value("name", language_code) if inventory.fertilizer_purchase else "Unknown"
            },
            'pesticide_purchase': {
                'id': inventory.pesticide_purchase.id if inventory.pesticide_purchase else None,
                'name': inventory.pesticide_purchase.get_translated_value("name", language_code) if inventory.pesticide_purchase else "Unknown"
            },
            'seeds_purchase': {
                'id': inventory.seeds_purchase.id if inventory.seeds_purchase else None,
                'name': inventory.seeds_purchase.get_translated_value("name", language_code) if inventory.seeds_purchase else "Unknown"
            },
            'status': inventory.status,
            'created_at': str(inventory.created_at) if inventory.created_at else "N/A",
            'updated_at': str(inventory.updated_at) if inventory.updated_at else "N/A",
            'farmer': {
                'id': inventory.farmer.id if inventory.farmer else None,
                'name': inventory.farmer.get_translated_value("name", language_code) if inventory.farmer else "Unknown",
            },
            'documents': {}  # Dictionary to group documents by file_type
        }

        # Add document details for consumption, grouped by file_type
        inventory_documents = MyInventoryDocuments.objects.filter(my_inventory=inventory)
        for doc in inventory_documents:
            file_type = doc.file_type.get_translated_value("name", language_code) if doc.file_type else "Unknown"
            file_type_id = doc.file_type.id if doc.file_type else None
            document_data = {
                'id': doc.id,
                'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
            }

            # Group documents by file_type
            if file_type not in fuel_consumption_data['documents']:
                fuel_consumption_data['documents'][file_type] = {
                    'id': file_type_id,
                    'name': file_type,
                    'documents': []
                }
            fuel_consumption_data['documents'][file_type]['documents'].append(document_data)

        response_data['machinery_consumption'].append(fuel_consumption_data)

    return Response(response_data)

# @api_view(['GET'])
# def get_pesticides_inventory_details(request, farmer_id, inventory_type_id, inventory_items_id):
#     # Fetch the farmer, inventory type, and inventory items
#     farmer = get_object_or_404(Farmer, id=farmer_id)
#     inventory_type = get_object_or_404(InventoryType, id=inventory_type_id)
#     inventory_items = get_object_or_404(InventoryItems, id=inventory_items_id)

#     # Filter inventories based on farmer, inventory type, and inventory items
#     inventories = MyInventory.objects.filter(
#         farmer=farmer,
#         inventory_type=inventory_type,
#         inventory_items=inventory_items
#     )

#     # Prepare response data
#     response_data = {
#         'pesticide_purchase': [],
#         'pesticide_consumption': []
#     }

#     # Iterate over the inventories to structure the response
#     for inventory in inventories:
#         # Pesticide Consumption Details
#         if inventory.pesticide_purchase:  # Check if pesticide purchase exists
#             pesticide_data = {
#                 'id': inventory.pesticide_purchase.id if inventory.pesticide_purchase else None,
#                 'farmer': {
#                     'id': inventory.pesticide_purchase.farmer.id if inventory.pesticide_purchase.farmer else None,
#                     'name': inventory.pesticide_purchase.farmer.name if inventory.pesticide_purchase.farmer else "Unknown",
#                 },
#                 'vendor': {
#                     'id': inventory.pesticide_purchase.vendor.id if inventory.pesticide_purchase.vendor else None,
#                     'name': inventory.pesticide_purchase.vendor.name if inventory.pesticide_purchase.vendor else "Unknown",
#                 },
#                 'inventory_type': {
#                     'id': inventory.pesticide_purchase.inventory_type.id if inventory.pesticide_purchase.inventory_type else None,
#                     'name': inventory.pesticide_purchase.inventory_type.name if inventory.pesticide_purchase.inventory_type else "Unknown",
#                 },
#                 'inventory_category': {
#                     'id': inventory.pesticide_purchase.inventory_category.id if inventory.pesticide_purchase.inventory_category else None,
#                     'name': inventory.pesticide_purchase.inventory_category.name if inventory.pesticide_purchase.inventory_category else "Unknown",
#                 },
#                 'inventory_items': {
#                     'id': inventory.pesticide_purchase.inventory_items.id if inventory.pesticide_purchase.inventory_items else None,
#                     'name': inventory.pesticide_purchase.inventory_items.name if inventory.pesticide_purchase.inventory_items else "Unknown",
#                 },
#                 'quantity': str(inventory.pesticide_purchase.quantity) if inventory.pesticide_purchase.quantity else "0.00",
#                 'quantity_unit': inventory.pesticide_purchase.quantity_unit.name if inventory.pesticide_purchase.quantity_unit else "Unknown",
#                 'purchase_amount': str(inventory.pesticide_purchase.purchase_amount) if inventory.pesticide_purchase.purchase_amount else "0.00",
#                 'description': inventory.pesticide_purchase.description if inventory.pesticide_purchase.description else "N/A",
#                 'status': inventory.pesticide_purchase.status,
#                 'created_at': str(inventory.pesticide_purchase.created_at) if inventory.pesticide_purchase.created_at else "N/A",
#                 'updated_at': str(inventory.pesticide_purchase.updated_at) if inventory.pesticide_purchase.updated_at else "N/A",
#             }

#             # Add documents related to pesticide purchase
#             pesticide_documents = MyPesticidesDocuments.objects.filter(pest=inventory.pesticide_purchase)
#             for doc in pesticide_documents:
#                 file_type = doc.file_type.name if doc.file_type else "Unknown"
#                 file_type_id = doc.file_type.id if doc.file_type else None
#                 document_data = {
#                     'id': doc.id,
#                     'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
#                 }

#                 # Group documents by file_type
#                 if file_type not in pesticide_data.get('documents', {}):
#                     pesticide_data['documents'] = {}
#                 if file_type not in pesticide_data['documents']:
#                     pesticide_data['documents'][file_type] = {
#                         'id': file_type_id,
#                         'name': file_type,
#                         'documents': []
#                     }
#                 pesticide_data['documents'][file_type]['documents'].append(document_data)

#             # Add to the response data
#             response_data['pesticide_purchase'].append(pesticide_data)

#             # Pesticide Consumption Details (from MyInventory)
#             pesticide_consumption_data = {
#                 'id': inventory.id,
#                 'quantity_utilized': str(inventory.quantity_utilized) if inventory.quantity_utilized else "0.00",
#                 'available_quans': str(inventory.available_quans) if inventory.available_quans else "0.00",
#                 'date_of_consumption': str(inventory.date_of_consumption) if inventory.date_of_consumption else "N/A",
#                 'description': inventory.description if inventory.description else "N/A",
#                 'status': inventory.status,
#                 'created_at': str(inventory.created_at) if inventory.created_at else "N/A",
#                 'updated_at': str(inventory.updated_at) if inventory.updated_at else "N/A",
#                 'farmer': {
#                     'id': inventory.farmer.id if inventory.farmer else None,
#                     'name': inventory.farmer.name if inventory.farmer else "Unknown",
#                 },
#                 'documents': {}
#             }

#             # Add documents related to inventory (pesticide consumption)
#             inventory_documents = MyInventoryDocuments.objects.filter(my_inventory=inventory)
#             for doc in inventory_documents:
#                 file_type = doc.file_type.name if doc.file_type else "Unknown"
#                 file_type_id = doc.file_type.id if doc.file_type else None
#                 document_data = {
#                     'id': doc.id,
#                     'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
#                 }

#                 # Group documents by file_type
#                 if file_type not in pesticide_consumption_data.get('documents', {}):
#                     pesticide_consumption_data['documents'] = {}
#                 if file_type not in pesticide_consumption_data['documents']:
#                     pesticide_consumption_data['documents'][file_type] = {
#                         'id': file_type_id,
#                         'name': file_type,
#                         'documents': []
#                     }
#                 pesticide_consumption_data['documents'][file_type]['documents'].append(document_data)

#             response_data['pesticide_consumption'].append(pesticide_consumption_data)

#     return Response(response_data)

# @api_view(['GET'])
# def get_pesticides_inventory_details(request, farmer_id, inventory_type_id, inventory_items_id):
#     # Fetch the farmer, inventory type, and inventory items
#     farmer = get_object_or_404(Farmer, id=farmer_id)
#     inventory_type = get_object_or_404(InventoryType, id=inventory_type_id)
#     inventory_items = get_object_or_404(InventoryItems, id=inventory_items_id)
#     try:
#         user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
#         language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
#     except UserLanguagePreference.DoesNotExist:
#         language_code = 'en'

#     # Filter inventories based on farmer, inventory type, and inventory items
#     inventories = MyInventory.objects.filter(
#         farmer=farmer,
#         inventory_type=inventory_type,
#         inventory_items=inventory_items
#     )

#     # Prepare response data
#     response_data = {
#         'pesticide_purchase': [],
#         'pesticide_consumption': []
#     }

#     # Iterate over the inventories to structure the response
#     for inventory in inventories:
#         # Pesticide Consumption Details
#         if inventory.pesticide_purchase:  # Check if pesticide purchase exists
#             pesticide_data = {
#                 'id': inventory.pesticide_purchase.id if inventory.pesticide_purchase else None,
#                 'farmer': {
#                     'id': inventory.pesticide_purchase.farmer.id if inventory.pesticide_purchase.farmer else None,
#                     'name': inventory.pesticide_purchase.farmer.get_translated_value("name", language_code) if inventory.pesticide_purchase.farmer else "Unknown",
#                 },
#                 'vendor': {
#                     'id': inventory.pesticide_purchase.vendor.id if inventory.pesticide_purchase.vendor else None,
#                     'name': inventory.pesticide_purchase.vendor.get_translated_value("name", language_code) if inventory.pesticide_purchase.vendor else "Unknown",
#                 },
#                 'inventory_type': {
#                     'id': inventory.pesticide_purchase.inventory_type.id if inventory.pesticide_purchase.inventory_type else None,
#                     'name': inventory.pesticide_purchase.inventory_type.get_translated_value("name", language_code) if inventory.pesticide_purchase.inventory_type else "Unknown",
#                 },
#                 'inventory_category': {
#                     'id': inventory.pesticide_purchase.inventory_category.id if inventory.pesticide_purchase.inventory_category else None,
#                     'name': inventory.pesticide_purchase.inventory_category.get_translated_value("name", language_code) if inventory.pesticide_purchase.inventory_category else "Unknown",
#                 },
#                 'inventory_items': {
#                     'id': inventory.pesticide_purchase.inventory_items.id if inventory.pesticide_purchase.inventory_items else None,
#                     'name': inventory.pesticide_purchase.inventory_items.get_translated_value("name", language_code) if inventory.pesticide_purchase.inventory_items else "Unknown",
#                 },
#                 'quantity': str(inventory.pesticide_purchase.quantity) if inventory.pesticide_purchase.quantity else "0.00",
#                 'quantity_unit': inventory.pesticide_purchase.quantity_unit.name if inventory.pesticide_purchase.quantity_unit else "Unknown",
#                 'purchase_amount': str(inventory.pesticide_purchase.purchase_amount) if inventory.pesticide_purchase.purchase_amount else "0.00",
#                 'description': inventory.pesticide_purchase.get_translated_value("description", language_code) if inventory.pesticide_purchase.description else "N/A",
#                 'status': inventory.pesticide_purchase.status,
#                 'created_at': str(inventory.pesticide_purchase.created_at) if inventory.pesticide_purchase.created_at else "N/A",
#                 'updated_at': str(inventory.pesticide_purchase.updated_at) if inventory.pesticide_purchase.updated_at else "N/A",
#             }

#             # Add documents related to pesticide purchase
#             pesticide_documents = MyPesticidesDocuments.objects.filter(pest=inventory.pesticide_purchase)
#             for doc in pesticide_documents:
#                 file_type = doc.file_type.get_translated_value("name", language_code) if doc.file_type else "Unknown"
#                 file_type_id = doc.file_type.id if doc.file_type else None
#                 document_data = {
#                     'id': doc.id,
#                     'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
#                 }

#                 # Group documents by file_type
#                 if file_type not in pesticide_data.get('documents', {}):
#                     pesticide_data['documents'] = {}
#                 if file_type not in pesticide_data['documents']:
#                     pesticide_data['documents'][file_type] = {
#                         'id': file_type_id,
#                         'name': file_type,
#                         'documents': []
#                     }
#                 pesticide_data['documents'][file_type]['documents'].append(document_data)

#             # Add to the response data
#             response_data['pesticide_purchase'].append(pesticide_data)

#             # Pesticide Consumption Details (from MyInventory)
#             pesticide_consumption_data = {
#                 'id': inventory.id,
#                 'quantity_utilized': str(inventory.quantity_utilized) if inventory.quantity_utilized else "0.00",
#                 'available_quans': str(inventory.available_quans) if inventory.available_quans else "0.00",
#                 'date_of_consumption': str(inventory.date_of_consumption) if inventory.date_of_consumption else "N/A",
#                 'description': inventory.get_translated_value("description", language_code) if inventory.description else "N/A",
#                 'status': inventory.status,
#                 'created_at': str(inventory.created_at) if inventory.created_at else "N/A",
#                 'updated_at': str(inventory.updated_at) if inventory.updated_at else "N/A",
#                 'farmer': {
#                     'id': inventory.farmer.id if inventory.farmer else None,
#                     'name': inventory.farmer.get_translated_value("name", language_code) if inventory.farmer else "Unknown",
#                 },
#                 'documents': {}
#             }

#             # Add documents related to inventory (pesticide consumption)
#             inventory_documents = MyInventoryDocuments.objects.filter(my_inventory=inventory)
#             for doc in inventory_documents:
#                 file_type = doc.file_type.get_translated_value("name", language_code) if doc.file_type else "Unknown"
#                 file_type_id = doc.file_type.id if doc.file_type else None
#                 document_data = {
#                     'id': doc.id,
#                     'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
#                 }

#                 # Group documents by file_type
#                 if file_type not in pesticide_consumption_data.get('documents', {}):
#                     pesticide_consumption_data['documents'] = {}
#                 if file_type not in pesticide_consumption_data['documents']:
#                     pesticide_consumption_data['documents'][file_type] = {
#                         'id': file_type_id,
#                         'name': file_type,
#                         'documents': []
#                     }
#                 pesticide_consumption_data['documents'][file_type]['documents'].append(document_data)

#             response_data['pesticide_consumption'].append(pesticide_consumption_data)

#     return Response(response_data)

 

@api_view(['GET'])
def get_pesticides_inventory_details(request, farmer_id, inventory_type_id, inventory_items_id):
    # Fetch the farmer, inventory type, and inventory items
    farmer = get_object_or_404(Farmer, id=farmer_id, status=0)
    inventory_type = get_object_or_404(InventoryType, id=inventory_type_id, status=0)
    inventory_items = get_object_or_404(InventoryItems, id=inventory_items_id, status=0)

    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'

    # Filter inventories
    inventories = MyInventory.objects.filter(
        farmer=farmer,
        inventory_type=inventory_type,
        inventory_items=inventory_items,
        status__in=[0, 1]
    )

    response_data = {
        'pesticide_purchase': [],
        'crop': [],
        'pesticide_consumption': []
    }

    for inventory in inventories:
        # ---------- PESTICIDE PURCHASE ----------
        if inventory.pesticide_purchase:
            purchase = inventory.pesticide_purchase
            pesticide_data = {
                'id': purchase.id,
                'farmer': {
                    'id': purchase.farmer.id,
                    'name': purchase.farmer.get_translated_value("name", language_code),
                },
                'vendor': {
                    'id': purchase.vendor.id if purchase.vendor else None,
                    'name': purchase.vendor.get_translated_value("name", language_code) if purchase.vendor else "Unknown",
                },
                'inventory_type': {
                    'id': purchase.inventory_type.id,
                    'name': purchase.inventory_type.get_translated_value("name", language_code),
                },
                'inventory_category': {
                    'id': purchase.inventory_category.id,
                    'name': purchase.inventory_category.get_translated_value("name", language_code),
                },
                'inventory_items': {
                    'id': purchase.inventory_items.id,
                    'name': purchase.inventory_items.get_translated_value("name", language_code),
                },
                'quantity': str(purchase.quantity or "0.00"),
                'quantity_unit': purchase.quantity_unit.get_translated_value("name", language_code) if purchase.quantity_unit else "Unknown",
                'purchase_amount': str(purchase.purchase_amount or "0.00"),
                'description': purchase.get_translated_value("description", language_code) if purchase.description else "N/A",
                'status': purchase.status,
                'created_at': str(purchase.created_at or "N/A"),
                'updated_at': str(purchase.updated_at or "N/A"),
                'documents': {}
            }

            # Documents for pesticide purchase
            pesticide_documents = MyPesticidesDocuments.objects.filter(pest=purchase)
            for doc in pesticide_documents:
                file_type = doc.file_type.get_translated_value("name", language_code) if doc.file_type else "Unknown"
                file_type_id = doc.file_type.id if doc.file_type else None
                document_data = {
                    'id': doc.id,
                    'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}') if doc.document else "",
                }

                if file_type not in pesticide_data['documents']:
                    pesticide_data['documents'][file_type] = {
                        'id': file_type_id,
                        'name': file_type,
                        'documents': []
                    }
                pesticide_data['documents'][file_type]['documents'].append(document_data)

            response_data['pesticide_purchase'].append(pesticide_data)

        # ---------- CROP DETAILS (if linked) ----------
        if inventory.crop:
            crop_data = {
                'id': inventory.crop.id,
                'crop_name': inventory.crop.crop.name,
                'land': inventory.crop.land.name,
                'img': request.build_absolute_uri(f'/SuperAdmin{inventory.crop.crop.img.url}') if inventory.crop.crop.img else "",
            }
            response_data['crop'].append(crop_data)

        # ---------- PESTICIDE CONSUMPTION ----------
        pesticide_consumption_data = {
            'id': inventory.id,
            'quantity_utilized': str(inventory.quantity_utilized or "0.00"),
            'available_quans': str(inventory.available_quans or "0.00"),
            'date_of_consumption': str(inventory.date_of_consumption or "N/A"),
            'description': inventory.get_translated_value("description", language_code) if inventory.description else "N/A",
            'status': inventory.status,
            'created_at': str(inventory.created_at or "N/A"),
            'updated_at': str(inventory.updated_at or "N/A"),
            'farmer': {
                'id': inventory.farmer.id,
                'name': inventory.farmer.get_translated_value("name", language_code),
            },
            'documents': {}
        }

        # Include crop data if available
        if inventory.crop:
            pesticide_consumption_data['crop'] = {
                'id': inventory.crop.id,
                'crop_name': inventory.crop.crop.name,
                'land': inventory.crop.land.name,
                'img': request.build_absolute_uri(f'/SuperAdmin{inventory.crop.crop.img.url}') if inventory.crop.crop.img else "",
            }

        # Documents for pesticide consumption
        inventory_documents = MyInventoryDocuments.objects.filter(my_inventory=inventory)
        for doc in inventory_documents:
            file_type = doc.file_type.get_translated_value("name", language_code) if doc.file_type else "Unknown"
            file_type_id = doc.file_type.id if doc.file_type else None
            document_data = {
                'id': doc.id,
                'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}') if doc.document else "",
            }

            if file_type not in pesticide_consumption_data['documents']:
                pesticide_consumption_data['documents'][file_type] = {
                    'id': file_type_id,
                    'name': file_type,
                    'documents': []
                }
            pesticide_consumption_data['documents'][file_type]['documents'].append(document_data)

        response_data['pesticide_consumption'].append(pesticide_consumption_data)

    return Response(response_data)





# @api_view(['GET'])
# def get_seeds_inventory_details(request, farmer_id, inventory_type_id, inventory_items_id):
#     # Fetch the farmer, inventory type, and inventory items
#     farmer = get_object_or_404(Farmer, id=farmer_id)
#     inventory_type = get_object_or_404(InventoryType, id=inventory_type_id)
#     inventory_items = get_object_or_404(InventoryItems, id=inventory_items_id)

#     # Filter inventories based on farmer, inventory type, and inventory items
#     inventories = MyInventory.objects.filter(
#         farmer=farmer,
#         inventory_type=inventory_type,
#         inventory_items=inventory_items
#     )

#     # Prepare response data
#     response_data = {
#         'seeds_purchase': [],
#         'seeds_consumption': []
#     }

#     # Iterate over the inventories to structure the response
#     for inventory in inventories:
#         # Seeds Consumption Details
#         if inventory.seeds_purchase:  # Check if seeds purchase exists
#             seeds_data = {
#                 'id': inventory.seeds_purchase.id if inventory.seeds_purchase else None,
#                 'farmer': {
#                     'id': inventory.seeds_purchase.farmer.id if inventory.seeds_purchase.farmer else None,
#                     'name': inventory.seeds_purchase.farmer.name if inventory.seeds_purchase.farmer else "Unknown",
#                 },
#                 'vendor': {
#                     'id': inventory.seeds_purchase.vendor.id if inventory.seeds_purchase.vendor else None,
#                     'name': inventory.seeds_purchase.vendor.name if inventory.seeds_purchase.vendor else "Unknown",
#                 },
#                 'inventory_type': {
#                     'id': inventory.seeds_purchase.inventory_type.id if inventory.seeds_purchase.inventory_type else None,
#                     'name': inventory.seeds_purchase.inventory_type.name if inventory.seeds_purchase.inventory_type else "Unknown",
#                 },
#                 'inventory_category': {
#                     'id': inventory.seeds_purchase.inventory_category.id if inventory.seeds_purchase.inventory_category else None,
#                     'name': inventory.seeds_purchase.inventory_category.name if inventory.seeds_purchase.inventory_category else "Unknown",
#                 },
#                 'inventory_items': {
#                     'id': inventory.seeds_purchase.inventory_items.id if inventory.seeds_purchase.inventory_items else None,
#                     'name': inventory.seeds_purchase.inventory_items.name if inventory.seeds_purchase.inventory_items else "Unknown",
#                 },
#                 'quantity': str(inventory.seeds_purchase.quantity) if inventory.seeds_purchase.quantity else "0.00",
#                 'quantity_unit': inventory.seeds_purchase.quantity_unit.name if inventory.seeds_purchase.quantity_unit else "Unknown",
#                 'purchase_amount': str(inventory.seeds_purchase.purchase_amount) if inventory.seeds_purchase.purchase_amount else "0.00",
#                 'description': inventory.seeds_purchase.description if inventory.seeds_purchase.description else "N/A",
#                 'status': inventory.seeds_purchase.status,
#                 'created_at': str(inventory.seeds_purchase.created_at) if inventory.seeds_purchase.created_at else "N/A",
#                 'updated_at': str(inventory.seeds_purchase.updated_at) if inventory.seeds_purchase.updated_at else "N/A",
#             }

#             # Add documents related to seeds purchase
#             seeds_documents = MyseedsDocuments.objects.filter(seeds=inventory.seeds_purchase)
#             for doc in seeds_documents:
#                 file_type = doc.file_type.name if doc.file_type else "Unknown"
#                 file_type_id = doc.file_type.id if doc.file_type else None
#                 document_data = {
#                     'id': doc.id,
#                     'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
#                 }

#                 # Group documents by file_type
#                 if file_type not in seeds_data.get('documents', {}):
#                     seeds_data['documents'] = {}
#                 if file_type not in seeds_data['documents']:
#                     seeds_data['documents'][file_type] = {
#                         'id': file_type_id,
#                         'name': file_type,
#                         'documents': []
#                     }
#                 seeds_data['documents'][file_type]['documents'].append(document_data)

#             # Add to the response data
#             response_data['seeds_purchase'].append(seeds_data)

#             # Seeds Consumption Details (from MyInventory)
#             seeds_consumption_data = {
#                 'id': inventory.id,
#                 'quantity_utilized': str(inventory.quantity_utilized) if inventory.quantity_utilized else "0.00",
#                 'available_quans': str(inventory.available_quans) if inventory.available_quans else "0.00",
#                 'date_of_consumption': str(inventory.date_of_consumption) if inventory.date_of_consumption else "N/A",
#                 'description': inventory.description if inventory.description else "N/A",
#                 'status': inventory.status,
#                 'created_at': str(inventory.created_at) if inventory.created_at else "N/A",
#                 'updated_at': str(inventory.updated_at) if inventory.updated_at else "N/A",
#                 'farmer': {
#                     'id': inventory.farmer.id if inventory.farmer else None,
#                     'name': inventory.farmer.name if inventory.farmer else "Unknown",
#                 },
#                 'documents': {}
#             }

#             # Add documents related to inventory (seeds consumption)
#             inventory_documents = MyInventoryDocuments.objects.filter(my_inventory=inventory)
#             for doc in inventory_documents:
#                 file_type = doc.file_type.name if doc.file_type else "Unknown"
#                 file_type_id = doc.file_type.id if doc.file_type else None
#                 document_data = {
#                     'id': doc.id,
#                     'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
#                 }

#                 # Group documents by file_type
#                 if file_type not in seeds_consumption_data.get('documents', {}):
#                     seeds_consumption_data['documents'] = {}
#                 if file_type not in seeds_consumption_data['documents']:
#                     seeds_consumption_data['documents'][file_type] = {
#                         'id': file_type_id,
#                         'name': file_type,
#                         'documents': []
#                     }
#                 seeds_consumption_data['documents'][file_type]['documents'].append(document_data)

#             response_data['seeds_consumption'].append(seeds_consumption_data)

#     return Response(response_data)


# @api_view(['GET'])
# def get_seeds_inventory_details(request, farmer_id, inventory_type_id, inventory_items_id):
#     # Fetch the farmer, inventory type, and inventory items
#     farmer = get_object_or_404(Farmer, id=farmer_id,status=0)
#     inventory_type = get_object_or_404(InventoryType, id=inventory_type_id,status=0)
#     inventory_items = get_object_or_404(InventoryItems, id=inventory_items_id,status=0)

#     try:
#         user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
#         language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
#     except UserLanguagePreference.DoesNotExist:
#         language_code = 'en'

#     # Filter inventories based on farmer, inventory type, and inventory items
#     inventories = MyInventory.objects.filter(
#         farmer=farmer,
#         inventory_type=inventory_type,
#         inventory_items=inventory_items,
#           status__in=[0, 1] 
#     )

#     # Prepare response data
#     response_data = {
#         'seeds_purchase': [],
#         'seeds_consumption': []
#     }

#     # Iterate over the inventories to structure the response
#     for inventory in inventories:
#         # Seeds Consumption Details
#         if inventory.seeds_purchase:  # Check if seeds purchase exists
#             seeds_data = {
#                 'id': inventory.seeds_purchase.id if inventory.seeds_purchase else None,
#                 'farmer': {
#                     'id': inventory.seeds_purchase.farmer.id if inventory.seeds_purchase.farmer else None,
#                     'name': inventory.seeds_purchase.farmer.get_translated_value("name", language_code) if inventory.seeds_purchase.farmer else "Unknown",
#                 },
#                 'vendor': {
#                     'id': inventory.seeds_purchase.vendor.id if inventory.seeds_purchase.vendor else None,
#                     'name': inventory.seeds_purchase.vendor.get_translated_value("name", language_code) if inventory.seeds_purchase.vendor else "Unknown",
#                 },
#                 'inventory_type': {
#                     'id': inventory.seeds_purchase.inventory_type.id if inventory.seeds_purchase.inventory_type else None,
#                     'name': inventory.seeds_purchase.inventory_type.get_translated_value("name", language_code) if inventory.seeds_purchase.inventory_type else "Unknown",
#                 },
#                 'inventory_category': {
#                     'id': inventory.seeds_purchase.inventory_category.id if inventory.seeds_purchase.inventory_category else None,
#                     'name': inventory.seeds_purchase.inventory_category.get_translated_value("name", language_code) if inventory.seeds_purchase.inventory_category else "Unknown",
#                 },
#                 'inventory_items': {
#                     'id': inventory.seeds_purchase.inventory_items.id if inventory.seeds_purchase.inventory_items else None,
#                     'name': inventory.seeds_purchase.inventory_items.get_translated_value("name", language_code) if inventory.seeds_purchase.inventory_items else "Unknown",
#                 },
#                 'quantity': str(inventory.seeds_purchase.quantity) if inventory.seeds_purchase.quantity else "0.00",
#                 'quantity_unit': inventory.seeds_purchase.quantity_unit.get_translated_value("name", language_code) if inventory.seeds_purchase.quantity_unit else "Unknown",
#                 'purchase_amount': str(inventory.seeds_purchase.purchase_amount) if inventory.seeds_purchase.purchase_amount else "0.00",
#                 'description': inventory.seeds_purchase.get_translated_value("description", language_code) if inventory.seeds_purchase.description else "N/A",
#                 'status': inventory.seeds_purchase.status,
#                 'created_at': str(inventory.seeds_purchase.created_at) if inventory.seeds_purchase.created_at else "N/A",
#                 'updated_at': str(inventory.seeds_purchase.updated_at) if inventory.seeds_purchase.updated_at else "N/A",
#             }

#             # Add documents related to seeds purchase
#             seeds_documents = MyseedsDocuments.objects.filter(seeds=inventory.seeds_purchase)
#             for doc in seeds_documents:
#                 file_type = doc.file_type.get_translated_value("name", language_code) if doc.file_type else "Unknown"
#                 file_type_id = doc.file_type.id if doc.file_type else None
#                 document_data = {
#                     'id': doc.id,
#                     'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
#                 }

#                 # Group documents by file_type
#                 if file_type not in seeds_data.get('documents', {}):
#                     seeds_data['documents'] = {}
#                 if file_type not in seeds_data['documents']:
#                     seeds_data['documents'][file_type] = {
#                         'id': file_type_id,
#                         'name': file_type,
#                         'documents': []
#                     }
#                 seeds_data['documents'][file_type]['documents'].append(document_data)

#             # Add to the response data
#             response_data['seeds_purchase'].append(seeds_data)

#             # Seeds Consumption Details (from MyInventory)
#             seeds_consumption_data = {
#                 'id': inventory.id,
#                 'quantity_utilized': str(inventory.quantity_utilized) if inventory.quantity_utilized else "0.00",
#                 'available_quans': str(inventory.available_quans) if inventory.available_quans else "0.00",
#                 'date_of_consumption': str(inventory.date_of_consumption) if inventory.date_of_consumption else "N/A",
#                 'description': inventory.get_translated_value("description", language_code) if inventory.description else "N/A",
#                 'status': inventory.status,
#                 'created_at': str(inventory.created_at) if inventory.created_at else "N/A",
#                 'updated_at': str(inventory.updated_at) if inventory.updated_at else "N/A",
#                 'farmer': {
#                     'id': inventory.farmer.id if inventory.farmer else None,
#                     'name': inventory.farmer.get_translated_value("name", language_code) if inventory.farmer else "Unknown",
#                 },
           
#                 'documents': {}
#             }

#             # Add documents related to inventory (seeds consumption)
#             inventory_documents = MyInventoryDocuments.objects.filter(my_inventory=inventory)
#             for doc in inventory_documents:
#                 file_type = doc.file_type.get_translated_value("name", language_code) if doc.file_type else "Unknown"
#                 file_type_id = doc.file_type.id if doc.file_type else None
#                 document_data = {
#                     'id': doc.id,
#                     'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
#                 }

#                 # Group documents by file_type
#                 if file_type not in seeds_consumption_data.get('documents', {}):
#                     seeds_consumption_data['documents'] = {}
#                 if file_type not in seeds_consumption_data['documents']:
#                     seeds_consumption_data['documents'][file_type] = {
#                         'id': file_type_id,
#                         'name': file_type,
#                         'documents': []
#                     }
#                 seeds_consumption_data['documents'][file_type]['documents'].append(document_data)

#             response_data['seeds_consumption'].append(seeds_consumption_data)

#     return Response(response_data)

# @api_view(['GET'])
# def get_seeds_inventory_details(request, farmer_id, inventory_type_id, inventory_items_id):
#     # Fetch the farmer, inventory type, and inventory items
#     farmer = get_object_or_404(Farmer, id=farmer_id, status=0)
#     inventory_type = get_object_or_404(InventoryType, id=inventory_type_id, status=0)
#     inventory_items = get_object_or_404(InventoryItems, id=inventory_items_id, status=0)

#     try:
#         user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
#         language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
#     except UserLanguagePreference.DoesNotExist:
#         language_code = 'en'

#     # Filter inventories based on farmer, inventory type, and inventory items
#     inventories = MyInventory.objects.filter(
#         farmer=farmer,
#         inventory_type=inventory_type,
#         inventory_items=inventory_items,
#         status__in=[0, 1]
#     )

#     # Prepare response data
#     response_data = {
#         'seeds_purchase': [],
#         'crop': [],  # Initialize the 'crop' list to avoid KeyError
#         'seeds_consumption': []
#     }

#     # Iterate over the inventories to structure the response
#     for inventory in inventories:
#         # Seeds Consumption Details
#         if inventory.seeds_purchase:  # Check if seeds purchase exists
#             seeds_data = {
#                 'id': inventory.seeds_purchase.id if inventory.seeds_purchase else None,
#                 'farmer': {
#                     'id': inventory.seeds_purchase.farmer.id if inventory.seeds_purchase.farmer else None,
#                     'name': inventory.seeds_purchase.farmer.get_translated_value("name", language_code) if inventory.seeds_purchase.farmer else "Unknown",
#                 },
#                 'vendor': {
#                     'id': inventory.seeds_purchase.vendor.id if inventory.seeds_purchase.vendor else None,
#                     'name': inventory.seeds_purchase.vendor.get_translated_value("name", language_code) if inventory.seeds_purchase.vendor else "Unknown",
#                 },
#                 'inventory_type': {
#                     'id': inventory.seeds_purchase.inventory_type.id if inventory.seeds_purchase.inventory_type else None,
#                     'name': inventory.seeds_purchase.inventory_type.get_translated_value("name", language_code) if inventory.seeds_purchase.inventory_type else "Unknown",
#                 },
#                 'inventory_category': {
#                     'id': inventory.seeds_purchase.inventory_category.id if inventory.seeds_purchase.inventory_category else None,
#                     'name': inventory.seeds_purchase.inventory_category.get_translated_value("name", language_code) if inventory.seeds_purchase.inventory_category else "Unknown",
#                 },
#                 'inventory_items': {
#                     'id': inventory.seeds_purchase.inventory_items.id if inventory.seeds_purchase.inventory_items else None,
#                     'name': inventory.seeds_purchase.inventory_items.get_translated_value("name", language_code) if inventory.seeds_purchase.inventory_items else "Unknown",
#                 },
#                 'quantity': str(inventory.seeds_purchase.quantity) if inventory.seeds_purchase.quantity else "0.00",
#                 'quantity_unit': inventory.seeds_purchase.quantity_unit.get_translated_value("name", language_code) if inventory.seeds_purchase.quantity_unit else "Unknown",
#                 'purchase_amount': str(inventory.seeds_purchase.purchase_amount) if inventory.seeds_purchase.purchase_amount else "0.00",
#                 'description': inventory.seeds_purchase.get_translated_value("description", language_code) if inventory.seeds_purchase.description else "N/A",
#                 'status': inventory.seeds_purchase.status,
#                 'created_at': str(inventory.seeds_purchase.created_at) if inventory.seeds_purchase.created_at else "N/A",
#                 'updated_at': str(inventory.seeds_purchase.updated_at) if inventory.seeds_purchase.updated_at else "N/A",
#             }

#             # Add documents related to seeds purchase
#             seeds_documents = MyseedsDocuments.objects.filter(seeds=inventory.seeds_purchase)
#             for doc in seeds_documents:
#                 file_type = doc.file_type.get_translated_value("name", language_code) if doc.file_type else "Unknown"
#                 file_type_id = doc.file_type.id if doc.file_type else None
#                 document_data = {
#                     'id': doc.id,
#                     'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
#                 }

#                 # Group documents by file_type
#                 if file_type not in seeds_data.get('documents', {}):
#                     seeds_data['documents'] = {}
#                 if file_type not in seeds_data['documents']:
#                     seeds_data['documents'][file_type] = {
#                         'id': file_type_id,
#                         'name': file_type,
#                         'documents': []
#                     }
#                 seeds_data['documents'][file_type]['documents'].append(document_data)

#             # Add to the response data
#             response_data['seeds_purchase'].append(seeds_data)

#         # Crop Details (from MyCrop)
#         if inventory.crop:
#             crop_data = {
#                 'id': inventory.crop.id,
#                 'crop_name': inventory.crop.crop.name,
#                 'land': inventory.crop.land.name,
#                 'img': request.build_absolute_uri(f'/SuperAdmin{inventory.crop.crop.img.url}' if inventory.crop.crop.img else inventory.crop.crop.img.url) if inventory.crop.crop.img else "",
#             }

#             # Append crop data to response_data['crop']
#             response_data['crop'].append(crop_data)

#         # Seeds Consumption Details (from MyInventory)
#         seeds_consumption_data = {
#             'id': inventory.id,
#             'quantity_utilized': str(inventory.quantity_utilized) if inventory.quantity_utilized else "0.00",
#             'available_quans': str(inventory.available_quans) if inventory.available_quans else "0.00",
#             'date_of_consumption': str(inventory.date_of_consumption) if inventory.date_of_consumption else "N/A",
#             'description': inventory.get_translated_value("description", language_code) if inventory.description else "N/A",
#             'status': inventory.status,
#             'created_at': str(inventory.created_at) if inventory.created_at else "N/A",
#             'updated_at': str(inventory.updated_at) if inventory.updated_at else "N/A",
#             'farmer': {
#                 'id': inventory.farmer.id if inventory.farmer else None,
#                 'name': inventory.farmer.get_translated_value("name", language_code) if inventory.farmer else "Unknown",
#             },
#             'documents': {}
#         }

#         # Add documents related to inventory (seeds consumption)
#         inventory_documents = MyInventoryDocuments.objects.filter(my_inventory=inventory)
#         for doc in inventory_documents:
#             file_type = doc.file_type.get_translated_value("name", language_code) if doc.file_type else "Unknown"
#             file_type_id = doc.file_type.id if doc.file_type else None
#             document_data = {
#                 'id': doc.id,
#                 'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
#             }

#             # Group documents by file_type
#             if file_type not in seeds_consumption_data.get('documents', {}):
#                 seeds_consumption_data['documents'] = {}
#             if file_type not in seeds_consumption_data['documents']:
#                 seeds_consumption_data['documents'][file_type] = {
#                     'id': file_type_id,
#                     'name': file_type,
#                     'documents': []
#                 }
#             seeds_consumption_data['documents'][file_type]['documents'].append(document_data)

#         response_data['seeds_consumption'].append(seeds_consumption_data)

#     return Response(response_data)

@api_view(['GET'])
def get_seeds_inventory_details(request, farmer_id, inventory_type_id, inventory_items_id):
    # Fetch the farmer, inventory type, and inventory items
    farmer = get_object_or_404(Farmer, id=farmer_id, status=0)
    inventory_type = get_object_or_404(InventoryType, id=inventory_type_id, status=0)
    inventory_items = get_object_or_404(InventoryItems, id=inventory_items_id, status=0)

    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'

    # Filter inventories based on farmer, inventory type, and inventory items
    inventories = MyInventory.objects.filter(
        farmer=farmer,
        inventory_type=inventory_type,
        inventory_items=inventory_items,
        status__in=[0, 1]
    )

    # Prepare response data
    response_data = {
        'seeds_purchase': [],
        'crop': [],  # Initialize the 'crop' list to avoid KeyError
        'seeds_consumption': []
    }

    # Iterate over the inventories to structure the response
    for inventory in inventories:
        # Seeds Consumption Details
        if inventory.seeds_purchase:  # Check if seeds purchase exists
            seeds_data = {
                'id': inventory.seeds_purchase.id if inventory.seeds_purchase else None,
                'farmer': {
                    'id': inventory.seeds_purchase.farmer.id if inventory.seeds_purchase.farmer else None,
                    'name': inventory.seeds_purchase.farmer.get_translated_value("name", language_code) if inventory.seeds_purchase.farmer else "Unknown",
                },
                'vendor': {
                    'id': inventory.seeds_purchase.vendor.id if inventory.seeds_purchase.vendor else None,
                    'name': inventory.seeds_purchase.vendor.get_translated_value("name", language_code) if inventory.seeds_purchase.vendor else "Unknown",
                },
                'inventory_type': {
                    'id': inventory.seeds_purchase.inventory_type.id if inventory.seeds_purchase.inventory_type else None,
                    'name': inventory.seeds_purchase.inventory_type.get_translated_value("name", language_code) if inventory.seeds_purchase.inventory_type else "Unknown",
                },
                'inventory_category': {
                    'id': inventory.seeds_purchase.inventory_category.id if inventory.seeds_purchase.inventory_category else None,
                    'name': inventory.seeds_purchase.inventory_category.get_translated_value("name", language_code) if inventory.seeds_purchase.inventory_category else "Unknown",
                },
                'inventory_items': {
                    'id': inventory.seeds_purchase.inventory_items.id if inventory.seeds_purchase.inventory_items else None,
                    'name': inventory.seeds_purchase.inventory_items.get_translated_value("name", language_code) if inventory.seeds_purchase.inventory_items else "Unknown",
                },
                'quantity': str(inventory.seeds_purchase.quantity) if inventory.seeds_purchase.quantity else "0.00",
                'quantity_unit': inventory.seeds_purchase.quantity_unit.get_translated_value("name", language_code) if inventory.seeds_purchase.quantity_unit else "Unknown",
                'purchase_amount': str(inventory.seeds_purchase.purchase_amount) if inventory.seeds_purchase.purchase_amount else "0.00",
                'description': inventory.seeds_purchase.get_translated_value("description", language_code) if inventory.seeds_purchase.description else "N/A",
                'status': inventory.seeds_purchase.status,
                'created_at': str(inventory.seeds_purchase.created_at) if inventory.seeds_purchase.created_at else "N/A",
                'updated_at': str(inventory.seeds_purchase.updated_at) if inventory.seeds_purchase.updated_at else "N/A",
            }

            # Add documents related to seeds purchase
            seeds_documents = MyseedsDocuments.objects.filter(seeds=inventory.seeds_purchase)
            for doc in seeds_documents:
                file_type = doc.file_type.get_translated_value("name", language_code) if doc.file_type else "Unknown"
                file_type_id = doc.file_type.id if doc.file_type else None
                document_data = {
                    'id': doc.id,
                    'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
                }

                # Group documents by file_type
                if file_type not in seeds_data.get('documents', {}):
                    seeds_data['documents'] = {}
                if file_type not in seeds_data['documents']:
                    seeds_data['documents'][file_type] = {
                        'id': file_type_id,
                        'name': file_type,
                        'documents': []
                    }
                seeds_data['documents'][file_type]['documents'].append(document_data)

            # Add to the response data
            response_data['seeds_purchase'].append(seeds_data)

        # Crop Details (from MyCrop)
        if inventory.crop:
            crop_data = {
                'id': inventory.crop.id,
                'crop_name': inventory.crop.crop.name,
                'land': inventory.crop.land.name,
                'img': request.build_absolute_uri(f'/SuperAdmin{inventory.crop.crop.img.url}' if inventory.crop.crop.img else inventory.crop.crop.img.url) if inventory.crop.crop.img else "",
            }

            # Append crop data to response_data['crop']
            response_data['crop'].append(crop_data)

        # Seeds Consumption Details (from MyInventory)
        seeds_consumption_data = {
            'id': inventory.id,
            'quantity_utilized': str(inventory.quantity_utilized) if inventory.quantity_utilized else "0.00",
            'available_quans': str(inventory.available_quans) if inventory.available_quans else "0.00",
            'date_of_consumption': str(inventory.date_of_consumption) if inventory.date_of_consumption else "N/A",
            'description': inventory.get_translated_value("description", language_code) if inventory.description else "N/A",
            'status': inventory.status,
            'created_at': str(inventory.created_at) if inventory.created_at else "N/A",
            'updated_at': str(inventory.updated_at) if inventory.updated_at else "N/A",
            'farmer': {
                'id': inventory.farmer.id if inventory.farmer else None,
                'name': inventory.farmer.get_translated_value("name", language_code) if inventory.farmer else "Unknown",
            },
            'documents': {}
        }

        # Add crop data to seeds_consumption_data
        if inventory.crop:
            seeds_consumption_data['crop'] = {
                'id': inventory.crop.id,
                'crop_name': inventory.crop.crop.name,
                'land': inventory.crop.land.name,
                'img': request.build_absolute_uri(f'/SuperAdmin{inventory.crop.crop.img.url}' if inventory.crop.crop.img else inventory.crop.crop.img.url) if inventory.crop.crop.img else "",
            }

        # Add documents related to inventory (seeds consumption)
        inventory_documents = MyInventoryDocuments.objects.filter(my_inventory=inventory)
        for doc in inventory_documents:
            file_type = doc.file_type.get_translated_value("name", language_code) if doc.file_type else "Unknown"
            file_type_id = doc.file_type.id if doc.file_type else None
            document_data = {
                'id': doc.id,
                'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
            }

            # Group documents by file_type
            if file_type not in seeds_consumption_data.get('documents', {}):
                seeds_consumption_data['documents'] = {}
            if file_type not in seeds_consumption_data['documents']:
                seeds_consumption_data['documents'][file_type] = {
                    'id': file_type_id,
                    'name': file_type,
                    'documents': []
                }
            seeds_consumption_data['documents'][file_type]['documents'].append(document_data)

        response_data['seeds_consumption'].append(seeds_consumption_data)

    return Response(response_data)


# @api_view(['GET'])
# def get_fertilizers_inventory_details(request, farmer_id, inventory_type_id, inventory_items_id):
#     # Fetch the farmer, inventory type, and inventory items
#     farmer = get_object_or_404(Farmer, id=farmer_id)
#     inventory_type = get_object_or_404(InventoryType, id=inventory_type_id)
#     inventory_items = get_object_or_404(InventoryItems, id=inventory_items_id)

#     # Filter fertilizers based on farmer, inventory type, and inventory items
#     fertilizers = MyFertilizers.objects.filter(
#         farmer=farmer,
#         inventory_type=inventory_type,
#         inventory_items=inventory_items
#     )

#     # Prepare response data
#     response_data = {
#         'fertilizers_purchase': [],
#         'fertilizers_consumption': []
#     }

#     # Iterate over the fertilizers to structure the response
#     for fertilizer in fertilizers:
#         # Fertilizers Purchase Details
#         fertilizers_data = {
#             'id': fertilizer.id,
#             'farmer': {
#                 'id': fertilizer.farmer.id if fertilizer.farmer else None,
#                 'name': fertilizer.farmer.name if fertilizer.farmer else "Unknown",
#             },
#             'vendor': {
#                 'id': fertilizer.vendor.id if fertilizer.vendor else None,
#                 'name': fertilizer.vendor.name if fertilizer.vendor else "Unknown",
#             },
#             'inventory_type': {
#                 'id': fertilizer.inventory_type.id if fertilizer.inventory_type else None,
#                 'name': fertilizer.inventory_type.name if fertilizer.inventory_type else "Unknown",
#             },
#             'inventory_category': {
#                 'id': fertilizer.inventory_category.id if fertilizer.inventory_category else None,
#                 'name': fertilizer.inventory_category.name if fertilizer.inventory_category else "Unknown",
#             },
#             'inventory_items': {
#                 'id': fertilizer.inventory_items.id if fertilizer.inventory_items else None,
#                 'name': fertilizer.inventory_items.name if fertilizer.inventory_items else "Unknown",
#             },
#             'quantity': str(fertilizer.quantity) if fertilizer.quantity else "0.00",
#             'quantity_unit': fertilizer.quantity_unit.name if fertilizer.quantity_unit else "Unknown",
#             'purchase_amount': str(fertilizer.purchase_amount) if fertilizer.purchase_amount else "0.00",
#             'description': fertilizer.description if fertilizer.description else "N/A",
#             'status': fertilizer.status,
#             'created_at': str(fertilizer.created_at) if fertilizer.created_at else "N/A",
#             'updated_at': str(fertilizer.updated_at) if fertilizer.updated_at else "N/A",
#         }

#         # Add documents related to fertilizers
#         fertilizers_documents = MyFertilizersDocuments.objects.filter(fertilizers=fertilizer)
#         for doc in fertilizers_documents:
#             file_type = doc.file_type.name if doc.file_type else "Unknown"
#             file_type_id = doc.file_type.id if doc.file_type else None
#             document_data = {
#                 'id': doc.id,
#                 'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
#             }

#             # Group documents by file_type
#             if file_type not in fertilizers_data.get('documents', {}):
#                 fertilizers_data['documents'] = {}
#             if file_type not in fertilizers_data['documents']:
#                 fertilizers_data['documents'][file_type] = {
#                     'id': file_type_id,
#                     'name': file_type,
#                     'documents': []
#                 }
#             fertilizers_data['documents'][file_type]['documents'].append(document_data)

#         # Add to the response data
#         response_data['fertilizers_purchase'].append(fertilizers_data)

#         # Fertilizers Consumption Details (use fields present in MyFertilizers)
#         fertilizers_consumption_data = {
#             'id': fertilizer.id,
#             'available_quans': str(fertilizer.available_quans) if fertilizer.available_quans else "0.00",
#             'date_of_consumption': str(fertilizer.date_of_consumption) if fertilizer.date_of_consumption else "N/A",
#             'description': fertilizer.description if fertilizer.description else "N/A",
#             'status': fertilizer.status,
#             'created_at': str(fertilizer.created_at) if fertilizer.created_at else "N/A",
#             'updated_at': str(fertilizer.updated_at) if fertilizer.updated_at else "N/A",
#             'farmer': {
#                 'id': fertilizer.farmer.id if fertilizer.farmer else None,
#                 'name': fertilizer.farmer.name if fertilizer.farmer else "Unknown",
#             },
#             'documents': {}
#         }

#         # Add documents related to fertilizer consumption
#         fertilizer_documents = MyFertilizersDocuments.objects.filter(fertilizers=fertilizer)
#         for doc in fertilizer_documents:
#             file_type = doc.file_type.name if doc.file_type else "Unknown"
#             file_type_id = doc.file_type.id if doc.file_type else None
#             document_data = {
#                 'id': doc.id,
#                 'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
#             }

#             # Group documents by file_type
#             if file_type not in fertilizers_consumption_data.get('documents', {}):
#                 fertilizers_consumption_data['documents'] = {}
#             if file_type not in fertilizers_consumption_data['documents']:
#                 fertilizers_consumption_data['documents'][file_type] = {
#                     'id': file_type_id,
#                     'name': file_type,
#                     'documents': []
#                 }
#             fertilizers_consumption_data['documents'][file_type]['documents'].append(document_data)

#         response_data['fertilizers_consumption'].append(fertilizers_consumption_data)

#     return Response(response_data)

# @api_view(['GET'])
# def get_fertilizers_inventory_details(request, farmer_id, inventory_type_id, inventory_items_id):
#     # Fetch the farmer, inventory type, and inventory items
#     farmer = get_object_or_404(Farmer, id=farmer_id)
#     inventory_type = get_object_or_404(InventoryType, id=inventory_type_id)
#     inventory_items = get_object_or_404(InventoryItems, id=inventory_items_id)

#     try:
#         user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
#         language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
#     except UserLanguagePreference.DoesNotExist:
#         language_code = 'en'


#     # Filter fertilizers based on farmer, inventory type, and inventory items
#     fertilizers = MyFertilizers.objects.filter(
#         farmer=farmer,
#         inventory_type=inventory_type,
#         inventory_items=inventory_items
#     )

#     # Prepare response data
#     response_data = {
#         'fertilizers_purchase': [],
#         'fertilizers_consumption': []
#     }

#     # Iterate over the fertilizers to structure the response
#     for fertilizer in fertilizers:
#         # Fertilizers Purchase Details
#         fertilizers_data = {
#             'id': fertilizer.id,
#             'farmer': {
#                 'id': fertilizer.farmer.id if fertilizer.farmer else None,
#                 'name': fertilizer.farmer.get_translated_value("name", language_code) if fertilizer.farmer else "Unknown",
#             },
#             'vendor': {
#                 'id': fertilizer.vendor.id if fertilizer.vendor else None,
#                 'name': fertilizer.vendor.get_translated_value("name", language_code) if fertilizer.vendor else "Unknown",
#             },
#             'inventory_type': {
#                 'id': fertilizer.inventory_type.id if fertilizer.inventory_type else None,
#                 'name': fertilizer.inventory_type.get_translated_value("name", language_code) if fertilizer.inventory_type else "Unknown",
#             },
#             'inventory_category': {
#                 'id': fertilizer.inventory_category.id if fertilizer.inventory_category else None,
#                 'name': fertilizer.inventory_category.get_translated_value("name", language_code) if fertilizer.inventory_category else "Unknown",
#             },
#             'inventory_items': {
#                 'id': fertilizer.inventory_items.id if fertilizer.inventory_items else None,
#                 'name': fertilizer.inventory_items.get_translated_value("name", language_code) if fertilizer.inventory_items else "Unknown",
#             },
#             'quantity': str(fertilizer.quantity) if fertilizer.quantity else "0.00",
#             'quantity_unit': fertilizer.quantity_unit.get_translated_value("name", language_code) if fertilizer.quantity_unit else "Unknown",
#             'purchase_amount': str(fertilizer.purchase_amount) if fertilizer.purchase_amount else "0.00",
#             'description': fertilizer.get_translated_value("description", language_code) if fertilizer.description else "N/A",
#             'status': fertilizer.status,
#             'created_at': str(fertilizer.created_at) if fertilizer.created_at else "N/A",
#             'updated_at': str(fertilizer.updated_at) if fertilizer.updated_at else "N/A",
#         }

#         # Add documents related to fertilizers
#         fertilizers_documents = MyFertilizersDocuments.objects.filter(fertilizers=fertilizer)
#         for doc in fertilizers_documents:
#             file_type = doc.file_type.get_translated_value("name", language_code) if doc.file_type else "Unknown"
#             file_type_id = doc.file_type.id if doc.file_type else None
#             document_data = {
#                 'id': doc.id,
#                 'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
#             }

#             # Group documents by file_type
#             if file_type not in fertilizers_data.get('documents', {}):
#                 fertilizers_data['documents'] = {}
#             if file_type not in fertilizers_data['documents']:
#                 fertilizers_data['documents'][file_type] = {
#                     'id': file_type_id,
#                     'name': file_type,
#                     'documents': []
#                 }
#             fertilizers_data['documents'][file_type]['documents'].append(document_data)

#         if fertilizer.crop:
#             fertilizers_data['crop'] = {
#                 'id': fertilizer.crop.id,
#                 'crop_name': fertilizer.crop.crop.name,
#                 'land': fertilizer.crop.land.name,
#                 'img': request.build_absolute_uri(f'/SuperAdmin{fertilizer.crop.crop.img.url}' if fertilizer.crop.crop.img else fertilizer.crop.crop.img.url) if fertilizer.crop.crop.img else "",
#             }

#         # Add to the response data
#         response_data['fertilizers_purchase'].append(fertilizers_data)

#         # Add to the response data
#         # response_data['fertilizers_purchase'].append(fertilizers_data)

#         # Fertilizers Consumption Details (use fields present in MyFertilizers)
#         fertilizers_consumption_data = {
#             'id': fertilizer.id,
#             'available_quans': str(fertilizer.available_quans) if fertilizer.available_quans else "0.00",
#             'date_of_consumption': str(fertilizer.date_of_consumption) if fertilizer.date_of_consumption else "N/A",
#             'description': fertilizer.get_translated_value("description", language_code) if fertilizer.description else "N/A",
#             'status': fertilizer.status,
#             'created_at': str(fertilizer.created_at) if fertilizer.created_at else "N/A",
#             'updated_at': str(fertilizer.updated_at) if fertilizer.updated_at else "N/A",
#             'farmer': {
#                 'id': fertilizer.farmer.id if fertilizer.farmer else None,
#                 'name': fertilizer.farmer.get_translated_value("name", language_code) if fertilizer.farmer else "Unknown",
#             },
#             'documents': {}
#         }

#         if fertilizer.crop:
#             fertilizers_consumption_data['crop'] = {
#                 'id': fertilizer.crop.id,
#                 'crop_name': fertilizer.crop.crop.name,
#                 'land': fertilizer.crop.land.name,
#                 'img': request.build_absolute_uri(f'/SuperAdmin{fertilizer.crop.crop.img.url}' if fertilizer.crop.crop.img else fertilizer.crop.crop.img.url) if fertilizer.crop.crop.img else "",
#             }

#         # Add documents related to fertilizer consumption
#         fertilizer_documents = MyFertilizersDocuments.objects.filter(fertilizers=fertilizer)
#         for doc in fertilizer_documents:
#             file_type = doc.file_type.get_translated_value("name", language_code) if doc.file_type else "Unknown"
#             file_type_id = doc.file_type.id if doc.file_type else None
#             document_data = {
#                 'id': doc.id,
#                 'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
#             }

#             # Group documents by file_type
#             if file_type not in fertilizers_consumption_data.get('documents', {}):
#                 fertilizers_consumption_data['documents'] = {}
#             if file_type not in fertilizers_consumption_data['documents']:
#                 fertilizers_consumption_data['documents'][file_type] = {
#                     'id': file_type_id,
#                     'name': file_type,
#                     'documents': []
#                 }
#             fertilizers_consumption_data['documents'][file_type]['documents'].append(document_data)

#         response_data['fertilizers_consumption'].append(fertilizers_consumption_data)

#     return Response(response_data)

@api_view(['GET'])
def get_fertilizers_inventory_details(request, farmer_id, inventory_type_id, inventory_items_id):
    # Fetch the farmer, inventory type, and inventory items
    farmer = get_object_or_404(Farmer, id=farmer_id,status=0)
    inventory_type = get_object_or_404(InventoryType, id=inventory_type_id,status=0)
    inventory_items = get_object_or_404(InventoryItems, id=inventory_items_id,status=0)

    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'


    # Filter fertilizers and inventory based on farmer, inventory type, and inventory items
    fertilizers = MyFertilizers.objects.filter(
        status__in=[0, 1],
        farmer=farmer,
        inventory_type=inventory_type,
        inventory_items=inventory_items
    )

    inventories = MyInventory.objects.filter(
        status__in=[0, 1],
        farmer=farmer,
        inventory_type=inventory_type,
        inventory_items=inventory_items
    )

    # Prepare response data
    response_data = {
        'fertilizers_purchase': [],
        'fertilizers_consumption': [],
        'inventory_details': []
    }

    # Process fertilizers
    for fertilizer in fertilizers:
        # Fertilizers Purchase Details
        fertilizers_data = {
            'id': fertilizer.id,
            'farmer': {
                'id': fertilizer.farmer.id if fertilizer.farmer else None,
                'name': fertilizer.farmer.get_translated_value("name", language_code) if fertilizer.farmer else "Unknown",
            },
            'vendor': {
                'id': fertilizer.vendor.id if fertilizer.vendor else None,
                'name': fertilizer.vendor.get_translated_value("name", language_code) if fertilizer.vendor else "Unknown",
            },
            'inventory_type': {
                'id': fertilizer.inventory_type.id if fertilizer.inventory_type else None,
                'name': fertilizer.inventory_type.get_translated_value("name", language_code) if fertilizer.inventory_type else "Unknown",
            },
            'inventory_category': {
                'id': fertilizer.inventory_category.id if fertilizer.inventory_category else None,
                'name': fertilizer.inventory_category.get_translated_value("name", language_code) if fertilizer.inventory_category else "Unknown",
            },
            'inventory_items': {
                'id': fertilizer.inventory_items.id if fertilizer.inventory_items else None,
                'name': fertilizer.inventory_items.get_translated_value("name", language_code) if fertilizer.inventory_items else "Unknown",
            },
            'quantity': str(fertilizer.quantity) if fertilizer.quantity else "0.00",
            'quantity_unit': fertilizer.quantity_unit.get_translated_value("name", language_code) if fertilizer.quantity_unit else "Unknown",
            'purchase_amount': str(fertilizer.purchase_amount) if fertilizer.purchase_amount else "0.00",
            'description': fertilizer.get_translated_value("description", language_code) if fertilizer.description else "N/A",
            'status': fertilizer.status,
            'created_at': str(fertilizer.created_at) if fertilizer.created_at else "N/A",
            'updated_at': str(fertilizer.updated_at) if fertilizer.updated_at else "N/A",
        }

        # Add documents related to fertilizers
        fertilizers_documents = MyFertilizersDocuments.objects.filter(fertilizers=fertilizer)
        for doc in fertilizers_documents:
            file_type = doc.file_type.get_translated_value("name", language_code) if doc.file_type else "Unknown"
            file_type_id = doc.file_type.id if doc.file_type else None
            document_data = {
                'id': doc.id,
                'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
            }

            # Group documents by file_type
            if file_type not in fertilizers_data.get('documents', {}):
                fertilizers_data['documents'] = {}
            if file_type not in fertilizers_data['documents']:
                fertilizers_data['documents'][file_type] = {
                    'id': file_type_id,
                    'name': file_type,
                    'documents': []
                }
            fertilizers_data['documents'][file_type]['documents'].append(document_data)

        # Add to the response data
        response_data['fertilizers_purchase'].append(fertilizers_data)

        # Fertilizers Consumption Details (use fields present in MyFertilizers)
        fertilizers_consumption_data = {
            'id': fertilizer.id,
            'available_quans': str(fertilizer.available_quans) if fertilizer.available_quans else "0.00",
            'date_of_consumption': str(fertilizer.date_of_consumption) if fertilizer.date_of_consumption else "N/A",
            'description': fertilizer.get_translated_value("description", language_code) if fertilizer.description else "N/A",
            'status': fertilizer.status,
            'created_at': str(fertilizer.created_at) if fertilizer.created_at else "N/A",
            'updated_at': str(fertilizer.updated_at) if fertilizer.updated_at else "N/A",
            'farmer': {
                'id': fertilizer.farmer.id if fertilizer.farmer else None,
                'name': fertilizer.farmer.get_translated_value("name", language_code) if fertilizer.farmer else "Unknown",
            },
            'documents': {}
        }

        # Add documents related to fertilizer consumption
        fertilizer_documents = MyFertilizersDocuments.objects.filter(fertilizers=fertilizer)
        for doc in fertilizer_documents:
            file_type = doc.file_type.get_translated_value("name", language_code) if doc.file_type else "Unknown"
            file_type_id = doc.file_type.id if doc.file_type else None
            document_data = {
                'id': doc.id,
                'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
            }

            # Group documents by file_type
            if file_type not in fertilizers_consumption_data.get('documents', {}):
                fertilizers_consumption_data['documents'] = {}
            if file_type not in fertilizers_consumption_data['documents']:
                fertilizers_consumption_data['documents'][file_type] = {
                    'id': file_type_id,
                    'name': file_type,
                    'documents': []
                }
            fertilizers_consumption_data['documents'][file_type]['documents'].append(document_data)

        response_data['fertilizers_consumption'].append(fertilizers_consumption_data)

    # Process inventories (using crop from MyInventory)
    for inventory in inventories:
        inventory_data = {
            'id': inventory.id,
            'farmer': {
                'id': inventory.farmer.id if inventory.farmer else None,
                'name': inventory.farmer.get_translated_value("name", language_code) if inventory.farmer else "Unknown",
            },
            'crop': {
                'id': inventory.crop.id if inventory.crop else None,
                'crop_name': inventory.crop.crop.name if inventory.crop else "Unknown",
                'land': inventory.crop.land.name if inventory.crop else "Unknown",
                'img': request.build_absolute_uri(f'/SuperAdmin{inventory.crop.crop.img.url}' if inventory.crop and inventory.crop.crop.img else "") if inventory.crop and inventory.crop.crop.img else "",
            },
            'inventory_type': {
                'id': inventory.inventory_type.id if inventory.inventory_type else None,
                'name': inventory.inventory_type.get_translated_value("name", language_code) if inventory.inventory_type else "Unknown",
            },
            'inventory_category': {
                'id': inventory.inventory_category.id if inventory.inventory_category else None,
                'name': inventory.inventory_category.get_translated_value("name", language_code) if inventory.inventory_category else "Unknown",
            },
            'inventory_items': {
                'id': inventory.inventory_items.id if inventory.inventory_items else None,
                'name': inventory.inventory_items.get_translated_value("name", language_code) if inventory.inventory_items else "Unknown",
            },
            'available_quans': str(inventory.available_quans) if inventory.available_quans else "0.00",
            'quantity_utilized': str(inventory.quantity_utilized) if inventory.quantity_utilized else "0.00",
            'description': inventory.get_translated_value("description", language_code) if inventory.description else "N/A",
            'status': inventory.status,
            'created_at': str(inventory.created_at) if inventory.created_at else "N/A",
            'updated_at': str(inventory.updated_at) if inventory.updated_at else "N/A",
        }

        # Add to the response data
        response_data['inventory_details'].append(inventory_data)

    return Response(response_data)


# @api_view(['GET'])
# def get_tools_inventory_details(request, farmer_id, inventory_type_id, inventory_items_id):
#     # Fetch the farmer, inventory type, and inventory items
#     farmer = get_object_or_404(Farmer, id=farmer_id)
#     inventory_type = get_object_or_404(InventoryType, id=inventory_type_id)
#     inventory_items = get_object_or_404(InventoryItems, id=inventory_items_id)

#     # Filter tools based on farmer, inventory type, and inventory items
#     tools = MyTools.objects.filter(
#         farmer=farmer,
#         inventory_type=inventory_type,
#         inventory_items=inventory_items
#     )

#     # Prepare response data
#     response_data = {
#         'tools_purchase': [],
#         'tools_consumption': []
#     }

#     # Iterate over the tools to structure the response
#     for tool in tools:
#         # Tools Purchase Details
#         tools_data = {
#             'id': tool.id,
#             'farmer': {
#                 'id': tool.farmer.id if tool.farmer else None,
#                 'name': tool.farmer.name if tool.farmer else "Unknown",
#             },
#             'vendor': {
#                 'id': tool.vendor.id if tool.vendor else None,
#                 'name': tool.vendor.name if tool.vendor else "Unknown",
#             },
#             'inventory_type': {
#                 'id': tool.inventory_type.id if tool.inventory_type else None,
#                 'name': tool.inventory_type.name if tool.inventory_type else "Unknown",
#             },
#             'inventory_category': {
#                 'id': tool.inventory_category.id if tool.inventory_category else None,
#                 'name': tool.inventory_category.name if tool.inventory_category else "Unknown",
#             },
#             'inventory_items': {
#                 'id': tool.inventory_items.id if tool.inventory_items else None,
#                 'name': tool.inventory_items.name if tool.inventory_items else "Unknown",
#             },
#             'quantity': str(tool.quantity) if tool.quantity else "0.00", 
#             'purchase_amount': str(tool.purchase_amount) if tool.purchase_amount else "0.00",
#             'description': tool.description if tool.description else "N/A",
#             'status': tool.status,
#             'created_at': str(tool.created_at) if tool.created_at else "N/A",
#             'updated_at': str(tool.updated_at) if tool.updated_at else "N/A",
#         }

#         # Add documents related to tools
#         tools_documents = MyToolsDocuments.objects.filter(tools=tool)
#         for doc in tools_documents:
#             file_type = doc.file_type.name if doc.file_type else "Unknown"
#             file_type_id = doc.file_type.id if doc.file_type else None
#             document_data = {
#                 'id': doc.id,
#                 'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
#             }

#             # Group documents by file_type
#             if file_type not in tools_data.get('documents', {}):
#                 tools_data['documents'] = {}
#             if file_type not in tools_data['documents']:
#                 tools_data['documents'][file_type] = {
#                     'id': file_type_id,
#                     'name': file_type,
#                     'documents': []
#                 }
#             tools_data['documents'][file_type]['documents'].append(document_data)

#         # Add to the response data
#         response_data['tools_purchase'].append(tools_data)

#         # Tools Consumption Details (use fields present in MyTools)
#         tools_consumption_data = {
#             'id': tool.id,
#             'available_quans': str(tool.available_quans) if tool.available_quans else "0.00",
#             # 'usage_hours': tool.usage_hours if tool.usage_hours else "Unknown",
#             'date_of_consumption': str(tool.date_of_consumption) if tool.date_of_consumption else "N/A",
#             'description': tool.description if tool.description else "N/A",
#             'status': tool.status,
#             'created_at': str(tool.created_at) if tool.created_at else "N/A",
#             'updated_at': str(tool.updated_at) if tool.updated_at else "N/A",
#             'farmer': {
#                 'id': tool.farmer.id if tool.farmer else None,
#                 'name': tool.farmer.name if tool.farmer else "Unknown",
#             },
#             'documents': {}
#         }

#         # Add documents related to tool consumption
#         tool_documents = MyToolsDocuments.objects.filter(tools=tool)
#         for doc in tool_documents:
#             file_type = doc.file_type.name if doc.file_type else "Unknown"
#             file_type_id = doc.file_type.id if doc.file_type else None
#             document_data = {
#                 'id': doc.id,
#                 'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
#             }

#             # Group documents by file_type
#             if file_type not in tools_consumption_data.get('documents', {}):
#                 tools_consumption_data['documents'] = {}
#             if file_type not in tools_consumption_data['documents']:
#                 tools_consumption_data['documents'][file_type] = {
#                     'id': file_type_id,
#                     'name': file_type,
#                     'documents': []
#                 }
#             tools_consumption_data['documents'][file_type]['documents'].append(document_data)

#         response_data['tools_consumption'].append(tools_consumption_data)

#     return Response(response_data)

# @api_view(['GET'])
# def get_tools_inventory_details(request, farmer_id, inventory_type_id, inventory_items_id):
#     # Fetch the farmer, inventory type, and inventory items
#     farmer = get_object_or_404(Farmer, id=farmer_id)
#     inventory_type = get_object_or_404(InventoryType, id=inventory_type_id)
#     inventory_items = get_object_or_404(InventoryItems, id=inventory_items_id)

#     try:
#         user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
#         language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
#     except UserLanguagePreference.DoesNotExist:
#         language_code = 'en'

#     # Filter tools based on farmer, inventory type, and inventory items
#     tools = MyTools.objects.filter(
#         farmer=farmer,
#         inventory_type=inventory_type,
#         inventory_items=inventory_items
#     )

#     # Prepare response data
#     response_data = {
#         'tools_purchase': [],
#         'tools_consumption': []
#     }

#     # Iterate over the tools to structure the response
#     for tool in tools:
#         # Tools Purchase Details
#         tools_data = {
#             'id': tool.id,
#             'farmer': {
#                 'id': tool.farmer.id if tool.farmer else None,
#                 'name': tool.farmer.get_translated_value("name", language_code) if tool.farmer else "Unknown",
#             },
#             'vendor': {
#                 'id': tool.vendor.id if tool.vendor else None,
#                 'name': tool.vendor.get_translated_value("name", language_code) if tool.vendor else "Unknown",
#             },
#             'inventory_type': {
#                 'id': tool.inventory_type.id if tool.inventory_type else None,
#                 'name': tool.inventory_type.get_translated_value("name", language_code) if tool.inventory_type else "Unknown",
#             },
#             'inventory_category': {
#                 'id': tool.inventory_category.id if tool.inventory_category else None,
#                 'name': tool.inventory_category.get_translated_value("name", language_code) if tool.inventory_category else "Unknown",
#             },
#             'inventory_items': {
#                 'id': tool.inventory_items.id if tool.inventory_items else None,
#                 'name': tool.inventory_items.get_translated_value("name", language_code) if tool.inventory_items else "Unknown",
#             },
#             'quantity': str(tool.quantity) if tool.quantity else "0.00", 
#             'purchase_amount': str(tool.purchase_amount) if tool.purchase_amount else "0.00",
#             'description': tool.get_translated_value("description", language_code) if tool.description else "N/A",
#             'status': tool.status,
#             'created_at': str(tool.created_at) if tool.created_at else "N/A",
#             'updated_at': str(tool.updated_at) if tool.updated_at else "N/A",
#         }

#         # Add documents related to tools
#         tools_documents = MyToolsDocuments.objects.filter(tools=tool)
#         for doc in tools_documents:
#             file_type = doc.file_type.get_translated_value("name", language_code) if doc.file_type else "Unknown"
#             file_type_id = doc.file_type.id if doc.file_type else None
#             document_data = {
#                 'id': doc.id,
#                 'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
#             }

#             # Group documents by file_type
#             if file_type not in tools_data.get('documents', {}):
#                 tools_data['documents'] = {}
#             if file_type not in tools_data['documents']:
#                 tools_data['documents'][file_type] = {
#                     'id': file_type_id,
#                     'name': file_type,
#                     'documents': []
#                 }
#             tools_data['documents'][file_type]['documents'].append(document_data)

#         # Add to the response data
#         response_data['tools_purchase'].append(tools_data)

#         # Tools Consumption Details (use fields present in MyTools)
#         tools_consumption_data = {
#             'id': tool.id,
#             'available_quans': str(tool.available_quans) if tool.available_quans else "0.00",
#             # 'usage_hours': tool.usage_hours if tool.usage_hours else "Unknown",
#             'date_of_consumption': str(tool.date_of_consumption) if tool.date_of_consumption else "N/A",
#             'description': tool.get_translated_value("description", language_code) if tool.description else "N/A",
#             'status': tool.status,
#             'created_at': str(tool.created_at) if tool.created_at else "N/A",
#             'updated_at': str(tool.updated_at) if tool.updated_at else "N/A",
#             'farmer': {
#                 'id': tool.farmer.id if tool.farmer else None,
#                 'name': tool.farmer.get_translated_value("name", language_code) if tool.farmer else "Unknown",
#             },
#             'documents': {}
#         }

#         # Add documents related to tool consumption
#         tool_documents = MyToolsDocuments.objects.filter(tools=tool)
#         for doc in tool_documents:
#             file_type = doc.file_type.get_translated_value("name", language_code) if doc.file_type else "Unknown"
#             file_type_id = doc.file_type.id if doc.file_type else None
#             document_data = {
#                 'id': doc.id,
#                 'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
#             }

#             # Group documents by file_type
#             if file_type not in tools_consumption_data.get('documents', {}):
#                 tools_consumption_data['documents'] = {}
#             if file_type not in tools_consumption_data['documents']:
#                 tools_consumption_data['documents'][file_type] = {
#                     'id': file_type_id,
#                     'name': file_type,
#                     'documents': []
#                 }
#             tools_consumption_data['documents'][file_type]['documents'].append(document_data)

#         response_data['tools_consumption'].append(tools_consumption_data)

#     return Response(response_data)

# @api_view(['GET'])
# def get_tools_inventory_details(request, farmer_id, inventory_type_id, inventory_items_id):
#     # Fetch the farmer, inventory type, and inventory items
#     farmer = get_object_or_404(Farmer, id=farmer_id, status=0)
#     inventory_type = get_object_or_404(InventoryType, id=inventory_type_id, status=0)
#     inventory_items = get_object_or_404(InventoryItems, id=inventory_items_id, status=0)

#     try:
#         user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
#         language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
#     except UserLanguagePreference.DoesNotExist:
#         language_code = 'en'

#     # Filter inventories based on farmer, inventory type, and inventory items
#     inventories = MyInventory.objects.filter(
#         farmer=farmer,
#         inventory_type=inventory_type,
#         inventory_items=inventory_items,
#         status__in=[0, 1]
#     )

#     # Prepare response data
#     response_data = {
#         'tools_purchase': [],  # Adjusted to 'tools_purchase' instead of 'seeds_purchase'
#         'crop': [],  # Adjusted to 'tools' instead of 'crop'
#         'tools_consumption': []  # Adjusted to 'tools_consumption' instead of 'seeds_consumption'
#     }

#     # Iterate over the inventories to structure the response
#     for inventory in inventories:
#         # Tools Purchase Details
#         if inventory.tool_purchase:  # Check if tools purchase exists
#             tools_data = {
#                 'id': inventory.tool_purchase.id if inventory.tool_purchase else None,
#                 'farmer': {
#                     'id': inventory.tool_purchase.farmer.id if inventory.tool_purchase.farmer else None,
#                     'name': inventory.tool_purchase.farmer.get_translated_value("name", language_code) if inventory.tool_purchase.farmer else "Unknown",
#                 },
#                 'vendor': {
#                     'id': inventory.tool_purchase.vendor.id if inventory.tool_purchase.vendor else None,
#                     'name': inventory.tool_purchase.vendor.get_translated_value("name", language_code) if inventory.tool_purchase.vendor else "Unknown",
#                 },
#                 'inventory_type': {
#                     'id': inventory.tool_purchase.inventory_type.id if inventory.tool_purchase.inventory_type else None,
#                     'name': inventory.tool_purchase.inventory_type.get_translated_value("name", language_code) if inventory.tool_purchase.inventory_type else "Unknown",
#                 },
#                 'inventory_category': {
#                     'id': inventory.tool_purchase.inventory_category.id if inventory.tool_purchase.inventory_category else None,
#                     'name': inventory.tool_purchase.inventory_category.get_translated_value("name", language_code) if inventory.tool_purchase.inventory_category else "Unknown",
#                 },
#                 'inventory_items': {
#                     'id': inventory.tool_purchase.inventory_items.id if inventory.tool_purchase.inventory_items else None,
#                     'name': inventory.tool_purchase.inventory_items.get_translated_value("name", language_code) if inventory.tool_purchase.inventory_items else "Unknown",
#                 },
#                 'quantity': str(inventory.tool_purchase.quantity) if inventory.tool_purchase.quantity else "0.00",
#                 # 'quantity_unit': inventory.tool_purchase.quantity_unit.get_translated_value("name", language_code) if inventory.tool_purchase.quantity_unit else "Unknown",
#                 'purchase_amount': str(inventory.tool_purchase.purchase_amount) if inventory.tool_purchase.purchase_amount else "0.00",
#                 'description': inventory.tool_purchase.get_translated_value("description", language_code) if inventory.tool_purchase.description else "N/A",
#                 'status': inventory.tool_purchase.status,
#                 'created_at': str(inventory.tool_purchase.created_at) if inventory.tool_purchase.created_at else "N/A",
#                 'updated_at': str(inventory.tool_purchase.updated_at) if inventory.tool_purchase.updated_at else "N/A",
#             }

#             # Add documents related to tools purchase
#             tools_documents = MyToolsDocuments.objects.filter(tools=inventory.tool_purchase)
#             for doc in tools_documents:
#                 file_type = doc.file_type.get_translated_value("name", language_code) if doc.file_type else "Unknown"
#                 file_type_id = doc.file_type.id if doc.file_type else None
#                 document_data = {
#                     'id': doc.id,
#                     'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
#                 }

#                 # Group documents by file_type
#                 if file_type not in tools_data.get('documents', {}):
#                     tools_data['documents'] = {}
#                 if file_type not in tools_data['documents']:
#                     tools_data['documents'][file_type] = {
#                         'id': file_type_id,
#                         'name': file_type,
#                         'documents': []
#                     }
#                 tools_data['documents'][file_type]['documents'].append(document_data)

#             # Add to the response data
#             response_data['tools_purchase'].append(tools_data)

#         # Tools Details (from MyTools)
#         if inventory.crop:
#             tools_data = {
#                 'id': inventory.crop.id,
#                 'crop_name': inventory.crop.crop,  # Adjusted to 'tool_name' instead of 'crop_name'
#                 'land': inventory.crop.land.name,  # Assuming tools are linked to land in a similar way as crops
#                 'img': request.build_absolute_uri(f'/SuperAdmin{inventory.crop.crop.img.url}' if inventory.crop.crop.img else ""),
#             }

#             # Append tools data to response_data['tools']
#             response_data['crop'].append(tools_data)

#         # Tools Consumption Details (from MyInventory)
#         tools_consumption_data = {
#             'id': inventory.id,
#             'quantity_utilized': str(inventory.quantity_utilized) if inventory.quantity_utilized else "0.00",
#             'available_quans': str(inventory.available_quans) if inventory.available_quans else "0.00",
#             'date_of_consumption': str(inventory.date_of_consumption) if inventory.date_of_consumption else "N/A",
#             'description': inventory.get_translated_value("description", language_code) if inventory.description else "N/A",
#             'status': inventory.status,
#             'created_at': str(inventory.created_at) if inventory.created_at else "N/A",
#             'updated_at': str(inventory.updated_at) if inventory.updated_at else "N/A",
#             'farmer': {
#                 'id': inventory.farmer.id if inventory.farmer else None,
#                 'name': inventory.farmer.get_translated_value("name", language_code) if inventory.farmer else "Unknown",
#             },
#             'documents': {}
#         }

#         # Add tools data to tools_consumption_data
#         if inventory.crop:
#             tools_consumption_data['tools'] = {
#                 'id': inventory.crop.id,
#                 'crop_name': inventory.crop.crop,  # Adjusted to 'tool_name' instead of 'crop_name'
#                 'land': inventory.crop.land.name,  # Assuming tools are linked to land in a similar way as crops
#                 'img': request.build_absolute_uri(f'/SuperAdmin{inventory.crop.crop.img.url}' if inventory.crop.crop.img else ""),
#             }

#         # Add documents related to tools consumption
#         inventory_documents = MyInventoryDocuments.objects.filter(my_inventory=inventory)
#         for doc in inventory_documents:
#             file_type = doc.file_type.get_translated_value("name", language_code) if doc.file_type else "Unknown"
#             file_type_id = doc.file_type.id if doc.file_type else None
#             document_data = {
#                 'id': doc.id,
#                 'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
#             }

#             # Group documents by file_type
#             if file_type not in tools_consumption_data.get('documents', {}):
#                 tools_consumption_data['documents'] = {}
#             if file_type not in tools_consumption_data['documents']:
#                 tools_consumption_data['documents'][file_type] = {
#                     'id': file_type_id,
#                     'name': file_type,
#                     'documents': []
#                 }
#             tools_consumption_data['documents'][file_type]['documents'].append(document_data)

#         response_data['tools_consumption'].append(tools_consumption_data)

#     return Response(response_data)

@api_view(['GET'])
def get_tools_inventory_details(request, farmer_id, inventory_type_id, inventory_items_id):
    # Fetch the farmer, inventory type, and inventory items
    farmer = get_object_or_404(Farmer, id=farmer_id, status=0)
    inventory_type = get_object_or_404(InventoryType, id=inventory_type_id, status=0)
    inventory_items = get_object_or_404(InventoryItems, id=inventory_items_id, status=0)

    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'

    # Filter inventories based on farmer, inventory type, and inventory items
    inventories = MyInventory.objects.filter(
        farmer=farmer,
        inventory_type=inventory_type,
        inventory_items=inventory_items,
        status__in=[0, 1]
    )

    # Prepare response data
    response_data = {
        'tools_purchase': [],
        'tools': [],
        'tools_consumption': []
    }

    # Iterate over the inventories to structure the response
    for inventory in inventories:
        # Tools Purchase Details
        if inventory.tool_purchase:  # Check if tools purchase exists
            tools_data = {
                'id': inventory.tool_purchase.id if inventory.tool_purchase else None,
                'farmer': {
                    'id': inventory.tool_purchase.farmer.id if inventory.tool_purchase.farmer else None,
                    'name': inventory.tool_purchase.farmer.get_translated_value("name", language_code) if inventory.tool_purchase.farmer else "Unknown",
                },
                'vendor': {
                    'id': inventory.tool_purchase.vendor.id if inventory.tool_purchase.vendor else None,
                    'name': inventory.tool_purchase.vendor.get_translated_value("name", language_code) if inventory.tool_purchase.vendor else "Unknown",
                },
                'inventory_type': {
                    'id': inventory.tool_purchase.inventory_type.id if inventory.tool_purchase.inventory_type else None,
                    'name': inventory.tool_purchase.inventory_type.get_translated_value("name", language_code) if inventory.tool_purchase.inventory_type else "Unknown",
                },
                'inventory_category': {
                    'id': inventory.tool_purchase.inventory_category.id if inventory.tool_purchase.inventory_category else None,
                    'name': inventory.tool_purchase.inventory_category.get_translated_value("name", language_code) if inventory.tool_purchase.inventory_category else "Unknown",
                },
                'inventory_items': {
                    'id': inventory.tool_purchase.inventory_items.id if inventory.tool_purchase.inventory_items else None,
                    'name': inventory.tool_purchase.inventory_items.get_translated_value("name", language_code) if inventory.tool_purchase.inventory_items else "Unknown",
                },
                'quantity': str(inventory.tool_purchase.quantity) if inventory.tool_purchase.quantity else "0.00",
                'purchase_amount': str(inventory.tool_purchase.purchase_amount) if inventory.tool_purchase.purchase_amount else "0.00",
                'description': inventory.tool_purchase.get_translated_value("description", language_code) if inventory.tool_purchase.description else "N/A",
                'status': inventory.tool_purchase.status,
                'created_at': str(inventory.tool_purchase.created_at) if inventory.tool_purchase.created_at else "N/A",
                'updated_at': str(inventory.tool_purchase.updated_at) if inventory.tool_purchase.updated_at else "N/A",
            }

            # Add documents related to tools purchase
            tools_documents = MyToolsDocuments.objects.filter(tools=inventory.tool_purchase)
            for doc in tools_documents:
                file_type = doc.file_type.get_translated_value("name", language_code) if doc.file_type else "Unknown"
                file_type_id = doc.file_type.id if doc.file_type else None
                document_data = {
                    'id': doc.id,
                    'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
                }

                # Group documents by file_type
                if file_type not in tools_data.get('documents', {}):
                    tools_data['documents'] = {}
                if file_type not in tools_data['documents']:
                    tools_data['documents'][file_type] = {
                        'id': file_type_id,
                        'name': file_type,
                        'documents': []
                    }
                tools_data['documents'][file_type]['documents'].append(document_data)

            # Add to the response data
            response_data['tools_purchase'].append(tools_data)

        # Tools Details (from MyTools)
        if inventory.crop:  # Adjusted to tools
            tools_data = {
                'id': inventory.crop.id,
                'tool_name': inventory.crop.crop.name if inventory.crop.crop else "Unknown",  # Adjusted to 'tool_name'
                'land': inventory.crop.land.name if inventory.crop.land else "Unknown",  # Assuming tools are linked to land in a similar way as crops
                'img': request.build_absolute_uri(f'/SuperAdmin{inventory.crop.crop.img.url}' if inventory.crop.crop.img else ""),
            }

            # Append tools data to response_data['tools']
            response_data['tools'].append(tools_data)

        # Tools Consumption Details (from MyInventory)
        tools_consumption_data = {
            'id': inventory.id,
            'quantity_utilized': str(inventory.quantity_utilized) if inventory.quantity_utilized else "0.00",
            'available_quans': str(inventory.available_quans) if inventory.available_quans else "0.00",
            'date_of_consumption': str(inventory.date_of_consumption) if inventory.date_of_consumption else "N/A",
            'description': inventory.get_translated_value("description", language_code) if inventory.description else "N/A",
            'status': inventory.status,
            'created_at': str(inventory.created_at) if inventory.created_at else "N/A",
            'updated_at': str(inventory.updated_at) if inventory.updated_at else "N/A",
            'farmer': {
                'id': inventory.farmer.id if inventory.farmer else None,
                'name': inventory.farmer.get_translated_value("name", language_code) if inventory.farmer else "Unknown",
            },
            'documents': {}
        }

        # Add tools data to tools_consumption_data
        if inventory.crop:  # Adjusted to tools
            tools_consumption_data['tools'] = {
                'id': inventory.crop.id,
                'tool_name': inventory.crop.crop.name if inventory.crop.crop else "Unknown",  # Adjusted to 'tool_name'
                'land': inventory.crop.land.name if inventory.crop.land else "Unknown",  # Assuming tools are linked to land in a similar way as crops
                'img': request.build_absolute_uri(f'/SuperAdmin{inventory.crop.crop.img.url}' if inventory.crop.crop.img else ""),
            }

        # Add documents related to tools consumption
        inventory_documents = MyInventoryDocuments.objects.filter(my_inventory=inventory)
        for doc in inventory_documents:
            file_type = doc.file_type.get_translated_value("name", language_code) if doc.file_type else "Unknown"
            file_type_id = doc.file_type.id if doc.file_type else None
            document_data = {
                'id': doc.id,
                'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
            }

            # Group documents by file_type
            if file_type not in tools_consumption_data.get('documents', {}):
                tools_consumption_data['documents'] = {}
            if file_type not in tools_consumption_data['documents']:
                tools_consumption_data['documents'][file_type] = {
                    'id': file_type_id,
                    'name': file_type,
                    'documents': []
                }
            tools_consumption_data['documents'][file_type]['documents'].append(document_data)

        response_data['tools_consumption'].append(tools_consumption_data)

    return Response(response_data)



# @api_view(['GET'])
# def get_vehicle_inventory_details(request, farmer_id, inventory_type_id, inventory_items_id):
#     # Fetch the farmer, inventory type, and inventory items
#     farmer = get_object_or_404(Farmer, id=farmer_id)
#     inventory_type = get_object_or_404(InventoryType, id=inventory_type_id)
#     inventory_items = get_object_or_404(InventoryItems, id=inventory_items_id)

#     # Filter vehicles based on farmer, inventory type, and inventory items
#     vehicles = MyVehicle.objects.filter(
#         farmer=farmer,
#         inventory_type=inventory_type,
#         inventory_items=inventory_items
#     )

#     # Prepare response data
#     response_data = {
#         'vehicle_purchase': [],
#         'vehicle_consumption': []
#     }

#     # Iterate over the vehicles to structure the response
#     for vehicle in vehicles:
#         # Vehicle Purchase Details
#         vehicle_data = {
#             'id': vehicle.id,
#             'farmer': {
#                 'id': vehicle.farmer.id if vehicle.farmer else None,
#                 'name': vehicle.farmer.name if vehicle.farmer else "Unknown",
#             },
#             'vendor': {
#                 'id': vehicle.vendor.id if vehicle.vendor else None,
#                 'name': vehicle.vendor.name if vehicle.vendor else "Unknown",
#             },
#             'inventory_type': {
#                 'id': vehicle.inventory_type.id if vehicle.inventory_type else None,
#                 'name': vehicle.inventory_type.name if vehicle.inventory_type else "Unknown",
#             },
#             'inventory_category': {
#                 'id': vehicle.inventory_category.id if vehicle.inventory_category else None,
#                 'name': vehicle.inventory_category.name if vehicle.inventory_category else "Unknown",
#             },
#             'inventory_items': {
#                 'id': vehicle.inventory_items.id if vehicle.inventory_items else None,
#                 'name': vehicle.inventory_items.name if vehicle.inventory_items else "Unknown",
#             },
#             'register_number': vehicle.register_number if vehicle.register_number else "Unknown",
#             'owner_name': vehicle.owner_name if vehicle.owner_name else "Unknown",
#             'date_of_registration': str(vehicle.date_of_registration) if vehicle.date_of_registration else "Unknown",
#             'engine_number': vehicle.engine_number if vehicle.engine_number else "Unknown",
#             'chasis_number': vehicle.chasis_number if vehicle.chasis_number else "Unknown",
#             'running_kilometer': str(vehicle.running_kilometer) if vehicle.running_kilometer else "0.00",
#             'fuel_capacity': str(vehicle.fuel_capacity) if vehicle.fuel_capacity else "0.00",
#             'average_mileage': str(vehicle.average_mileage) if vehicle.average_mileage else "0.00",
#             'purchase_amount': str(vehicle.purchase_amount) if vehicle.purchase_amount else "0.00",
#             'insurance': vehicle.insurance,
#             'company_name': vehicle.company_name if vehicle.company_name else "Unknown",
#             'insurance_no': vehicle.insurance_no if vehicle.insurance_no else "Unknown",
#             'insurance_amount': str(vehicle.insurance_amount) if vehicle.insurance_amount else "0.00",
#             'insurance_start_date': str(vehicle.insurance_start_date) if vehicle.insurance_start_date else "Unknown",
#             'insurance_end_date': str(vehicle.insurance_end_date) if vehicle.insurance_end_date else "Unknown",
#             'insurance_renewal_date': str(vehicle.insurance_renewal_date) if vehicle.insurance_renewal_date else "Unknown",
#             'description': vehicle.description if vehicle.description else "N/A",
#             'status': vehicle.status,
#             'created_at': str(vehicle.created_at) if vehicle.created_at else "N/A",
#             'updated_at': str(vehicle.updated_at) if vehicle.updated_at else "N/A",
#         }

#         # Add documents related to vehicle
#         vehicle_documents = MyVehicleDocuments.objects.filter(vehicle=vehicle)
#         for doc in vehicle_documents:
#             file_type = doc.file_type.name if doc.file_type else "Unknown"
#             file_type_id = doc.file_type.id if doc.file_type else None
#             document_data = {
#                 'id': doc.id,
#                 'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
#             }

#             # Group documents by file_type
#             if file_type not in vehicle_data.get('documents', {}):
#                 vehicle_data['documents'] = {}
#             if file_type not in vehicle_data['documents']:
#                 vehicle_data['documents'][file_type] = {
#                     'id': file_type_id,
#                     'name': file_type,
#                     'documents': []
#                 }
#             vehicle_data['documents'][file_type]['documents'].append(document_data)

#         # Add to the response data
#         response_data['vehicle_purchase'].append(vehicle_data)

#         # Vehicle Consumption Details (use fields present in MyVehicle)
#         vehicle_consumption_data = {
#             'id': vehicle.id,
#             'available_quans': vehicle.available_quans if vehicle.available_quans else "Unknown",
#             'date_of_consumption': str(vehicle.date_of_consumption) if vehicle.date_of_consumption else "N/A",
#             'description': vehicle.description if vehicle.description else "N/A",
#             'status': vehicle.status,
#             'created_at': str(vehicle.created_at) if vehicle.created_at else "N/A",
#             'updated_at': str(vehicle.updated_at) if vehicle.updated_at else "N/A",
#             'farmer': {
#                 'id': vehicle.farmer.id if vehicle.farmer else None,
#                 'name': vehicle.farmer.name if vehicle.farmer else "Unknown",
#             },
#             'documents': {}
#         }

#         # Add documents related to vehicle consumption
#         for doc in vehicle_documents:
#             file_type = doc.file_type.name if doc.file_type else "Unknown"
#             file_type_id = doc.file_type.id if doc.file_type else None
#             document_data = {
#                 'id': doc.id,
#                 'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
#             }

#             # Group documents by file_type
#             if file_type not in vehicle_consumption_data.get('documents', {}):
#                 vehicle_consumption_data['documents'] = {}
#             if file_type not in vehicle_consumption_data['documents']:
#                 vehicle_consumption_data['documents'][file_type] = {
#                     'id': file_type_id,
#                     'name': file_type,
#                     'documents': []
#                 }
#             vehicle_consumption_data['documents'][file_type]['documents'].append(document_data)

#         response_data['vehicle_consumption'].append(vehicle_consumption_data)

#     return Response(response_data)
 

# @api_view(['GET'])
# def get_vehicle_inventory_details(request, farmer_id, inventory_type_id, inventory_items_id):
#     # Fetch the farmer, inventory type, and inventory items
#     farmer = get_object_or_404(Farmer, id=farmer_id,status=0)
#     inventory_type = get_object_or_404(InventoryType, id=inventory_type_id,status=0)
#     inventory_items = get_object_or_404(InventoryItems, id=inventory_items_id,status=0)

#     try:
#         user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
#         language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'  # Fallback to 'en' if no language code
#     except UserLanguagePreference.DoesNotExist:
#         language_code = 'en'


#     # Filter vehicles based on farmer, inventory type, and inventory items
#     vehicles = MyVehicle.objects.filter(
#         farmer=farmer,
#         inventory_type=inventory_type,
#         inventory_items=inventory_items,
#         status__in=[0, 1]
#     )

#     # Prepare response data
#     response_data = {
#         'vehicle_purchase': [],
#         'vehicle_consumption': [], 
#     }

#     # Iterate over the vehicles to structure the response
#     for vehicle in vehicles:
#         # Vehicle Purchase Details
#         vehicle_data = {
#             'id': vehicle.id,
#             'farmer': {
#                 'id': vehicle.farmer.id if vehicle.farmer else None,
#                 'name': vehicle.farmer.get_translated_value("name", language_code) if vehicle.farmer else "Unknown",
#             },
#             'vendor': {
#                 'id': vehicle.vendor.id if vehicle.vendor else None,
#                 'name': vehicle.vendor.get_translated_value("name", language_code) if vehicle.vendor else "Unknown",
#             },
#             'inventory_type': {
#                 'id': vehicle.inventory_type.id if vehicle.inventory_type else None,
#                 'name': vehicle.inventory_type.get_translated_value("name", language_code) if vehicle.inventory_type else "Unknown",
#             },
#             'inventory_category': {
#                 'id': vehicle.inventory_category.id if vehicle.inventory_category else None,
#                 'name': vehicle.inventory_category.get_translated_value("name", language_code) if vehicle.inventory_category else "Unknown",
#             },
#             'inventory_items': {
#                 'id': vehicle.inventory_items.id if vehicle.inventory_items else None,
#                 'name': vehicle.inventory_items.get_translated_value("name", language_code) if vehicle.inventory_items else "Unknown",
#             },
#             'register_number': vehicle.register_number if vehicle.register_number else "Unknown",
#             'owner_name': vehicle.get_translated_value("owner_name", language_code) if vehicle.owner_name else "Unknown",
#             'date_of_registration': str(vehicle.date_of_registration) if vehicle.date_of_registration else "Unknown",
#             'engine_number': vehicle.engine_number if vehicle.engine_number else "Unknown",
#             'chasis_number': vehicle.chasis_number if vehicle.chasis_number else "Unknown",
#             'running_kilometer': str(vehicle.running_kilometer) if vehicle.running_kilometer else "0.00",
#             'fuel_capacity': str(vehicle.fuel_capacity) if vehicle.fuel_capacity else "0.00",
#             'average_mileage': str(vehicle.average_mileage) if vehicle.average_mileage else "0.00",
#             'purchase_amount': str(vehicle.purchase_amount) if vehicle.purchase_amount else "0.00",
#             'insurance': vehicle.insurance,
#             'company_name': vehicle.get_translated_value("company_name", language_code) if vehicle.company_name else "Unknown",
#             'insurance_no': vehicle.insurance_no if vehicle.insurance_no else "Unknown",
#             'insurance_amount': str(vehicle.insurance_amount) if vehicle.insurance_amount else "0.00",
#             'insurance_start_date': str(vehicle.insurance_start_date) if vehicle.insurance_start_date else "Unknown",
#             'insurance_end_date': str(vehicle.insurance_end_date) if vehicle.insurance_end_date else "Unknown",
#             'insurance_renewal_date': str(vehicle.insurance_renewal_date) if vehicle.insurance_renewal_date else "Unknown",
#             'description': vehicle.get_translated_value("description", language_code) if vehicle.description else "N/A",
#             'status': vehicle.status,
#             'created_at': str(vehicle.created_at) if vehicle.created_at else "N/A",
#             'updated_at': str(vehicle.updated_at) if vehicle.updated_at else "N/A",
#         }

#         # Add documents related to vehicle
#         vehicle_documents = MyVehicleDocuments.objects.filter(vehicle=vehicle)
#         for doc in vehicle_documents:
#             file_type = doc.file_type.get_translated_value("name", language_code) if doc.file_type else "Unknown"
#             file_type_id = doc.file_type.id if doc.file_type else None
#             document_data = {
#                 'id': doc.id,
#                 'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
#             }

#             # Group documents by file_type
#             if file_type not in vehicle_data.get('documents', {}):
#                 vehicle_data['documents'] = {}
#             if file_type not in vehicle_data['documents']:
#                 vehicle_data['documents'][file_type] = {
#                     'id': file_type_id,
#                     'name': file_type,
#                     'documents': []
#                 }
#             vehicle_data['documents'][file_type]['documents'].append(document_data)

#         # Add to the response data
#         response_data['vehicle_purchase'].append(vehicle_data)

#         # Vehicle Consumption Details (use fields present in MyVehicle)
#         vehicle_consumption_data = {
#             'id': vehicle.id,
#             'available_quans': vehicle.available_quans if vehicle.available_quans else "Unknown",
#             'date_of_consumption': str(vehicle.date_of_consumption) if vehicle.date_of_consumption else "N/A",
#             'description': vehicle.get_translated_value("description", language_code) if vehicle.description else "N/A",
#             'status': vehicle.status,
#             'created_at': str(vehicle.created_at) if vehicle.created_at else "N/A",
#             'updated_at': str(vehicle.updated_at) if vehicle.updated_at else "N/A",
#             'farmer': {
#                 'id': vehicle.farmer.id if vehicle.farmer else None,
#                 'name': vehicle.farmer.get_translated_value("name", language_code) if vehicle.farmer else "Unknown",
#             },
#             'documents': {}
#         }

#         # Add documents related to vehicle consumption
#         for doc in vehicle_documents:
#             file_type = doc.file_type.get_translated_value("name", language_code) if doc.file_type else "Unknown"
#             file_type_id = doc.file_type.id if doc.file_type else None
#             document_data = {
#                 'id': doc.id,
#                 'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
#             }

#             # Group documents by file_type
#             if file_type not in vehicle_consumption_data.get('documents', {}):
#                 vehicle_consumption_data['documents'] = {}
#             if file_type not in vehicle_consumption_data['documents']:
#                 vehicle_consumption_data['documents'][file_type] = {
#                     'id': file_type_id,
#                     'name': file_type,
#                     'documents': []
#                 }
#             vehicle_consumption_data['documents'][file_type]['documents'].append(document_data)

#         response_data['vehicle_consumption'].append(vehicle_consumption_data)

#     return Response(response_data)
 
# @api_view(['GET'])
# def get_vehicle_inventory_details(request, farmer_id, inventory_type_id, inventory_items_id):
#     farmer = get_object_or_404(Farmer, id=farmer_id, status=0)
#     inventory_type = get_object_or_404(InventoryType, id=inventory_type_id, status=0)
#     inventory_items = get_object_or_404(InventoryItems, id=inventory_items_id, status=0)

#     try:
#         user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
#         language_code = user_language_pref.language_code or 'en'
#     except UserLanguagePreference.DoesNotExist:
#         language_code = 'en'

#     vehicles = MyVehicle.objects.filter(
#         farmer=farmer,
#         inventory_type=inventory_type,
#         inventory_items=inventory_items,
#         status__in=[0, 1]
#     )

#     response_data = {
#         'vehicle_purchase': [],
#         'vehicle_consumption': [],
#         'crop': []
#     }

#     for vehicle in vehicles:
#         # --- Vehicle Purchase ---
#         vehicle_data = {
#             'id': vehicle.id,
#             'farmer': {
#                 'id': vehicle.farmer.id if vehicle.farmer else None,
#                 'name': vehicle.farmer.get_translated_value("name", language_code) if vehicle.farmer else "Unknown",
#             },
#             'vendor': {
#                 'id': vehicle.vendor.id if vehicle.vendor else None,
#                 'name': vehicle.vendor.get_translated_value("name", language_code) if vehicle.vendor else "Unknown",
#             },
#             'inventory_type': {
#                 'id': vehicle.inventory_type.id if vehicle.inventory_type else None,
#                 'name': vehicle.inventory_type.get_translated_value("name", language_code) if vehicle.inventory_type else "Unknown",
#             },
#             'inventory_category': {
#                 'id': vehicle.inventory_category.id if vehicle.inventory_category else None,
#                 'name': vehicle.inventory_category.get_translated_value("name", language_code) if vehicle.inventory_category else "Unknown",
#             },
#             'inventory_items': {
#                 'id': vehicle.inventory_items.id if vehicle.inventory_items else None,
#                 'name': vehicle.inventory_items.get_translated_value("name", language_code) if vehicle.inventory_items else "Unknown",
#             },
#             'register_number': vehicle.register_number or "Unknown",
#             'owner_name': vehicle.get_translated_value("owner_name", language_code) if vehicle.owner_name else "Unknown",
#             'date_of_registration': str(vehicle.date_of_registration or "Unknown"),
#             'engine_number': vehicle.engine_number or "Unknown",
#             'chasis_number': vehicle.chasis_number or "Unknown",
#             'running_kilometer': str(vehicle.running_kilometer or "0.00"),
#             'fuel_capacity': str(vehicle.fuel_capacity or "0.00"),
#             'average_mileage': str(vehicle.average_mileage or "0.00"),
#             'purchase_amount': str(vehicle.purchase_amount or "0.00"),
#             'insurance': vehicle.insurance,
#             'company_name': vehicle.get_translated_value("company_name", language_code) if vehicle.company_name else "Unknown",
#             'insurance_no': vehicle.insurance_no or "Unknown",
#             'insurance_amount': str(vehicle.insurance_amount or "0.00"),
#             'insurance_start_date': str(vehicle.insurance_start_date or "Unknown"),
#             'insurance_end_date': str(vehicle.insurance_end_date or "Unknown"),
#             'insurance_renewal_date': str(vehicle.insurance_renewal_date or "Unknown"),
#             'description': vehicle.get_translated_value("description", language_code) if vehicle.description else "N/A",
#             'status': vehicle.status,
#             'created_at': str(vehicle.created_at or "N/A"),
#             'updated_at': str(vehicle.updated_at or "N/A"),
#             'documents': {}
#         }

#         # --- Vehicle Documents ---
#         vehicle_documents = MyVehicleDocuments.objects.filter(vehicle=vehicle)
#         for doc in vehicle_documents:
#             file_type = doc.file_type.get_translated_value("name", language_code) if doc.file_type else "Unknown"
#             file_type_id = doc.file_type.id if doc.file_type else None
#             document_data = {
#                 'id': doc.id,
#                 'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}') if doc.document else "",
#             }
#             if file_type not in vehicle_data['documents']:
#                 vehicle_data['documents'][file_type] = {
#                     'id': file_type_id,
#                     'name': file_type,
#                     'documents': []
#                 }
#             vehicle_data['documents'][file_type]['documents'].append(document_data)

#         response_data['vehicle_purchase'].append(vehicle_data)

#         # --- Vehicle Consumption ---
#         vehicle_consumption_data = {
#             'id': vehicle.id,
#             'available_quans': str(vehicle.available_quans or "Unknown"),
#             'date_of_consumption': str(vehicle.date_of_consumption or "N/A"),
#             'description': vehicle.get_translated_value("description", language_code) if vehicle.description else "N/A",
#             'status': vehicle.status,
#             'created_at': str(vehicle.created_at or "N/A"),
#             'updated_at': str(vehicle.updated_at or "N/A"),
#             'farmer': {
#                 'id': vehicle.farmer.id if vehicle.farmer else None,
#                 'name': vehicle.farmer.get_translated_value("name", language_code) if vehicle.farmer else "Unknown",
#             },
#             'documents': {}
#         }

#         # Reuse documents for consumption
#         for doc in vehicle_documents:
#             file_type = doc.file_type.get_translated_value("name", language_code) if doc.file_type else "Unknown"
#             file_type_id = doc.file_type.id if doc.file_type else None
#             document_data = {
#                 'id': doc.id,
#                 'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}') if doc.document else "",
#             }
#             if file_type not in vehicle_consumption_data['documents']:
#                 vehicle_consumption_data['documents'][file_type] = {
#                     'id': file_type_id,
#                     'name': file_type,
#                     'documents': []
#                 }
#             vehicle_consumption_data['documents'][file_type]['documents'].append(document_data)

#         response_data['vehicle_consumption'].append(vehicle_consumption_data)

#         # --- Crop Details (if vehicle is linked to a crop) ---
#         if hasattr(vehicle, 'crop') and vehicle.crop:
#             crop_data = {
#                 'id': vehicle.crop.id,
#                 'crop_name': vehicle.crop.crop.name,
#                 'land': vehicle.crop.land.name,
#                 'img': request.build_absolute_uri(f'/SuperAdmin{vehicle.crop.crop.img.url}') if vehicle.crop.crop.img else "",
#             }
#             response_data['crop'].append(crop_data)

#     return Response(response_data)

@api_view(['GET'])
def get_vehicle_inventory_details(request, farmer_id, inventory_type_id, inventory_items_id):
    farmer = get_object_or_404(Farmer, id=farmer_id, status=0)
    inventory_type = get_object_or_404(InventoryType, id=inventory_type_id, status=0)
    inventory_items = get_object_or_404(InventoryItems, id=inventory_items_id, status=0)

    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
        language_code = user_language_pref.language_code or 'en'
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'

    inventories = MyInventory.objects.filter(
        farmer=farmer,
        inventory_type=inventory_type,
        inventory_items=inventory_items,
        status__in=[0, 1]
    )

    response_data = {
        'vehicle_purchase': [],
        'vehicle_consumption': [],
        'crop': []
    }

    for vehicle in inventories:
        # --- Vehicle Purchase ---
        if vehicle.vehicle_purchase: 
            vehicle_data = {
                'id': vehicle.vehicle_purchase.id,
                'farmer': {
                    'id': vehicle.vehicle_purchase.farmer.id if vehicle.vehicle_purchase.farmer else None,
                    'name': vehicle.vehicle_purchase.farmer.get_translated_value("name", language_code) if vehicle.vehicle_purchase.farmer else "Unknown",
                },
                'vendor': {
                    'id': vehicle.vehicle_purchase.vendor.id if vehicle.vehicle_purchase.vendor else None,
                    'name': vehicle.vehicle_purchase.vendor.get_translated_value("name", language_code) if vehicle.vehicle_purchase.vendor else "Unknown",
                },
                'inventory_type': {
                    'id': vehicle.vehicle_purchase.inventory_type.id if vehicle.inventory_type else None,
                    'name': vehicle.vehicle_purchase.inventory_type.get_translated_value("name", language_code) if vehicle.vehicle_purchase.inventory_type else "Unknown",
                },
                'inventory_category': {
                    'id': vehicle.vehicle_purchase.inventory_category.id if vehicle.vehicle_purchase.inventory_category else None,
                    'name': vehicle.vehicle_purchase.inventory_category.get_translated_value("name", language_code) if vehicle.inventory_category else "Unknown",
                },
                'inventory_items': {
                    'id': vehicle.vehicle_purchase.inventory_items.id if vehicle.vehicle_purchase.inventory_items else None,
                    'name': vehicle.vehicle_purchase.inventory_items.get_translated_value("name", language_code) if vehicle.vehicle_purchase.inventory_items else "Unknown",
                },
                'register_number': vehicle.vehicle_purchase.register_number or "Unknown",
                'owner_name': vehicle.vehicle_purchase.get_translated_value("owner_name", language_code) if vehicle.vehicle_purchase.owner_name else "Unknown",
                'date_of_registration': str(vehicle.vehicle_purchase.date_of_registration or "Unknown"),
                'engine_number': vehicle.vehicle_purchase.engine_number or "Unknown",
                'chasis_number': vehicle.vehicle_purchase.chasis_number or "Unknown",
                'running_kilometer': str(vehicle.vehicle_purchase.running_kilometer or "0.00"),
                'fuel_capacity': str(vehicle.vehicle_purchase.fuel_capacity or "0.00"),
                'average_mileage': str(vehicle.vehicle_purchase.average_mileage or "0.00"),
                'purchase_amount': str(vehicle.vehicle_purchase.purchase_amount or "0.00"),
                'insurance': vehicle.vehicle_purchase.insurance,
                'company_name': vehicle.vehicle_purchase.get_translated_value("company_name", language_code) if vehicle.vehicle_purchase.company_name else "Unknown",
                'insurance_no': vehicle.vehicle_purchase.insurance_no or "Unknown",
                'insurance_amount': str(vehicle.vehicle_purchase.insurance_amount or "0.00"),
                'insurance_start_date': str(vehicle.vehicle_purchase.insurance_start_date or "Unknown"),
                'insurance_end_date': str(vehicle.vehicle_purchase.insurance_end_date or "Unknown"),
                'insurance_renewal_date': str(vehicle.vehicle_purchase.insurance_renewal_date or "Unknown"),
                'description': vehicle.vehicle_purchase.get_translated_value("description", language_code) if vehicle.vehicle_purchase.description else "N/A",
                'status': vehicle.vehicle_purchase.status,
                'created_at': str(vehicle.vehicle_purchase.created_at or "N/A"),
                'updated_at': str(vehicle.vehicle_purchase.updated_at or "N/A"),
                'documents': {}
            }

        # --- Vehicle Documents ---
        vehicle_documents = MyVehicleDocuments.objects.filter(vehicle=vehicle.vehicle_purchase)
        for doc in vehicle_documents:
            file_type = doc.file_type.get_translated_value("name", language_code) if doc.file_type else "Unknown"
            file_type_id = doc.file_type.id if doc.file_type else None
            document_data = {
                'id': doc.id,
                'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}') if doc.document else "",
            }
            if file_type not in vehicle_data['documents']:
                vehicle_data['documents'][file_type] = {
                    'id': file_type_id,
                    'name': file_type,
                    'documents': []
                }
            vehicle_data['documents'][file_type]['documents'].append(document_data)

        response_data['vehicle_purchase'].append(vehicle_data)

        if vehicle.crop:  # Adjusted to tools
            vehicle_data = {
                'id': vehicle.crop.id,
                'tool_name': vehicle.crop.crop.name if vehicle.crop.crop else "Unknown",  # Adjusted to 'tool_name'
                'land': vehicle.crop.land.name if vehicle.crop.land else "Unknown",  # Assuming tools are linked to land in a similar way as crops
                'img': request.build_absolute_uri(f'/SuperAdmin{vehicle.crop.crop.img.url}' if vehicle.crop.crop.img else ""),
            }

            # Append tools data to response_data['tools']
            response_data['crop'].append(vehicle_data)

        # --- Vehicle Consumption ---
        vehicle_consumption_data = {
            'id': vehicle.id,
            'available_quans': str(vehicle.available_quans or "Unknown"),
            'date_of_consumption': str(vehicle.date_of_consumption or "N/A"),
            'description': vehicle.get_translated_value("description", language_code) if vehicle.description else "N/A",
            'status': vehicle.status,
            'created_at': str(vehicle.created_at or "N/A"),
            'updated_at': str(vehicle.updated_at or "N/A"),
            'farmer': {
                'id': vehicle.farmer.id if vehicle.farmer else None,
                'name': vehicle.farmer.get_translated_value("name", language_code) if vehicle.farmer else "Unknown",
            },
            'documents': {}
        }

        if vehicle.crop:  # Adjusted to tools
            vehicle_consumption_data['crop'] = {
                'id': vehicle.crop.id,
                'tool_name': vehicle.crop.crop.name if vehicle.crop.crop else "Unknown",  # Adjusted to 'tool_name'
                'land': vehicle.crop.land.name if vehicle.crop.land else "Unknown",  # Assuming tools are linked to land in a similar way as crops
                'img': request.build_absolute_uri(f'/SuperAdmin{vehicle.crop.crop.img.url}' if vehicle.crop.crop.img else ""),
            }

        # Reuse documents for consumption
        for doc in vehicle_documents:
            file_type = doc.file_type.get_translated_value("name", language_code) if doc.file_type else "Unknown"
            file_type_id = doc.file_type.id if doc.file_type else None
            document_data = {
                'id': doc.id,
                'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}') if doc.document else "",
            }
            if file_type not in vehicle_consumption_data['documents']:
                vehicle_consumption_data['documents'][file_type] = {
                    'id': file_type_id,
                    'name': file_type,
                    'documents': []
                }
            vehicle_consumption_data['documents'][file_type]['documents'].append(document_data)

        response_data['vehicle_consumption'].append(vehicle_consumption_data)
 
     

    return Response(response_data)


@api_view(['GET'])
def get_general_settings(request):
    try:
        # Fetch all GeneralSetting entries
        general_settings = GeneralSetting.objects.all()
        
        # Prepare the response data
        data = []
        for setting in general_settings:
            setting_data = {  
                "date_format": setting.date_format,
                "time_format": setting.time_format,  
            }
            data.append(setting_data)

        return JsonResponse(data, safe=False, status=status.HTTP_200_OK)

    except GeneralSetting.DoesNotExist:
        return JsonResponse({"detail": "GeneralSettings not found"}, status=status.HTTP_404_NOT_FOUND)
 
 
 

@api_view(['POST'])
def pay_sales_outstanding(request, farmer_id, customer_id):
    try:
        farmer = get_object_or_404(Farmer, id=farmer_id)
        action = request.data.get('action')

        if action == "create_pay":
            payment_date_str = request.data.get('date')
            sale_id = request.data.get('sale_id')
            payment = request.data.get('payment_amount')
            description = request.data.get('description')
            documents_data = request.data.get('documents', [])  # List of documents (file types and files)

            # Convert date
            if payment_date_str:
                try:
                    payment_date = datetime.strptime(payment_date_str, "%d-%m-%Y").date()
                except ValueError:
                    return Response({"detail": "Invalid date format. Use 'dd-mm-yyyy'."}, status=status.HTTP_400_BAD_REQUEST)

            sale = get_object_or_404(MySales, pk=int(sale_id))
            customer = get_object_or_404(MyCustomer, pk=customer_id)
            payment = Decimal(payment)

            # Get latest outstanding
            last_outstanding = Outstanding.objects.filter(farmer=farmer, customer=customer, sale=sale).last()

            if last_outstanding and last_outstanding.to_receive <= 0:
                return Response({
                    "detail": "Account is already closed. No outstanding balance left to pay."
                }, status=status.HTTP_400_BAD_REQUEST)

            original_balance = Decimal(sale.total_sales_amount)

            if last_outstanding:
                previous_to_receive = last_outstanding.to_receive

                if payment > previous_to_receive:
                    return Response({
                        "detail": f"Payment cannot be greater than the remaining outstanding amount of {previous_to_receive}."
                    }, status=status.HTTP_400_BAD_REQUEST)

                received = last_outstanding.received + payment
                total_received = received
                to_receive = previous_to_receive - payment
            else:
                received = payment
                total_received = payment
                to_receive = original_balance - payment

            if to_receive < 0:
                to_receive = Decimal(0)

            # Create Outstanding record
            outstanding = Outstanding.objects.create(
                farmer=farmer,
                customer=customer,
                sale=sale,
                balance=to_receive,
                received=received,
                to_receive=to_receive,
                received_date=payment_date,
                total_received=total_received,
                payment_amount=payment,  # Store the actual payment made in this transaction
                created_by=None,
                created_at=timezone.now(),
                description=description if description else None
            )

            # Handle documents, if any
            document_details = []
            if documents_data:
                for doc_data in documents_data:
                    file_type_id = doc_data.get('file_type')
                    documents = doc_data.get('documents', [])

                    # Fetch file type
                    file_type = get_object_or_404(DocumentCategory, id=file_type_id)

                    # Process each document
                    for i, document_base64 in enumerate(documents):
                        try:
                            # Validate MIME type
                            mime_type = validate_image_type(document_base64)
                            if mime_type:
                                document_data = document_base64.split(';base64,')[1]
                                document_bytes = base64.b64decode(document_data)

                                # Check file size (max 10MB)
                                if len(document_bytes) > 10 * 1024 * 1024:  # 10MB limit
                                    return Response({'error': 'File is too large. Max size is 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

                                # Create a document file
                                document_name = f"outstanding_{farmer_id}_{file_type.id}_{i}.{mime_type.split('/')[1]}"
                                document_file = ContentFile(document_bytes, name=document_name)

                                # Create OutstandingDocuments record
                                outstanding_document = OutstandingDocuments(
                                    outstanding=outstanding,
                                    document_type=file_type,
                                    document=document_file,
                                    uploaded_at=timezone.now(),
                                    created_by=None,
                                    created_at=timezone.now()
                                )
                                outstanding_document.save()

                                document_details.append({
                                    'id': outstanding_document.id,
                                    'file_name': outstanding_document.document.name,
                                    'file_type': outstanding_document.document_type.name
                                })

                            else:
                                return Response({'error': 'Invalid MIME type for the document.'}, status=status.HTTP_400_BAD_REQUEST)
                        except Exception as e:
                            return Response({'error': f"Error processing document: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

            # Update customer's balance
            customer.opening_balance = Decimal(customer.opening_balance) - payment
            customer.save()

            if to_receive <= 0:
                outstanding.status = 1  # Closed
                outstanding.save()

                return Response({
                    "detail": "Payment Created and Outstanding Closed",
                    "data": {
                        "total_received": float(total_received),
                        "to_receive": float(to_receive),
                        "payment_amount": float(payment),
                        "customer_balance": float(customer.opening_balance),
                        "documents": document_details
                    }
                }, status=status.HTTP_201_CREATED)

            return Response({
                "detail": "Payment Created Successfully",
                "data": {
                    "total_received": float(total_received),
                    "to_receive": float(to_receive),
                    "payment_amount": float(payment),
                    "customer_balance": float(customer.opening_balance),
                    "documents": document_details
                }
            }, status=status.HTTP_201_CREATED)

        else:
            return Response({"detail": "Invalid action."}, status=status.HTTP_400_BAD_REQUEST)

    except Exception as e:
        print(f"Error occurred: {e}")
        return Response({"detail": "An error occurred."}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


 
@api_view(['POST'])
def pay_purchase_outstanding(request, farmer_id, vendor_id):
    try:
        farmer = get_object_or_404(Farmer, id=farmer_id)
        action = request.data.get('action')

        if action == "create_receive":
            payment_date_str = request.data.get('date')
            payment = request.data.get('payment_amount')
            description = request.data.get('description')
            purchase_type = request.data.get('purchase_type')  # e.g., 'fuel', 'seeds', etc.
            documents_data = request.data.get('documents', [])  # List of documents (optional)

            # Mapping of purchase types
            purchase_mapping = {
                "fuel":        {"model": MyFuel,        "field": "fuel_purchase",        "id_key": "fuel_purchase_id",        "amount_field": "paid_amount"},
                "seeds":       {"model": MySeeds,       "field": "seeds_purchase",       "id_key": "seeds_purchase_id",       "amount_field": "paid_amount"},
                "tools":       {"model": MyTools,       "field": "tool_purchase",        "id_key": "tool_purchase_id",        "amount_field": "paid_amount"},
                "vehicle":     {"model": MyVehicle,     "field": "vehicle_purchase",     "id_key": "vehicle_purchase_id",     "amount_field": "paid_amount"},
                "machinery":   {"model": MyMachinery,   "field": "machinery_purchase",   "id_key": "machinery_purchase_id",   "amount_field": "paid_amount"},
                "fertilizer":  {"model": MyFertilizers, "field": "fertilizer_purchase",  "id_key": "fertilizer_purchase_id",  "amount_field": "paid_amount"},
                "pesticides":  {"model": MyPesticides,  "field": "pesticide_purchase",   "id_key": "pesticide_purchase_id",   "amount_field": "paid_amount"},
            }

            # Validate purchase_type
            if purchase_type not in purchase_mapping:
                return Response({"detail": "Invalid purchase type."}, status=status.HTTP_400_BAD_REQUEST)

            mapping = purchase_mapping[purchase_type]
            purchase_model = mapping["model"]
            purchase_field = mapping["field"]
            purchase_id = request.data.get(mapping["id_key"])
            amount_field = mapping["amount_field"]

            if not purchase_id:
                return Response({"detail": f"{mapping['id_key']} is required."}, status=status.HTTP_400_BAD_REQUEST)

            # Convert inputs
            payment = Decimal(payment)
            purchase = get_object_or_404(purchase_model, pk=int(purchase_id))
            vendor = get_object_or_404(MyVendor, pk=vendor_id)

            # Convert date
            if payment_date_str:
                try:
                    payment_date = datetime.strptime(payment_date_str, "%d-%m-%Y").date()
                except ValueError:
                    return Response({"detail": "Invalid date format. Use 'dd-mm-yyyy'."}, status=status.HTTP_400_BAD_REQUEST)

            # Get latest outstanding (receivables)
            last_outstanding = Outstanding.objects.filter(
                farmer=farmer,
                vendor=vendor,
                **{purchase_field: purchase}
            ).last()

            if last_outstanding and last_outstanding.to_receive <= 0:
                return Response({
                    "detail": "Account is already closed. No outstanding balance left to receive."
                }, status=status.HTTP_400_BAD_REQUEST)

            original_balance = Decimal(getattr(purchase, amount_field))

            if last_outstanding:
                previous_to_receive = last_outstanding.to_receive
                if payment > previous_to_receive:
                    return Response({
                        "detail": f"Received amount cannot exceed outstanding of {previous_to_receive}."
                    }, status=status.HTTP_400_BAD_REQUEST)

                received = last_outstanding.received + payment
                total_received = last_outstanding.total_received + payment
                to_receive = previous_to_receive - payment
            else:
                received = last_outstanding.received + payment
                total_received = payment
                to_receive = original_balance - payment

            if to_receive < 0:
                to_receive = Decimal(0)

            # Create Outstanding entry (receivables)
            outstanding = Outstanding.objects.create(
                farmer=farmer,
                vendor=vendor,
                **{purchase_field: purchase},
                balance=to_receive,
                received=received,
                to_receive=to_receive,
                received_date=payment_date,
                total_received=total_received,
                payment_amount=payment,
                created_by=None,
                created_at=timezone.now(),
                description=description if description else None
            )

            # Process documents (if any)
            if documents_data:
                for doc_data in documents_data:
                    file_type_id = doc_data.get('file_type')
                    document_base64 = doc_data.get('document')

                    if file_type_id is None or not document_base64:
                        return Response({"detail": "File type and document are required."}, status=status.HTTP_400_BAD_REQUEST)

                    # Validate and process the document
                    try:
                        # Validate MIME type for images or PDF
                        mime_type = validate_image_type(document_base64)
                        if mime_type:
                            # Extract the base64 data (remove the prefix)
                            document_data = document_base64.split(';base64,')[1]
                            document_bytes = base64.b64decode(document_data)

                            # Check file size (after decoding)
                            if len(document_bytes) > (10 * 1024 * 1024):  # 10MB limit
                                return Response({'error': 'File is too large. Max size is 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

                            # Create the document file (ContentFile)
                            document_name = f"purchase_outstanding_{farmer_id}_{vendor_id}_{purchase_id}.pdf"  # Or other extensions as needed
                            document_file = ContentFile(document_bytes, name=document_name)

                            # Fetch the file type
                            file_type = get_object_or_404(DocumentCategory, id=file_type_id)

                            # Create and save the document
                            outstanding_document = OutstandingDocuments.objects.create(
                                outstanding=outstanding,
                                document_type=file_type,
                                document=document_file,
                                uploaded_at=timezone.now(),
                                created_by=None,
                                created_at=timezone.now()
                            )

                    except Exception as e:
                        return Response({'error': f"Error processing document: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

            # Close outstanding if balance is fully paid
            if to_receive <= 0:
                outstanding.status = 1  # Closed
                outstanding.save()

                return Response({
                    "detail": "Payment Received and Outstanding Closed",
                    "data": {
                        "total_received": float(total_received),
                        "to_receive": float(to_receive),
                        "payment_amount": float(payment)
                    }
                }, status=status.HTTP_201_CREATED)

            return Response({
                "detail": "Payment Received Successfully",
                "data": {
                    "total_received": float(total_received),
                    "to_receive": float(to_receive),
                    "payment_amount": float(payment)
                }
            }, status=status.HTTP_201_CREATED)

        return Response({"detail": "Invalid action."}, status=status.HTTP_400_BAD_REQUEST)

    except Exception as e:
        print(f"Error occurred: {e}")
        return Response({"detail": "An error occurred."}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


def validate_image_type(document_base64):
    """
    This function validates the MIME type of the base64 string
    """
    if document_base64.startswith("data:image/jpeg"):
        return "image/jpeg"
    elif document_base64.startswith("data:image/png"):
        return "image/png"
    elif document_base64.startswith("data:application/pdf"):
        return "application/pdf"
    return None
 
# @api_view(['POST'])
# def vendor_purchase_Payables_outstanding(request, farmer_id, vendor_id):
#     try:
#         farmer = get_object_or_404(Farmer, id=farmer_id)
#         action = request.data.get('action')

#         if action == "create_pay":
#             payment_date_str = request.data.get('date')
#             payment = request.data.get('payment_amount')
#             description = request.data.get('description')
#             purchase_type = request.data.get('purchase_type')  # e.g., 'fuel', 'seeds', etc.
#             documents_data = request.data.get('documents', [])  # List of documents (optional)

#             # Mapping of purchase types
#             purchase_mapping = {
#                 "fuel":        {"model": MyFuel,        "field": "fuel_purchase",        "id_key": "fuel_purchase_id",        "amount_field": "paid_amount"},
#                 "seeds":       {"model": MySeeds,       "field": "seeds_purchase",       "id_key": "seeds_purchase_id",       "amount_field": "paid_amount"},
#                 "tools":       {"model": MyTools,       "field": "tool_purchase",        "id_key": "tool_purchase_id",        "amount_field": "paid_amount"},
#                 "vehicle":     {"model": MyVehicle,     "field": "vehicle_purchase",     "id_key": "vehicle_purchase_id",     "amount_field": "paid_amount"},
#                 "machinery":   {"model": MyMachinery,   "field": "machinery_purchase",   "id_key": "machinery_purchase_id",   "amount_field": "paid_amount"},
#                 "fertilizer":  {"model": MyFertilizers, "field": "fertilizer_purchase",  "id_key": "fertilizer_purchase_id",  "amount_field": "paid_amount"},
#                 "pesticides":  {"model": MyPesticides,  "field": "pesticide_purchase",   "id_key": "pesticide_purchase_id",   "amount_field": "paid_amount"},
#             }

#             if purchase_type not in purchase_mapping:
#                 return Response({"detail": "Invalid purchase type."}, status=status.HTTP_400_BAD_REQUEST)

#             mapping = purchase_mapping[purchase_type]
#             purchase_model = mapping["model"]
#             purchase_field = mapping["field"]
#             purchase_id = request.data.get(mapping["id_key"])
#             amount_field = mapping["amount_field"]

#             if not purchase_id:
#                 return Response({"detail": f"{mapping['id_key']} is required."}, status=status.HTTP_400_BAD_REQUEST)

#             payment = Decimal(payment)
#             purchase = get_object_or_404(purchase_model, pk=int(purchase_id))
#             vendor = get_object_or_404(MyVendor, pk=vendor_id)

#             # Convert date
#             if payment_date_str:
#                 try:
#                     payment_date = datetime.strptime(payment_date_str, "%d-%m-%Y").date()
#                 except ValueError:
#                     return Response({"detail": "Invalid date format. Use 'dd-mm-yyyy'."}, status=status.HTTP_400_BAD_REQUEST)

#             last_outstanding = Outstanding.objects.filter(
#                 farmer=farmer,
#                 vendor=vendor,
#                 **{purchase_field: purchase}
#             ).last()

#             if last_outstanding and last_outstanding.to_pay <= 0:
#                 return Response({
#                     "detail": "Account is already closed. No outstanding balance left to pay."
#                 }, status=status.HTTP_400_BAD_REQUEST)

#             original_balance = Decimal(getattr(purchase, amount_field))

#             if last_outstanding:
#                 previous_to_pay = last_outstanding.to_pay
#                 if payment > previous_to_pay:
#                     return Response({
#                         "detail": f"Payment cannot exceed the outstanding amount of {previous_to_pay}."
#                     }, status=status.HTTP_400_BAD_REQUEST)

#                 paid = last_outstanding.paid + payment  # this transaction only
#                 total_paid = last_outstanding.total_paid + payment
#                 to_pay = previous_to_pay - payment
#             else:
#                 paid = payment
#                 total_paid = payment
#                 to_pay = original_balance - payment

#             if to_pay < 0:
#                 to_pay = Decimal(0)

#             # Create Outstanding entry (payables)
#             outstanding = Outstanding.objects.create(
#                 farmer=farmer,
#                 vendor=vendor,
#                 **{purchase_field: purchase},
#                 balance=to_pay,
#                 paid=paid,
#                 to_pay=to_pay,
#                 paid_date=payment_date,
#                 total_paid=total_paid,
#                 payment_amount=payment,
#                 created_by=None,
#                 created_at=timezone.now(),
#                 description=description if description else None
#             )
#             documents_data = request.data.get('documents', [])
#             # Process documents (if any)
#             if documents_data:
#                 for doc_data in documents_data:
#                     file_type_id = doc_data.get('file_type')
#                     document_base64 = doc_data.get('document')

#                     if file_type_id is None or not document_base64:
#                         return Response({"detail": "File type and document are required."}, status=status.HTTP_400_BAD_REQUEST)

#                     # Validate and process the document
#                     try:
#                         # Validate MIME type for images or PDF
#                         mime_type = validate_image_type(document_base64)
#                         if mime_type:
#                             # Extract the base64 data (remove the prefix)
#                             document_data = document_base64.split(';base64,')[1]
#                             document_bytes = base64.b64decode(document_data)

#                             # Check file size (after decoding)
#                             if len(document_bytes) > (10 * 1024 * 1024):  # 10MB limit
#                                 return Response({'error': 'File is too large. Max size is 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

#                             # Create the document file (ContentFile)
#                             document_name = f"purchase_outstanding_{farmer_id}_{vendor_id}_{purchase_id}.pdf"  # Or other extensions as needed
#                             document_file = ContentFile(document_bytes, name=document_name)

#                             # Fetch the file type
#                             file_type = get_object_or_404(DocumentCategory, id=file_type_id)

#                             # Create and save the document
#                             outstanding_document = OutstandingDocuments.objects.create(
#                                 outstanding=outstanding,
#                                 document_type=file_type,
#                                 document=document_file,
#                                 uploaded_at=timezone.now(),
#                                 created_by=None,
#                                 created_at=timezone.now()
#                             )

#                     except Exception as e:
#                         return Response({'error': f"Error processing document: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

#             # Close outstanding if balance is fully paid
#             if to_pay <= 0:
#                 outstanding.status = 1  # Closed
#                 outstanding.save()

#                 return Response({
#                     "detail": "Payment Created and Outstanding Closed",
#                     "data": {
#                         "total_paid": float(total_paid),
#                         "to_pay": float(to_pay),
#                         "payment_amount": float(payment)
#                     }
#                 }, status=status.HTTP_201_CREATED)

#             return Response({
#                 "detail": "Payment Created Successfully",
#                 "data": {
#                     "total_paid": float(total_paid),
#                     "to_pay": float(to_pay),
#                     "payment_amount": float(payment)
#                 }
#             }, status=status.HTTP_201_CREATED)

#         return Response({"detail": "Invalid action."}, status=status.HTTP_400_BAD_REQUEST)

#     # except Exception as e:
#     #     print(f"Error occurred: {e}")
#     #     return Response({"detail": "An error occurred."}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
#     except Exception as e:
#         traceback_str = traceback.format_exc()
#         print(f"Full traceback: {traceback_str}")
#         return Response({"detail": f"An error occurred: {str(e)}"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
from rest_framework.decorators import api_view
from rest_framework.response import Response
from rest_framework import status
from django.shortcuts import get_object_or_404
from decimal import Decimal
from datetime import datetime
import base64
from django.core.files.base import ContentFile
from django.utils import timezone
import traceback

@api_view(['POST'])
def vendor_purchase_Payables_outstanding(request, farmer_id, vendor_id):
    try:
        farmer = get_object_or_404(Farmer, id=farmer_id)
        action = request.data.get('action')

        if action != "create_pay":
            return Response({"detail": "Invalid action."}, status=status.HTTP_400_BAD_REQUEST)

        payment_date_str = request.data.get('date')
        payment = request.data.get('payment_amount')
        description = request.data.get('description')
        purchase_type = request.data.get('purchase_type')
        documents_data = request.data.get('documents', [])

        # Validate documents_data to be a list
        if documents_data and not isinstance(documents_data, list):
            return Response({"detail": "'documents' must be a list of objects."}, status=status.HTTP_400_BAD_REQUEST)

        # Mapping of purchase types
        purchase_mapping = {
            "fuel":        {"model": MyFuel,        "field": "fuel_purchase",        "id_key": "fuel_purchase_id",        "amount_field": "paid_amount"},
            "seeds":       {"model": MySeeds,       "field": "seeds_purchase",       "id_key": "seeds_purchase_id",       "amount_field": "paid_amount"},
            "tools":       {"model": MyTools,       "field": "tool_purchase",        "id_key": "tool_purchase_id",        "amount_field": "paid_amount"},
            "vehicle":     {"model": MyVehicle,     "field": "vehicle_purchase",     "id_key": "vehicle_purchase_id",     "amount_field": "paid_amount"},
            "machinery":   {"model": MyMachinery,   "field": "machinery_purchase",   "id_key": "machinery_purchase_id",   "amount_field": "paid_amount"},
            "fertilizer":  {"model": MyFertilizers, "field": "fertilizer_purchase",  "id_key": "fertilizer_purchase_id",  "amount_field": "paid_amount"},
            "pesticides":  {"model": MyPesticides,  "field": "pesticide_purchase",   "id_key": "pesticide_purchase_id",   "amount_field": "paid_amount"},
        }

        if purchase_type not in purchase_mapping:
            return Response({"detail": "Invalid purchase type."}, status=status.HTTP_400_BAD_REQUEST)

        mapping = purchase_mapping[purchase_type]
        purchase_model = mapping["model"]
        purchase_field = mapping["field"]
        purchase_id = request.data.get(mapping["id_key"])
        amount_field = mapping["amount_field"]

        if not purchase_id:
            return Response({"detail": f"{mapping['id_key']} is required."}, status=status.HTTP_400_BAD_REQUEST)

        # Convert payment to Decimal safely
        try:
            payment = Decimal(payment)
        except Exception:
            return Response({"detail": "Invalid payment amount."}, status=status.HTTP_400_BAD_REQUEST)

        purchase = get_object_or_404(purchase_model, pk=int(purchase_id))
        vendor = get_object_or_404(MyVendor, pk=vendor_id)

        # Parse date if provided
        payment_date = None
        if payment_date_str:
            try:
                payment_date = datetime.strptime(payment_date_str, "%d-%m-%Y").date()
            except ValueError:
                return Response({"detail": "Invalid date format. Use 'dd-mm-yyyy'."}, status=status.HTTP_400_BAD_REQUEST)

        last_outstanding = Outstanding.objects.filter(
            farmer=farmer,
            vendor=vendor,
            **{purchase_field: purchase}
        ).last()

        if last_outstanding and last_outstanding.to_pay <= 0:
            return Response({
                "detail": "Account is already closed. No outstanding balance left to pay."
            }, status=status.HTTP_400_BAD_REQUEST)

        original_balance = Decimal(getattr(purchase, amount_field))

        if last_outstanding:
            previous_to_pay = last_outstanding.to_pay
            if payment > previous_to_pay:
                return Response({
                    "detail": f"Payment cannot exceed the outstanding amount of {previous_to_pay}."
                }, status=status.HTTP_400_BAD_REQUEST)

            paid = last_outstanding.paid + payment
            total_paid = last_outstanding.total_paid + payment
            to_pay = previous_to_pay - payment
        else:
            paid = payment
            total_paid = payment
            to_pay = original_balance - payment

        if to_pay < 0:
            to_pay = Decimal(0)

        # Create Outstanding entry
        outstanding = Outstanding.objects.create(
            farmer=farmer,
            vendor=vendor,
            **{purchase_field: purchase},
            balance=to_pay,
            paid=paid,
            to_pay=to_pay,
            paid_date=payment_date,
            total_paid=total_paid,
            payment_amount=payment,
            created_by=None,
            created_at=timezone.now(),
            description=description if description else None
        )

        # Process documents (if any)
        if documents_data:
            for idx, doc_data in enumerate(documents_data):
                # Defensive: doc_data must be dict
                if not isinstance(doc_data, dict):
                    return Response({"detail": f"Each document entry must be an object. Error at index {idx}."},
                                    status=status.HTTP_400_BAD_REQUEST)

                file_type_id = doc_data.get('file_type')
                document_base64 = doc_data.get('document')

                if file_type_id is None or not document_base64:
                    return Response({"detail": "File type and document are required for each document."},
                                    status=status.HTTP_400_BAD_REQUEST)

                try:
                    # Validate MIME type - you need to have validate_image_type function defined elsewhere
                    mime_type = validate_image_type(document_base64)
                    if not mime_type:
                        return Response({'detail': 'Invalid document format. Only images and PDFs allowed.'},
                                        status=status.HTTP_400_BAD_REQUEST)

                    # Extract base64 content after comma
                    if ';base64,' in document_base64:
                        document_data = document_base64.split(';base64,')[1]
                    else:
                        document_data = document_base64  # Assume pure base64

                    document_bytes = base64.b64decode(document_data)

                    if len(document_bytes) > (10 * 1024 * 1024):  # 10MB limit
                        return Response({'detail': 'File is too large. Max size is 10MB.'},
                                        status=status.HTTP_400_BAD_REQUEST)

                    ext = 'pdf' if 'pdf' in mime_type else 'jpg'  # Basic extension guess
                    document_name = f"purchase_outstanding_{farmer_id}_{vendor_id}_{purchase_id}_{idx}.{ext}"
                    document_file = ContentFile(document_bytes, name=document_name)

                    file_type = get_object_or_404(DocumentCategory, id=file_type_id)

                    OutstandingDocuments.objects.create(
                        outstanding=outstanding,
                        document_type=file_type,
                        document=document_file,
                        uploaded_at=timezone.now(),
                        created_by=None,
                        created_at=timezone.now()
                    )

                except Exception as e:
                    return Response({'detail': f"Error processing document: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

        # Close outstanding if fully paid
        if to_pay <= 0:
            outstanding.status = 1  # Closed
            outstanding.save()
            return Response({
                "detail": "Payment Created and Outstanding Closed",
                "data": {
                    "total_paid": float(total_paid),
                    "to_pay": float(to_pay),
                    "payment_amount": float(payment)
                }
            }, status=status.HTTP_201_CREATED)

        return Response({
            "detail": "Payment Created Successfully",
            "data": {
                "total_paid": float(total_paid),
                "to_pay": float(to_pay),
                "payment_amount": float(payment)
            }
        }, status=status.HTTP_201_CREATED)

    except Exception as e:
        traceback_str = traceback.format_exc()
        print(f"Full traceback: {traceback_str}")
        return Response({"detail": f"An error occurred: {str(e)}"}, status=status.HTTP_500_INTERNAL_SERVER)

# @api_view(['POST'])
# def pay_sales_payables_outstanding(request, farmer_id, customer_id):
#     try:
#         farmer = get_object_or_404(Farmer, id=farmer_id)
#         action = request.data.get('action')

#         if action == "create_pay":
#             payment_date_str = request.data.get('date')
#             sale_id = request.data.get('sale_id')
#             payment = request.data.get('payment_amount')
#             description = request.data.get('description')

#             # Convert date
#             if payment_date_str:
#                 try:
#                     payment_date = datetime.strptime(payment_date_str, "%d-%m-%Y").date()
#                 except ValueError:
#                     return Response({"detail": "Invalid date format. Use 'dd-mm-yyyy'."}, status=status.HTTP_400_BAD_REQUEST)

#             sale = get_object_or_404(MySales, pk=int(sale_id))
#             customer = get_object_or_404(MyCustomer, pk=customer_id)
#             payment = Decimal(payment)

#             # Get latest outstanding
#             last_outstanding = Outstanding.objects.filter(farmer=farmer, customer=customer, sale=sale).last()

#             if last_outstanding and last_outstanding.to_pay <= 0:
#                 return Response({
#                     "detail": "Account is already closed. No outstanding balance left to pay."
#                 }, status=status.HTTP_400_BAD_REQUEST)

#             original_balance = Decimal(sale.total_sales_amount)

#             if last_outstanding:
#                 previous_to_pay = last_outstanding.to_pay

#                 if payment > previous_to_pay:
#                     return Response({
#                         "detail": f"Payment cannot be greater than the remaining outstanding amount of {previous_to_pay}."
#                     }, status=status.HTTP_400_BAD_REQUEST)

#                 paid = last_outstanding.paid + payment
#                 total_paid = paid
#                 to_pay = previous_to_pay - payment
#             else:
#                 paid = payment
#                 total_paid = payment
#                 to_pay = original_balance - payment

#             if to_pay < 0:
#                 to_pay = Decimal(0)

#             # âœ… Create Outstanding record using payable fields
#             outstanding = Outstanding.objects.create(
#                 farmer=farmer,
#                 customer=customer,
#                 sale=sale,
#                 balance=to_pay,              # âž¡ balance reflects the remaining due
#                 paid=paid,                   # âž¡ current paid (cumulative)
#                 to_pay=to_pay,               # âž¡ remaining amount to pay
#                 paid_date=payment_date,      # âž¡ payment date
#                 total_paid=total_paid,       # âž¡ total amount paid so far
#                 payment_amount=payment,      # âž¡ current transaction payment
#                 created_by=None,
#                 created_at=timezone.now(),
#                 description=description if description else None
#             )

#             # Update customer balance
#             customer.opening_balance = Decimal(customer.opening_balance) - payment
#             customer.save()

#             if to_pay <= 0:
#                 outstanding.status = 1  # Closed
#                 outstanding.save()

#                 return Response({
#                     "detail": "Payment Created and Outstanding Closed",
#                     "data": {
#                         "total_paid": float(total_paid),
#                         "to_pay": float(to_pay),
#                         "payment_amount": float(payment),
#                         "customer_balance": float(customer.opening_balance)
#                     }
#                 }, status=status.HTTP_201_CREATED)

#             return Response({
#                 "detail": "Payment Created Successfully",
#                 "data": {
#                     "total_paid": float(total_paid),
#                     "to_pay": float(to_pay),
#                     "payment_amount": float(payment),
#                     "customer_balance": float(customer.opening_balance)
#                 }
#             }, status=status.HTTP_201_CREATED)

#         else:
#             return Response({"detail": "Invalid action."}, status=status.HTTP_400_BAD_REQUEST)

#     except Exception as e:
#         print(f"Error occurred: {e}")
#         return Response({"detail": "An error occurred."}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@api_view(['POST'])
def pay_sales_payables_outstanding(request, farmer_id, customer_id):
    try:
        farmer = get_object_or_404(Farmer, id=farmer_id)
        action = request.data.get('action')

        if action == "create_pay":
            payment_date_str = request.data.get('date')
            sale_id = request.data.get('sale_id')
            payment = request.data.get('payment_amount')
            description = request.data.get('description')
            documents_data = request.data.get('documents', [])  # List of documents (optional)

            # Convert date
            if payment_date_str:
                try:
                    payment_date = datetime.strptime(payment_date_str, "%d-%m-%Y").date()
                except ValueError:
                    return Response({"detail": "Invalid date format. Use 'dd-mm-yyyy'."}, status=status.HTTP_400_BAD_REQUEST)

            sale = get_object_or_404(MySales, pk=int(sale_id))
            customer = get_object_or_404(MyCustomer, pk=customer_id)
            payment = Decimal(payment)

            # Get latest outstanding
            last_outstanding = Outstanding.objects.filter(farmer=farmer, customer=customer, sale=sale).last()

            if last_outstanding and last_outstanding.to_pay <= 0:
                return Response({
                    "detail": "Account is already closed. No outstanding balance left to pay."
                }, status=status.HTTP_400_BAD_REQUEST)

            original_balance = Decimal(sale.total_sales_amount)

            if last_outstanding:
                previous_to_pay = last_outstanding.to_pay

                if payment > previous_to_pay:
                    return Response({
                        "detail": f"Payment cannot be greater than the remaining outstanding amount of {previous_to_pay}."
                    }, status=status.HTTP_400_BAD_REQUEST)

                paid = last_outstanding.paid + payment
                total_paid = paid
                to_pay = previous_to_pay - payment
            else:
                paid = payment
                total_paid = payment
                to_pay = original_balance - payment

            if to_pay < 0:
                to_pay = Decimal(0)

            # âœ… Create Outstanding record using payable fields
            outstanding = Outstanding.objects.create(
                farmer=farmer,
                customer=customer,
                sale=sale,
                balance=to_pay,              # âž¡ balance reflects the remaining due
                paid=paid,                   # âž¡ current paid (cumulative)
                to_pay=to_pay,               # âž¡ remaining amount to pay
                paid_date=payment_date,      # âž¡ payment date
                total_paid=total_paid,       # âž¡ total amount paid so far
                payment_amount=payment,      # âž¡ current transaction payment
                created_by=None,
                created_at=timezone.now(),
                description=description if description else None
            )

            # Process documents (if any)
            if documents_data:
                for doc_data in documents_data:
                    file_type_id = doc_data.get('file_type')
                    document_base64 = doc_data.get('document')

                    if file_type_id is None or not document_base64:
                        return Response({"detail": "File type and document are required."}, status=status.HTTP_400_BAD_REQUEST)

                    # Validate and process the document
                    try:
                        # Validate MIME type for images or PDF
                        mime_type = validate_image_type(document_base64)
                        if mime_type:
                            # Extract the base64 data (remove the prefix)
                            document_data = document_base64.split(';base64,')[1]
                            document_bytes = base64.b64decode(document_data)

                            # Check file size (after decoding)
                            if len(document_bytes) > (10 * 1024 * 1024):  # 10MB limit
                                return Response({'error': 'File is too large. Max size is 10MB.'}, status=status.HTTP_400_BAD_REQUEST)

                            # Create the document file (ContentFile)
                            document_name = f"sales_outstanding_{farmer_id}_{customer_id}_{sale_id}.pdf"  # Or other extensions as needed
                            document_file = ContentFile(document_bytes, name=document_name)

                            # Fetch the file type
                            file_type = get_object_or_404(DocumentCategory, id=file_type_id)

                            # Create and save the document
                            outstanding_document = OutstandingDocuments.objects.create(
                                outstanding=outstanding,
                                document_type=file_type,
                                document=document_file,
                                uploaded_at=timezone.now(),
                                created_by=None,
                                created_at=timezone.now()
                            )

                    except Exception as e:
                        return Response({'error': f"Error processing document: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

            # Update customer balance
            customer.opening_balance = Decimal(customer.opening_balance) - payment
            customer.save()

            if to_pay <= 0:
                outstanding.status = 1  # Closed
                outstanding.save()

                return Response({
                    "detail": "Payment Created and Outstanding Closed",
                    "data": {
                        "total_paid": float(total_paid),
                        "to_pay": float(to_pay),
                        "payment_amount": float(payment),
                        "customer_balance": float(customer.opening_balance)
                    }
                }, status=status.HTTP_201_CREATED)

            return Response({
                "detail": "Payment Created Successfully",
                "data": {
                    "total_paid": float(total_paid),
                    "to_pay": float(to_pay),
                    "payment_amount": float(payment),
                    "customer_balance": float(customer.opening_balance)
                }
            }, status=status.HTTP_201_CREATED)

        else:
            return Response({"detail": "Invalid action."}, status=status.HTTP_400_BAD_REQUEST)

    except Exception as e:
        print(f"Error occurred: {e}")
        return Response({"detail": "An error occurred."}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

def validate_image_type(base64_string):
    try:
        header, base64_data = base64_string.split(';base64,')
        file_type = header.split(':')[1]  # e.g., "image/png"
        return file_type
    except Exception:
        return None

@api_view(['GET'])
def get_sales_outstanding_history(request, farmer_id):
    try:
        # Get farmer from URL
        farmer = get_object_or_404(Farmer, id=farmer_id)

        # Get query params
        customer_id = request.query_params.get('customer_id')
        sale_id = request.query_params.get('sale_id')
        outstanding_id = request.query_params.get('outstanding_id')  # New query parameter for outstanding_id

        # Validate params
        if not customer_id or not sale_id:
            return Response({
                "detail": "Both 'customer_id' and 'sale_id' are required query parameters."
            }, status=status.HTTP_400_BAD_REQUEST)

        customer = get_object_or_404(MyCustomer, id=customer_id, is_customer_is_vendor = False, status=0)
        sale = get_object_or_404(MySales, id=sale_id,status=0)

        # Build filter for the Outstanding records
        filters = {
            'farmer': farmer,
            'customer': customer,
            'sale': sale
        }

        # If outstanding_id is provided, add it to the filter
        if outstanding_id:
            filters['id'] = outstanding_id

        # Fetch matching Outstanding records
        records = Outstanding.objects.filter(**filters).order_by('-created_at')

        # Manually serialize the data
        data = []
        for record in records:
            data.append({
                "id": record.id,
                "balance": float(record.balance),
                "received": float(record.received),
                "payment_amount": float(record.payment_amount),
                "to_receive": float(record.to_receive),
                "total_received": float(record.total_received),
                "received_date": record.received_date.strftime('%d-%m-%Y') if record.received_date else None,
                "description": record.description,
                "status": record.status,
                "created_at": record.created_at.strftime('%d-%m-%Y %H:%M:%S') if record.created_at else None,
            })

        return Response({
            "count": records.count(),
            "data": data
        }, status=status.HTTP_200_OK)

    except Exception as e:
        print("Error fetching outstanding history:", e)
        return Response({"detail": "An error occurred while fetching the data."}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
 
# @api_view(['GET'])
# def get_sales_payables_outstanding_history(request, farmer_id):
#     try:
#         # Get farmer from URL
#         farmer = get_object_or_404(Farmer, id=farmer_id)

#         # Get query params
#         customer_id = request.query_params.get('customer_id')
#         sale_id = request.query_params.get('sale_id')
#         outstanding_id = request.query_params.get('outstanding_id')  # New query parameter

#         # Validate params
#         if not customer_id or not sale_id:
#             return Response({
#                 "detail": "Both 'customer_id' and 'sale_id' are required query parameters."
#             }, status=status.HTTP_400_BAD_REQUEST)

#         customer = get_object_or_404(MyCustomer, id=customer_id, is_customer_is_vendor = False, status=0)
#         sale = get_object_or_404(MySales, id=sale_id, status=0)

#         # Build filter for the Outstanding records
#         filters = {
#             'farmer': farmer,
#             'customer': customer,
#             'sale': sale
#         }

#         # Add outstanding_id filter if provided
#         if outstanding_id:
#             filters['id'] = outstanding_id

#         # Fetch matching Outstanding records with dynamic filters
#         records = Outstanding.objects.filter(**filters).order_by('-created_at')

#         # Manually serialize the data
#         data = []
#         for record in records:
#             data.append({
#                 "id": record.id,
#                 "balance": float(record.balance),  # Balance reflects remaining to pay
#                 "paid": float(record.paid),  # Paid amount so far
#                 "payment_amount": float(record.payment_amount),  # The amount paid in this transaction
#                 "to_pay": float(record.to_pay),  # Remaining amount to pay
#                 "total_paid": float(record.total_paid),  # Total paid so far
#                 "paid_date": record.paid_date.strftime('%d-%m-%Y') if record.paid_date else None,  # Payment date
#                 "description": record.description,
#                 "status": record.status,
#                 "created_at": record.created_at.strftime('%d-%m-%Y %H:%M:%S') if record.created_at else None,
#             })

#         return Response({
#             "count": records.count(),
#             "data": data
#         }, status=status.HTTP_200_OK)

#     except Exception as e:
#         print("Error fetching outstanding history:", e)
#         return Response({"detail": "An error occurred while fetching the data."}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
@api_view(['GET'])
def get_sales_payables_outstanding_history(request, farmer_id):
    try:
        # Get farmer from URL
        farmer = get_object_or_404(Farmer, id=farmer_id)

        # Get query params
        customer_id = request.query_params.get('customer_id')
        sale_id = request.query_params.get('sale_id')
        outstanding_id = request.query_params.get('outstanding_id')  # New query parameter

        # Validate params
        if not customer_id or not sale_id:
            return Response({
                "detail": "Both 'customer_id' and 'sale_id' are required query parameters."
            }, status=status.HTTP_400_BAD_REQUEST)

        # Get customer and sale objects with proper 404 handling
        customer = get_object_or_404(MyCustomer, id=customer_id, is_customer_is_vendor=False, status=0)
        sale = get_object_or_404(MySales, id=sale_id, status=0)

        # Build filter for the Outstanding records
        filters = {
            'farmer': farmer,
            'customer': customer,
            'sale': sale
        }

        # Add outstanding_id filter if provided
        if outstanding_id:
            filters['id'] = outstanding_id

        # Fetch matching Outstanding records with dynamic filters
        records = Outstanding.objects.filter(**filters).order_by('-created_at')

        # Manually serialize the data
        data = []
        for record in records:
            data.append({
                "id": record.id,
                "balance": float(record.balance),
                "paid": float(record.paid),
                "payment_amount": float(record.payment_amount),
                "to_pay": float(record.to_pay),
                "total_paid": float(record.total_paid),
                "paid_date": record.paid_date.strftime('%d-%m-%Y') if record.paid_date else None,
                "description": record.description,
                "status": record.status,
                "created_at": record.created_at.strftime('%d-%m-%Y %H:%M:%S') if record.created_at else None,
            })

        return Response({
            "count": records.count(),
            "data": data
        }, status=status.HTTP_200_OK)

    except Http404 as e:
        # Object not found: return 404 response
        return Response({"detail": str(e)}, status=status.HTTP_404_NOT_FOUND)

    except Exception as e:
        # Log the error instead of print to avoid I/O errors
        logger.error(f"Error fetching outstanding history: {e}", exc_info=True)
        return Response({"detail": "An error occurred while fetching the data."}, status=status.HTTP_500_INTERNAL_SERVER_ERROR) 

# @api_view(['GET'])
# def get_farmer_vendor_outstanding_history(request, farmer_id):
#     try:
#         # Required: Farmer & Vendor
#         farmer = get_object_or_404(Farmer, id=farmer_id)
#         vendor_id = request.query_params.get('vendor_id')

#         if not vendor_id:
#             return Response({"detail": "'vendor_id' is a required query parameter."}, status=status.HTTP_400_BAD_REQUEST)

#         vendor = get_object_or_404(MyVendor, id=vendor_id, is_customer_is_vendor = False, status=0)

#         # Optional item IDs
#         fuel_id = request.query_params.get('fuel_id')
#         machinery_id = request.query_params.get('machinery_id')
#         tool_id = request.query_params.get('tool_id')
#         vehicle_id = request.query_params.get('vehicle_id')
#         fertilizer_id = request.query_params.get('fertilizer_id')
#         pesticides_id = request.query_params.get('pesticides_id')
#         seed_id = request.query_params.get('seed_id')
#         outstanding_id = request.query_params.get('outstanding_id')

#         # Base filters
#         filters = {
#             'farmer': farmer,
#             'vendor': vendor
#         }

#         # Add optional filters only if present
#         if fuel_id:
#             filters['fuel_purchase'] = get_object_or_404(MyFuel, id=fuel_id)

#         if machinery_id:
#             filters['machinery_purchase'] = get_object_or_404(MyMachinery, id=machinery_id)

#         if tool_id:
#             filters['tool_purchase'] = get_object_or_404(MyTools, id=tool_id)

#         if vehicle_id:
#             filters['vehicle_purchase'] = get_object_or_404(MyVehicle, id=vehicle_id)

#         if fertilizer_id:
#             filters['fertilizer_purchase'] = get_object_or_404(MyFertilizers, id=fertilizer_id)

#         if pesticides_id:
#             filters['pesticide_purchase'] = get_object_or_404(MyPesticides, id=pesticides_id)

#         if seed_id:
#             filters['seeds_purchase'] = get_object_or_404(MySeeds, id=seed_id)

#         if outstanding_id:
#             filters['id'] = outstanding_id

#         # Fetch matching records
#         records = Outstanding.objects.filter(**filters).order_by('-created_at')

#         # Serialize
#         data = []
#         for record in records:
#             data.append({
#                 "id": record.id,
#                 "balance": float(record.balance),
#                 "paid": float(record.paid),
#                 "payment_amount": float(record.payment_amount),
#                 "to_pay": float(record.to_pay),
#                 "total_paid": float(record.total_paid),
#                 "paid_date": record.paid_date.strftime('%d-%m-%Y') if record.paid_date else None,
#                 "description": record.description,
#                 "status": record.status,
#                 "created_at": record.created_at.strftime('%d-%m-%Y %H:%M:%S') if record.created_at else None,
#             })

#         return Response({
#             "count": records.count(),
#             "data": data
#         }, status=status.HTTP_200_OK)

#     except Exception as e:
#         print("Error fetching outstanding history:", e)
#         return Response({"detail": "An error occurred while fetching the data."}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@api_view(['GET'])
def get_farmer_vendor_outstanding_history(request, farmer_id):
    try:
        # Validate and get farmer
        try:
            farmer_id = to_int(farmer_id, 'farmer_id')
        except ValueError as ve:
            return Response({"detail": str(ve)}, status=status.HTTP_400_BAD_REQUEST)
        farmer = get_object_or_404(Farmer, id=farmer_id)

        # Validate and get vendor
        vendor_id = request.query_params.get('vendor_id')
        if not vendor_id:
            return Response({"detail": "'vendor_id' is a required query parameter."}, status=status.HTTP_400_BAD_REQUEST)
        try:
            vendor_id = to_int(vendor_id, 'vendor_id')
        except ValueError as ve:
            return Response({"detail": str(ve)}, status=status.HTTP_400_BAD_REQUEST)
        vendor = get_object_or_404(MyVendor, id=vendor_id, is_customer_is_vendor=False, status=0)

        # Base filters
        filters = {
            'farmer': farmer,
            'vendor': vendor
        }

        # Optional item (id + type)
        item_id = request.query_params.get('id')
        item_type = request.query_params.get('type')

        item_type_mapping = {
            'fuel': (MyFuel, 'fuel_purchase'),
            'machinery': (MyMachinery, 'machinery_purchase'),
            'tools': (MyTools, 'tool_purchase'),
            'vehicle': (MyVehicle, 'vehicle_purchase'),
            'fertilizers': (MyFertilizers, 'fertilizer_purchase'),
            'pesticides': (MyPesticides, 'pesticide_purchase'),
            'seeds': (MySeeds, 'seeds_purchase'),
        }

        if item_id:
            if not item_type:
                return Response({"detail": "'type' parameter is required when 'id' is provided."}, status=status.HTTP_400_BAD_REQUEST)

            item_type_key = item_type.strip().lower()
            if item_type_key not in item_type_mapping:
                return Response({"detail": f"Invalid type '{item_type}' provided."}, status=status.HTTP_400_BAD_REQUEST)

            try:
                item_id = to_int(item_id, 'id')
            except ValueError as ve:
                return Response({"detail": str(ve)}, status=status.HTTP_400_BAD_REQUEST)

            model, filter_key = item_type_mapping[item_type_key]
            filters[filter_key] = get_object_or_404(model, id=item_id)

        # Optional: outstanding_id
        outstanding_id = request.query_params.get('outstanding_id')
        if outstanding_id:
            try:
                filters['id'] = to_int(outstanding_id, 'outstanding_id')
            except ValueError as ve:
                return Response({"detail": str(ve)}, status=status.HTTP_400_BAD_REQUEST)

        # Fetch data
        records = Outstanding.objects.filter(**filters).order_by('-created_at')

        # Serialize
        data = []
        for record in records:
            data.append({
                "id": record.id,
                "balance": float(record.balance),
                "paid": float(record.paid),
                "payment_amount": float(record.payment_amount),
                "to_pay": float(record.to_pay),
                "total_paid": float(record.total_paid),
                "paid_date": record.paid_date.strftime('%d-%m-%Y') if record.paid_date else None,
                "description": record.description,
                "status": record.status,
                "created_at": record.created_at.strftime('%d-%m-%Y %H:%M:%S') if record.created_at else None,
            })

        return Response({
            "count": records.count(),
            "data": data
        }, status=status.HTTP_200_OK)

    except Exception as e:
        print("Error fetching outstanding history:", e)
        return Response({"detail": "An error occurred while fetching the data."}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


def to_int(value, param_name):
    try:
        return int(value)
    except (ValueError, TypeError):
        raise ValueError(f"'{param_name}' must be an integer.")

# @api_view(['GET'])
# def get_farmer_vendor_received_outstanding_history(request, farmer_id):
#     try:
#         # Validate farmer_id param (already an int from URL but let's be safe)
#         try:
#             farmer_id = to_int(farmer_id, 'farmer_id')
#         except ValueError as ve:
#             return Response({"detail": str(ve)}, status=status.HTTP_400_BAD_REQUEST)
        
#         farmer = get_object_or_404(Farmer, id=farmer_id)

#         vendor_id = request.query_params.get('vendor_id')
#         if not vendor_id:
#             return Response({"detail": "'vendor_id' is a required query parameter."}, status=status.HTTP_400_BAD_REQUEST)
#         try:
#             vendor_id = to_int(vendor_id, 'vendor_id')
#         except ValueError as ve:
#             return Response({"detail": str(ve)}, status=status.HTTP_400_BAD_REQUEST)
#         vendor = get_object_or_404(MyVendor, id=vendor_id, is_customer_is_vendor=False, status=0)

#         # Optional item IDs
#         fuel_id = request.query_params.get('fuel_id')
#         machinery_id = request.query_params.get('machinery_id')
#         tool_id = request.query_params.get('tool_id')
#         vehicle_id = request.query_params.get('vehicle_id')
#         fertilizer_id = request.query_params.get('fertilizer_id')
#         pesticides_id = request.query_params.get('pesticides_id')
#         seed_id = request.query_params.get('seed_id')
#         outstanding_id = request.query_params.get('outstanding_id')

#         filters = {
#             'farmer': farmer,   
#             'vendor': vendor
#         }

#         # Helper function to process optional IDs
#         def process_optional_id(param_value, param_name, model, filter_key):
#             if param_value:
#                 try:
#                     int_value = to_int(param_value, param_name)
#                 except ValueError as ve:
#                     raise ValueError(str(ve))
#                 obj = get_object_or_404(model, id=int_value)
#                 filters[filter_key] = obj

#         try:
#             process_optional_id(fuel_id, 'fuel_id', MyFuel, 'fuel_purchase')
#             process_optional_id(machinery_id, 'machinery_id', MyMachinery, 'machinery_purchase')
#             process_optional_id(tool_id, 'tool_id', MyTools, 'tool_purchase')
#             process_optional_id(vehicle_id, 'vehicle_id', MyVehicle, 'vehicle_purchase')
#             process_optional_id(fertilizer_id, 'fertilizer_id', MyFertilizers, 'fertilizer_purchase')
#             process_optional_id(pesticides_id, 'pesticides_id', MyPesticides, 'pesticide_purchase')
#             process_optional_id(seed_id, 'seed_id', MySeeds, 'seeds_purchase')
#             if outstanding_id:
#                 try:
#                     filters['id'] = to_int(outstanding_id, 'outstanding_id')
#                 except ValueError as ve:
#                     return Response({"detail": str(ve)}, status=status.HTTP_400_BAD_REQUEST)
#         except ValueError as e:
#             return Response({"detail": str(e)}, status=status.HTTP_400_BAD_REQUEST)

#         records = Outstanding.objects.filter(**filters).order_by('-created_at')

#         data = []
#         for record in records:
#             data.append({
#                 "id": record.id,
#                 "balance": float(record.balance),
#                 "received": float(record.received),
#                 "payment_amount": float(record.payment_amount),
#                 "to_receive": float(record.to_receive),
#                 "total_received": float(record.total_received),
#                 "received_date": record.received_date.strftime('%d-%m-%Y') if record.received_date else None,
#                 "description": record.description,
#                 "status": record.status,
#                 "created_at": record.created_at.strftime('%d-%m-%Y %H:%M:%S') if record.created_at else None,
#             })

#         return Response({
#             "count": records.count(),
#             "data": data
#         }, status=status.HTTP_200_OK)

#     except Exception as e:
#         traceback.print_exc()
#         return Response({"detail": "An error occurred while fetching the data."}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
@api_view(['GET'])
def get_farmer_vendor_received_outstanding_history(request, farmer_id):
    try:
        # Validate and get farmer
        try:
            farmer_id = to_int(farmer_id, 'farmer_id')
        except ValueError as ve:
            return Response({"detail": str(ve)}, status=status.HTTP_400_BAD_REQUEST)
        farmer = get_object_or_404(Farmer, id=farmer_id)

        # Validate and get vendor
        vendor_id = request.query_params.get('vendor_id')
        if not vendor_id:
            return Response({"detail": "'vendor_id' is a required query parameter."}, status=status.HTTP_400_BAD_REQUEST)
        try:
            vendor_id = to_int(vendor_id, 'vendor_id')
        except ValueError as ve:
            return Response({"detail": str(ve)}, status=status.HTTP_400_BAD_REQUEST)
        vendor = get_object_or_404(MyVendor, id=vendor_id, is_customer_is_vendor=False, status=0)

        # Prepare filters
        filters = {
            'farmer': farmer,
            'vendor': vendor
        }

        # Optional single item filter: id + type
        item_id = request.query_params.get('id')
        item_type = request.query_params.get('type')  # e.g. 'Fuel', 'Machinery', etc.

        # Use lowercase keys for mapping
        item_type_mapping = {
            'fuel': (MyFuel, 'fuel_purchase'),
            'machinery': (MyMachinery, 'machinery_purchase'),
            'tools': (MyTools, 'tool_purchase'),
            'vehicle': (MyVehicle, 'vehicle_purchase'),
            'fertilizers': (MyFertilizers, 'fertilizer_purchase'),
            'pesticides': (MyPesticides, 'pesticide_purchase'),
            'seeds': (MySeeds, 'seeds_purchase'),
        }

        if item_id:
            if not item_type:
                return Response({"detail": "'type' parameter is required when 'id' is provided."}, status=status.HTTP_400_BAD_REQUEST)

            item_type_key = item_type.strip().lower()  # Normalize to lowercase
            if item_type_key not in item_type_mapping:
                return Response({"detail": f"Invalid type '{item_type}' provided."}, status=status.HTTP_400_BAD_REQUEST)

            try:
                item_id = to_int(item_id, 'id')
            except ValueError as ve:
                return Response({"detail": str(ve)}, status=status.HTTP_400_BAD_REQUEST)

            model, filter_key = item_type_mapping[item_type_key]
            item_instance = get_object_or_404(model, id=item_id)
            filters[filter_key] = item_instance

        # Optional outstanding_id
        outstanding_id = request.query_params.get('outstanding_id')
        if outstanding_id:
            try:
                filters['id'] = to_int(outstanding_id, 'outstanding_id')
            except ValueError as ve:
                return Response({"detail": str(ve)}, status=status.HTTP_400_BAD_REQUEST)

        # Fetch and serialize records
        records = Outstanding.objects.filter(**filters).order_by('-created_at')

        data = []
        for record in records:
            data.append({
                "id": record.id,
                "balance": float(record.balance),
                "received": float(record.received),
                "payment_amount": float(record.payment_amount),
                "to_receive": float(record.to_receive),
                "total_received": float(record.total_received),
                "received_date": record.received_date.strftime('%d-%m-%Y') if record.received_date else None,
                "description": record.description,
                "status": record.status,
                "created_at": record.created_at.strftime('%d-%m-%Y %H:%M:%S') if record.created_at else None,
            })

        return Response({
            "count": records.count(),
            "data": data
        }, status=status.HTTP_200_OK)

    except Exception as e:
        traceback.print_exc()
        return Response({"detail": "An error occurred while fetching the data."}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@api_view(['GET'])
def get_farmer_both_receivables_outstanding_history(request, farmer_id):
    try:
        # Get Farmer from URL
        farmer = get_object_or_404(Farmer, id=farmer_id)

        # Get query params
        customer_id = request.query_params.get('customer_id')
        sale_id = request.query_params.get('sale_id')
        vendor_id = request.query_params.get('vendor_id')
        purchase_id = request.query_params.get('purchase_id')
        outstanding_id = request.query_params.get('outstanding_id')  # Optional

        # Scenario 1: Sales (Customer, Sale)
        if customer_id and sale_id:
            customer = get_object_or_404(MyCustomer, id=customer_id, is_customer_is_vendor=True, status=0)
            sale = get_object_or_404(MySales, id=sale_id, status=0)

            # Build filters for Sales Outstanding records
            filters = {
                'farmer': farmer,
                'customer': customer,
                'sale': sale
            }

            if outstanding_id:
                filters['id'] = outstanding_id

            # Fetch matching records
            records = Outstanding.objects.filter(**filters).order_by('-created_at')

        # Scenario 2: Purchase (Vendor, Purchase type - Fuel, Machinery, Tools, etc.)
        elif vendor_id and purchase_id:
            vendor = get_object_or_404(MyVendor, id=vendor_id, is_customer_is_vendor=True, status=0)

            # Determine the type of purchase (fuel, machinery, tools, etc.)
            if purchase_id == 'fuel':
                purchase_field = 'fuel_purchase'
                purchase_instance = get_object_or_404(MyFuel, id=request.query_params.get('fuel_id'))
            elif purchase_id == 'machinery':
                purchase_field = 'machinery_purchase'
                purchase_instance = get_object_or_404(MyMachinery, id=request.query_params.get('machinery_id'))
            elif purchase_id == 'tool':
                purchase_field = 'tool_purchase'
                purchase_instance = get_object_or_404(MyTools, id=request.query_params.get('tool_id'))
            elif purchase_id == 'vehicle':
                purchase_field = 'vehicle_purchase'
                purchase_instance = get_object_or_404(MyVehicle, id=request.query_params.get('vehicle_id'))
            elif purchase_id == 'fertilizer':
                purchase_field = 'fertilizer_purchase'
                purchase_instance = get_object_or_404(MyFertilizers, id=request.query_params.get('fertilizer_id'))
            elif purchase_id == 'pesticide':
                purchase_field = 'pesticide_purchase'
                purchase_instance = get_object_or_404(MyPesticides, id=request.query_params.get('pesticides_id'))
            elif purchase_id == 'seed':
                purchase_field = 'seeds_purchase'
                purchase_instance = get_object_or_404(MySeeds, id=request.query_params.get('seed_id'))
            else:
                return Response({
                    "detail": "Invalid purchase type. Must be one of ['fuel', 'machinery', 'tool', 'vehicle', 'fertilizer', 'pesticide', 'seed']."
                }, status=status.HTTP_400_BAD_REQUEST)

            # Build filters for Purchase Outstanding records
            filters = {
                'farmer': farmer,
                'vendor': vendor,
                purchase_field: purchase_instance
            }

            if outstanding_id:
                filters['id'] = outstanding_id

            # Fetch matching records
            records = Outstanding.objects.filter(**filters).order_by('-created_at')

        else:
            return Response({
                "detail": "Either 'customer_id' and 'sale_id' or 'vendor_id' and 'purchase_id' are required."
            }, status=status.HTTP_400_BAD_REQUEST)

        # Serialize results
        data = []
        for record in records:
            data.append({
                "id": record.id,
                "balance": float(record.balance),
                "received": float(record.received),
                "payment_amount": float(record.payment_amount),
                "to_receive": float(record.to_receive),
                "total_received": float(record.total_received),
                "received_date": record.received_date.strftime('%d-%m-%Y') if record.received_date else None,
                "description": record.description,
                "status": record.status,
                "created_at": record.created_at.strftime('%d-%m-%Y %H:%M:%S') if record.created_at else None,
            })

        return Response({
            "count": records.count(),
            "data": data
        }, status=status.HTTP_200_OK)

    except Exception as e:
        print("Error fetching outstanding history:", e)
        return Response({"detail": "An error occurred while fetching the data."}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@api_view(['GET'])
def get_farmer_both_payables_outstanding_history(request, farmer_id):
    try:
        # Get Farmer from URL
        farmer = get_object_or_404(Farmer, id=farmer_id)

        # Get query params
        customer_id = request.query_params.get('customer_id')
        sale_id = request.query_params.get('sale_id')
        vendor_id = request.query_params.get('vendor_id')
        purchase_id = request.query_params.get('purchase_id')
        outstanding_id = request.query_params.get('outstanding_id')  # Optional

        # Scenario 1: Sales (Customer, Sale) - To Pay by Farmer (Outstanding Sale Amount)
        if customer_id and sale_id:
            customer = get_object_or_404(MyCustomer, id=customer_id, is_customer_is_vendor=True, status=0)
            sale = get_object_or_404(MySales, id=sale_id, status=0)

            # Build filters for Sales Outstanding records
            filters = {
                'farmer': farmer,
                'customer': customer,
                'sale': sale
            }

            if outstanding_id:
                filters['id'] = outstanding_id

            # Fetch matching records
            records = Outstanding.objects.filter(**filters).order_by('-created_at')

        # Scenario 2: Purchase (Vendor, Purchase type - Fuel, Machinery, Tools, etc.) - To Pay by Farmer
        elif vendor_id and purchase_id:
            vendor = get_object_or_404(MyVendor, id=vendor_id, is_customer_is_vendor=True, status=0)

            # Determine the type of purchase (fuel, machinery, tools, etc.)
            if purchase_id == 'fuel':
                purchase_field = 'fuel_purchase'
                purchase_instance = get_object_or_404(MyFuel, id=request.query_params.get('fuel_id'))
            elif purchase_id == 'machinery':
                purchase_field = 'machinery_purchase'
                purchase_instance = get_object_or_404(MyMachinery, id=request.query_params.get('machinery_id'))
            elif purchase_id == 'tool':
                purchase_field = 'tool_purchase'
                purchase_instance = get_object_or_404(MyTools, id=request.query_params.get('tool_id'))
            elif purchase_id == 'vehicle':
                purchase_field = 'vehicle_purchase'
                purchase_instance = get_object_or_404(MyVehicle, id=request.query_params.get('vehicle_id'))
            elif purchase_id == 'fertilizer':
                purchase_field = 'fertilizer_purchase'
                purchase_instance = get_object_or_404(MyFertilizers, id=request.query_params.get('fertilizer_id'))
            elif purchase_id == 'pesticide':
                purchase_field = 'pesticide_purchase'
                purchase_instance = get_object_or_404(MyPesticides, id=request.query_params.get('pesticides_id'))
            elif purchase_id == 'seed':
                purchase_field = 'seeds_purchase'
                purchase_instance = get_object_or_404(MySeeds, id=request.query_params.get('seed_id'))
            else:
                return Response({
                    "detail": "Invalid purchase type. Must be one of ['fuel', 'machinery', 'tool', 'vehicle', 'fertilizer', 'pesticide', 'seed']."
                }, status=status.HTTP_400_BAD_REQUEST)

            # Build filters for Purchase Outstanding records
            filters = {
                'farmer': farmer,
                'vendor': vendor,
                purchase_field: purchase_instance
            }

            if outstanding_id:
                filters['id'] = outstanding_id

            # Fetch matching records
            records = Outstanding.objects.filter(**filters).order_by('-created_at')

        else:
            return Response({
                "detail": "Either 'customer_id' and 'sale_id' or 'vendor_id' and 'purchase_id' are required."
            }, status=status.HTTP_400_BAD_REQUEST)

        # Serialize results
        data = []
        for record in records:
            data.append({
                "id": record.id,
                "balance": float(record.balance),  # Balance to pay
                "payment_amount": float(record.payment_amount),  # Amount paid by farmer
                "to_pay": float(record.to_pay),  # Amount farmer still needs to pay
                "total_paid": float(record.total_paid),  # Total paid so far
                "description": record.description,
                "status": record.status,
                "created_at": record.created_at.strftime('%d-%m-%Y %H:%M:%S') if record.created_at else None,
            })

        return Response({
            "count": records.count(),
            "data": data
        }, status=status.HTTP_200_OK)

    except Exception as e:
        print("Error fetching outstanding history:", e)
        return Response({"detail": "An error occurred while fetching the data."}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@api_view(['GET'])
def get_farmer_notification_count(request, farmer_id): 
    try:
        # Check if farmer exists
        farmer = Farmer.objects.get(id=farmer_id)
        
        # Total notifications
        total_count = FarmerNotification.objects.filter(farmer=farmer).count()
        
        # Read notifications
        read_count = FarmerNotification.objects.filter(farmer=farmer, is_read=True).count()
        
        # Unread notifications
        unread_count = total_count - read_count
        # Alternatively: FarmerNotification.objects.filter(farmer=farmer, is_read=False).count()
        
        return Response({
            'farmer_id': farmer.id,
            'total_notifications': total_count,
            'read_notifications': read_count,
            'unread_notifications': unread_count
        }, status=status.HTTP_200_OK)
    
    except Farmer.DoesNotExist:
        return Response({
            'error': 'Farmer not found'
        }, status=status.HTTP_404_NOT_FOUND)


@api_view(['GET'])
def get_farmer_notifications(request, farmer_id):
    # Get the farmer instance
    farmer = Farmer.objects.filter(id=farmer_id).first()
    if not farmer:
        return Response({'error': 'Farmer not found'}, status=status.HTTP_404_NOT_FOUND)
    
    # Get all notifications for this farmer
    notifications = FarmerNotification.objects.filter(farmer=farmer).order_by('-created_at')
    
    if not notifications.exists():
        return Response({'error': 'No notifications found for this farmer'}, status=status.HTTP_404_NOT_FOUND)
    
    # Prepare notifications list
    notifications_list = []
    for n in notifications:
        notifications_list.append({
            'notification_id': n.id,
            'name': n.name,
            'type': n.type,
            'message': n.message,
            'is_read': n.is_read,
            'created_at': n.created_at
        })
    
    # Counts
    total_count = notifications.count()
    read_count = notifications.filter(is_read=True).count()
    unread_count = total_count - read_count
    
    return Response({
        'farmer_id': farmer.id,
        'total_notifications': total_count,
        'read_notifications': read_count,
        'unread_notifications': unread_count,
        'notifications': notifications_list
    }, status=status.HTTP_200_OK)

@api_view(['GET'])
def get_farmer_notification(request, farmer_id, notification_id=None):
    # Get the farmer instance
    farmer = Farmer.objects.filter(id=farmer_id).first()
    if not farmer:
        return Response({'error': 'Farmer not found'}, status=status.HTTP_404_NOT_FOUND)
    
    if notification_id:
        # Fetch specific notification
        notification = FarmerNotification.objects.filter(farmer=farmer, id=notification_id).first()
        if not notification:
            return Response({'error': 'Notification not found for this farmer'}, status=status.HTTP_404_NOT_FOUND)
        
        return Response({
            'farmer_id': farmer.id,
            'notification_id': notification.id,
            'name': notification.name,
            'type': notification.type,
            'message': notification.message,
            'is_read': notification.is_read,
            'created_at': notification.created_at
        }, status=status.HTTP_200_OK)
    
    else:
        # Fetch all notifications
        notifications = FarmerNotification.objects.filter(farmer=farmer).order_by('-created_at')
        notifications_list = []
        for n in notifications:
            notifications_list.append({
                'notification_id': n.id,
                'name': n.name,
                'type': n.type,
                'message': n.message,
                'is_read': n.is_read,
                'created_at': n.created_at
            })
        
        total_count = notifications.count()
        read_count = notifications.filter(is_read=True).count()
        unread_count = total_count - read_count
        
        return Response({
            'farmer_id': farmer.id,
            'total_notifications': total_count,
            'read_notifications': read_count,
            'unread_notifications': unread_count,
            'notifications': notifications_list
        }, status=status.HTTP_200_OK)

@api_view(['POST'])
def mark_notification_read(request, farmer_id, notification_id):
    # Get the farmer
    farmer = Farmer.objects.filter(id=farmer_id).first()
    if not farmer:
        return Response({'error': 'Farmer not found'}, status=status.HTTP_404_NOT_FOUND)
    
    # Get the notification
    notification = FarmerNotification.objects.filter(farmer=farmer, id=notification_id).first()
    if not notification:
        return Response({'error': 'Notification not found for this farmer'}, status=status.HTTP_404_NOT_FOUND)
    
    # Update is_read
    notification.is_read = True
    notification.save()
    
    return Response({
        'farmer_id': farmer.id,
        'notification_id': notification.id,
        'is_read': notification.is_read,
        'message': 'Notification marked as read successfully'
    }, status=status.HTTP_200_OK)


@api_view(['GET'])
def land_view(request, farmer_id, land_id):
    try:
        land = MyLand.objects.get(id=land_id, farmer_id=farmer_id)
    except MyLand.DoesNotExist:
        return Response({'error': 'Land not found for this farmer'}, status=status.HTTP_404_NOT_FOUND)

    # Manually serialize survey details like MyLandSurveyDetailsSerializer
    survey_details = []
    for survey in land.survey_details.all():
        survey_details.append({
            'id': survey.id,
            'farmer': str(survey.farmer) if survey.farmer else None,  # StringRelatedField equivalent
            'MyLand': str(survey.MyLand) if survey.MyLand else None,  # StringRelatedField equivalent
            'survey_no': survey.survey_no,
            'survey_measurement_value': survey.survey_measurement_value,
            'survey_measurement_unit': str(survey.survey_measurement_unit) if survey.survey_measurement_unit else None,  # StringRelatedField
        })

    # Manually serialize documents like MyLandDocumentSerializer
    documents = []
    for doc in land.documents.all():
        documents.append({
        'id': doc.id,
        'farmer': str(doc.farmer) if doc.farmer else None,
        'myland': str(doc.myland) if doc.myland else None,
        'document_category': {
            'id': doc.document_category.id,
            'name': doc.document_category.name  # or any field you want to show
        } if doc.document_category else None,
        # 'upload_document': doc.upload_document.url if doc.upload_document else None,
        'upload_document': request.build_absolute_uri('/assets' + doc.upload_document.url) if doc.upload_document else None,

        'status': doc.status,
    })


    # Construct the main land data response
    data = {
        'id': land.id,
        'name': land.name,
        'measurement_value': land.measurement_value,
        'measurement_unit': {
            'id': land.measurement_unit.id,
            'name': land.measurement_unit.name
        } if land.measurement_unit else None,
        'soil_type': {
            'id': land.soil_type.id,
            'name': land.soil_type.name
        } if land.soil_type else None,
        'country': {
            'id': land.country.id,
            'name': land.country.name
        } if land.country else None,
        'state': {
            'id': land.state.id,
            'name': land.state.name
        } if land.state else None,
        'city': {
            'id': land.city.id,
            'name': land.city.name
        } if land.city else None,
        'taluk': {
            'id': land.taluk.id,
            'name': land.taluk.name
        } if land.taluk else None,
        'village': {
            'id': land.village.id,
            'name': land.village.name
        } if land.village else None,
        'door_no': land.door_no,
        'locations': land.locations,
        'latitude': land.latitude,
        'longitude': land.longitude,
        'geo_marks': land.geo_marks,
        'patta_number': land.patta_number,
        'description': land.description,
        'code': land.code,
        'status': land.status,
        'l_status': land.l_status,
        'created_at': land.created_at.isoformat() if land.created_at else None,
        'created_by': {
            'id': land.created_by.id, 
        } if land.created_by else None,
        'updated_at': land.updated_at.isoformat() if land.updated_at else None,
        'updated_by': {
            'id': land.updated_by.id, 
        } if land.updated_by else None,
        'translate_json': land.translate_json,
        'survey_details': survey_details,
        'documents': documents,
    }

    return Response(data, status=status.HTTP_200_OK)



@api_view(['GET'])
def crop_view(request, farmer_id, land_id, crop_id):
    try:
        crop = MyCrop.objects.get(id=crop_id, land_id=land_id, farmer_id=farmer_id)
    except MyCrop.DoesNotExist:
        return Response({'error': 'Crop not found for the given farmer and land'}, status=status.HTTP_404_NOT_FOUND)

    def get_related(obj):
        if obj:
            return {'id': obj.id, 'name': str(obj)}
        return None

    data = {
        'id': crop.id,
        'farmer': get_related(crop.farmer),
        'crop_type': get_related(crop.crop_type),
        'crop': get_related(crop.crop),
        'crop_image': request.build_absolute_uri(f'/assets{crop.crop.img.url}') if crop.crop and crop.crop and crop.crop.img else "", 
        'harvesting_type': get_related(crop.harvesting_type),
        'plantation_date': crop.plantation_date.isoformat() if crop.plantation_date else None,
        'land': get_related(crop.land),
        'soil_type': get_related(crop.soil_type),
        'taluk': get_related(crop.taluk),
        'village': get_related(crop.village),
        'measurement_value': crop.measurement_value,
        'measurement_unit': get_related(crop.measurement_unit),
        'description': crop.description,
        'status': crop.status,
        'created_at': crop.created_at.isoformat() if crop.created_at else None,
        'created_by': get_related(crop.created_by),
        'updated_at': crop.updated_at.isoformat() if crop.updated_at else None,
        'updated_by': get_related(crop.updated_by),
        'geo_marks': crop.geo_marks,
        'expense': crop.expense,
        'sales': crop.sales,
        'crop_status': crop.crop_status,
        'translate_json': crop.translate_json,

        # Add survey details here using the existing serializer:
        'survey_details': MyLandSurveyDetailsSerializer(crop.survey_details.all(), many=True).data,
    }

    return Response(data, status=status.HTTP_200_OK)

# Schedule Calender(list) for Crop 
 

@api_view(['GET'])
def get_task_calender_list_for_month_and_crop(request, farmer_id):
    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
        language_code = user_language_pref.language_code or 'en'
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'

    land_id = request.query_params.get('land_id')
    crop_id = request.query_params.get('crop_id')
    month = request.query_params.get('month')
    year = request.query_params.get('year')  # New year param

    # Validate required params
    if not land_id or not month or not crop_id:
        return Response(
            {"error": "Parameters 'land_id', 'crop_id' and 'month' are all required."}, 
            status=status.HTTP_400_BAD_REQUEST
        )

    try:
        month = int(month)
        if not 1 <= month <= 12:
            return Response({"error": "Month should be between 1 and 12."}, status=status.HTTP_400_BAD_REQUEST)
    except ValueError:
        return Response({"error": "'month' parameter should be an integer."}, status=status.HTTP_400_BAD_REQUEST)

    try:
        if year is not None:
            year = int(year)
        else:
            farmer_instance = get_object_or_404(Farmer, id=farmer_id, status=0)
            year = farmer_instance.created_at.year
    except ValueError:
        return Response({"error": "'year' parameter should be an integer."}, status=status.HTTP_400_BAD_REQUEST)
    except Exception:
        return Response({"error": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)

    farmer_instance = get_object_or_404(Farmer, id=farmer_id, status=0)

    # Filter tasks by farmer, land, crop, status=0
    tasks = MySchedule.objects.filter(
        farmer=farmer_instance, 
        my_land_id=land_id, 
        my_crop_id=crop_id,
        status=0
    )

    start_date = datetime(year, month, 1)
    if month == 12:
        end_date = datetime(year + 1, 1, 1)
    else:
        end_date = datetime(year, month + 1, 1)

    tasks = tasks.filter(start_date__gte=start_date, start_date__lt=end_date)

    task_serializer = MyScheduleDetailsSerializer(tasks, many=True, context={'language_code': language_code})

    status_map = {
        "Waiting Completion": {"id": 1, "name": {"en": "Waiting Completion", "ta": "à®¨à®¿à®±à¯ˆà®µà¯ à®•à®¾à®¤à¯à®¤à®¿à®°à¯à®•à¯à®•à®¿à®±à®¤à¯"}},
        "Completed": {"id": 2, "name": {"en": "Completed", "ta": "à®¨à®¿à®±à¯ˆà®µà®Ÿà¯ˆà®¨à¯à®¤à®¤à¯"}},
        "In Progress": {"id": 3, "name": {"en": "In Progress", "ta": "à®šà¯†à®¯à®²à®¿à®²à¯ à®‰à®³à¯à®³à®¤à¯"}},
        "Pending": {"id": 4, "name": {"en": "Pending", "ta": "à®¨à®¿à®²à¯à®µà¯ˆà®¯à®¿à®²à¯ à®‰à®³à¯à®³à®¤à¯"}},
        "Cancelled": {"id": 5, "name": {"en": "Cancelled", "ta": "à®°à®¤à¯à®¤à¯ à®šà¯†à®¯à¯à®¯à®ªà¯à®ªà®Ÿà¯à®Ÿà®¤à¯"}},
    }

    response_by_date = defaultdict(lambda: {
        "task_count": 0,
        "tasks": [],
        "Completed": 0,
        "Waiting Completion": 0,
        "Cancelled": 0,
        "Pending": 0,
        "In Progress": 0
    })

    for task in task_serializer.data:
        task_date_raw = task.get('start_date')
        try:
            task_date = datetime.strptime(task_date_raw, '%Y-%m-%d').date() if isinstance(task_date_raw, str) else task_date_raw
        except Exception:
            continue  # skip invalid dates

        schedule_status = task.get('schedule_status')
        status_info = status_map.get(schedule_status)
        if not status_info:
            continue  # skip unknown statuses

        localized_status_name = status_info["name"].get(language_code, status_info["name"]["en"])

        response_by_date[task_date]["task_count"] += 1
        response_by_date[task_date]["tasks"].append({
            "task_id": task.get('id'),
            "activity_type_name": task.get('schedule_activity_type'),
            "description": task.get('schedule'),
            "status_id": status_info["id"],
            "status": localized_status_name
        })

        response_by_date[task_date][schedule_status] += 1

    completed, waiting, cancelled, pending, in_progress, events = [], [], [], [], [], []

    for date, data in sorted(response_by_date.items()):
        date_str = date.strftime('%Y-%m-%d')

        events.append({
            "Date": date_str,
            "count": data["task_count"],
            "status": next((key.lower().replace(" ", "_") for key in status_map if data[key] > 0), "status_of_red_color"),
            "tasks": data["tasks"]
        })

        if data["Completed"] > 0:
            completed.append({"Date": date_str, "tasks": data["tasks"], "count": data["task_count"]})
        if data["Waiting Completion"] > 0:
            waiting.append({"Date": date_str, "tasks": data["tasks"], "count": data["task_count"]})
        if data["Cancelled"] > 0:
            cancelled.append({"Date": date_str, "tasks": data["tasks"], "count": data["task_count"]})
        if data["Pending"] > 0:
            pending.append({"Date": date_str, "tasks": data["tasks"], "count": data["task_count"]})
        if data["In Progress"] > 0:
            in_progress.append({"Date": date_str, "tasks": data["tasks"], "count": data["task_count"]})

    return Response({
        "completed_task": completed,
        "waiting_task": waiting,
        "cancelled_task": cancelled,
        "pending_task": pending,
        "in_progress_task": in_progress,
        "events": events,
        "language": {"default": language_code}
    }, status=status.HTTP_200_OK)


# Schedule List for Crop 
 
@api_view(['GET'])
def get_task_list_for_month_and_crop(request, id):
    try:
        user_language_pref = UserLanguagePreference.objects.get(user=id)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'

    user_id = id
    land_id = request.query_params.get('land_id')
    crop_id = request.query_params.get('crop_id')
    month = request.query_params.get('month')
    year = request.query_params.get('year')

    # Get farmer instance or return 404
    try:
        farmer_instance = Farmer.objects.get(id=user_id, status=0)
    except Farmer.DoesNotExist:
        return Response({"error": "Farmer not found."}, status=status.HTTP_404_NOT_FOUND)

    # Get date format from settings or fallback
    try:
        settings = GeneralSetting.objects.first()
        date_format = convert_to_strftime_format(settings.date_format)
    except Exception:
        date_format = '%d-%m-%Y'  # fallback format

    # Start filtering tasks
    tasks = MySchedule.objects.filter(farmer=farmer_instance, status=0)

    if land_id:
        tasks = tasks.filter(my_land__id=land_id)

    if crop_id:
        tasks = tasks.filter(my_crop__id=crop_id)

    if month:
        try:
            month_int = int(month)
            if not 1 <= month_int <= 12:
                return Response({"error": "Month should be between 1 and 12."}, status=status.HTTP_400_BAD_REQUEST)
            tasks = tasks.filter(start_date__month=month_int)
        except ValueError:
            return Response({"error": "'month' parameter should be an integer between 1 and 12."}, status=status.HTTP_400_BAD_REQUEST)

    if year:
        try:
            year_int = int(year)
            tasks = tasks.filter(start_date__year=year_int)
        except ValueError:
            return Response({"error": "'year' parameter should be a valid integer."}, status=status.HTTP_400_BAD_REQUEST)

    if not tasks.exists():
        return Response({"error": "No tasks found for this farmer."}, status=status.HTTP_404_NOT_FOUND)

    grouped_tasks = defaultdict(list)
    for task in tasks:
        try:
            date_str = task.start_date.strftime(date_format)
        except ValueError:
            return Response({"error": "Invalid date format in General Settings."}, status=status.HTTP_400_BAD_REQUEST)

        day_name = task.start_date.strftime('%a')

        crop_info = {
            "id": task.id if task.id else None,
            "crop_type": (
                f"{task.my_crop.land.get_translated_value('name', language_code)} - {task.my_crop.crop.get_translated_value('name', language_code)}"
                if task.my_crop and task.my_crop.crop and task.my_crop.land
                else "No Crop Available"
            ),
            "crop_image": request.build_absolute_uri(f'/assets{task.my_crop.crop.img.url}') if task.my_crop and task.my_crop.crop and task.my_crop.crop.img else "",
            "description": (
                task.get_translated_value('schedule', language_code)
                if hasattr(task, 'get_translated_value') else (task.schedule or "No Description Available")
            ),
        }

        grouped_tasks[date_str].append({"Day": day_name, "crop": [crop_info]})

    response_data = [
        {
            "Date": date,
            "Day": day_info[0]['Day'],
            "crop": [item['crop'][0] for item in day_info],
            "language": {
                "default": language_code
            }
        }
        for date, day_info in grouped_tasks.items()
    ]

    return Response(response_data, status=status.HTTP_200_OK)



@api_view(['GET'])
def land_vs_crop_chart(request, farmer_id): 
    lands = MyLand.objects.filter(farmer_id=farmer_id, status=0).annotate(crop_count=Count('mycrop'))

    if not lands.exists():
        return Response({"error": "No land found for the given farmer."}, status=status.HTTP_404_NOT_FOUND)
 
    labels = [land.name for land in lands]
    crop_counts = [land.crop_count for land in lands]

    return Response({
        "labels": labels,
        "data": crop_counts
    }, status=status.HTTP_200_OK)

# CONVERSION_TO_SQ_M = {
#     "acre": 4046.8564224,
#     "hectare": 10000,
#     "sq.ft": 0.092903,
#     "sq.m": 1,
#     "sq.km": 1000000,
#     "sq.cm": 0.0001,
#     "sq.in": 0.00064516,
#     "cent": 40.468564224,
#     "gunta": 101.17141,
# }

# @api_view(['POST'])
# def convert_land_unit(request):
#     try:
#         from_unit = get_object_or_404(LandUnit, id=request.data.get("from_unit_id"))
#         to_unit = get_object_or_404(LandUnit, id=request.data.get("to_unit_id"))
#         value = float(request.data.get("value", 0))

#         print("\nSTEP 1: INPUT DATA")
#         print(f"From Unit: {from_unit.name}")
#         print(f"To Unit: {to_unit.name}")
#         print(f"Input Value: {value}")

#         # Step 2: convert source â†’ sq.m
#         value_in_sq_m = value * from_unit.factor_to_sq_m
#         print("\nSTEP 2: CONVERT TO SQ.M")
#         print(f"{value} {from_unit.name} Ã— {from_unit.factor_to_sq_m} = {value_in_sq_m} sq.m")

#         # Step 3: convert sq.m â†’ target
#         result = value_in_sq_m / to_unit.factor_to_sq_m
#         print("\nSTEP 3: CONVERT TO TARGET UNIT")
#         print(f"{value_in_sq_m} sq.m Ã· {to_unit.factor_to_sq_m} = {result} {to_unit.name}")

#         return Response({
#             "from_unit": from_unit.name,
#             "to_unit": to_unit.name,
#             "input_value": value,
#             "converted_value": result
#         })
#     except Exception as e:
#         return Response({"error": str(e)}, status=400)

# Direct Conversion Factor Dictionary: Convert from one unit to another directly
CONVERSION_FACTORS = {
    "acre": {
        "hectare": 0.40468564224,
        "sq.ft": 43560,
        "sq.m": 4046.8564224,
        "sq.km": 0.0000040468564224,
        "sq.cm": 404685.64224,
        "sq.in": 627264,
        "cent": 40.468564224,
        "gunta": 101.17141
    },
    "hectare": {
        "acre": 2.47105381467,
        "sq.ft": 107639.104167,
        "sq.m": 10000,
        "sq.km": 0.01,
        "sq.cm": 1000000,
        "sq.in": 1550000,
        "cent": 100,
        "gunta": 247.105384
    },
    "sq.ft": {
        "acre": 0.000022957,
        "hectare": 0.0000092903,
        "sq.m": 0.092903,
        "sq.km": 9.2903e-8,
        "sq.cm": 929.0304,
        "sq.in": 144,
        "cent": 0.000228,
        "gunta": 0.000246
    },
    "sq.m": {
        "acre": 0.000247105,
        "hectare": 0.0001,
        "sq.ft": 10.7639,
        "sq.km": 1e-6,
        "sq.cm": 10000,
        "sq.in": 1550.0031,
        "cent": 0.002471,
        "gunta": 0.002471
    },
    "sq.km": {
        "acre": 247.105384,
        "hectare": 100,
        "sq.ft": 107639104.167,
        "sq.m": 1000000,
        "sq.cm": 10000000000,
        "sq.in": 1550000000,
        "cent": 10000,
        "gunta": 247105.384
    },
    "sq.cm": {
        "acre": 2.47105381467e-5,
        "hectare": 1e-8,
        "sq.ft": 0.001076391,
        "sq.m": 0.0001,
        "sq.km": 1e-10,
        "sq.in": 0.0015500031,
        "cent": 2.47105381467e-5,
        "gunta": 2.47105381467e-5
    },
    "sq.in": {
        "acre": 1.5953e-5,
        "hectare": 6.4516e-6,
        "sq.ft": 0.00694444,
        "sq.m": 0.00064516,
        "sq.km": 6.4516e-12,
        "sq.cm": 6.4516,
        "cent": 6.4516e-5,
        "gunta": 6.4516e-5
    },
    "cent": {
        "acre": 0.0247105381,
        "hectare": 0.01,
        "sq.ft": 435.6,
        "sq.m": 40.468564224,
        "sq.km": 4.04685642e-5,
        "sq.cm": 4046.85642,
        "sq.in": 627.264,
        "gunta": 1.17171
    },
    "gunta": {
        "acre": 0.0098694,
        "hectare": 0.004047,
        "sq.ft": 1089,
        "sq.m": 101.17141,
        "sq.km": 1.0117e-7,
        "sq.cm": 10117.141,
        "sq.in": 15504.76,
        "cent": 0.852,
    }
}


@api_view(['POST'])
def convert_land_unit(request):
    try:
        # Get the from and to unit by their IDs
        from_unit = get_object_or_404(LandUnit, id=request.data.get("from_unit_id"))
        to_unit = get_object_or_404(LandUnit, id=request.data.get("to_unit_id"))
        value = float(request.data.get("value", 0))

        # Convert to lowercase to avoid case mismatch with dictionary keys
        from_unit_name = from_unit.landunitdef.lower()
        to_unit_name = to_unit.landunitdef.lower()

        print("\nSTEP 1: INPUT DATA")
        print(f"From Unit: {from_unit.landunitdef} (Lowercased: {from_unit_name})")
        print(f"To Unit: {to_unit.landunitdef} (Lowercased: {to_unit_name})")
        print(f"Input Value: {value}")

        # Check conversion factors available in the dictionary
        if from_unit_name not in CONVERSION_FACTORS:
            raise ValueError(f"Invalid 'from' unit: {from_unit_name}")
        if to_unit_name not in CONVERSION_FACTORS[from_unit_name]:
            raise ValueError(f"Invalid 'to' unit: {to_unit_name}")

        # Step 2: Convert using the direct conversion factor
        conversion_factor = CONVERSION_FACTORS[from_unit_name].get(to_unit_name, 1)
        result = value * conversion_factor

        print("\nSTEP 2: CONVERT TO TARGET UNIT")
        print(f"{value} {from_unit_name} Ã— {conversion_factor} = {result} {to_unit_name}")

        return Response({
            "from_unit": from_unit.landunitdef,
            "to_unit": to_unit.landunitdef,
            "input_value": value,
            "converted_value": result
        })
    except Exception as e:
        return Response({"error": str(e)}, status=400)

 
# @api_view(['GET'])
# def get_crop_schedule(request, farmer_id, land_id, crop_id):
#     # Filter MyCrop for this farmer, land, and crop
#     crops = MyCrop.objects.filter(
#         farmer_id=farmer_id,
#         land_id=land_id,
#         crop_id=crop_id
#     )

#     if not crops.exists():
#         return Response({"error": "No crop found for given farmer, land, and crop"}, status=404)

#     # Fetch schedules for this crop
#     schedules = Schedule.objects.filter(crop_id=crop_id, status=0)

#     schedule_list = []
#     for s in schedules:
#         crop_img = ""
#         if s.crop and hasattr(s.crop, "img") and s.crop.img: 
#             crop_img = request.build_absolute_uri(f'/SuperAdmin{s.crop.img.url}')

#         schedule_list.append({
#             "id": s.id,
#             "crop_id": s.crop.id if s.crop else None,
#             "crop": s.crop.name if s.crop else None,
#             "crop_image": crop_img,
#             "activity_type_id": s.activity_type.id if s.activity_type else None,
#             "activity_type": s.activity_type.name if s.activity_type else None,
#             "days": s.days,
#             "description": s.description,
#         })

#     return Response({"schedules": schedule_list})

@api_view(['GET'])
def get_crop_schedule(request, farmer_id, land_id, my_crop_id):
    # Get MyCrop and validate farmer and land
    try:
        my_crop = MyCrop.objects.get(id=my_crop_id, farmer_id=farmer_id, land_id=land_id)
    except MyCrop.DoesNotExist:
        return Response({"error": "MyCrop not found for the given farmer and land"}, status=404)

    crop_id = my_crop.crop.id if my_crop.crop else None
    if not crop_id:
        return Response({"error": "This MyCrop has no linked crop"}, status=400)

    # Fetch schedules for this crop
    schedules = Schedule.objects.filter(crop_id=crop_id, status=0)

    schedule_list = []
    for s in schedules:
        crop_img = ""
        if s.crop and hasattr(s.crop, "img") and s.crop.img:
            crop_img = request.build_absolute_uri(f'/SuperAdmin{s.crop.img.url}')

        schedule_list.append({
            "id": s.id,
            "farmer_id": farmer_id,
            "land_id": land_id,
            "my_crop_id": my_crop.id,
            "crop_id": s.crop.id if s.crop else None,
            "crop": s.crop.name if s.crop else None,
            "crop_image": crop_img,
            "activity_type_id": s.activity_type.id if s.activity_type else None,
            "activity_type": s.activity_type.name if s.activity_type else None,
            "days": s.days,
            "description": s.description,
        })

    return Response({"schedules": schedule_list})


# @api_view(['GET'])
# def get_schedule_detail(request, farmer_id, land_id, crop_id, schedule_id):
#     # Check if the farmer has this crop on this land
#     crops = MyCrop.objects.filter(
#         farmer_id=farmer_id,
#         land_id=land_id,
#         crop_id=crop_id
#     )

#     if not crops.exists():
#         return Response({"error": "No crop found for given farmer, land, and crop"}, status=404)

#     # Fetch the schedule only if it matches the crop
#     try:
#         schedule = Schedule.objects.get(id=schedule_id, crop_id=crop_id, status=0)
#     except Schedule.DoesNotExist:
#         return Response({"error": "Schedule not found for the given crop"}, status=404)

#     # Build crop image URL
#     crop_img = ""
#     if schedule.crop and hasattr(schedule.crop, "img") and schedule.crop.img:
#         crop_img = request.build_absolute_uri(f'/SuperAdmin{schedule.crop.img.url}')

#     data = {
#         "id": schedule.id,
#         "crop_id": schedule.crop.id if schedule.crop else None,
#         "crop": schedule.crop.name if schedule.crop else None,
#         "crop_image": crop_img,
#         "activity_type_id": schedule.activity_type.id if schedule.activity_type else None,
#         "activity_type": schedule.activity_type.name if schedule.activity_type else None,
#         "days": schedule.days,
#         "description": schedule.description,
#     }

#     return Response({"schedule": data})

@api_view(['GET'])
def get_schedule_detail(request, farmer_id, land_id, my_crop_id, schedule_id):
    # Get MyCrop and validate farmer and land
    try:
        my_crop = MyCrop.objects.get(id=my_crop_id, farmer_id=farmer_id, land_id=land_id)
    except MyCrop.DoesNotExist:
        return Response({"error": "MyCrop not found for the given farmer and land"}, status=404)

    crop_id = my_crop.crop.id if my_crop.crop else None
    if not crop_id:
        return Response({"error": "This MyCrop has no linked crop"}, status=400)

    # Fetch the schedule only if it matches the crop
    try:
        schedule = Schedule.objects.get(id=schedule_id, crop_id=crop_id, status=0)
    except Schedule.DoesNotExist:
        return Response({"error": "Schedule not found for the given crop"}, status=404)

    # Build crop image URL
    crop_img = ""
    if schedule.crop and hasattr(schedule.crop, "img") and schedule.crop.img:
        crop_img = request.build_absolute_uri(f'/SuperAdmin{schedule.crop.img.url}')

    data = {
        "id": schedule.id,
        "farmer_id": farmer_id,
        "land_id": land_id,
        "my_crop_id": my_crop.id,
        "crop_id": schedule.crop.id if schedule.crop else None,
        "crop": schedule.crop.name if schedule.crop else None,
        "crop_image": crop_img,
        "activity_type_id": schedule.activity_type.id if schedule.activity_type else None,
        "activity_type": schedule.activity_type.name if schedule.activity_type else None,
        "days": schedule.days,
        "description": schedule.description,
    }

    return Response({"schedule": data})
 
@api_view(['GET'])
def get_crop_summary(request, farmer_id, land_id, crop_id):
    try:
        # Fetch land and crop with status=0 and linked to farmer
        land = MyLand.objects.get(id=land_id, farmer_id=farmer_id, status=0)
        mycrop = MyCrop.objects.get(id=crop_id, land=land, status=0)
        crop = mycrop.crop

        # Aggregate expenses and sales for this crop and farmer
        total_expenses = MyExpense.objects.filter(
            my_crop=mycrop,
            farmer_id=farmer_id,
            status=0
        ).aggregate(total_expenses_amount=Sum('amount'))['total_expenses_amount'] or 0

        total_sales = MySales.objects.filter(
            my_crop=mycrop,
            farmer_id=farmer_id,
            status=0
        ).aggregate(total_sales_amount=Sum('total_sales_amount'))['total_sales_amount'] or 0

        # Fetch today's tasks
        today = date.today()
        tasks_qs = MySchedule.objects.filter(
            farmer_id=farmer_id,
            my_land=land,
            my_crop=mycrop,
            start_date__lte=today,
            end_date__gte=today,
            status=0
        )

        tasks = []
        for task in tasks_qs:
            tasks.append({
                "id": task.id,
                "activity_type": task.schedule_activity_type.get_translated_value("name", "en") if task.schedule_activity_type else "",
                "description": task.get_translated_value("comment", "en") if task else "",
                "schedule_status": task.schedule_status.id if task.schedule_status else None,
                "schedule_status_name": task.schedule_status.get_translated_value("name", "en") if task.schedule_status else "",
            })

        response_data = {
            "id": crop.id,
            "crop": crop.get_translated_value("name", "en") if crop else "",
            "type": crop.croptype.get_translated_value("name", "en") if crop.croptype else "",
            "soil_type": mycrop.soil_type.get_translated_value("name", "en") if mycrop.soil_type else "",
            "plantation_date": mycrop.plantation_date.isoformat() if mycrop.plantation_date else None,
            "harvesting_type": mycrop.harvesting_type.get_translated_value("name", "en") if mycrop.harvesting_type else "",
            "measurement_value": land.measurement_value,
            "measurement_unit": land.measurement_unit.get_translated_value("name", "en") if land.measurement_unit else "",
            "expense": total_expenses,
            "sales": total_sales,
            "task": tasks,
        }

        return Response(response_data, status=status.HTTP_200_OK)

    except MyLand.DoesNotExist:
        return Response({"error": "Land not found for this farmer."}, status=status.HTTP_404_NOT_FOUND)

    except MyCrop.DoesNotExist:
        return Response({"error": "Crop not found for this land."}, status=status.HTTP_404_NOT_FOUND)



# region Add new api function by Bala
@extend_schema(operation_id="01_get_inventory_types_quantity",tags=["Inventory"],)
@api_view(['GET'])
def get_inventory_types_quantity(request, farmer_id):
    try:
        my_fuels = MyFuel.objects.filter(farmer_id=farmer_id, status__in=[0, 1])
        my_vehicles = MyVehicle.objects.filter(farmer_id=farmer_id, status__in=[0, 1])
        my_machinery = MyMachinery.objects.filter(farmer_id=farmer_id, status__in=[0, 1])
        my_tools = MyTools.objects.filter(farmer_id=farmer_id, status__in=[0, 1])
        my_seeds = MySeeds.objects.filter(farmer_id=farmer_id, status__in=[0, 1])
        my_fertilizers = MyFertilizers.objects.filter(farmer_id=farmer_id, status__in=[0, 1])
        my_pesticides = MyPesticides.objects.filter(farmer_id=farmer_id, status__in=[0, 1])

        total_fuel_liters = sum([float(fuel.quantity) if fuel.quantity is not None else 0 for fuel in my_fuels])
        total_vehicle_count = my_vehicles.count()
        total_machinery_count = my_machinery.count()
        total_tool_quantity = sum([float(tool.quantity) if tool.quantity is not None else 0 for tool in my_tools])
        total_seeds_quantity = sum([float(seeds.quantity) if seeds.quantity is not None else 0 for seeds in my_seeds])
        total_fertilizers_quantity = sum([float(fertilizers.quantity) if fertilizers.quantity is not None else 0 for fertilizers in my_fertilizers])
        total_pesticides_quantity = sum([float(pesticides.quantity) if pesticides.quantity is not None else 0 for pesticides in my_pesticides])

        response_data = [
            {
                'id': 1,
                'name': 'Vehicle',
                'unit_type': "No's",
                'quantity': total_vehicle_count
            },
            {
                'id': 2,
                'name': 'Machinery',
                'unit_type': "No's", 
                'quantity': total_machinery_count
            },
            {
                'id': 3,
                'name': 'Tools',
                'unit_type': "No's",
                'quantity': int(total_tool_quantity)
            },
            {
                'id': 4,
                'name': 'Pesticides / Fertilizers',
                'unit_type': "kg",
                'quantity': int(total_pesticides_quantity)
            },
            # {
            #     'id': 5,
            #     'name': 'Fertilizers',
            #     'unit_type': "kg",
            #     'quantity': int(total_fertilizers_quantity)
            # },
            {
                'id': 6,
                'name': 'Fuel',
                'unit_type': "liter",
                'quantity': int(total_fuel_liters)
            },
            {
                'id': 7,
                'name': 'Seeds',
                'unit_type': "kg",
                'quantity': int(total_seeds_quantity)
            }
        ]

        return Response(response_data, status=status.HTTP_200_OK)

    except Exception as e:
        return Response(
            {"error": f"An error occurred: {str(e)}"},
            status=status.HTTP_500_INTERNAL_SERVER_ERROR
        )


    except Exception as e:
        return Response(
            {"error": "Item not found.", "message": str(e)},
            status=status.HTTP_400_BAD_REQUEST
        )

@extend_schema(operation_id="02_get_inventory_items",tags=["Inventory"],)
@api_view(['GET'])
def get_inventory_items(request, inventory_type_id):
    language_code = request.GET.get('lang', 'en')  # Default to English

    inventory_type = get_object_or_404(InventoryType, id=inventory_type_id)
    
    inventory_items = InventoryItems.objects.filter(inventory_type_id=inventory_type_id, status=0)

    if not inventory_items.exists():
        return Response(
            {"error": "Category not found.", "message": f"No inventory items found for the given category - id {id}."},
            status=status.HTTP_400_BAD_REQUEST
        )

    serializer = InventoryItemsSerializer(inventory_items, many=True, context={'language_code': language_code})
    
    return Response({        
        "data": serializer.data
    }, status=200)
 
@extend_schema(operation_id="03_get_inventory_item_quantity",tags=["Inventory"],)
@api_view(['GET'])
def get_inventory_item_quantity(request, farmer_id, inventory_type_id, inventory_items_id):
    language_code = request.GET.get('lang', 'en') 

    farmer = get_object_or_404(Farmer, id=farmer_id)
    inventory_type = get_object_or_404(InventoryType, id=inventory_type_id)
    inventory_item = get_object_or_404(InventoryItems, id=inventory_items_id)

    qs = MyInventory.objects.filter(
        farmer=farmer,
        inventory_type=inventory_type,
        inventory_items=inventory_item
    )
    inventory_map = {
        1: ("Vehicle",False, ""),  
        2: ("Machinery",False, ""),   
        3: ("Tools",False, ""),   
        4: ("Pesticides",True, "kg"),   
        5: ("Fertilizers",True, "kg"),  
        6: ("Fuel",True, "liter"),
        7: ("Seeds",True, "kg"),   
    }
    inventory_type, has_quantity, unit_type = inventory_map[inventory_type.id]
    if not qs.exists():
        return Response(
            {"detail": "No inventory items found for the given category."},
            status=404
        )

    # Example: only return id & quantity
    data = list(qs.values("id", "available_quans"))[-1]
    data['name'] = inventory_type

    if has_quantity:
        data['unit_type'] = unit_type

    return Response(data, status=200)

@extend_schema(operation_id="01_get_inventory_purchase_list", parameters=[OpenApiParameter(name="page", type=int, location=OpenApiParameter.QUERY),],tags=["Inventory Purchase"],)
@api_view(['GET'])
def get_inventory_purchase_list(request, farmer_id, inventory_type_id, inventory_items_id):
    farmer = get_object_or_404(Farmer, id=farmer_id)
    inventory_type = get_object_or_404(InventoryType, id=inventory_type_id)
    inventory_items = get_object_or_404(InventoryItems, id=inventory_items_id)

    # Map inventory_type_id to actual purchase model and extra info
    inventory_map = {
        1: (MyVehicle, False, ""),  
        2: (MyMachinery, False, ""),   
        3: (MyTools, False, ""),   
        4: (MyPesticides, True, "kg"),   
        5: (MyFertilizers, True, "kg"),  
        6: (MyFuel, True, "liter"),
        7: (MySeeds, True, "kg"),   
    }

    if inventory_type.id not in inventory_map:
        return Response([], status=status.HTTP_200_OK)

    PurchaseModel, has_quantity, unit_type = inventory_map[inventory_type.id]

    # Filter the specific purchase records directly
    purchase_qs = PurchaseModel.objects.filter(
        farmer=farmer,
        inventory_type=inventory_type,
        inventory_items=inventory_items
    ).select_related('vendor') 

    paginator = PageNumberPagination()
    paginator.page_size = 10

    try:
        paginated_purchases = paginator.paginate_queryset(purchase_qs, request)
    except Exception:
        return Response({
            "error": "No more items.",
            "message": "You have reached the end of the list."
        }, status=status.HTTP_400_BAD_REQUEST)

    def format_purchase(purchase):
        result = {
            'id': purchase.id,
            'date_of_consumption': str(purchase.date_of_consumption or "N/A"),
            'purchase_amount': int(purchase.purchase_amount or 0),
            'vendor': {
                'id': purchase.vendor.id if purchase.vendor else None,
                'name': purchase.vendor.name if purchase.vendor else "Unknown",
            }
        }
        if has_quantity:
            result['quantity'] = int(purchase.quantity or 0)
            result['unit_type'] = unit_type
        return result

    response_data = [format_purchase(p) for p in paginated_purchases]
    return Response(response_data, status=status.HTTP_200_OK)

@extend_schema(operation_id="01_get_inventory_consumption_list", parameters=[OpenApiParameter(name="page", type=int, location=OpenApiParameter.QUERY),],tags=["Inventory Cusumption"],)
@api_view(['GET'])
def get_inventory_consumption_list(request, farmer_id, inventory_type_id, inventory_items_id):
    farmer = get_object_or_404(Farmer, id=farmer_id)
    inventory_type = get_object_or_404(InventoryType, id=inventory_type_id)
    inventory_items = get_object_or_404(InventoryItems, id=inventory_items_id)
    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'

    inventories = MyInventory.objects.filter(
        farmer=farmer,
        inventory_type=inventory_type,
        inventory_items=inventory_items,
    ).exclude(
        Q(quantity_utilized=0) | Q(usage_hours=0) | Q(start_kilometer=0) | Q(end_kilometer=0)
    ).select_related('crop', 'crop__crop')
    
    paginator = PageNumberPagination()
    paginator.page_size = 10

    try:
        paginated = paginator.paginate_queryset(inventories, request)
    except Exception:
        return Response({
            "error": "No more items.",
            "message": "You have reached the end of the list."
        }, status=status.HTTP_400_BAD_REQUEST)
    inventory_map = {
        1: (False, ""),  
        2: (False, "hrs"),   
        3: (False, "hrs"),   
        4: (True, "kg"),   
        5: (True, "kg"),  
        6: (True, "liter"),
        7: (True, "kg"),   
    }
    
    has_quantity, unit_type = inventory_map[inventory_type.id]    

    response_data = [
        {
            'id': int(inv.id),
            'quantity': int(inv.quantity_utilized) if inv.quantity_utilized is not None else None,
            'date_of_consumption': str(inv.date_of_consumption or "N/A"),
            'unit_type': unit_type,
            'start_kilometer': float(inv.start_kilometer) if inv.start_kilometer is not None else None,
            'end_kilometer': float(inv.end_kilometer) if inv.end_kilometer is not None else None,
            'usage_hours': float(inv.usage_hours) if inv.usage_hours is not None else None,
            'rental': int(inv.rental or 0),
            'crop_id': int(inv.crop.id) if inv.crop else None,
            'crop_name': inv.crop.crop.get_translated_value("name", language_code) if inv.crop else "Unknown Crop",
        }
        for inv in paginated
    ]


    return Response(response_data, status=status.HTTP_200_OK)

@extend_schema(operation_id="02_get_inventory_purchase_details",tags=["Inventory Purchase"],)
@api_view(['GET'])
def get_inventory_purchase_details(request, farmer_id, inventory_type_id, id):
    try:
        user_language_pref = UserLanguagePreference.objects.get(user=farmer_id)
        language_code = user_language_pref.language_code if user_language_pref.language_code else 'en'
    except UserLanguagePreference.DoesNotExist:
        language_code = 'en'
    # Map inventory_type_id to (Model, has_quantity, unit,docModel)
    inventory_map = {
        1: (MyVehicle, False, "", MyVehicleDocuments, 'vehicle_id'),  
        2: (MyMachinery, False, "", MyMachineryDocuments, 'machinary_id'),   
        3: (MyTools, False, "", MyToolsDocuments, 'tools_id'),   
        4: (MyPesticides, True, "kg", MyPesticidesDocuments, 'pest_id'),   
        5: (MyFertilizers, True, "kg", MyFertilizersDocuments, 'fertilizers_id'),  
        6: (MyFuel, True, "liter", MyFuelDocuments, 'fuel_id'),
        7: (MySeeds, True, "kg", MyseedsDocuments, 'seeds_id'),   
    }

    Model, has_quantity, unit, documentModel, documentModelGet = inventory_map[inventory_type_id]

    if inventory_type_id not in inventory_map:
        return Response({"detail": "Invalid inventory type."}, status=400)


    farmer = get_object_or_404(Farmer, id=farmer_id)
    try:
        item = Model.objects.select_related('vendor').get(id=id, farmer=farmer)
    except Model.DoesNotExist:
        return Response(
            {"error": "Item not found.", "message": f"No inventory found with id {id}."},
            status=status.HTTP_400_BAD_REQUEST
        )
    data = {
        "id": item.id,
        "date_of_consumption": str(item.date_of_consumption) if hasattr(item, 'date_of_consumption') and item.date_of_consumption else None,
        "purchase_amount": str(item.purchase_amount or "0.00"),
        "vendor": {
            "id": getattr(item.vendor, "id", None),
            "name": getattr(item.vendor, "name", None),
        },
        "inventory_type": {
            "id": item.inventory_type.id if item.inventory_type else None,
            "name": item.inventory_type.get_translated_value("name", language_code) if item.inventory_type else "Unknown",
        },
        "inventory_items": {
            "id": item.inventory_items.id if item.inventory_items else None,
            "name": item.inventory_items.get_translated_value("name", language_code) if item.inventory_items else None,
        },
        "quantity_unit": (item.quantity_unit.get_translated_value("name", language_code) if hasattr(item, 'quantity_unit') and item.quantity_unit else None ),
        "status": item.status if hasattr(item, "status") else None,
        "register_number": item.register_number if hasattr(item, "register_number") and item.register_number else None,
        "owner_name": item.get_translated_value("owner_name", language_code) if hasattr(item, "owner_name") and item.owner_name else None,
        "date_of_registration": str(item.date_of_registration) if hasattr(item, "date_of_registration") and item.date_of_registration else None,
        "engine_number": item.engine_number if hasattr(item, "engine_number") and item.engine_number else None,
        "chasis_number": item.chasis_number if hasattr(item, "chasis_number") and item.chasis_number else None,
        "running_kilometer": int(item.running_kilometer) if hasattr(item, "running_kilometer") and item.running_kilometer else 0,
        "average_mileage": int(item.average_mileage) if hasattr(item, "average_mileage") and item.average_mileage else 0,
        "insurance": item.insurance if hasattr(item, "insurance") else None,
        "company_name": item.get_translated_value("company_name", language_code) if hasattr(item, "company_name") and item.company_name else None,
        "insurance_no": item.insurance_no if hasattr(item, "insurance_no") and item.insurance_no else None,
        "insurance_amount": int(item.insurance_amount) if hasattr(item, "insurance_amount") and item.insurance_amount else 0,
        "insurance_start_date": str(item.insurance_start_date) if hasattr(item, "insurance_start_date") and item.insurance_start_date else None,
        "insurance_end_date": str(item.insurance_end_date) if hasattr(item, "insurance_end_date") and item.insurance_end_date else None,
        "insurance_renewal_date": str(item.insurance_renewal_date) if hasattr(item, "insurance_renewal_date") and item.insurance_renewal_date else None,
        "fuel_capacity": int(item.fuel_capacity) if hasattr(item, "fuel_capacity") and item.fuel_capacity else 0,
        "warranty_start_date": str(item.warranty_start_date) if hasattr(item, "warranty_start_date") and item.warranty_start_date else None,
        "warranty_end_date": str(item.warranty_end_date) if hasattr(item, "warranty_end_date") and item.warranty_end_date else None,
        "description": item.description if item.description else None,
        "documents": []
    }

    machinery_documents = documentModel.objects.filter(**{documentModelGet: item})
    for doc in machinery_documents:
        file_type = doc.file_type.get_translated_value("name", language_code) if doc.file_type else "Unknown"
        file_type_id = doc.file_type.id if doc.file_type else None
        document_data = {
            'id': doc.id,
            'document': request.build_absolute_uri(f'/SuperAdmin{doc.document.url}' if doc.document else doc.document.url) if doc.document else "",
        }

        # Group documents by file_type
        if file_type not in data['documents']:
            data['documents'][file_type] = {
                'id': file_type_id,
                'name': file_type,
                'documents': []
            }
        data['documents'][file_type]['documents'].append(document_data)

 
    if has_quantity:
        data.update({
            "quantity": str(getattr(item, "quantity", "0.00")),
            "unit_type": unit,
        })

    return Response(data)

@extend_schema(  operation_id="02_get_inventory_cusumption_details",tags=["Inventory Cusumption"],)
@api_view(['GET'])
def get_inventory_cusumption_details(request, farmer_id, inventory_type_id, id):
    # Validate inventory type early
    inventory_map = {
        1: (False, "", MyVehicleDocuments),
        2: (False, "hrs", MyMachineryDocuments),
        3: (False, "hrs", MyToolsDocuments),
        4: (True, "kg", MyPesticidesDocuments),
        5: (True, "kg", MyFertilizersDocuments),
        6: (True, "liter", MyFuelDocuments),
        7: (True, "kg", MyseedsDocuments),
    }

    inventory_type_data = inventory_map.get(inventory_type_id)
    if not inventory_type_data:
        return Response(
            {"error": "Invalid inventory type."},
            status=status.HTTP_400_BAD_REQUEST
        )

    has_quantity, unit_type, DocumentModel = inventory_type_data

    # Get inventory object with related fields
    inventory = MyInventory.objects.select_related(
        'crop__crop', 'inventory_items', 'inventory_type'
    ).filter(id=id).first()

    if not inventory:
        return Response(
            {"error": "Item not found.", "message": f"No inventory found with id {id}."},
            status=status.HTTP_400_BAD_REQUEST
        )

    language_code = request.headers.get('Accept-Language', 'en')

    # Helper for safe attribute fetching and translation
    def safe_translated(obj, attr):
        return obj.get_translated_value(attr, language_code) if obj else None

    response_data = {
        'id': inventory.id,
        'quantity': int(inventory.quantity_utilized) if inventory.quantity_utilized else None,
        'date_of_consumption': str(inventory.date_of_consumption) if inventory.date_of_consumption else None,
        'start_kilometer': int(inventory.start_kilometer) if inventory.start_kilometer else None,
        'end_kilometer': int(inventory.end_kilometer) if inventory.end_kilometer else None,
        'usage_hours': int(inventory.usage_hours) if inventory.usage_hours else None,
        'rental': int(inventory.rental) if inventory.rental else None,
        'crop_id': getattr(inventory.crop, 'id', None),
        'crop_name': safe_translated(inventory.crop.crop if inventory.crop else None, "name"),
        'inventory_items': {
            'id': getattr(inventory.inventory_items, 'id', None),
            'name': safe_translated(inventory.inventory_items, "name") or "Unknown",
        },
        'inventory_type': {
            'id': getattr(inventory.inventory_type, 'id', None),
            'name': safe_translated(inventory.inventory_type, "name") or "Unknown",
        },
        'description': safe_translated(inventory, "description"),
        'documents': []
    }

    # Group documents by file_type
    documents = DocumentModel.objects.filter(fuel=inventory.fuel_purchase).select_related('file_type')
    grouped_documents = defaultdict(lambda: {'id': None, 'name': '', 'documents': []})

    for doc in documents:
        file_type = safe_translated(doc.file_type, "name") or "Unknown"
        file_type_id = getattr(doc.file_type, 'id', None)
        document_url = request.build_absolute_uri(f'/SuperAdmin{doc.document.url}') if doc.document else ""

        grouped_documents[file_type]['id'] = file_type_id
        grouped_documents[file_type]['name'] = file_type
        grouped_documents[file_type]['documents'].append({
            'id': doc.id,
            'document': document_url,
        })

    response_data['documents'] = list(grouped_documents.values())

    return Response(response_data, status=status.HTTP_200_OK)

@extend_schema( parameters=[OpenApiParameter(name="page", type=int, location=OpenApiParameter.QUERY),],tags=["Customer Outstanding"])
@api_view(['GET'])
def get_customer_payables_list(request, farmer_id):
    customers = MyCustomer.objects.filter(
        farmer_id=farmer_id,
        status=0,
        is_customer_is_vendor=False,
        is_credit=False
    ).only('id', 'customer_name', 'shop_name', 'is_credit', 'opening_balance')

    paginator = PageNumberPagination()
    paginator.page_size = 5

    
    try:
        paginated_customers = paginator.paginate_queryset(customers, request)
    except Exception:
        return Response({
            "error": "No more items.",
            "message": "You have reached the end of the list."
        }, status=status.HTTP_400_BAD_REQUEST)

    customer_payables_data = [
        {
            "id": c.id,
            "name": c.customer_name,
            "business_name": c.shop_name,
            "is_credit": c.is_credit,
            "balance": c.opening_balance,
        }
        for c in paginated_customers
    ]

    return Response(customer_payables_data, status=status.HTTP_200_OK)

@extend_schema(parameters=[OpenApiParameter(name="page", type=int, location=OpenApiParameter.QUERY),],tags=["Customer Outstanding"])
@api_view(['GET'])
def get_customer_receivables_list(request, farmer_id):
    customers = MyCustomer.objects.filter(
        farmer_id=farmer_id,
        status=0,
        is_customer_is_vendor=False,
        is_credit=True
    ).only('id', 'customer_name', 'shop_name', 'is_credit', 'opening_balance')

    paginator = PageNumberPagination()
    paginator.page_size = 5

    try:
        paginated_customers = paginator.paginate_queryset(customers, request)
    except Exception:
        return Response({
            "error": "No more items.",
            "message": "You have reached the end of the list."
        }, status=status.HTTP_400_BAD_REQUEST)
    
    customer_receivables_data = []

    for customer in paginated_customers:
        customer_info = {
            "id": customer.id,
            "name": customer.customer_name,
            "business_name": customer.shop_name,
            "is_credit": customer.is_credit,
            "balance": customer.opening_balance,
        }
        customer_receivables_data.append(customer_info)
        
    return Response(customer_receivables_data, status=status.HTTP_200_OK)

@extend_schema(parameters=[OpenApiParameter(name="page", type=int, location=OpenApiParameter.QUERY),],tags=["Vendors Outstanding"])
@api_view(['GET'])
def get_vendors_payables_list(request, farmer_id):
    vendors = MyVendor.objects.filter(
        farmer_id=farmer_id,
        status=0,
        is_customer_is_vendor=False,
        credit=False
    ).only('id', 'name', 'business_name', 'credit', 'opening_balance')

    paginator = PageNumberPagination()
    paginator.page_size = 10
    
    try:
        paginated_vendors = paginator.paginate_queryset(vendors, request)
    except Exception:
        return Response({
            "error": "No more items.",
            "message": "You have reached the end of the list."
        }, status=status.HTTP_400_BAD_REQUEST)

    vendors_payables_data = []

    for vendor in paginated_vendors:
        vendor_info = {
            "id": vendor.id,
            "name": vendor.name,
            "business_name": vendor.business_name,
            "is_credit": vendor.credit,
            "balance": vendor.opening_balance,
        }
        vendors_payables_data.append(vendor_info)

    return Response(vendors_payables_data, status=status.HTTP_200_OK)

@extend_schema(parameters=[OpenApiParameter(name="page", type=int, location=OpenApiParameter.QUERY),],tags=["Vendors Outstanding"])
@api_view(['GET'])
def get_vendors_receivables_list(request, farmer_id):
    vendors = MyVendor.objects.filter(
        farmer_id=farmer_id,
        status=0,
        is_customer_is_vendor=False,
        credit=True
    ).only('id', 'name', 'business_name', 'credit', 'opening_balance')

    paginator = PageNumberPagination()
    paginator.page_size = 10
    
    try:
        paginated_vendors = paginator.paginate_queryset(vendors, request)
    except Exception:
        return Response({
            "error": "No more items.",
            "message": "You have reached the end of the list."
        }, status=status.HTTP_400_BAD_REQUEST)

    vendors_receivables_data = []

    for vendor in paginated_vendors:
        vendor_info = {
            "id": vendor.id,
            "name": vendor.name,
            "business_name": vendor.business_name,
            "is_credit": vendor.credit,
            "balance": vendor.opening_balance,
        }
        vendors_receivables_data.append(vendor_info)

    return Response(vendors_receivables_data, status=status.HTTP_200_OK)



# ---------------- CREATE EMPLOYEE ----------------
@extend_schema(
    request=None,
    responses={201: dict},
    tags=["Employee Management"]
)
@api_view(['POST'])
def create_employee(request):
    data = request.data
    try:
        # Handle both farmer and manager relationships
        farmer_id = data.get("farmer_id")
        manager_id = data.get("manager_id")
        
        farmer = None
        manager = None
        
        if farmer_id:
            farmer = get_object_or_404(Farmer, id=farmer_id)
        if manager_id:
            manager = get_object_or_404(ManagerUser, id=manager_id)
        
        # Create employee
        employee = Employee.objects.create(
            farmer=farmer,
            manager=manager,
            name=data.get("name"),
            mobile_no=data.get("mobile_no"),
            employee_type_id=data.get("employee_type"),
            work_type_id=data.get("work_type"),
            locations=data.get("locations"),
            latitude=data.get("latitude"),
            longitude=data.get("longitude"),
            door_no=data.get("door_no"),
            pincode=data.get("pincode"),
            description=data.get("description"),
            status=data.get("status", 0),
            created_by=farmer.farmer_user
        )
        
        # Handle image upload if provided
        if 'image' in request.FILES:
            employee.image = request.FILES['image']
            employee.save()

        return Response({"message": "Employee created", "id": employee.id}, status=status.HTTP_201_CREATED)
    except Exception as e:
        return Response({"error": str(e)}, status=status.HTTP_400_BAD_REQUEST)


# ---------------- UPDATE EMPLOYEE ----------------
@extend_schema(
    request=None,
    responses={200: dict},
    tags=["Employee Management"]
)
@api_view(['PUT'])
def update_employee(request, employee_id):
    employee = get_object_or_404(Employee, id=employee_id)
    data = request.data

    try:
        # Update relationships
        if "farmer_id" in data:
            employee.farmer = get_object_or_404(Farmer, id=data["farmer_id"]) if data["farmer_id"] else None
        if "manager_id" in data:
            employee.manager = get_object_or_404(ManagerUser, id=data["manager_id"]) if data["manager_id"] else None
        
        # Update foreign key fields and other fields
        fields_mapping = {
            "name": "name",
            "mobile_no": "mobile_no",
            "employee_type": "employee_type_id",
            "work_type": "work_type_id",
            "salary": "salary",
            "advance": "advance",
            "topay": "topay",
            "locations": "locations",
            "latitude": "latitude",
            "longitude": "longitude",
            "country": "country_id",
            "state": "state_id",
            "city": "city_id",
            "taluk": "taluk_id",
            "village": "village_id",
            "door_no": "door_no",
            "pincode": "pincode",
            "description": "description",
            "authority_users": "authority_users",
            "my_farms": "my_farms",
            "my_sales": "my_sales",
            "my_expense": "my_expense",
            "my_inventory": "my_inventory",
            "attendance_payouts": "attendance_payouts",
            "username": "username",
            "password": "password",
            "employee_user": "employee_user_id",
            "status": "status",
            "translate_json": "translate_json"
        }

        for field, model_field in fields_mapping.items():
            if field in data:
                setattr(employee, model_field, data[field])
        
        # Handle image update
        if 'image' in request.FILES:
            employee.image = request.FILES['image']
        
        employee.updated_by = request.user if request.user.is_authenticated else None
        employee.save()
        
        # Handle document uploads
        if 'documents' in request.FILES:
            documents = request.FILES.getlist('documents')
            for doc_file in documents:
                EmployeeDocument.objects.create(
                    employee=employee,
                    upload_document=doc_file,
                    created_by=request.user if request.user.is_authenticated else None
                )
        
        return Response({"message": "Employee updated"})
    except Exception as e:
        return Response({"error": str(e)}, status=status.HTTP_400_BAD_REQUEST)


# ---------------- DELETE EMPLOYEE ----------------
@extend_schema(
    responses={200: dict},
    tags=["Employee Management"]
)
@api_view(['DELETE'])
def delete_employee(request, employee_id):
    employee = get_object_or_404(Employee, id=employee_id)
    employee.delete()
    return Response({"message": "Employee deleted"})


# ---------------- STATUS UPDATE ----------------
@extend_schema(
    request=None,
    responses={200: dict},
    tags=["Employee Management"]
)
@api_view(['PATCH'])
def update_employee_status(request, employee_id):
    employee = get_object_or_404(Employee, id=employee_id)
    status_val = request.data.get("status")
    if status_val is None:
        return Response({"error": "status required"}, status=status.HTTP_400_BAD_REQUEST)

    employee.status = status_val
    employee.updated_by = request.user if request.user.is_authenticated else None
    employee.save()
    return Response({"message": "Status updated"})


# ---------------- GET EMPLOYEE DETAILS ----------------
@extend_schema(
    parameters=[
        OpenApiParameter(name="employee_id", type=int, location=OpenApiParameter.PATH),
    ],
    responses={200: dict},
    tags=["Employee Management"]
)
@api_view(['GET'])
def get_employee_details(request, employee_id):
    employee = get_object_or_404(Employee.objects.select_related(
        "farmer", "manager", "employee_type", "work_type", "country", 
        "state", "city", "taluk", "village", "employee_user"
    ), id=employee_id)
    
    # Get employee documents
    documents = EmployeeDocument.objects.filter(employee=employee).values(
        'id', 'upload_document', 'status', 'created_at'
    )

    data = {
        "id": employee.id,
        "name": employee.name,
        "mobile_no": employee.mobile_no,
        "employee_type": employee.employee_type.name if employee.employee_type else None,
        "work_type": employee.work_type.name if employee.work_type else None,
        "salary": str(employee.salary) if employee.salary else "0",
        "farmer": {
            "id": employee.farmer.id,
            "name": employee.farmer.name
        } if employee.farmer else None,
        "manager": {
            "id": employee.manager.id,
            "name": employee.manager.name
        } if employee.manager else None,
        "advance": str(employee.advance),
        "topay": str(employee.topay),
        "status": employee.status,
        "locations": employee.locations,
        "latitude": employee.latitude,
        "longitude": employee.longitude,
        "address": {
            "door_no": employee.door_no,
            "pincode": employee.pincode,
            "country": employee.country.name if employee.country else None,
            "state": employee.state.name if employee.state else None,
            "city": employee.city.name if employee.city else None,
            "taluk": employee.taluk.name if employee.taluk else None,
            "village": employee.village.name if employee.village else None,
        },
        "image": employee.image.url if employee.image else None,
        "description": employee.description,
        "permissions": {
            "authority_users": employee.authority_users,
            "my_farms": employee.my_farms,
            "my_sales": employee.my_sales,
            "my_expense": employee.my_expense,
            "my_inventory": employee.my_inventory,
            "attendance_payouts": employee.attendance_payouts,
        },
        "username": employee.username,
        "employee_user": employee.employee_user.username if employee.employee_user else None,
        "translate_json": employee.translate_json,
        "documents": list(documents),
        "created_at": employee.created_at,
        "updated_at": employee.updated_at
    }

    return Response({"employee": data}, status=status.HTTP_200_OK)


# ---------------- GET EMPLOYEES BY FARMER (SPECIFIC) ----------------
@extend_schema(
    parameters=[
        OpenApiParameter("page", type=int, location=OpenApiParameter.QUERY),
        OpenApiParameter("page_size", type=int, location=OpenApiParameter.QUERY),
        OpenApiParameter("search", type=str, location=OpenApiParameter.QUERY),
    ],
    tags=["Employee Management"]
)
@api_view(['GET'])
def get_employees_by_farmer(request, farmer_id):
    """
    Get employees list for a specific farmer
    """
    try:
        farmer = get_object_or_404(Farmer, id=farmer_id)
        employees = Employee.objects.filter(farmer=farmer).select_related(
            "employee_type", "work_type", 
        )
        
        search_word = request.query_params.get("search")
        if search_word:
            employees = employees.filter(
                Q(name__icontains=search_word) | 
                Q(mobile_no__icontains=search_word)
            )
        
        paginator = PageNumberPagination()
        paginator.page_size = int(request.query_params.get("page_size", 10))
        page_obj = paginator.paginate_queryset(employees.order_by("-id"), request)
        
        data = []
        for emp in page_obj:
            data.append({
                "id": emp.id,
                "name": emp.name,
                "mobile_no": emp.mobile_no,
                "employee_type": emp.employee_type.name if emp.employee_type else None,
                "work_type": emp.work_type.name if emp.work_type else None,
                "salary": str(emp.salary) if emp.salary else "0",
                "advance": str(emp.advance),
                "topay": str(emp.topay),
                "status": emp.status,
                "locations": emp.locations,
                "image": emp.image.url if emp.image else None
            })
        
        return paginator.get_paginated_response({
            "farmer": {
                "id": farmer.id,
                "name": farmer.name
            },
            "employees": data
        })
    
    except Exception as e:
        return Response({"error": str(e)}, status=status.HTTP_400_BAD_REQUEST)



# ---------------- GET Attendance list BY FARMER (SPECIFIC) ----------------
@extend_schema(
    parameters=[  OpenApiParameter("date", type=str, location=OpenApiParameter.QUERY),
        OpenApiParameter("page", type=int, location=OpenApiParameter.QUERY),
        OpenApiParameter("page_size", type=int, location=OpenApiParameter.QUERY),
        OpenApiParameter("search", type=str, location=OpenApiParameter.QUERY),
        OpenApiParameter("farmer_id", type=str, location=OpenApiParameter.QUERY),
        OpenApiParameter("manager_id", type=str, location=OpenApiParameter.QUERY),
      
    ],
    tags=["Employee Management"]
)
@api_view(['GET'])
def get_employees_attendance_list(request,):
    try:
        date =request.query_params.get("date")
        farmer_id =request.query_params.get("farmer_id")
        manager_id =request.query_params.get("manager_id")
        employees =None 
        if farmer_id:
            employees = Employee.objects.filter(farmer=farmer_id).select_related("employee_type", "work_type",)
        elif farmer_id:
            employees = Employee.objects.filter(manager=manager_id).select_related("employee_type", "work_type",)
        else:
            Response({"error": 'NO Details'}, status=status.HTTP_400_BAD_REQUEST)


        search_word = request.query_params.get("search")
        if search_word:
            employees = employees.filter(
                Q(name__icontains=search_word) | 
                Q(mobile_no__icontains=search_word)
            )
        
        paginator = PageNumberPagination()
        paginator.page_size = int(request.query_params.get("page_size", 10))
        page_obj = paginator.paginate_queryset(employees, request)
        
        data = []
        for emp in page_obj:
            attendance = None
            try:
                attendance = AttendanceReport.objects.filter(employee=emp, created_at__date=date).first()
            except Exception as e:
                print(f"Error fetching attendance for employee {emp.id}: {e}")
            finally:
                print(f"Processed employee {emp.id}")

            data.append({
                "id": emp.id,
                "name": emp.name,
                "role": "Employee",
                "salaryType": emp.employee_type.name if emp.employee_type else None,
                "work_type": emp.work_type.name if emp.work_type else None,
                "image": emp.image.url if emp.image else None,
                "login": attendance.login_time if attendance and attendance.login_time else None,
                "logout": attendance.logout_time if attendance and attendance.logout_time else None,
                "hours": attendance.total_hour if attendance and attendance.total_hour else None,
                "salary": attendance.salary if attendance and attendance.salary else None,
                "paid_status": attendance.salary_status if attendance and attendance.salary_status else None,
            })

        
        return Response(data, status=status.HTTP_200_OK)
    
    except Exception as e:
        return Response({"error": str(e)}, status=status.HTTP_400_BAD_REQUEST)




# ---------------- CREATE ----------------
@extend_schema(tags=["ManagerUser Management"])
@api_view(['POST'])
def create_manager_user(request):

    data = request.data
    required_fields = ['name']
    errors = {}
    for field in required_fields:
        if not data.get(field):
            errors[field] = f"{field} is required"

    if errors:
        return Response({"status_code": 400, "error": "validation_error", "message": errors}, status=status.HTTP_400_BAD_REQUEST)

    try:
        manager_user = ManagerUser.objects.create(
            name=data.get('name'),
            farmer=Farmer.objects.get(id=data['farmer']) if data.get('farmer') else None,
            mobile_no=data.get('mobile_no'),
            alter_no=data.get('alter_no'),
            date_of_birth=data.get('date_of_birth'),
            gender_id=data.get('gender'),
            email=data.get('email'),
            date_of_join=data.get('date_of_join'),
            employee_type_id=data.get('employee_type'),
            image=data.get('image'),
            address=data.get('address'),
            pincode=data.get('pincode'),
            locations=data.get('locations'),
            latitude=data.get('latitude'),
            longitude=data.get('longitude'),
            role_id=data.get('role'),
            description=data.get('description'),
            username=data.get('username'),
            password=data.get('password'),
            manager_user=CustomUser.objects.get(id=data['manager_user']) if data.get('manager_user') else None,
            status=data.get('status', 0),
            created_by=CustomUser.objects.get(id=data['created_by']) if data.get('created_by') else None,
            translate_json=data.get('translate_json'),
            permissions=data.get('permissions'),
        )
        return Response({"status_code": 201, "message": "ManagerUser created successfully", "manager_user_id": manager_user.id}, status=status.HTTP_201_CREATED)
    except Exception as e:
        return Response({"status_code": 500, "error": "server_error", "message": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

# ---------------- UPDATE ----------------
@extend_schema(tags=["ManagerUser Management"])
@api_view(['PUT'])
def update_manager_user(request, manager_id):
    manager_user = get_object_or_404(ManagerUser, id=manager_id)
    data = request.data
    # Dynamic update only provided fields
    for field in data:
        if hasattr(manager_user, field):
            setattr(manager_user, field, data[field])
    try:
        manager_user.save()
        return Response({"status_code": 200, "message": "ManagerUser updated successfully"}, status=status.HTTP_200_OK)
    except Exception as e:
        return Response({"status_code": 500, "error": "server_error", "message": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

# ---------------- DELETE ----------------
@extend_schema(tags=["ManagerUser Management"])
@api_view(['DELETE'])
def delete_manager_user(request, manager_id):
    manager_user = get_object_or_404(ManagerUser, id=manager_id)
    manager_user.delete()
    return Response({"status_code": 200, "message": "ManagerUser deleted successfully"}, status=status.HTTP_200_OK)

# ---------------- STATUS UPDATE ----------------
@extend_schema(tags=["ManagerUser Management"])
@api_view(['PATCH'])
def update_manager_user_status(request, manager_id):
    manager_user = get_object_or_404(ManagerUser, id=manager_id)
    status_value = request.data.get('status')
    if status_value is None:
        return Response({"status_code": 400, "error": "validation_error", "message": "status is required"}, status=status.HTTP_400_BAD_REQUEST)
    manager_user.status = status_value
    manager_user.save(update_fields=['status'])
    return Response({"status_code": 200, "message": "ManagerUser status updated successfully"}, status=status.HTTP_200_OK)

# ---------------- GET LIST ----------------
@extend_schema(parameters=[
    OpenApiParameter(name="page", type=int, location=OpenApiParameter.QUERY),
    OpenApiParameter(name="search", type=str, location=OpenApiParameter.QUERY)
], tags=["ManagerUser Management"])
@api_view(['GET'])
def get_manager_user_list(request, farmer_id):
    search = request.GET.get('search', '')
    managers = ManagerUser.objects.filter(
        farmer_id=farmer_id
    ).select_related('farmer', 'role').only('id', 'name', 'status', 'role__name')

    if search:
        managers = managers.filter(name__icontains=search)

    paginator = PageNumberPagination()
    paginator.page_size = 10
    paginated = paginator.paginate_queryset(managers, request)
    data = [{"id": m.id, "name": m.name, "status": m.status, "role": m.role.name if m.role else None} for m in paginated]
    return paginator.get_paginated_response(data)

# ---------------- GET DETAIL ----------------
@extend_schema(tags=["ManagerUser Management"])
@api_view(['GET'])
def get_manager_user_detail(request, manager_id):
    manager = get_object_or_404(ManagerUser.objects.select_related('farmer', 'role'), id=manager_id)
    data = {
        "id": manager.id,
        "name": manager.name,
        "mobile_no": manager.mobile_no,
        "alter_no": manager.alter_no,
        "email": manager.email,
        "date_of_birth": manager.date_of_birth,
        "role": manager.role.name if manager.role else None,
        "status": manager.status,
        "farmer": {"id": manager.farmer.id, "name": manager.farmer.name} if manager.farmer else None
    }
    return Response({"status_code": 200, "manager_user": data}, status=status.HTTP_200_OK)


@extend_schema(
    operation_id="02_employee_types",
    tags=["Employee"],
)
@api_view(['GET'])
def get_employee_types(request):
    lang = request.GET.get('lang', 'en')  # Default to English

    employee_types = EmployeeType.objects.filter(status=0).only("id", "name")

    if not employee_types.exists():
        return Response(
            {"error": "EmployeeType not found", "message": "No Employee Type found."},
            status=status.HTTP_404_NOT_FOUND
        )

    data = [
        {"id": e.id, "name": e.get_translated_value("name", lang)}
        for e in employee_types
    ]

    return Response(data, status=status.HTTP_200_OK)

@extend_schema(
    operation_id="02_manageUser_role",
    tags=["Employee"],
)
@api_view(['GET'])
def get_manager_roals(request):
    lang = request.GET.get('lang', 'en')  

    manager_types = ManageUserRole.objects.filter(status=0).only("id", "name")
    if not manager_types.exists():
        return Response(
            {"error": "EmployeeType not found", "message": "No Employee Type found."},
            status=status.HTTP_404_NOT_FOUND
        )
    data = [
        {"id": e.id, "name": e.name}
        for e in manager_types
    ]
    return Response(data, status=status.HTTP_200_OK)

@extend_schema(operation_id="02_genders",tags=["Genders"],)
@api_view(['GET'])
def get_genders(request):
    lang = request.GET.get('lang', 'en')  

    gender_types = Gender.objects.filter(status=0).only("id", "gender")
    if not gender_types.exists():
        return Response(
            {"error": "EmployeeType not found", "message": "No Employee Type found."},
            status=status.HTTP_404_NOT_FOUND
        )
    data = [
        {"id": e.id, "name": e.gender}
        for e in gender_types
    ]
    return Response(data, status=status.HTTP_200_OK)

@extend_schema(operation_id="vendor_payables",tags=["Vendors Outstanding"],)
@api_view(['GET'])
def get_vendor_payables(request, vendor_id):   
    # vendor_id = request.query_params.get('vendor_id', None)
 
    # Fetching vendors based on the farmer ID and the status.
    vendor = MyVendor.objects.get(id=vendor_id, status=0)

    vendor_inventory_data = None

   
    if vendor.credit is False: 
        fuel_purchases = MyExpense.objects.filter(vendor=vendor, status__in=[0, 1]) 
        payables_fuel = []

        for fuel in fuel_purchases:
            fuel_data = {
                "id": fuel.id,
                "date": fuel.created_day,
                "total_amount": fuel.paid_amount,
                "amount_paid":fuel.paid_amount,   
                "received_amount": 0.0,   
                "to_amount": fuel.amount
            }
            payables_fuel.append(fuel_data)

        # If any items exist for the vendor, append to the final structure
        if any([payables_fuel]):
            vendor_inventory_data = {
                "id": vendor.id,
                "name": vendor.name,
                "business_name": vendor.business_name,
                "vendor_image": request.build_absolute_uri(f'/assets{vendor.vendor_image.url}' if vendor.vendor_image else vendor.vendor_image.url) if vendor.vendor_image else "",
                "expenses": payables_fuel
            }

    return Response( vendor_inventory_data, status=status.HTTP_200_OK)


@extend_schema(operation_id="vendors_receivables",tags=["Vendors Outstanding"],)
@api_view(['GET'])
def get_vendors_receivables(request, vendor_id):   
    # vendor_id = request.query_params.get('vendor_id', None)
 
    # Fetching vendors based on the farmer ID and the status.
    vendor = MyVendor.objects.get(id=vendor_id, status=0)

    vendor_inventory_data = None

   
    if vendor.credit : 
        fuel_purchases = MyExpense.objects.filter(vendor=vendor, status__in=[0, 1]) 
        payables_fuel = []

        for fuel in fuel_purchases:
            fuel_data = {
                "id": fuel.id,
                "date": fuel.created_day,
                "total_amount": fuel.paid_amount,
                "amount_paid":fuel.paid_amount,   
                "received_amount": 0.0,   
                "to_amount": fuel.amount
            }
            payables_fuel.append(fuel_data)

        # If any items exist for the vendor, append to the final structure
        if any([payables_fuel]):
            vendor_inventory_data = {
                "id": vendor.id,
                "name": vendor.name,
                "business_name": vendor.business_name,
                "vendor_image": request.build_absolute_uri(f'/assets{vendor.vendor_image.url}' if vendor.vendor_image else vendor.vendor_image.url) if vendor.vendor_image else "",
                "expenses": payables_fuel
            }

    return Response( vendor_inventory_data, status=status.HTTP_200_OK)


@extend_schema(operation_id="vendors_outstaing_history",tags=["Vendors Outstanding"],)
@api_view(['GET'])
def get_vendors_outstaing_history(request, expense_id):      

    records = Outstanding.objects.filter(expense=expense_id, status__in=[0, 1]) 
    history = []

    for record in records:
        fuel_data = {
          
            "id": record.id,
            "balance":  float(record.balance),
            "paid": float(record.paid),
            "payment_amount":  float(record.payment_amount),
            "to_pay": float(record.to_pay),
            "total_paid":  float(record.total_paid),
            "paid_date":record.paid_date.strftime('%d-%m-%Y') if record.paid_date else None,
            "description":record.description,
            "status": record.status,
  
        }
        history.append(fuel_data)

    return Response( history, status=status.HTTP_200_OK)



# ---------------- UPDATE ATTENDANCE REPORT ----------------
@extend_schema(
    request=None,
    responses={200: dict},
    tags=["Attendance Management"]
)
@api_view(['POST'])
def add_attendance(request,):
    """
    Update an existing attendance report
    """
    for data in request.data:
        employee = get_object_or_404(Employee.objects.select_related('farmer',), id=data['employee_id'])
        try:
            attendance = AttendanceReport.objects.filter(employee=employee, created_at__date=data['created_day']).first()
            if attendance is None:
                attendance = AttendanceReport.objects.create(farmer=employee.farmer, employee=employee, created_at=timezone.now(),)
            # Update fields if provided
            update_fields = []
            
            if 'employee_id' in data:
                employee = get_object_or_404(Employee, id=data['employee_id'])
                attendance.employee = employee
                attendance.farmer = employee.farmer
                update_fields.extend(['employee', 'farmer'])
            
            if 'present' in data:
                attendance.present = data['present']
                update_fields.append('present')
            
            if 'created_day' in data:
                # Check for duplicate attendance if date is being changed
                if data['created_day'] != str(attendance.created_day):
                    existing = AttendanceReport.objects.filter(
                        employee=attendance.employee,
                        created_day=data['created_day']
                    ).exclude(id=attendance.id).first()
                    if existing:
                        return Response({
                            "error": "Attendance already exists for this employee on the specified day",
                            "attendance_id": existing.id
                        }, status=status.HTTP_400_BAD_REQUEST)
                attendance.created_day = data['created_day']
                update_fields.append('created_day')
            
            # Handle time calculations
            login_time = data.get('login_time', attendance.login_time)
            logout_time = data.get('logout_time', attendance.logout_time)
            
            total_hour = attendance.total_hour
            if 'login_time' in data or 'logout_time' in data:
                if login_time and logout_time:
                    try:
                        time_formats = ['%H:%M:%S', '%H:%M', '%I:%M %p', '%I:%M:%S %p']
                        login_dt = None
                        logout_dt = None
                        
                        for time_format in time_formats:
                            try:
                                login_dt = datetime.strptime(login_time, time_format).time()
                                logout_dt = datetime.strptime(logout_time, time_format).time()
                                break
                            except ValueError:
                                continue
                        
                        if login_dt and logout_dt:
                            login_datetime = datetime.combine(datetime.today(), login_dt)
                            logout_datetime = datetime.combine(datetime.today(), logout_dt)
                            
                            if logout_datetime < login_datetime:
                                logout_datetime += timedelta(days=1)
                            
                            time_diff = logout_datetime - login_datetime
                            total_hour = round(time_diff.total_seconds() / 3600, 2)
                            attendance.total_hour = total_hour
                            update_fields.append('total_hour')
                            
                    except Exception as e:
                        return Response({"error": f"Invalid time format: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)
            
            attendance.login_time = login_time
            attendance.logout_time = logout_time
            update_fields.extend(['login_time', 'logout_time'])
            
            # Update salary
            if 'salary' in data:
                attendance.salary = data['salary']
                update_fields.append('salary')

            
            if 'salary_status' in data:
                attendance.salary_status = data['salary_status']
                update_fields.append('salary_status')
            
            # Save if any fields were updated
            if update_fields:
                attendance.save()
           
        except Exception as e:
            return Response({"error": str(e)}, status=status.HTTP_400_BAD_REQUEST)

    return Response({"message": "Attendance report updated successfully",}, status=status.HTTP_200_OK)

# endregion








